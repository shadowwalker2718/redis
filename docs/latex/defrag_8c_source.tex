\hypertarget{defrag_8c_source}{}\section{defrag.\+c}
\label{defrag_8c_source}\index{src/defrag.\+c@{src/defrag.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* }
00002 \textcolor{comment}{ * Active memory defragmentation}
00003 \textcolor{comment}{ * Try to find key / value allocations that need to be re-allocated in order }
00004 \textcolor{comment}{ * to reduce external fragmentation.}
00005 \textcolor{comment}{ * We do that by scanning the keyspace and for each pointer we have, we can try to}
00006 \textcolor{comment}{ * ask the allocator if moving it to a new address will help reduce fragmentation.}
00007 \textcolor{comment}{ *}
00008 \textcolor{comment}{ * Copyright (c) 2017, Oran Agra}
00009 \textcolor{comment}{ * Copyright (c) 2017, Redis Labs, Inc}
00010 \textcolor{comment}{ * All rights reserved.}
00011 \textcolor{comment}{ *}
00012 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00013 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00014 \textcolor{comment}{ *}
00015 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00016 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00017 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00018 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00019 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00020 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00021 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00022 \textcolor{comment}{ *     specific prior written permission.}
00023 \textcolor{comment}{ *}
00024 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00025 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00026 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00027 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00028 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00029 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00030 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00031 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00032 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00033 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00034 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00035 \textcolor{comment}{ */}
00036 
00037 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{server_8h}{"server.h"}
00038 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{time}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00039 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{assert}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00040 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stddef}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00041 
00042 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \textcolor{preprocessor}{HAVE\_DEFRAG}
00043 
00044 \textcolor{comment}{/* this method was added to jemalloc in order to help us understand which}
00045 \textcolor{comment}{ * pointers are worthwhile moving and which aren't */}
00046 \textcolor{keywordtype}{int} je\_get\_defrag\_hint(\textcolor{keywordtype}{void}* ptr, \textcolor{keywordtype}{int} *bin\_util, \textcolor{keywordtype}{int} *run\_util);
00047 
00048 \textcolor{comment}{/* Defrag helper for generic allocations.}
00049 \textcolor{comment}{ *}
00050 \textcolor{comment}{ * returns NULL in case the allocatoin wasn't moved.}
00051 \textcolor{comment}{ * when it returns a non-null value, the old pointer was already released}
00052 \textcolor{comment}{ * and should NOT be accessed. */}
00053 \textcolor{keywordtype}{void}* activeDefragAlloc(\textcolor{keywordtype}{void} *ptr) \{
00054     \textcolor{keywordtype}{int} bin\_util, run\_util;
00055     size\_t size;
00056     \textcolor{keywordtype}{void} *newptr;
00057     \textcolor{keywordflow}{if}(!je\_get\_defrag\_hint(ptr, &bin\_util, &run\_util)) \{
00058         server.stat\_active\_defrag\_misses++;
00059         \textcolor{keywordflow}{return} NULL;
00060     \}
00061     \textcolor{comment}{/* if this run is more utilized than the average utilization in this bin}
00062 \textcolor{comment}{     * (or it is full), skip it. This will eventually move all the allocations}
00063 \textcolor{comment}{     * from relatively empty runs into relatively full runs. */}
00064     \textcolor{keywordflow}{if} (run\_util > bin\_util || run\_util == 1<<16) \{
00065         server.stat\_active\_defrag\_misses++;
00066         \textcolor{keywordflow}{return} NULL;
00067     \}
00068     \textcolor{comment}{/* move this allocation to a new allocation.}
00069 \textcolor{comment}{     * make sure not to use the thread cache. so that we don't get back the same}
00070 \textcolor{comment}{     * pointers we try to free */}
00071     size = zmalloc\_size(ptr);
00072     newptr = zmalloc\_no\_tcache(size);
00073     memcpy(newptr, ptr, size);
00074     zfree\_no\_tcache(ptr);
00075     \textcolor{keywordflow}{return} newptr;
00076 \}
00077 
00078 \textcolor{comment}{/*Defrag helper for sds strings}
00079 \textcolor{comment}{ *}
00080 \textcolor{comment}{ * returns NULL in case the allocatoin wasn't moved.}
00081 \textcolor{comment}{ * when it returns a non-null value, the old pointer was already released}
00082 \textcolor{comment}{ * and should NOT be accessed. */}
00083 sds activeDefragSds(sds sdsptr) \{
00084     \textcolor{keywordtype}{void}* ptr = sdsAllocPtr(sdsptr);
00085     \textcolor{keywordtype}{void}* newptr = activeDefragAlloc(ptr);
00086     \textcolor{keywordflow}{if} (newptr) \{
00087         size\_t offset = sdsptr - (\textcolor{keywordtype}{char}*)ptr;
00088         sdsptr = (\textcolor{keywordtype}{char}*)newptr + offset;
00089         \textcolor{keywordflow}{return} sdsptr;
00090     \}
00091     \textcolor{keywordflow}{return} NULL;
00092 \}
00093 
00094 \textcolor{comment}{/* Defrag helper for robj and/or string objects}
00095 \textcolor{comment}{ *}
00096 \textcolor{comment}{ * returns NULL in case the allocatoin wasn't moved.}
00097 \textcolor{comment}{ * when it returns a non-null value, the old pointer was already released}
00098 \textcolor{comment}{ * and should NOT be accessed. */}
00099 robj *activeDefragStringOb(robj* ob, \textcolor{keywordtype}{int} *defragged) \{
00100     robj *ret = NULL;
00101     \textcolor{keywordflow}{if} (ob->refcount!=1)
00102         \textcolor{keywordflow}{return} NULL;
00103 
00104     \textcolor{comment}{/* try to defrag robj (only if not an EMBSTR type (handled below). */}
00105     \textcolor{keywordflow}{if} (ob->type!=OBJ\_STRING || ob->encoding!=OBJ\_ENCODING\_EMBSTR) \{
00106         \textcolor{keywordflow}{if} ((ret = activeDefragAlloc(ob))) \{
00107             ob = ret;
00108             (*defragged)++;
00109         \}
00110     \}
00111 
00112     \textcolor{comment}{/* try to defrag string object */}
00113     \textcolor{keywordflow}{if} (ob->type == OBJ\_STRING) \{
00114         \textcolor{keywordflow}{if}(ob->encoding==OBJ\_ENCODING\_RAW) \{
00115             sds newsds = activeDefragSds((sds)ob->ptr);
00116             \textcolor{keywordflow}{if} (newsds) \{
00117                 ob->ptr = newsds;
00118                 (*defragged)++;
00119             \}
00120         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ob->encoding==OBJ\_ENCODING\_EMBSTR) \{
00121             \textcolor{comment}{/* The sds is embedded in the object allocation, calculate the}
00122 \textcolor{comment}{             * offset and update the pointer in the new allocation. */}
00123             \textcolor{keywordtype}{long} ofs = (intptr\_t)ob->ptr - (intptr\_t)ob;
00124             \textcolor{keywordflow}{if} ((ret = activeDefragAlloc(ob))) \{
00125                 ret->ptr = (\textcolor{keywordtype}{void}*)((intptr\_t)ret + ofs);
00126                 (*defragged)++;
00127             \}
00128         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ob->encoding!=OBJ\_ENCODING\_INT) \{
00129             serverPanic(\textcolor{stringliteral}{"Unknown string encoding"});
00130         \}
00131     \}
00132     \textcolor{keywordflow}{return} ret;
00133 \}
00134 
00135 \textcolor{comment}{/* Defrag helper for dictEntries to be used during dict iteration (called on}
00136 \textcolor{comment}{ * each step). Teturns a stat of how many pointers were moved. */}
00137 \textcolor{keywordtype}{int} dictIterDefragEntry(dictIterator *iter) \{
00138     \textcolor{comment}{/* This function is a little bit dirty since it messes with the internals}
00139 \textcolor{comment}{     * of the dict and it's iterator, but the benefit is that it is very easy}
00140 \textcolor{comment}{     * to use, and require no other chagnes in the dict. */}
00141     \textcolor{keywordtype}{int} defragged = 0;
00142     dictht *ht;
00143     \textcolor{comment}{/* Handle the next entry (if there is one), and update the pointer in the}
00144 \textcolor{comment}{     * current entry. */}
00145     \textcolor{keywordflow}{if} (iter->nextEntry) \{
00146         dictEntry *newde = activeDefragAlloc(iter->nextEntry);
00147         \textcolor{keywordflow}{if} (newde) \{
00148             defragged++;
00149             iter->nextEntry = newde;
00150             iter->entry->next = newde;
00151         \}
00152     \}
00153     \textcolor{comment}{/* handle the case of the first entry in the hash bucket. */}
00154     ht = &iter->d->ht[iter->table];
00155     \textcolor{keywordflow}{if} (ht->table[iter->index] == iter->entry) \{
00156         dictEntry *newde = activeDefragAlloc(iter->entry);
00157         \textcolor{keywordflow}{if} (newde) \{
00158             iter->entry = newde;
00159             ht->table[iter->index] = newde;
00160             defragged++;
00161         \}
00162     \}
00163     \textcolor{keywordflow}{return} defragged;
00164 \}
00165 
00166 \textcolor{comment}{/* Defrag helper for dict main allocations (dict struct, and hash tables).}
00167 \textcolor{comment}{ * receives a pointer to the dict* and implicitly updates it when the dict}
00168 \textcolor{comment}{ * struct itself was moved. Returns a stat of how many pointers were moved. */}
00169 \textcolor{keywordtype}{int} dictDefragTables(dict** dictRef) \{
00170     dict *d = *dictRef;
00171     dictEntry **newtable;
00172     \textcolor{keywordtype}{int} defragged = 0;
00173     \textcolor{comment}{/* handle the dict struct */}
00174     dict *newd = activeDefragAlloc(d);
00175     \textcolor{keywordflow}{if} (newd)
00176         defragged++, *dictRef = d = newd;
00177     \textcolor{comment}{/* handle the first hash table */}
00178     newtable = activeDefragAlloc(d->ht[0].table);
00179     \textcolor{keywordflow}{if} (newtable)
00180         defragged++, d->ht[0].table = newtable;
00181     \textcolor{comment}{/* handle the second hash table */}
00182     \textcolor{keywordflow}{if} (d->ht[1].table) \{
00183         newtable = activeDefragAlloc(d->ht[1].table);
00184         \textcolor{keywordflow}{if} (newtable)
00185             defragged++, d->ht[1].table = newtable;
00186     \}
00187     \textcolor{keywordflow}{return} defragged;
00188 \}
00189 
00190 \textcolor{comment}{/* Internal function used by zslDefrag */}
00191 \textcolor{keywordtype}{void} zslUpdateNode(zskiplist *zsl, zskiplistNode *oldnode, zskiplistNode *newnode, zskiplistNode **
      update) \{
00192     \textcolor{keywordtype}{int} i;
00193     \textcolor{keywordflow}{for} (i = 0; i < zsl->level; i++) \{
00194         \textcolor{keywordflow}{if} (update[i]->level[i].forward == oldnode)
00195             update[i]->level[i].forward = newnode;
00196     \}
00197     serverAssert(zsl->header!=oldnode);
00198     \textcolor{keywordflow}{if} (newnode->level[0].forward) \{
00199         serverAssert(newnode->level[0].forward->backward==oldnode);
00200         newnode->level[0].forward->backward = newnode;
00201     \} \textcolor{keywordflow}{else} \{
00202         serverAssert(zsl->tail==oldnode);
00203         zsl->tail = newnode;
00204     \}
00205 \}
00206 
00207 \textcolor{comment}{/* Defrag helper for sorted set.}
00208 \textcolor{comment}{ * Update the robj pointer, defrag the skiplist struct and return the new score}
00209 \textcolor{comment}{ * reference. We may not access oldele pointer (not even the pointer stored in}
00210 \textcolor{comment}{ * the skiplist), as it was already freed. Newele may be null, in which case we}
00211 \textcolor{comment}{ * only need to defrag the skiplist, but not update the obj pointer.}
00212 \textcolor{comment}{ * When return value is non-NULL, it is the score reference that must be updated}
00213 \textcolor{comment}{ * in the dict record. */}
00214 \textcolor{keywordtype}{double} *zslDefrag(zskiplist *zsl, \textcolor{keywordtype}{double} score, sds oldele, sds newele) \{
00215     zskiplistNode *update[ZSKIPLIST\_MAXLEVEL], *x, *newx;
00216     \textcolor{keywordtype}{int} i;
00217     sds ele = newele? newele: oldele;
00218 
00219     \textcolor{comment}{/* find the skiplist node referring to the object that was moved,}
00220 \textcolor{comment}{     * and all pointers that need to be updated if we'll end up moving the skiplist node. */}
00221     x = zsl->header;
00222     \textcolor{keywordflow}{for} (i = zsl->level-1; i >= 0; i--) \{
00223         \textcolor{keywordflow}{while} (x->level[i].forward &&
00224             x->level[i].forward->ele != oldele && \textcolor{comment}{/* make sure not to access the}
00225 \textcolor{comment}{                                                     ->obj pointer if it matches}
00226 \textcolor{comment}{                                                     oldele */}
00227             (x->level[i].forward->score < score ||
00228                 (x->level[i].forward->score == score &&
00229                 sdscmp(x->level[i].forward->ele,ele) < 0)))
00230             x = x->level[i].forward;
00231         update[i] = x;
00232     \}
00233 
00234     \textcolor{comment}{/* update the robj pointer inside the skip list record. */}
00235     x = x->level[0].forward;
00236     serverAssert(x && score == x->score && x->ele==oldele);
00237     \textcolor{keywordflow}{if} (newele)
00238         x->ele = newele;
00239 
00240     \textcolor{comment}{/* try to defrag the skiplist record itself */}
00241     newx = activeDefragAlloc(x);
00242     \textcolor{keywordflow}{if} (newx) \{
00243         zslUpdateNode(zsl, x, newx, update);
00244         \textcolor{keywordflow}{return} &newx->score;
00245     \}
00246     \textcolor{keywordflow}{return} NULL;
00247 \}
00248 
00249 \textcolor{comment}{/* Utility function that replaces an old key pointer in the dictionary with a}
00250 \textcolor{comment}{ * new pointer. Additionally, we try to defrag the dictEntry in that dict.}
00251 \textcolor{comment}{ * Oldkey mey be a dead pointer and should not be accessed (we get a}
00252 \textcolor{comment}{ * pre-calculated hash value). Newkey may be null if the key pointer wasn't}
00253 \textcolor{comment}{ * moved. Return value is the the dictEntry if found, or NULL if not found.}
00254 \textcolor{comment}{ * NOTE: this is very ugly code, but it let's us avoid the complication of}
00255 \textcolor{comment}{ * doing a scan on another dict. */}
00256 dictEntry* replaceSateliteDictKeyPtrAndOrDefragDictEntry(dict *d, sds oldkey, sds newkey, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}
       hash, \textcolor{keywordtype}{int} *defragged) \{
00257     dictEntry **deref = dictFindEntryRefByPtrAndHash(d, oldkey, hash);
00258     \textcolor{keywordflow}{if} (deref) \{
00259         dictEntry *de = *deref;
00260         dictEntry *newde = activeDefragAlloc(de);
00261         \textcolor{keywordflow}{if} (newde) \{
00262             de = *deref = newde;
00263             (*defragged)++;
00264         \}
00265         \textcolor{keywordflow}{if} (newkey)
00266             de->key = newkey;
00267         \textcolor{keywordflow}{return} de;
00268     \}
00269     \textcolor{keywordflow}{return} NULL;
00270 \}
00271 
00272 \textcolor{comment}{/* for each key we scan in the main dict, this function will attempt to defrag}
00273 \textcolor{comment}{ * all the various pointers it has. Returns a stat of how many pointers were}
00274 \textcolor{comment}{ * moved. */}
00275 \textcolor{keywordtype}{int} defragKey(redisDb *db, dictEntry *de) \{
00276     sds keysds = dictGetKey(de);
00277     robj *newob, *ob;
00278     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *newzl;
00279     dict *d;
00280     dictIterator *di;
00281     \textcolor{keywordtype}{int} defragged = 0;
00282     sds newsds;
00283 
00284     \textcolor{comment}{/* Try to defrag the key name. */}
00285     newsds = activeDefragSds(keysds);
00286     \textcolor{keywordflow}{if} (newsds)
00287         defragged++, de->key = newsds;
00288     \textcolor{keywordflow}{if} (dictSize(db->expires)) \{
00289          \textcolor{comment}{/* Dirty code:}
00290 \textcolor{comment}{          * I can't search in db->expires for that key after i already released}
00291 \textcolor{comment}{          * the pointer it holds it won't be able to do the string compare */}
00292         uint64\_t hash = dictGetHash(db->dict, de->key);
00293         replaceSateliteDictKeyPtrAndOrDefragDictEntry(db->expires, keysds, newsds, hash, &defragged);
00294     \}
00295 
00296     \textcolor{comment}{/* Try to defrag robj and / or string value. */}
00297     ob = dictGetVal(de);
00298     \textcolor{keywordflow}{if} ((newob = activeDefragStringOb(ob, &defragged))) \{
00299         de->v.val = newob;
00300         ob = newob;
00301     \}
00302 
00303     \textcolor{keywordflow}{if} (ob->type == OBJ\_STRING) \{
00304         \textcolor{comment}{/* Already handled in activeDefragStringOb. */}
00305     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ob->type == OBJ\_LIST) \{
00306         \textcolor{keywordflow}{if} (ob->encoding == OBJ\_ENCODING\_QUICKLIST) \{
00307             quicklist *ql = ob->ptr, *newql;
00308             quicklistNode *node = ql->head, *newnode;
00309             \textcolor{keywordflow}{if} ((newql = activeDefragAlloc(ql)))
00310                 defragged++, ob->ptr = ql = newql;
00311             \textcolor{keywordflow}{while} (node) \{
00312                 \textcolor{keywordflow}{if} ((newnode = activeDefragAlloc(node))) \{
00313                     \textcolor{keywordflow}{if} (newnode->prev)
00314                         newnode->prev->next = newnode;
00315                     \textcolor{keywordflow}{else}
00316                         ql->head = newnode;
00317                     \textcolor{keywordflow}{if} (newnode->next)
00318                         newnode->next->prev = newnode;
00319                     \textcolor{keywordflow}{else}
00320                         ql->tail = newnode;
00321                     node = newnode;
00322                     defragged++;
00323                 \}
00324                 \textcolor{keywordflow}{if} ((newzl = activeDefragAlloc(node->zl)))
00325                     defragged++, node->zl = newzl;
00326                 node = node->next;
00327             \}
00328         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ob->encoding == OBJ\_ENCODING\_ZIPLIST) \{
00329             \textcolor{keywordflow}{if} ((newzl = activeDefragAlloc(ob->ptr)))
00330                 defragged++, ob->ptr = newzl;
00331         \} \textcolor{keywordflow}{else} \{
00332             serverPanic(\textcolor{stringliteral}{"Unknown list encoding"});
00333         \}
00334     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ob->type == OBJ\_SET) \{
00335         \textcolor{keywordflow}{if} (ob->encoding == OBJ\_ENCODING\_HT) \{
00336             d = ob->ptr;
00337             di = dictGetIterator(d);
00338             \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
00339                 sds sdsele = dictGetKey(de);
00340                 \textcolor{keywordflow}{if} ((newsds = activeDefragSds(sdsele)))
00341                     defragged++, de->key = newsds;
00342                 defragged += dictIterDefragEntry(di);
00343             \}
00344             dictReleaseIterator(di);
00345             dictDefragTables((dict**)&ob->ptr);
00346         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ob->encoding == OBJ\_ENCODING\_INTSET) \{
00347             intset *is = ob->ptr;
00348             intset *newis = activeDefragAlloc(is);
00349             \textcolor{keywordflow}{if} (newis)
00350                 defragged++, ob->ptr = newis;
00351         \} \textcolor{keywordflow}{else} \{
00352             serverPanic(\textcolor{stringliteral}{"Unknown set encoding"});
00353         \}
00354     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ob->type == OBJ\_ZSET) \{
00355         \textcolor{keywordflow}{if} (ob->encoding == OBJ\_ENCODING\_ZIPLIST) \{
00356             \textcolor{keywordflow}{if} ((newzl = activeDefragAlloc(ob->ptr)))
00357                 defragged++, ob->ptr = newzl;
00358         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ob->encoding == OBJ\_ENCODING\_SKIPLIST) \{
00359             zset *zs = (zset*)ob->ptr;
00360             zset *newzs;
00361             zskiplist *newzsl;
00362             \textcolor{keyword}{struct} zskiplistNode *newheader;
00363             \textcolor{keywordflow}{if} ((newzs = activeDefragAlloc(zs)))
00364                 defragged++, ob->ptr = zs = newzs;
00365             \textcolor{keywordflow}{if} ((newzsl = activeDefragAlloc(zs->zsl)))
00366                 defragged++, zs->zsl = newzsl;
00367             \textcolor{keywordflow}{if} ((newheader = activeDefragAlloc(zs->zsl->header)))
00368                 defragged++, zs->zsl->header = newheader;
00369             d = zs->dict;
00370             di = dictGetIterator(d);
00371             \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
00372                 \textcolor{keywordtype}{double}* newscore;
00373                 sds sdsele = dictGetKey(de);
00374                 \textcolor{keywordflow}{if} ((newsds = activeDefragSds(sdsele)))
00375                     defragged++, de->key = newsds;
00376                 newscore = zslDefrag(zs->zsl, *(\textcolor{keywordtype}{double}*)dictGetVal(de), sdsele, newsds);
00377                 \textcolor{keywordflow}{if} (newscore) \{
00378                     dictSetVal(d, de, newscore);
00379                     defragged++;
00380                 \}
00381                 defragged += dictIterDefragEntry(di);
00382             \}
00383             dictReleaseIterator(di);
00384             dictDefragTables(&zs->dict);
00385         \} \textcolor{keywordflow}{else} \{
00386             serverPanic(\textcolor{stringliteral}{"Unknown sorted set encoding"});
00387         \}
00388     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ob->type == OBJ\_HASH) \{
00389         \textcolor{keywordflow}{if} (ob->encoding == OBJ\_ENCODING\_ZIPLIST) \{
00390             \textcolor{keywordflow}{if} ((newzl = activeDefragAlloc(ob->ptr)))
00391                 defragged++, ob->ptr = newzl;
00392         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ob->encoding == OBJ\_ENCODING\_HT) \{
00393             d = ob->ptr;
00394             di = dictGetIterator(d);
00395             \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
00396                 sds sdsele = dictGetKey(de);
00397                 \textcolor{keywordflow}{if} ((newsds = activeDefragSds(sdsele)))
00398                     defragged++, de->key = newsds;
00399                 sdsele = dictGetVal(de);
00400                 \textcolor{keywordflow}{if} ((newsds = activeDefragSds(sdsele)))
00401                     defragged++, de->v.val = newsds;
00402                 defragged += dictIterDefragEntry(di);
00403             \}
00404             dictReleaseIterator(di);
00405             dictDefragTables((dict**)&ob->ptr);
00406         \} \textcolor{keywordflow}{else} \{
00407             serverPanic(\textcolor{stringliteral}{"Unknown hash encoding"});
00408         \}
00409     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ob->type == OBJ\_MODULE) \{
00410         \textcolor{comment}{/* Currently defragmenting modules private data types}
00411 \textcolor{comment}{         * is not supported. */}
00412     \} \textcolor{keywordflow}{else} \{
00413         serverPanic(\textcolor{stringliteral}{"Unknown object type"});
00414     \}
00415     \textcolor{keywordflow}{return} defragged;
00416 \}
00417 
00418 \textcolor{comment}{/* Defrag scan callback for the main db dictionary. */}
00419 \textcolor{keywordtype}{void} defragScanCallback(\textcolor{keywordtype}{void} *privdata, \textcolor{keyword}{const} dictEntry *de) \{
00420     \textcolor{keywordtype}{int} defragged = defragKey((redisDb*)privdata, (dictEntry*)de);
00421     server.stat\_active\_defrag\_hits += defragged;
00422     \textcolor{keywordflow}{if}(defragged)
00423         server.stat\_active\_defrag\_key\_hits++;
00424     \textcolor{keywordflow}{else}
00425         server.stat\_active\_defrag\_key\_misses++;
00426 \}
00427 
00428 \textcolor{comment}{/* Defrag scan callback for for each hash table bicket,}
00429 \textcolor{comment}{ * used in order to defrag the dictEntry allocations. */}
00430 \textcolor{keywordtype}{void} defragDictBucketCallback(\textcolor{keywordtype}{void} *privdata, dictEntry **bucketref) \{
00431     UNUSED(privdata);
00432     \textcolor{keywordflow}{while}(*bucketref) \{
00433         dictEntry *de = *bucketref, *newde;
00434         \textcolor{keywordflow}{if} ((newde = activeDefragAlloc(de))) \{
00435             *bucketref = newde;
00436         \}
00437         bucketref = &(*bucketref)->next;
00438     \}
00439 \}
00440 
00441 \textcolor{comment}{/* Utility function to get the fragmentation ratio from jemalloc.}
00442 \textcolor{comment}{ * It is critical to do that by comparing only heap maps that belown to}
00443 \textcolor{comment}{ * jemalloc, and skip ones the jemalloc keeps as spare. Since we use this}
00444 \textcolor{comment}{ * fragmentation ratio in order to decide if a defrag action should be taken}
00445 \textcolor{comment}{ * or not, a false detection can cause the defragmenter to waste a lot of CPU}
00446 \textcolor{comment}{ * without the possibility of getting any results. */}
00447 \textcolor{keywordtype}{float} getAllocatorFragmentation(size\_t *out\_frag\_bytes) \{
00448     size\_t epoch = 1, allocated = 0, resident = 0, active = 0, sz = \textcolor{keyword}{sizeof}(size\_t);
00449     \textcolor{comment}{/* Update the statistics cached by mallctl. */}
00450     je\_mallctl(\textcolor{stringliteral}{"epoch"}, &epoch, &sz, &epoch, sz);
00451     \textcolor{comment}{/* Unlike RSS, this does not include RSS from shared libraries and other non}
00452 \textcolor{comment}{     * heap mappings. */}
00453     je\_mallctl(\textcolor{stringliteral}{"stats.resident"}, &resident, &sz, NULL, 0);
00454     \textcolor{comment}{/* Unlike resident, this doesn't not include the pages jemalloc reserves}
00455 \textcolor{comment}{     * for re-use (purge will clean that). */}
00456     je\_mallctl(\textcolor{stringliteral}{"stats.active"}, &active, &sz, NULL, 0);
00457     \textcolor{comment}{/* Unlike zmalloc\_used\_memory, this matches the stats.resident by taking}
00458 \textcolor{comment}{     * into account all allocations done by this process (not only zmalloc). */}
00459     je\_mallctl(\textcolor{stringliteral}{"stats.allocated"}, &allocated, &sz, NULL, 0);
00460     \textcolor{keywordtype}{float} frag\_pct = ((\textcolor{keywordtype}{float})active / allocated)*100 - 100;
00461     size\_t frag\_bytes = active - allocated;
00462     \textcolor{keywordtype}{float} rss\_pct = ((\textcolor{keywordtype}{float})resident / allocated)*100 - 100;
00463     size\_t rss\_bytes = resident - allocated;
00464     \textcolor{keywordflow}{if}(out\_frag\_bytes)
00465         *out\_frag\_bytes = frag\_bytes;
00466     serverLog(LL\_DEBUG,
00467         \textcolor{stringliteral}{"allocated=%zu, active=%zu, resident=%zu, frag=%.0f%% (%.0f%% rss), frag\_bytes=%zu (%zu%%
       rss)"},
00468         allocated, active, resident, frag\_pct, rss\_pct, frag\_bytes, rss\_bytes);
00469     \textcolor{keywordflow}{return} frag\_pct;
00470 \}
00471 
00472 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{INTERPOLATE}\textcolor{preprocessor}{(}\textcolor{preprocessor}{x}\textcolor{preprocessor}{,} \textcolor{preprocessor}{x1}\textcolor{preprocessor}{,} \textcolor{preprocessor}{x2}\textcolor{preprocessor}{,} \textcolor{preprocessor}{y1}\textcolor{preprocessor}{,} \textcolor{preprocessor}{y2}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(} \textcolor{preprocessor}{(}\textcolor{preprocessor}{y1}\textcolor{preprocessor}{)} \textcolor{preprocessor}{+} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{x}\textcolor{preprocessor}{)}\textcolor{preprocessor}{-}\textcolor{preprocessor}{(}\textcolor{preprocessor}{x1}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)} \textcolor{preprocessor}{*} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{y2}\textcolor{preprocessor}{)}\textcolor{preprocessor}{-}\textcolor{preprocessor}{(}\textcolor{preprocessor}{y1}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)} \textcolor{preprocessor}{/} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{x2}\textcolor{preprocessor}{)}\textcolor{preprocessor}{-}\textcolor{preprocessor}{(}\textcolor{preprocessor}{x1}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)} \textcolor{preprocessor}{)}
00473 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LIMIT}\textcolor{preprocessor}{(}\textcolor{preprocessor}{y}\textcolor{preprocessor}{,} \textcolor{preprocessor}{min}\textcolor{preprocessor}{,} \textcolor{preprocessor}{max}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{y}\textcolor{preprocessor}{)}\textcolor{preprocessor}{<}\textcolor{preprocessor}{(}\textcolor{preprocessor}{min}\textcolor{preprocessor}{)}\textcolor{preprocessor}{?} \textcolor{preprocessor}{min}\textcolor{preprocessor}{:} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{y}\textcolor{preprocessor}{)}\textcolor{preprocessor}{>}\textcolor{preprocessor}{(}\textcolor{preprocessor}{max}\textcolor{preprocessor}{)}\textcolor{preprocessor}{?} \textcolor{preprocessor}{max}\textcolor{preprocessor}{:} \textcolor{preprocessor}{(}\textcolor{preprocessor}{y}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00474 
00475 \textcolor{comment}{/* Perform incremental defragmentation work from the serverCron.}
00476 \textcolor{comment}{ * This works in a similar way to activeExpireCycle, in the sense that}
00477 \textcolor{comment}{ * we do incremental work across calls. */}
00478 \textcolor{keywordtype}{void} activeDefragCycle(\textcolor{keywordtype}{void}) \{
00479     \textcolor{keyword}{static} \textcolor{keywordtype}{int} current\_db = -1;
00480     \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} cursor = 0;
00481     \textcolor{keyword}{static} redisDb *db = NULL;
00482     \textcolor{keyword}{static} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} start\_scan, start\_stat;
00483     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} iterations = 0;
00484     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} defragged = server.stat\_active\_defrag\_hits;
00485     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} start, timelimit;
00486 
00487     \textcolor{keywordflow}{if} (server.aof\_child\_pid!=-1 || server.rdb\_child\_pid!=-1)
00488         \textcolor{keywordflow}{return}; \textcolor{comment}{/* Defragging memory while there's a fork will just do damage. */}
00489 
00490     \textcolor{comment}{/* Once a second, check if we the fragmentation justfies starting a scan}
00491 \textcolor{comment}{     * or making it more aggressive. */}
00492     run\_with\_period(1000) \{
00493         size\_t frag\_bytes;
00494         \textcolor{keywordtype}{float} frag\_pct = getAllocatorFragmentation(&frag\_bytes);
00495         \textcolor{comment}{/* If we're not already running, and below the threshold, exit. */}
00496         \textcolor{keywordflow}{if} (!server.active\_defrag\_running) \{
00497             \textcolor{keywordflow}{if}(frag\_pct < server.active\_defrag\_threshold\_lower || frag\_bytes < server.
      active\_defrag\_ignore\_bytes)
00498                 \textcolor{keywordflow}{return};
00499         \}
00500 
00501         \textcolor{comment}{/* Calculate the adaptive aggressiveness of the defrag */}
00502         \textcolor{keywordtype}{int} cpu\_pct = INTERPOLATE(frag\_pct,
00503                 server.active\_defrag\_threshold\_lower,
00504                 server.active\_defrag\_threshold\_upper,
00505                 server.active\_defrag\_cycle\_min,
00506                 server.active\_defrag\_cycle\_max);
00507         cpu\_pct = LIMIT(cpu\_pct,
00508                 server.active\_defrag\_cycle\_min,
00509                 server.active\_defrag\_cycle\_max);
00510          \textcolor{comment}{/* We allow increasing the aggressiveness during a scan, but don't}
00511 \textcolor{comment}{          * reduce it. */}
00512         \textcolor{keywordflow}{if} (!server.active\_defrag\_running ||
00513             cpu\_pct > server.active\_defrag\_running)
00514         \{
00515             server.active\_defrag\_running = cpu\_pct;
00516             serverLog(LL\_VERBOSE,
00517                 \textcolor{stringliteral}{"Starting active defrag, frag=%.0f%%, frag\_bytes=%zu, cpu=%d%%"},
00518                 frag\_pct, frag\_bytes, cpu\_pct);
00519         \}
00520     \}
00521     \textcolor{keywordflow}{if} (!server.active\_defrag\_running)
00522         \textcolor{keywordflow}{return};
00523 
00524     \textcolor{comment}{/* See activeExpireCycle for how timelimit is handled. */}
00525     start = ustime();
00526     timelimit = 1000000*server.active\_defrag\_running/server.hz/100;
00527     \textcolor{keywordflow}{if} (timelimit <= 0) timelimit = 1;
00528 
00529     \textcolor{keywordflow}{do} \{
00530         \textcolor{keywordflow}{if} (!cursor) \{
00531             \textcolor{comment}{/* Move on to next database, and stop if we reached the last one. */}
00532             \textcolor{keywordflow}{if} (++current\_db >= server.dbnum) \{
00533                 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} now = ustime();
00534                 size\_t frag\_bytes;
00535                 \textcolor{keywordtype}{float} frag\_pct = getAllocatorFragmentation(&frag\_bytes);
00536                 serverLog(LL\_VERBOSE,
00537                     \textcolor{stringliteral}{"Active defrag done in %dms, reallocated=%d, frag=%.0f%%, frag\_bytes=%zu"},
00538                     (\textcolor{keywordtype}{int})((now - start\_scan)/1000), (\textcolor{keywordtype}{int})(server.stat\_active\_defrag\_hits - start\_stat)
      , frag\_pct, frag\_bytes);
00539 
00540                 start\_scan = now;
00541                 current\_db = -1;
00542                 cursor = 0;
00543                 db = NULL;
00544                 server.active\_defrag\_running = 0;
00545                 \textcolor{keywordflow}{return};
00546             \}
00547             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (current\_db==0) \{
00548                 \textcolor{comment}{/* Start a scan from the first database. */}
00549                 start\_scan = ustime();
00550                 start\_stat = server.stat\_active\_defrag\_hits;
00551             \}
00552 
00553             db = &server.db[current\_db];
00554             cursor = 0;
00555         \}
00556 
00557         \textcolor{keywordflow}{do} \{
00558             cursor = dictScan(db->dict, cursor, defragScanCallback, defragDictBucketCallback, db);
00559             \textcolor{comment}{/* Once in 16 scan iterations, or 1000 pointer reallocations}
00560 \textcolor{comment}{             * (if we have a lot of pointers in one hash bucket), check if we}
00561 \textcolor{comment}{             * reached the tiem limit. */}
00562             \textcolor{keywordflow}{if} (cursor && (++iterations > 16 || server.stat\_active\_defrag\_hits - defragged > 1000)) \{
00563                 \textcolor{keywordflow}{if} ((ustime() - start) > timelimit) \{
00564                     \textcolor{keywordflow}{return};
00565                 \}
00566                 iterations = 0;
00567                 defragged = server.stat\_active\_defrag\_hits;
00568             \}
00569         \} \textcolor{keywordflow}{while}(cursor);
00570     \} \textcolor{keywordflow}{while}(1);
00571 \}
00572 
00573 \textcolor{preprocessor}{#}\textcolor{preprocessor}{else} \textcolor{comment}{/* HAVE\_DEFRAG */}
00574 
00575 \textcolor{keywordtype}{void} activeDefragCycle(\textcolor{keywordtype}{void}) \{
00576     \textcolor{comment}{/* Not implemented yet. */}
00577 \}
00578 
00579 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
\end{DoxyCode}
