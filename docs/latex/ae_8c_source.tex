\hypertarget{ae_8c_source}{}\section{ae.\+c}
\label{ae_8c_source}\index{src/ae.\+c@{src/ae.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* A simple event-driven programming library. Originally I wrote this code}
00002 \textcolor{comment}{ * for the Jim's event-loop (Jim is a Tcl interpreter) but later translated}
00003 \textcolor{comment}{ * it in form of a library for easy reuse.}
00004 \textcolor{comment}{ *}
00005 \textcolor{comment}{ * Copyright (c) 2006-2010, Salvatore Sanfilippo <antirez at gmail dot com>}
00006 \textcolor{comment}{ * All rights reserved.}
00007 \textcolor{comment}{ *}
00008 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00009 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00010 \textcolor{comment}{ *}
00011 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00012 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00013 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00014 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00015 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00016 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00017 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00018 \textcolor{comment}{ *     specific prior written permission.}
00019 \textcolor{comment}{ *}
00020 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00021 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00022 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00023 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00024 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00025 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00026 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00027 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00028 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00029 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00030 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00031 \textcolor{comment}{ */}
00032 
00033 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdio}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00034 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{time}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00035 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{types}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00036 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{unistd}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00037 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdlib}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00038 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{poll}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00039 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{string}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00040 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{time}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00041 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{errno}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00042 
00043 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{ae_8h}{"ae.h"}
00044 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{zmalloc_8h}{"zmalloc.h"}
00045 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{config_8h}{"config.h"}
00046 
00047 \textcolor{comment}{/* Include the best multiplexing layer supported by this system.}
00048 \textcolor{comment}{ * The following should be ordered by performances, descending. */}
00049 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \textcolor{preprocessor}{HAVE\_EVPORT}
00050 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{stringliteral}{"ae\_evport.c"}
00051 \textcolor{preprocessor}{#}\textcolor{preprocessor}{else}
00052     \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} HAVE\_EPOLL
00053     \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{"ae\_epoll.c"}
00054     \textcolor{preprocessor}{#}\textcolor{preprocessor}{else}
00055         \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \textcolor{preprocessor}{HAVE\_KQUEUE}
00056         \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{stringliteral}{"ae\_kqueue.c"}
00057         \textcolor{preprocessor}{#}\textcolor{preprocessor}{else}
00058         \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{stringliteral}{"ae\_select.c"}
00059         \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
00060     \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
00061 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
00062 
00063 aeEventLoop *aeCreateEventLoop(\textcolor{keywordtype}{int} setsize) \{
00064     aeEventLoop *eventLoop;
00065     \textcolor{keywordtype}{int} i;
00066 
00067     \textcolor{keywordflow}{if} ((eventLoop = zmalloc(\textcolor{keyword}{sizeof}(*eventLoop))) == NULL) \textcolor{keywordflow}{goto} err;
00068     eventLoop->events = zmalloc(\textcolor{keyword}{sizeof}(aeFileEvent)*setsize);
00069     eventLoop->fired = zmalloc(\textcolor{keyword}{sizeof}(aeFiredEvent)*setsize);
00070     \textcolor{keywordflow}{if} (eventLoop->events == NULL || eventLoop->fired == NULL) \textcolor{keywordflow}{goto} err;
00071     eventLoop->setsize = setsize;
00072     eventLoop->lastTime = time(NULL);
00073     eventLoop->timeEventHead = NULL;
00074     eventLoop->timeEventNextId = 0;
00075     eventLoop->stop = 0;
00076     eventLoop->maxfd = -1;
00077     eventLoop->beforesleep = NULL;
00078     eventLoop->aftersleep = NULL;
00079     \textcolor{keywordflow}{if} (aeApiCreate(eventLoop) == -1) \textcolor{keywordflow}{goto} err;
00080     \textcolor{comment}{/* Events with mask == AE\_NONE are not set. So let's initialize the}
00081 \textcolor{comment}{     * vector with it. */}
00082     \textcolor{keywordflow}{for} (i = 0; i < setsize; i++)
00083         eventLoop->events[i].mask = \hyperlink{ae_8h_aea2e33b645e48a3fbb26261005f6df41}{AE\_NONE};
00084     \textcolor{keywordflow}{return} eventLoop;
00085 
00086 err:
00087     \textcolor{keywordflow}{if} (eventLoop) \{
00088         zfree(eventLoop->events);
00089         zfree(eventLoop->fired);
00090         zfree(eventLoop);
00091     \}
00092     \textcolor{keywordflow}{return} NULL;
00093 \}
00094 
00095 \textcolor{comment}{/* Return the current set size. */}
00096 \textcolor{keywordtype}{int} aeGetSetSize(aeEventLoop *eventLoop) \{
00097     \textcolor{keywordflow}{return} eventLoop->setsize;
00098 \}
00099 
00100 \textcolor{comment}{/* Resize the maximum set size of the event loop.}
00101 \textcolor{comment}{ * If the requested set size is smaller than the current set size, but}
00102 \textcolor{comment}{ * there is already a file descriptor in use that is >= the requested}
00103 \textcolor{comment}{ * set size minus one, AE\_ERR is returned and the operation is not}
00104 \textcolor{comment}{ * performed at all.}
00105 \textcolor{comment}{ *}
00106 \textcolor{comment}{ * Otherwise AE\_OK is returned and the operation is successful. */}
00107 \textcolor{keywordtype}{int} aeResizeSetSize(aeEventLoop *eventLoop, \textcolor{keywordtype}{int} setsize) \{
00108     \textcolor{keywordtype}{int} i;
00109 
00110     \textcolor{keywordflow}{if} (setsize == eventLoop->setsize) \textcolor{keywordflow}{return} \hyperlink{ae_8h_afaac43d9573452f9fc6c718f90c4c645}{AE\_OK};
00111     \textcolor{keywordflow}{if} (eventLoop->maxfd >= setsize) \textcolor{keywordflow}{return} \hyperlink{ae_8h_aa16dcf7effdf8f8df97f51b1cb51a9df}{AE\_ERR};
00112     \textcolor{keywordflow}{if} (aeApiResize(eventLoop,setsize) == -1) \textcolor{keywordflow}{return} \hyperlink{ae_8h_aa16dcf7effdf8f8df97f51b1cb51a9df}{AE\_ERR};
00113 
00114     eventLoop->events = zrealloc(eventLoop->events,\textcolor{keyword}{sizeof}(aeFileEvent)*setsize);
00115     eventLoop->fired = zrealloc(eventLoop->fired,\textcolor{keyword}{sizeof}(aeFiredEvent)*setsize);
00116     eventLoop->setsize = setsize;
00117 
00118     \textcolor{comment}{/* Make sure that if we created new slots, they are initialized with}
00119 \textcolor{comment}{     * an AE\_NONE mask. */}
00120     \textcolor{keywordflow}{for} (i = eventLoop->maxfd+1; i < setsize; i++)
00121         eventLoop->events[i].mask = \hyperlink{ae_8h_aea2e33b645e48a3fbb26261005f6df41}{AE\_NONE};
00122     \textcolor{keywordflow}{return} \hyperlink{ae_8h_afaac43d9573452f9fc6c718f90c4c645}{AE\_OK};
00123 \}
00124 
00125 \textcolor{keywordtype}{void} aeDeleteEventLoop(aeEventLoop *eventLoop) \{
00126     aeApiFree(eventLoop);
00127     zfree(eventLoop->events);
00128     zfree(eventLoop->fired);
00129     zfree(eventLoop);
00130 \}
00131 
00132 \textcolor{keywordtype}{void} aeStop(aeEventLoop *eventLoop) \{
00133     eventLoop->stop = 1;
00134 \}
00135 
00136 \textcolor{keywordtype}{int} aeCreateFileEvent(aeEventLoop *eventLoop, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{int} mask,
00137         aeFileProc *proc, \textcolor{keywordtype}{void} *clientData)
00138 \{
00139     \textcolor{keywordflow}{if} (fd >= eventLoop->setsize) \{
00140         errno = ERANGE;
00141         \textcolor{keywordflow}{return} \hyperlink{ae_8h_aa16dcf7effdf8f8df97f51b1cb51a9df}{AE\_ERR};
00142     \}
00143     aeFileEvent *fe = &eventLoop->events[fd];
00144 
00145     \textcolor{keywordflow}{if} (aeApiAddEvent(eventLoop, fd, mask) == -1)
00146         \textcolor{keywordflow}{return} \hyperlink{ae_8h_aa16dcf7effdf8f8df97f51b1cb51a9df}{AE\_ERR};
00147     fe->mask |= mask;
00148     \textcolor{keywordflow}{if} (mask & \hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE}) fe->rfileProc = proc;
00149     \textcolor{keywordflow}{if} (mask & \hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE}) fe->wfileProc = proc;
00150     fe->clientData = clientData;
00151     \textcolor{keywordflow}{if} (fd > eventLoop->maxfd)
00152         eventLoop->maxfd = fd;
00153     \textcolor{keywordflow}{return} \hyperlink{ae_8h_afaac43d9573452f9fc6c718f90c4c645}{AE\_OK};
00154 \}
00155 
00156 \textcolor{keywordtype}{void} aeDeleteFileEvent(aeEventLoop *eventLoop, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{int} mask)
00157 \{
00158     \textcolor{keywordflow}{if} (fd >= eventLoop->setsize) \textcolor{keywordflow}{return};
00159     aeFileEvent *fe = &eventLoop->events[fd];
00160     \textcolor{keywordflow}{if} (fe->mask == \hyperlink{ae_8h_aea2e33b645e48a3fbb26261005f6df41}{AE\_NONE}) \textcolor{keywordflow}{return};
00161 
00162     aeApiDelEvent(eventLoop, fd, mask);
00163     fe->mask = fe->mask & (~mask);
00164     \textcolor{keywordflow}{if} (fd == eventLoop->maxfd && fe->mask == \hyperlink{ae_8h_aea2e33b645e48a3fbb26261005f6df41}{AE\_NONE}) \{
00165         \textcolor{comment}{/* Update the max fd */}
00166         \textcolor{keywordtype}{int} j;
00167 
00168         \textcolor{keywordflow}{for} (j = eventLoop->maxfd-1; j >= 0; j--)
00169             \textcolor{keywordflow}{if} (eventLoop->events[j].mask != \hyperlink{ae_8h_aea2e33b645e48a3fbb26261005f6df41}{AE\_NONE}) \textcolor{keywordflow}{break};
00170         eventLoop->maxfd = j;
00171     \}
00172 \}
00173 
00174 \textcolor{keywordtype}{int} aeGetFileEvents(aeEventLoop *eventLoop, \textcolor{keywordtype}{int} fd) \{
00175     \textcolor{keywordflow}{if} (fd >= eventLoop->setsize) \textcolor{keywordflow}{return} 0;
00176     aeFileEvent *fe = &eventLoop->events[fd];
00177 
00178     \textcolor{keywordflow}{return} fe->mask;
00179 \}
00180 
00181 \textcolor{keyword}{static} \textcolor{keywordtype}{void} aeGetTime(\textcolor{keywordtype}{long} *seconds, \textcolor{keywordtype}{long} *milliseconds)
00182 \{
00183     \textcolor{keyword}{struct} timeval tv;
00184 
00185     gettimeofday(&tv, NULL);
00186     *seconds = tv.tv\_sec;
00187     *milliseconds = tv.tv\_usec/1000;
00188 \}
00189 
00190 \textcolor{keyword}{static} \textcolor{keywordtype}{void} aeAddMillisecondsToNow(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} milliseconds, \textcolor{keywordtype}{long} *sec, \textcolor{keywordtype}{long} *ms) \{
00191     \textcolor{keywordtype}{long} cur\_sec, cur\_ms, when\_sec, when\_ms;
00192 
00193     aeGetTime(&cur\_sec, &cur\_ms);
00194     when\_sec = cur\_sec + milliseconds/1000;
00195     when\_ms = cur\_ms + milliseconds%1000;
00196     \textcolor{keywordflow}{if} (when\_ms >= 1000) \{
00197         when\_sec ++;
00198         when\_ms -= 1000;
00199     \}
00200     *sec = when\_sec;
00201     *ms = when\_ms;
00202 \}
00203 
00204 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} aeCreateTimeEvent(aeEventLoop *eventLoop, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} milliseconds,
00205         aeTimeProc *proc, \textcolor{keywordtype}{void} *clientData,
00206         aeEventFinalizerProc *finalizerProc)
00207 \{
00208     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} id = eventLoop->timeEventNextId++;
00209     aeTimeEvent *te;
00210 
00211     te = zmalloc(\textcolor{keyword}{sizeof}(*te));
00212     \textcolor{keywordflow}{if} (te == NULL) \textcolor{keywordflow}{return} \hyperlink{ae_8h_aa16dcf7effdf8f8df97f51b1cb51a9df}{AE\_ERR};
00213     te->id = id;
00214     aeAddMillisecondsToNow(milliseconds,&te->when\_sec,&te->when\_ms);
00215     te->timeProc = proc;
00216     te->finalizerProc = finalizerProc;
00217     te->clientData = clientData;
00218     te->next = eventLoop->timeEventHead;
00219     eventLoop->timeEventHead = te;
00220     \textcolor{keywordflow}{return} id;
00221 \}
00222 
00223 \textcolor{keywordtype}{int} aeDeleteTimeEvent(aeEventLoop *eventLoop, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} id)
00224 \{
00225     aeTimeEvent *te = eventLoop->timeEventHead;
00226     \textcolor{keywordflow}{while}(te) \{
00227         \textcolor{keywordflow}{if} (te->id == id) \{
00228             te->id = \hyperlink{ae_8h_aee0b2fc7b62d8e06517136a91d7f635d}{AE\_DELETED\_EVENT\_ID};
00229             \textcolor{keywordflow}{return} \hyperlink{ae_8h_afaac43d9573452f9fc6c718f90c4c645}{AE\_OK};
00230         \}
00231         te = te->next;
00232     \}
00233     \textcolor{keywordflow}{return} \hyperlink{ae_8h_aa16dcf7effdf8f8df97f51b1cb51a9df}{AE\_ERR}; \textcolor{comment}{/* NO event with the specified ID found */}
00234 \}
00235 
00236 \textcolor{comment}{/* Search the first timer to fire.}
00237 \textcolor{comment}{ * This operation is useful to know how many time the select can be}
00238 \textcolor{comment}{ * put in sleep without to delay any event.}
00239 \textcolor{comment}{ * If there are no timers NULL is returned.}
00240 \textcolor{comment}{ *}
00241 \textcolor{comment}{ * Note that's O(N) since time events are unsorted.}
00242 \textcolor{comment}{ * Possible optimizations (not needed by Redis so far, but...):}
00243 \textcolor{comment}{ * 1) Insert the event in order, so that the nearest is just the head.}
00244 \textcolor{comment}{ *    Much better but still insertion or deletion of timers is O(N).}
00245 \textcolor{comment}{ * 2) Use a skiplist to have this operation as O(1) and insertion as O(log(N)).}
00246 \textcolor{comment}{ */}
00247 \textcolor{keyword}{static} aeTimeEvent *aeSearchNearestTimer(aeEventLoop *eventLoop)
00248 \{
00249     aeTimeEvent *te = eventLoop->timeEventHead;
00250     aeTimeEvent *nearest = NULL;
00251 
00252     \textcolor{keywordflow}{while}(te) \{
00253         \textcolor{keywordflow}{if} (!nearest || te->when\_sec < nearest->when\_sec ||
00254                 (te->when\_sec == nearest->when\_sec &&
00255                  te->when\_ms < nearest->when\_ms))
00256             nearest = te;
00257         te = te->next;
00258     \}
00259     \textcolor{keywordflow}{return} nearest;
00260 \}
00261 
00262 \textcolor{comment}{/* Process time events */}
00263 \textcolor{keyword}{static} \textcolor{keywordtype}{int} processTimeEvents(aeEventLoop *eventLoop) \{
00264     \textcolor{keywordtype}{int} processed = 0;
00265     aeTimeEvent *te, *prev;
00266     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} maxId;
00267     time\_t now = time(NULL);
00268 
00269     \textcolor{comment}{/* If the system clock is moved to the future, and then set back to the}
00270 \textcolor{comment}{     * right value, time events may be delayed in a random way. Often this}
00271 \textcolor{comment}{     * means that scheduled operations will not be performed soon enough.}
00272 \textcolor{comment}{     *}
00273 \textcolor{comment}{     * Here we try to detect system clock skews, and force all the time}
00274 \textcolor{comment}{     * events to be processed ASAP when this happens: the idea is that}
00275 \textcolor{comment}{     * processing events earlier is less dangerous than delaying them}
00276 \textcolor{comment}{     * indefinitely, and practice suggests it is. */}
00277     \textcolor{keywordflow}{if} (now < eventLoop->lastTime) \{
00278         te = eventLoop->timeEventHead;
00279         \textcolor{keywordflow}{while}(te) \{
00280             te->when\_sec = 0;
00281             te = te->next;
00282         \}
00283     \}
00284     eventLoop->lastTime = now;
00285 
00286     prev = NULL;
00287     te = eventLoop->timeEventHead;
00288     maxId = eventLoop->timeEventNextId-1;
00289     \textcolor{keywordflow}{while}(te) \{
00290         \textcolor{keywordtype}{long} now\_sec, now\_ms;
00291         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} id;
00292 
00293         \textcolor{comment}{/* Remove events scheduled for deletion. */}
00294         \textcolor{keywordflow}{if} (te->id == \hyperlink{ae_8h_aee0b2fc7b62d8e06517136a91d7f635d}{AE\_DELETED\_EVENT\_ID}) \{
00295             aeTimeEvent *next = te->next;
00296             \textcolor{keywordflow}{if} (prev == NULL)
00297                 eventLoop->timeEventHead = te->next;
00298             \textcolor{keywordflow}{else}
00299                 prev->next = te->next;
00300             \textcolor{keywordflow}{if} (te->finalizerProc)
00301                 te->finalizerProc(eventLoop, te->clientData);
00302             zfree(te);
00303             te = next;
00304             \textcolor{keywordflow}{continue};
00305         \}
00306 
00307         \textcolor{comment}{/* Make sure we don't process time events created by time events in}
00308 \textcolor{comment}{         * this iteration. Note that this check is currently useless: we always}
00309 \textcolor{comment}{         * add new timers on the head, however if we change the implementation}
00310 \textcolor{comment}{         * detail, this check may be useful again: we keep it here for future}
00311 \textcolor{comment}{         * defense. */}
00312         \textcolor{keywordflow}{if} (te->id > maxId) \{
00313             te = te->next;
00314             \textcolor{keywordflow}{continue};
00315         \}
00316         aeGetTime(&now\_sec, &now\_ms);
00317         \textcolor{keywordflow}{if} (now\_sec > te->when\_sec ||
00318             (now\_sec == te->when\_sec && now\_ms >= te->when\_ms))
00319         \{
00320             \textcolor{keywordtype}{int} retval;
00321 
00322             id = te->id;
00323             retval = te->timeProc(eventLoop, id, te->clientData);
00324             processed++;
00325             \textcolor{keywordflow}{if} (retval != \hyperlink{ae_8h_a51464410d1f951b043b6d881574e4a4a}{AE\_NOMORE}) \{
00326                 aeAddMillisecondsToNow(retval,&te->when\_sec,&te->when\_ms);
00327             \} \textcolor{keywordflow}{else} \{
00328                 te->id = \hyperlink{ae_8h_aee0b2fc7b62d8e06517136a91d7f635d}{AE\_DELETED\_EVENT\_ID};
00329             \}
00330         \}
00331         prev = te;
00332         te = te->next;
00333     \}
00334     \textcolor{keywordflow}{return} processed;
00335 \}
00336 
00337 \textcolor{comment}{/* Process every pending time event, then every pending file event}
00338 \textcolor{comment}{ * (that may be registered by time event callbacks just processed).}
00339 \textcolor{comment}{ * Without special flags the function sleeps until some file event}
00340 \textcolor{comment}{ * fires, or when the next time event occurs (if any).}
00341 \textcolor{comment}{ *}
00342 \textcolor{comment}{ * If flags is 0, the function does nothing and returns.}
00343 \textcolor{comment}{ * if flags has AE\_ALL\_EVENTS set, all the kind of events are processed.}
00344 \textcolor{comment}{ * if flags has AE\_FILE\_EVENTS set, file events are processed.}
00345 \textcolor{comment}{ * if flags has AE\_TIME\_EVENTS set, time events are processed.}
00346 \textcolor{comment}{ * if flags has AE\_DONT\_WAIT set the function returns ASAP until all}
00347 \textcolor{comment}{ * if flags has AE\_CALL\_AFTER\_SLEEP set, the aftersleep callback is called.}
00348 \textcolor{comment}{ * the events that's possible to process without to wait are processed.}
00349 \textcolor{comment}{ *}
00350 \textcolor{comment}{ * The function returns the number of events processed. */}
00351 \textcolor{keywordtype}{int} aeProcessEvents(aeEventLoop *eventLoop, \textcolor{keywordtype}{int} flags)
00352 \{
00353     \textcolor{keywordtype}{int} processed = 0, numevents;
00354 
00355     \textcolor{comment}{/* Nothing to do? return ASAP */}
00356     \textcolor{keywordflow}{if} (!(flags & \hyperlink{ae_8h_acdc6c5c42302bc81959ed645b22800aa}{AE\_TIME\_EVENTS}) && !(flags & \hyperlink{ae_8h_ac3fe42c648aaa679f6bffaeb1f8f9ea8}{AE\_FILE\_EVENTS})) \textcolor{keywordflow}{return} 0;
00357 
00358     \textcolor{comment}{/* Note that we want call select() even if there are no}
00359 \textcolor{comment}{     * file events to process as long as we want to process time}
00360 \textcolor{comment}{     * events, in order to sleep until the next time event is ready}
00361 \textcolor{comment}{     * to fire. */}
00362     \textcolor{keywordflow}{if} (eventLoop->maxfd != -1 ||
00363         ((flags & \hyperlink{ae_8h_acdc6c5c42302bc81959ed645b22800aa}{AE\_TIME\_EVENTS}) && !(flags & \hyperlink{ae_8h_a95ce6d5997d5b55cef5e1977dc80af28}{AE\_DONT\_WAIT}))) \{
00364         \textcolor{keywordtype}{int} j;
00365         aeTimeEvent *shortest = NULL;
00366         \textcolor{keyword}{struct} timeval tv, *tvp;
00367 
00368         \textcolor{keywordflow}{if} (flags & \hyperlink{ae_8h_acdc6c5c42302bc81959ed645b22800aa}{AE\_TIME\_EVENTS} && !(flags & \hyperlink{ae_8h_a95ce6d5997d5b55cef5e1977dc80af28}{AE\_DONT\_WAIT}))
00369             shortest = aeSearchNearestTimer(eventLoop);
00370         \textcolor{keywordflow}{if} (shortest) \{
00371             \textcolor{keywordtype}{long} now\_sec, now\_ms;
00372 
00373             aeGetTime(&now\_sec, &now\_ms);
00374             tvp = &tv;
00375 
00376             \textcolor{comment}{/* How many milliseconds we need to wait for the next}
00377 \textcolor{comment}{             * time event to fire? */}
00378             \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ms =
00379                 (shortest->when\_sec - now\_sec)*1000 +
00380                 shortest->when\_ms - now\_ms;
00381 
00382             \textcolor{keywordflow}{if} (ms > 0) \{
00383                 tvp->tv\_sec = ms/1000;
00384                 tvp->tv\_usec = (ms % 1000)*1000;
00385             \} \textcolor{keywordflow}{else} \{
00386                 tvp->tv\_sec = 0;
00387                 tvp->tv\_usec = 0;
00388             \}
00389         \} \textcolor{keywordflow}{else} \{
00390             \textcolor{comment}{/* If we have to check for events but need to return}
00391 \textcolor{comment}{             * ASAP because of AE\_DONT\_WAIT we need to set the timeout}
00392 \textcolor{comment}{             * to zero */}
00393             \textcolor{keywordflow}{if} (flags & \hyperlink{ae_8h_a95ce6d5997d5b55cef5e1977dc80af28}{AE\_DONT\_WAIT}) \{
00394                 tv.tv\_sec = tv.tv\_usec = 0;
00395                 tvp = &tv;
00396             \} \textcolor{keywordflow}{else} \{
00397                 \textcolor{comment}{/* Otherwise we can block */}
00398                 tvp = NULL; \textcolor{comment}{/* wait forever */}
00399             \}
00400         \}
00401 
00402         \textcolor{comment}{/* Call the multiplexing API, will return only on timeout or when}
00403 \textcolor{comment}{         * some event fires. */}
00404         numevents = aeApiPoll(eventLoop, tvp);
00405 
00406         \textcolor{comment}{/* After sleep callback. */}
00407         \textcolor{keywordflow}{if} (eventLoop->aftersleep != NULL && flags & \hyperlink{ae_8h_a7fc929b2d363fc270b311f09d5048cca}{AE\_CALL\_AFTER\_SLEEP})
00408             eventLoop->aftersleep(eventLoop);
00409 
00410         \textcolor{keywordflow}{for} (j = 0; j < numevents; j++) \{
00411             aeFileEvent *fe = &eventLoop->events[eventLoop->fired[j].fd];
00412             \textcolor{keywordtype}{int} mask = eventLoop->fired[j].mask;
00413             \textcolor{keywordtype}{int} fd = eventLoop->fired[j].fd;
00414             \textcolor{keywordtype}{int} rfired = 0;
00415 
00416         \textcolor{comment}{/* note the fe->mask & mask & ... code: maybe an already processed}
00417 \textcolor{comment}{             * event removed an element that fired and we still didn't}
00418 \textcolor{comment}{             * processed, so we check if the event is still valid. */}
00419             \textcolor{keywordflow}{if} (fe->mask & mask & \hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE}) \{
00420                 rfired = 1;
00421                 fe->rfileProc(eventLoop,fd,fe->clientData,mask);
00422             \}
00423             \textcolor{keywordflow}{if} (fe->mask & mask & \hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE}) \{
00424                 \textcolor{keywordflow}{if} (!rfired || fe->wfileProc != fe->rfileProc)
00425                     fe->wfileProc(eventLoop,fd,fe->clientData,mask);
00426             \}
00427             processed++;
00428         \}
00429     \}
00430     \textcolor{comment}{/* Check time events */}
00431     \textcolor{keywordflow}{if} (flags & \hyperlink{ae_8h_acdc6c5c42302bc81959ed645b22800aa}{AE\_TIME\_EVENTS})
00432         processed += processTimeEvents(eventLoop);
00433 
00434     \textcolor{keywordflow}{return} processed; \textcolor{comment}{/* return the number of processed file/time events */}
00435 \}
00436 
00437 \textcolor{comment}{/* Wait for milliseconds until the given file descriptor becomes}
00438 \textcolor{comment}{ * writable/readable/exception */}
00439 \textcolor{keywordtype}{int} aeWait(\textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{int} mask, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} milliseconds) \{
00440     \textcolor{keyword}{struct} pollfd pfd;
00441     \textcolor{keywordtype}{int} retmask = 0, retval;
00442 
00443     memset(&pfd, 0, \textcolor{keyword}{sizeof}(pfd));
00444     pfd.fd = fd;
00445     \textcolor{keywordflow}{if} (mask & \hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE}) pfd.events |= POLLIN;
00446     \textcolor{keywordflow}{if} (mask & \hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE}) pfd.events |= POLLOUT;
00447 
00448     \textcolor{keywordflow}{if} ((retval = poll(&pfd, 1, milliseconds))== 1) \{
00449         \textcolor{keywordflow}{if} (pfd.revents & POLLIN) retmask |= \hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE};
00450         \textcolor{keywordflow}{if} (pfd.revents & POLLOUT) retmask |= \hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE};
00451     \textcolor{keywordflow}{if} (pfd.revents & POLLERR) retmask |= \hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE};
00452         \textcolor{keywordflow}{if} (pfd.revents & POLLHUP) retmask |= \hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE};
00453         \textcolor{keywordflow}{return} retmask;
00454     \} \textcolor{keywordflow}{else} \{
00455         \textcolor{keywordflow}{return} retval;
00456     \}
00457 \}
00458 
00459 \textcolor{keywordtype}{void} aeMain(aeEventLoop *eventLoop) \{
00460     eventLoop->stop = 0;
00461     \textcolor{keywordflow}{while} (!eventLoop->stop) \{
00462         \textcolor{keywordflow}{if} (eventLoop->beforesleep != NULL)
00463             eventLoop->beforesleep(eventLoop);
00464         aeProcessEvents(eventLoop, \hyperlink{ae_8h_a680280f52124f876adfeb7e81cb20264}{AE\_ALL\_EVENTS}|
      \hyperlink{ae_8h_a7fc929b2d363fc270b311f09d5048cca}{AE\_CALL\_AFTER\_SLEEP});
00465     \}
00466 \}
00467 
00468 \textcolor{keywordtype}{char} *aeGetApiName(\textcolor{keywordtype}{void}) \{
00469     \textcolor{keywordflow}{return} aeApiName();
00470 \}
00471 
00472 \textcolor{keywordtype}{void} aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep) \{
00473     eventLoop->beforesleep = beforesleep;
00474 \}
00475 
00476 \textcolor{keywordtype}{void} aeSetAfterSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *aftersleep) \{
00477     eventLoop->aftersleep = aftersleep;
00478 \}
\end{DoxyCode}
