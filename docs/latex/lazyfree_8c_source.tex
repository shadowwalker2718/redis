\hypertarget{lazyfree_8c_source}{}\section{lazyfree.\+c}
\label{lazyfree_8c_source}\index{src/lazyfree.\+c@{src/lazyfree.\+c}}

\begin{DoxyCode}
00001 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{server_8h}{"server.h"}
00002 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{bio_8h}{"bio.h"}
00003 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{atomicvar_8h}{"atomicvar.h"}
00004 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{cluster_8h}{"cluster.h"}
00005 
00006 \textcolor{keyword}{static} size\_t lazyfree\_objects = 0;
00007 pthread\_mutex\_t lazyfree\_objects\_mutex = PTHREAD\_MUTEX\_INITIALIZER;
00008 
00009 \textcolor{comment}{/* Return the number of currently pending objects to free. */}
00010 size\_t lazyfreeGetPendingObjectsCount(\textcolor{keywordtype}{void}) \{
00011     size\_t aux;
00012     \hyperlink{atomicvar_8h_a57b17e058ecff6871debb3d1d4f3031a}{atomicGet}(lazyfree\_objects,aux);
00013     \textcolor{keywordflow}{return} aux;
00014 \}
00015 
00016 \textcolor{comment}{/* Return the amount of work needed in order to free an object.}
00017 \textcolor{comment}{ * The return value is not always the actual number of allocations the}
00018 \textcolor{comment}{ * object is compoesd of, but a number proportional to it.}
00019 \textcolor{comment}{ *}
00020 \textcolor{comment}{ * For strings the function always returns 1.}
00021 \textcolor{comment}{ *}
00022 \textcolor{comment}{ * For aggregated objects represented by hash tables or other data structures}
00023 \textcolor{comment}{ * the function just returns the number of elements the object is composed of.}
00024 \textcolor{comment}{ *}
00025 \textcolor{comment}{ * Objects composed of single allocations are always reported as having a}
00026 \textcolor{comment}{ * single item even if they are actaully logical composed of multiple}
00027 \textcolor{comment}{ * elements.}
00028 \textcolor{comment}{ *}
00029 \textcolor{comment}{ * For lists the funciton returns the number of elements in the quicklist}
00030 \textcolor{comment}{ * representing the list. */}
00031 size\_t lazyfreeGetFreeEffort(robj *obj) \{
00032     \textcolor{keywordflow}{if} (obj->type == \hyperlink{server_8h_a4a5f22a280949c97a0cb0d4213275126}{OBJ\_LIST}) \{
00033         quicklist *ql = obj->ptr;
00034         \textcolor{keywordflow}{return} ql->len;
00035     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (obj->type == \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET} && obj->encoding == 
      \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00036         dict *ht = obj->ptr;
00037         \textcolor{keywordflow}{return} \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(ht);
00038     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (obj->type == \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET} && obj->encoding == 
      \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST})\{
00039         zset *zs = obj->ptr;
00040         \textcolor{keywordflow}{return} zs->zsl->length;
00041     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (obj->type == \hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH} && obj->encoding == 
      \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00042         dict *ht = obj->ptr;
00043         \textcolor{keywordflow}{return} \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(ht);
00044     \} \textcolor{keywordflow}{else} \{
00045         \textcolor{keywordflow}{return} 1; \textcolor{comment}{/* Everything else is a single allocation. */}
00046     \}
00047 \}
00048 
00049 \textcolor{comment}{/* Delete a key, value, and associated expiration entry if any, from the DB.}
00050 \textcolor{comment}{ * If there are enough allocations to free the value object may be put into}
00051 \textcolor{comment}{ * a lazy free list instead of being freed synchronously. The lazy free list}
00052 \textcolor{comment}{ * will be reclaimed in a different bio.c thread. */}
00053 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LAZYFREE\_THRESHOLD} 64
00054 \textcolor{keywordtype}{int} dbAsyncDelete(redisDb *db, robj *key) \{
00055     \textcolor{comment}{/* Deleting an entry from the expires dict will not free the sds of}
00056 \textcolor{comment}{     * the key, because it is shared with the main dictionary. */}
00057     \textcolor{keywordflow}{if} (\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(db->expires) > 0) dictDelete(db->expires,key->ptr);
00058 
00059     \textcolor{comment}{/* If the value is composed of a few allocations, to free in a lazy way}
00060 \textcolor{comment}{     * is actually just slower... So under a certain limit we just free}
00061 \textcolor{comment}{     * the object synchronously. */}
00062     dictEntry *de = dictUnlink(db->dict,key->ptr);
00063     \textcolor{keywordflow}{if} (de) \{
00064         robj *val = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
00065         size\_t free\_effort = lazyfreeGetFreeEffort(val);
00066 
00067         \textcolor{comment}{/* If releasing the object is too much work, let's put it into the}
00068 \textcolor{comment}{         * lazy free list. */}
00069         \textcolor{keywordflow}{if} (free\_effort > \hyperlink{lazyfree_8c_a16c7a657b0fbf79b2e92306f347c4512}{LAZYFREE\_THRESHOLD}) \{
00070             \hyperlink{atomicvar_8h_acb57163a8c3d3c29f38ad239ef0a9c2d}{atomicIncr}(lazyfree\_objects,1);
00071             bioCreateBackgroundJob(\hyperlink{bio_8h_afdc82658b2e29c63afcdb2e808b8a510}{BIO\_LAZY\_FREE},val,NULL,NULL);
00072             \hyperlink{dict_8h_a95cae6581aca3a7a4c5e226e565294c9}{dictSetVal}(db->dict,de,NULL);
00073         \}
00074     \}
00075 
00076     \textcolor{comment}{/* Release the key-val pair, or just the key if we set the val}
00077 \textcolor{comment}{     * field to NULL in order to lazy free it later. */}
00078     \textcolor{keywordflow}{if} (de) \{
00079         dictFreeUnlinkedEntry(db->dict,de);
00080         \textcolor{keywordflow}{if} (server.cluster\_enabled) slotToKeyDel(key);
00081         \textcolor{keywordflow}{return} 1;
00082     \} \textcolor{keywordflow}{else} \{
00083         \textcolor{keywordflow}{return} 0;
00084     \}
00085 \}
00086 
00087 \textcolor{comment}{/* Empty a Redis DB asynchronously. What the function does actually is to}
00088 \textcolor{comment}{ * create a new empty set of hash tables and scheduling the old ones for}
00089 \textcolor{comment}{ * lazy freeing. */}
00090 \textcolor{keywordtype}{void} emptyDbAsync(redisDb *db) \{
00091     dict *oldht1 = db->dict, *oldht2 = db->expires;
00092     db->dict = dictCreate(&dbDictType,NULL);
00093     db->expires = dictCreate(&keyptrDictType,NULL);
00094     \hyperlink{atomicvar_8h_acb57163a8c3d3c29f38ad239ef0a9c2d}{atomicIncr}(lazyfree\_objects,\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(oldht1));
00095     bioCreateBackgroundJob(\hyperlink{bio_8h_afdc82658b2e29c63afcdb2e808b8a510}{BIO\_LAZY\_FREE},NULL,oldht1,oldht2);
00096 \}
00097 
00098 \textcolor{comment}{/* Empty the slots-keys map of Redis CLuster by creating a new empty one}
00099 \textcolor{comment}{ * and scheduiling the old for lazy freeing. */}
00100 \textcolor{keywordtype}{void} slotToKeyFlushAsync(\textcolor{keywordtype}{void}) \{
00101     rax *old = server.cluster->slots\_to\_keys;
00102 
00103     server.cluster->slots\_to\_keys = raxNew();
00104     memset(server.cluster->slots\_keys\_count,0,
00105            \textcolor{keyword}{sizeof}(server.cluster->slots\_keys\_count));
00106     \hyperlink{atomicvar_8h_acb57163a8c3d3c29f38ad239ef0a9c2d}{atomicIncr}(lazyfree\_objects,old->numele);
00107     bioCreateBackgroundJob(\hyperlink{bio_8h_afdc82658b2e29c63afcdb2e808b8a510}{BIO\_LAZY\_FREE},NULL,NULL,old);
00108 \}
00109 
00110 \textcolor{comment}{/* Release objects from the lazyfree thread. It's just decrRefCount()}
00111 \textcolor{comment}{ * updating the count of objects to release. */}
00112 \textcolor{keywordtype}{void} lazyfreeFreeObjectFromBioThread(robj *o) \{
00113     decrRefCount(o);
00114     \hyperlink{atomicvar_8h_ab416a5857f1cf1a6dee0310c39ea2036}{atomicDecr}(lazyfree\_objects,1);
00115 \}
00116 
00117 \textcolor{comment}{/* Release a database from the lazyfree thread. The 'db' pointer is the}
00118 \textcolor{comment}{ * database which was substitutied with a fresh one in the main thread}
00119 \textcolor{comment}{ * when the database was logically deleted. 'sl' is a skiplist used by}
00120 \textcolor{comment}{ * Redis Cluster in order to take the hash slots -> keys mapping. This}
00121 \textcolor{comment}{ * may be NULL if Redis Cluster is disabled. */}
00122 \textcolor{keywordtype}{void} lazyfreeFreeDatabaseFromBioThread(dict *ht1, dict *ht2) \{
00123     size\_t numkeys = \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(ht1);
00124     dictRelease(ht1);
00125     dictRelease(ht2);
00126     \hyperlink{atomicvar_8h_ab416a5857f1cf1a6dee0310c39ea2036}{atomicDecr}(lazyfree\_objects,numkeys);
00127 \}
00128 
00129 \textcolor{comment}{/* Release the skiplist mapping Redis Cluster keys to slots in the}
00130 \textcolor{comment}{ * lazyfree thread. */}
00131 \textcolor{keywordtype}{void} lazyfreeFreeSlotsMapFromBioThread(rax *rt) \{
00132     size\_t len = rt->numele;
00133     raxFree(rt);
00134     \hyperlink{atomicvar_8h_ab416a5857f1cf1a6dee0310c39ea2036}{atomicDecr}(lazyfree\_objects,len);
00135 \}
\end{DoxyCode}
