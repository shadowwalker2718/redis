\hypertarget{helloblock_8c_source}{}\section{helloblock.\+c}
\label{helloblock_8c_source}\index{src/modules/helloblock.\+c@{src/modules/helloblock.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* Helloblock module -- An example of blocking command implementation}
00002 \textcolor{comment}{ * with threads.}
00003 \textcolor{comment}{ *}
00004 \textcolor{comment}{ * -----------------------------------------------------------------------------}
00005 \textcolor{comment}{ *}
00006 \textcolor{comment}{ * Copyright (c) 2016, Salvatore Sanfilippo <antirez at gmail dot com>}
00007 \textcolor{comment}{ * All rights reserved.}
00008 \textcolor{comment}{ *}
00009 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00010 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00011 \textcolor{comment}{ *}
00012 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00013 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00014 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00015 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00016 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00017 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00018 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00019 \textcolor{comment}{ *     specific prior written permission.}
00020 \textcolor{comment}{ *}
00021 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00022 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00023 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00024 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00025 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00026 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00027 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00028 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00029 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00030 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00031 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00032 \textcolor{comment}{ */}
00033 
00034 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_EXPERIMENTAL\_API}
00035 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{"../redismodule.h"}
00036 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdio}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00037 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdlib}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00038 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{pthread}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00039 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{unistd}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00040 
00041 \textcolor{comment}{/* Reply callback for blocking command HELLO.BLOCK */}
00042 \textcolor{keywordtype}{int} HelloBlock\_Reply(RedisModuleCtx *ctx, RedisModuleString **argv, \textcolor{keywordtype}{int} argc) \{
00043     \hyperlink{redismodule_8h_a46d75d81383a00bd6b941af6cadf64c2}{REDISMODULE\_NOT\_USED}(argv);
00044     \hyperlink{redismodule_8h_a46d75d81383a00bd6b941af6cadf64c2}{REDISMODULE\_NOT\_USED}(argc);
00045     \textcolor{keywordtype}{int} *myint = RedisModule\_GetBlockedClientPrivateData(ctx);
00046     \textcolor{keywordflow}{return} RedisModule\_ReplyWithLongLong(ctx,*myint);
00047 \}
00048 
00049 \textcolor{comment}{/* Timeout callback for blocking command HELLO.BLOCK */}
00050 \textcolor{keywordtype}{int} HelloBlock\_Timeout(RedisModuleCtx *ctx, RedisModuleString **argv, \textcolor{keywordtype}{int} argc) \{
00051     \hyperlink{redismodule_8h_a46d75d81383a00bd6b941af6cadf64c2}{REDISMODULE\_NOT\_USED}(argv);
00052     \hyperlink{redismodule_8h_a46d75d81383a00bd6b941af6cadf64c2}{REDISMODULE\_NOT\_USED}(argc);
00053     \textcolor{keywordflow}{return} RedisModule\_ReplyWithSimpleString(ctx,\textcolor{stringliteral}{"Request timedout"});
00054 \}
00055 
00056 \textcolor{comment}{/* Private data freeing callback for HELLO.BLOCK command. */}
00057 \textcolor{keywordtype}{void} HelloBlock\_FreeData(\textcolor{keywordtype}{void} *privdata) \{
00058     RedisModule\_Free(privdata);
00059 \}
00060 
00061 \textcolor{comment}{/* The thread entry point that actually executes the blocking part}
00062 \textcolor{comment}{ * of the command HELLO.BLOCK. */}
00063 \textcolor{keywordtype}{void} *HelloBlock\_ThreadMain(\textcolor{keywordtype}{void} *arg) \{
00064     \textcolor{keywordtype}{void} **targ = arg;
00065     RedisModuleBlockedClient *bc = targ[0];
00066     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} delay = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})targ[1];
00067     RedisModule\_Free(targ);
00068 
00069     sleep(delay);
00070     \textcolor{keywordtype}{int} *r = RedisModule\_Alloc(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}));
00071     *r = rand();
00072     RedisModule\_UnblockClient(bc,r);
00073     \textcolor{keywordflow}{return} NULL;
00074 \}
00075 
00076 \textcolor{comment}{/* HELLO.BLOCK <delay> <timeout> -- Block for <count> seconds, then reply with}
00077 \textcolor{comment}{ * a random number. Timeout is the command timeout, so that you can test}
00078 \textcolor{comment}{ * what happens when the delay is greater than the timeout. */}
00079 \textcolor{keywordtype}{int} HelloBlock\_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, \textcolor{keywordtype}{int} argc) \{
00080     \textcolor{keywordflow}{if} (argc != 3) \textcolor{keywordflow}{return} RedisModule\_WrongArity(ctx);
00081     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} delay;
00082     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} timeout;
00083 
00084     \textcolor{keywordflow}{if} (RedisModule\_StringToLongLong(argv[1],&delay) != \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK}) \{
00085         \textcolor{keywordflow}{return} RedisModule\_ReplyWithError(ctx,\textcolor{stringliteral}{"ERR invalid count"});
00086     \}
00087 
00088     \textcolor{keywordflow}{if} (RedisModule\_StringToLongLong(argv[2],&timeout) != \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK}) \{
00089         \textcolor{keywordflow}{return} RedisModule\_ReplyWithError(ctx,\textcolor{stringliteral}{"ERR invalid count"});
00090     \}
00091 
00092     pthread\_t tid;
00093     RedisModuleBlockedClient *bc = RedisModule\_BlockClient(ctx,HelloBlock\_Reply,HelloBlock\_Timeout,
      HelloBlock\_FreeData,timeout);
00094 
00095     \textcolor{comment}{/* Now that we setup a blocking client, we need to pass the control}
00096 \textcolor{comment}{     * to the thread. However we need to pass arguments to the thread:}
00097 \textcolor{comment}{     * the delay and a reference to the blocked client handle. */}
00098     \textcolor{keywordtype}{void} **targ = RedisModule\_Alloc(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*)*2);
00099     targ[0] = bc;
00100     targ[1] = (\textcolor{keywordtype}{void}*)(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}) delay;
00101 
00102     \textcolor{keywordflow}{if} (pthread\_create(&tid,NULL,HelloBlock\_ThreadMain,targ) != 0) \{
00103         RedisModule\_AbortBlock(bc);
00104         \textcolor{keywordflow}{return} RedisModule\_ReplyWithError(ctx,\textcolor{stringliteral}{"-ERR Can't start thread"});
00105     \}
00106     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
00107 \}
00108 
00109 \textcolor{comment}{/* The thread entry point that actually executes the blocking part}
00110 \textcolor{comment}{ * of the command HELLO.KEYS.}
00111 \textcolor{comment}{ *}
00112 \textcolor{comment}{ * Note: this implementation is very simple on purpose, so no duplicated}
00113 \textcolor{comment}{ * keys (returned by SCAN) are filtered. However adding such a functionality}
00114 \textcolor{comment}{ * would be trivial just using any data structure implementing a dictionary}
00115 \textcolor{comment}{ * in order to filter the duplicated items. */}
00116 \textcolor{keywordtype}{void} *HelloKeys\_ThreadMain(\textcolor{keywordtype}{void} *arg) \{
00117     RedisModuleBlockedClient *bc = arg;
00118     RedisModuleCtx *ctx = RedisModule\_GetThreadSafeContext(bc);
00119     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} cursor = 0;
00120     size\_t replylen = 0;
00121 
00122     RedisModule\_ReplyWithArray(ctx,\hyperlink{redismodule_8h_af07005134cbf107aad1c8e0ded8fcf2b}{REDISMODULE\_POSTPONED\_ARRAY\_LEN});
00123     \textcolor{keywordflow}{do} \{
00124         RedisModule\_ThreadSafeContextLock(ctx);
00125         RedisModuleCallReply *reply = RedisModule\_Call(ctx,
00126             \textcolor{stringliteral}{"SCAN"},\textcolor{stringliteral}{"l"},(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long})cursor);
00127         RedisModule\_ThreadSafeContextUnlock(ctx);
00128 
00129         RedisModuleCallReply *cr\_cursor =
00130             RedisModule\_CallReplyArrayElement(reply,0);
00131         RedisModuleCallReply *cr\_keys =
00132             RedisModule\_CallReplyArrayElement(reply,1);
00133 
00134         RedisModuleString *s = RedisModule\_CreateStringFromCallReply(cr\_cursor);
00135         RedisModule\_StringToLongLong(s,&cursor);
00136         RedisModule\_FreeString(ctx,s);
00137 
00138         size\_t items = RedisModule\_CallReplyLength(cr\_keys);
00139         \textcolor{keywordflow}{for} (size\_t j = 0; j < items; j++) \{
00140             RedisModuleCallReply *ele =
00141                 RedisModule\_CallReplyArrayElement(cr\_keys,j);
00142             RedisModule\_ReplyWithCallReply(ctx,ele);
00143             replylen++;
00144         \}
00145         RedisModule\_FreeCallReply(reply);
00146     \} \textcolor{keywordflow}{while} (cursor != 0);
00147     RedisModule\_ReplySetArrayLength(ctx,replylen);
00148 
00149     RedisModule\_FreeThreadSafeContext(ctx);
00150     RedisModule\_UnblockClient(bc,NULL);
00151     \textcolor{keywordflow}{return} NULL;
00152 \}
00153 
00154 \textcolor{comment}{/* HELLO.KEYS -- Return all the keys in the current database without blocking}
00155 \textcolor{comment}{ * the server. The keys do not represent a point-in-time state so only the keys}
00156 \textcolor{comment}{ * that were in the database from the start to the end are guaranteed to be}
00157 \textcolor{comment}{ * there. */}
00158 \textcolor{keywordtype}{int} HelloKeys\_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, \textcolor{keywordtype}{int} argc) \{
00159     \hyperlink{redismodule_8h_a46d75d81383a00bd6b941af6cadf64c2}{REDISMODULE\_NOT\_USED}(argv);
00160     \textcolor{keywordflow}{if} (argc != 1) \textcolor{keywordflow}{return} RedisModule\_WrongArity(ctx);
00161 
00162     pthread\_t tid;
00163 
00164     \textcolor{comment}{/* Note that when blocking the client we do not set any callback: no}
00165 \textcolor{comment}{     * timeout is possible since we passed '0', nor we need a reply callback}
00166 \textcolor{comment}{     * because we'll use the thread safe context to accumulate a reply. */}
00167     RedisModuleBlockedClient *bc = RedisModule\_BlockClient(ctx,NULL,NULL,NULL,0);
00168 
00169     \textcolor{comment}{/* Now that we setup a blocking client, we need to pass the control}
00170 \textcolor{comment}{     * to the thread. However we need to pass arguments to the thread:}
00171 \textcolor{comment}{     * the reference to the blocked client handle. */}
00172     \textcolor{keywordflow}{if} (pthread\_create(&tid,NULL,HelloKeys\_ThreadMain,bc) != 0) \{
00173         RedisModule\_AbortBlock(bc);
00174         \textcolor{keywordflow}{return} RedisModule\_ReplyWithError(ctx,\textcolor{stringliteral}{"-ERR Can't start thread"});
00175     \}
00176     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
00177 \}
00178 
00179 \textcolor{comment}{/* This function must be present on each Redis module. It is used in order to}
00180 \textcolor{comment}{ * register the commands into the Redis server. */}
00181 \textcolor{keywordtype}{int} RedisModule\_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, \textcolor{keywordtype}{int} argc) \{
00182     \hyperlink{redismodule_8h_a46d75d81383a00bd6b941af6cadf64c2}{REDISMODULE\_NOT\_USED}(argv);
00183     \hyperlink{redismodule_8h_a46d75d81383a00bd6b941af6cadf64c2}{REDISMODULE\_NOT\_USED}(argc);
00184 
00185     \textcolor{keywordflow}{if} (RedisModule\_Init(ctx,\textcolor{stringliteral}{"helloblock"},1,\hyperlink{redismodule_8h_a1fc9be44e4cd6d60f7129d4393b6b580}{REDISMODULE\_APIVER\_1})
00186         == \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR}) \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
00187 
00188     \textcolor{keywordflow}{if} (RedisModule\_CreateCommand(ctx,\textcolor{stringliteral}{"hello.block"},
00189         HelloBlock\_RedisCommand,\textcolor{stringliteral}{""},0,0,0) == \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR})
00190         \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
00191     \textcolor{keywordflow}{if} (RedisModule\_CreateCommand(ctx,\textcolor{stringliteral}{"hello.keys"},
00192         HelloKeys\_RedisCommand,\textcolor{stringliteral}{""},0,0,0) == \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR})
00193         \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
00194 
00195     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
00196 \}
\end{DoxyCode}
