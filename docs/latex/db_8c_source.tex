\hypertarget{db_8c_source}{}\section{db.\+c}
\label{db_8c_source}\index{src/db.\+c@{src/db.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>}
00003 \textcolor{comment}{ * All rights reserved.}
00004 \textcolor{comment}{ *}
00005 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00006 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00007 \textcolor{comment}{ *}
00008 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00009 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00010 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00011 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00012 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00013 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00014 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00015 \textcolor{comment}{ *     specific prior written permission.}
00016 \textcolor{comment}{ *}
00017 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00018 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00019 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00020 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00021 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00022 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00023 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00024 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00025 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00026 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00027 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00028 \textcolor{comment}{ */}
00029 
00030 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{server_8h}{"server.h"}
00031 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{cluster_8h}{"cluster.h"}
00032 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{atomicvar_8h}{"atomicvar.h"}
00033 
00034 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{signal}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00035 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{ctype}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00036 
00037 \textcolor{comment}{/*-----------------------------------------------------------------------------}
00038 \textcolor{comment}{ * C-level DB API}
00039 \textcolor{comment}{ *----------------------------------------------------------------------------*/}
00040 
00041 \textcolor{comment}{/* Update LFU when an object is accessed.}
00042 \textcolor{comment}{ * Firstly, decrement the counter if the decrement time is reached.}
00043 \textcolor{comment}{ * Then logarithmically increment the counter, and update the access time. */}
00044 \textcolor{keywordtype}{void} updateLFU(robj *val) \{
00045     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} counter = LFUDecrAndReturn(val);
00046     counter = LFULogIncr(counter);
00047     val->lru = (LFUGetTimeInMinutes()<<8) | counter;
00048 \}
00049 
00050 \textcolor{comment}{/* Low level key lookup API, not actually called directly from commands}
00051 \textcolor{comment}{ * implementations that should instead rely on lookupKeyRead(),}
00052 \textcolor{comment}{ * lookupKeyWrite() and lookupKeyReadWithFlags(). */}
00053 robj *lookupKey(redisDb *db, robj *key, \textcolor{keywordtype}{int} flags) \{
00054     dictEntry *de = dictFind(db->dict,key->ptr);
00055     \textcolor{keywordflow}{if} (de) \{
00056         robj *val = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
00057 
00058         \textcolor{comment}{/* Update the access time for the ageing algorithm.}
00059 \textcolor{comment}{         * Don't do it if we have a saving child, as this will trigger}
00060 \textcolor{comment}{         * a copy on write madness. */}
00061         \textcolor{keywordflow}{if} (server.rdb\_child\_pid == -1 &&
00062             server.aof\_child\_pid == -1 &&
00063             !(flags & \hyperlink{server_8h_aedc57e62fa05a1b438fa4ed16a803718}{LOOKUP\_NOTOUCH}))
00064         \{
00065             \textcolor{keywordflow}{if} (server.maxmemory\_policy & \hyperlink{server_8h_aac2d3ad7a604f87e06e25233dbd01c9b}{MAXMEMORY\_FLAG\_LFU}) \{
00066                 updateLFU(val);
00067             \} \textcolor{keywordflow}{else} \{
00068                 val->lru = LRU\_CLOCK();
00069             \}
00070         \}
00071         \textcolor{keywordflow}{return} val;
00072     \} \textcolor{keywordflow}{else} \{
00073         \textcolor{keywordflow}{return} NULL;
00074     \}
00075 \}
00076 
00077 \textcolor{comment}{/* Lookup a key for read operations, or return NULL if the key is not found}
00078 \textcolor{comment}{ * in the specified DB.}
00079 \textcolor{comment}{ *}
00080 \textcolor{comment}{ * As a side effect of calling this function:}
00081 \textcolor{comment}{ * 1. A key gets expired if it reached it's TTL.}
00082 \textcolor{comment}{ * 2. The key last access time is updated.}
00083 \textcolor{comment}{ * 3. The global keys hits/misses stats are updated (reported in INFO).}
00084 \textcolor{comment}{ *}
00085 \textcolor{comment}{ * This API should not be used when we write to the key after obtaining}
00086 \textcolor{comment}{ * the object linked to the key, but only for read only operations.}
00087 \textcolor{comment}{ *}
00088 \textcolor{comment}{ * Flags change the behavior of this command:}
00089 \textcolor{comment}{ *}
00090 \textcolor{comment}{ *  LOOKUP\_NONE (or zero): no special flags are passed.}
00091 \textcolor{comment}{ *  LOOKUP\_NOTOUCH: don't alter the last access time of the key.}
00092 \textcolor{comment}{ *}
00093 \textcolor{comment}{ * Note: this function also returns NULL is the key is logically expired}
00094 \textcolor{comment}{ * but still existing, in case this is a slave, since this API is called only}
00095 \textcolor{comment}{ * for read operations. Even if the key expiry is master-driven, we can}
00096 \textcolor{comment}{ * correctly report a key is expired on slaves even if the master is lagging}
00097 \textcolor{comment}{ * expiring our key via DELs in the replication link. */}
00098 robj *lookupKeyReadWithFlags(redisDb *db, robj *key, \textcolor{keywordtype}{int} flags) \{
00099     robj *val;
00100 
00101     \textcolor{keywordflow}{if} (expireIfNeeded(db,key) == 1) \{
00102         \textcolor{comment}{/* Key expired. If we are in the context of a master, expireIfNeeded()}
00103 \textcolor{comment}{         * returns 0 only when the key does not exist at all, so it's safe}
00104 \textcolor{comment}{         * to return NULL ASAP. */}
00105         \textcolor{keywordflow}{if} (server.masterhost == NULL) \textcolor{keywordflow}{return} NULL;
00106 
00107         \textcolor{comment}{/* However if we are in the context of a slave, expireIfNeeded() will}
00108 \textcolor{comment}{         * not really try to expire the key, it only returns information}
00109 \textcolor{comment}{         * about the "logical" status of the key: key expiring is up to the}
00110 \textcolor{comment}{         * master in order to have a consistent view of master's data set.}
00111 \textcolor{comment}{         *}
00112 \textcolor{comment}{         * However, if the command caller is not the master, and as additional}
00113 \textcolor{comment}{         * safety measure, the command invoked is a read-only command, we can}
00114 \textcolor{comment}{         * safely return NULL here, and provide a more consistent behavior}
00115 \textcolor{comment}{         * to clients accessign expired values in a read-only fashion, that}
00116 \textcolor{comment}{         * will say the key as non exisitng.}
00117 \textcolor{comment}{         *}
00118 \textcolor{comment}{         * Notably this covers GETs when slaves are used to scale reads. */}
00119         \textcolor{keywordflow}{if} (server.current\_client &&
00120             server.current\_client != server.master &&
00121             server.current\_client->cmd &&
00122             server.current\_client->cmd->flags & \hyperlink{server_8h_a7e9c728f228e1c82ae1e22173375abcf}{CMD\_READONLY})
00123         \{
00124             \textcolor{keywordflow}{return} NULL;
00125         \}
00126     \}
00127     val = lookupKey(db,key,flags);
00128     \textcolor{keywordflow}{if} (val == NULL)
00129         server.stat\_keyspace\_misses++;
00130     \textcolor{keywordflow}{else}
00131         server.stat\_keyspace\_hits++;
00132     \textcolor{keywordflow}{return} val;
00133 \}
00134 
00135 \textcolor{comment}{/* Like lookupKeyReadWithFlags(), but does not use any flag, which is the}
00136 \textcolor{comment}{ * common case. */}
00137 robj *lookupKeyRead(redisDb *db, robj *key) \{
00138     \textcolor{keywordflow}{return} lookupKeyReadWithFlags(db,key,\hyperlink{server_8h_a72b53acd3e3042660b3b76685a6335ca}{LOOKUP\_NONE});
00139 \}
00140 
00141 \textcolor{comment}{/* Lookup a key for write operations, and as a side effect, if needed, expires}
00142 \textcolor{comment}{ * the key if its TTL is reached.}
00143 \textcolor{comment}{ *}
00144 \textcolor{comment}{ * Returns the linked value object if the key exists or NULL if the key}
00145 \textcolor{comment}{ * does not exist in the specified DB. */}
00146 robj *lookupKeyWrite(redisDb *db, robj *key) \{
00147     expireIfNeeded(db,key);
00148     \textcolor{keywordflow}{return} lookupKey(db,key,\hyperlink{server_8h_a72b53acd3e3042660b3b76685a6335ca}{LOOKUP\_NONE});
00149 \}
00150 
00151 robj *lookupKeyReadOrReply(\hyperlink{structclient}{client} *c, robj *key, robj *reply) \{
00152     robj *o = lookupKeyRead(c->db, key);
00153     \textcolor{keywordflow}{if} (!o) addReply(c,reply);
00154     \textcolor{keywordflow}{return} o;
00155 \}
00156 
00157 robj *lookupKeyWriteOrReply(\hyperlink{structclient}{client} *c, robj *key, robj *reply) \{
00158     robj *o = lookupKeyWrite(c->db, key);
00159     \textcolor{keywordflow}{if} (!o) addReply(c,reply);
00160     \textcolor{keywordflow}{return} o;
00161 \}
00162 
00163 \textcolor{comment}{/* Add the key to the DB. It's up to the caller to increment the reference}
00164 \textcolor{comment}{ * counter of the value if needed.}
00165 \textcolor{comment}{ *}
00166 \textcolor{comment}{ * The program is aborted if the key already exists. */}
00167 \textcolor{keywordtype}{void} dbAdd(redisDb *db, robj *key, robj *val) \{
00168     sds copy = sdsdup(key->ptr);
00169     \textcolor{keywordtype}{int} retval = dictAdd(db->dict, copy, val);
00170 
00171     \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(NULL,key,retval == \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK});
00172     \textcolor{keywordflow}{if} (val->type == \hyperlink{server_8h_a4a5f22a280949c97a0cb0d4213275126}{OBJ\_LIST}) signalKeyAsReady(db, key);
00173     \textcolor{keywordflow}{if} (server.cluster\_enabled) slotToKeyAdd(key);
00174 \}
00175 
00176 \textcolor{comment}{/* Overwrite an existing key with a new value. Incrementing the reference}
00177 \textcolor{comment}{ * count of the new value is up to the caller.}
00178 \textcolor{comment}{ * This function does not modify the expire time of the existing key.}
00179 \textcolor{comment}{ *}
00180 \textcolor{comment}{ * The program is aborted if the key was not already present. */}
00181 \textcolor{keywordtype}{void} dbOverwrite(redisDb *db, robj *key, robj *val) \{
00182     dictEntry *de = dictFind(db->dict,key->ptr);
00183 
00184     \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(NULL,key,de != NULL);
00185     \textcolor{keywordflow}{if} (server.maxmemory\_policy & \hyperlink{server_8h_aac2d3ad7a604f87e06e25233dbd01c9b}{MAXMEMORY\_FLAG\_LFU}) \{
00186         robj *old = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
00187         \textcolor{keywordtype}{int} saved\_lru = old->lru;
00188         dictReplace(db->dict, key->ptr, val);
00189         val->lru = saved\_lru;
00190         \textcolor{comment}{/* LFU should be not only copied but also updated}
00191 \textcolor{comment}{         * when a key is overwritten. */}
00192         updateLFU(val);
00193     \} \textcolor{keywordflow}{else} \{
00194         dictReplace(db->dict, key->ptr, val);
00195     \}
00196 \}
00197 
00198 \textcolor{comment}{/* High level Set operation. This function can be used in order to set}
00199 \textcolor{comment}{ * a key, whatever it was existing or not, to a new object.}
00200 \textcolor{comment}{ *}
00201 \textcolor{comment}{ * 1) The ref count of the value object is incremented.}
00202 \textcolor{comment}{ * 2) clients WATCHing for the destination key notified.}
00203 \textcolor{comment}{ * 3) The expire time of the key is reset (the key is made persistent).}
00204 \textcolor{comment}{ *}
00205 \textcolor{comment}{ * All the new keys in the database should be craeted via this interface. */}
00206 \textcolor{keywordtype}{void} setKey(redisDb *db, robj *key, robj *val) \{
00207     \textcolor{keywordflow}{if} (lookupKeyWrite(db,key) == NULL) \{
00208         dbAdd(db,key,val);
00209     \} \textcolor{keywordflow}{else} \{
00210         dbOverwrite(db,key,val);
00211     \}
00212     incrRefCount(val);
00213     removeExpire(db,key);
00214     signalModifiedKey(db,key);
00215 \}
00216 
00217 \textcolor{keywordtype}{int} dbExists(redisDb *db, robj *key) \{
00218     \textcolor{keywordflow}{return} dictFind(db->dict,key->ptr) != NULL;
00219 \}
00220 
00221 \textcolor{comment}{/* Return a random key, in form of a Redis object.}
00222 \textcolor{comment}{ * If there are no keys, NULL is returned.}
00223 \textcolor{comment}{ *}
00224 \textcolor{comment}{ * The function makes sure to return keys not already expired. */}
00225 robj *dbRandomKey(redisDb *db) \{
00226     dictEntry *de;
00227 
00228     \textcolor{keywordflow}{while}(1) \{
00229         sds key;
00230         robj *keyobj;
00231 
00232         de = dictGetRandomKey(db->dict);
00233         \textcolor{keywordflow}{if} (de == NULL) \textcolor{keywordflow}{return} NULL;
00234 
00235         key = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
00236         keyobj = createStringObject(key,sdslen(key));
00237         \textcolor{keywordflow}{if} (dictFind(db->expires,key)) \{
00238             \textcolor{keywordflow}{if} (expireIfNeeded(db,keyobj)) \{
00239                 decrRefCount(keyobj);
00240                 \textcolor{keywordflow}{continue}; \textcolor{comment}{/* search for another key. This expired. */}
00241             \}
00242         \}
00243         \textcolor{keywordflow}{return} keyobj;
00244     \}
00245 \}
00246 
00247 \textcolor{comment}{/* Delete a key, value, and associated expiration entry if any, from the DB */}
00248 \textcolor{keywordtype}{int} dbSyncDelete(redisDb *db, robj *key) \{
00249     \textcolor{comment}{/* Deleting an entry from the expires dict will not free the sds of}
00250 \textcolor{comment}{     * the key, because it is shared with the main dictionary. */}
00251     \textcolor{keywordflow}{if} (\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(db->expires) > 0) dictDelete(db->expires,key->ptr);
00252     \textcolor{keywordflow}{if} (dictDelete(db->dict,key->ptr) == \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK}) \{
00253         \textcolor{keywordflow}{if} (server.cluster\_enabled) slotToKeyDel(key);
00254         \textcolor{keywordflow}{return} 1;
00255     \} \textcolor{keywordflow}{else} \{
00256         \textcolor{keywordflow}{return} 0;
00257     \}
00258 \}
00259 
00260 \textcolor{comment}{/* This is a wrapper whose behavior depends on the Redis lazy free}
00261 \textcolor{comment}{ * configuration. Deletes the key synchronously or asynchronously. */}
00262 \textcolor{keywordtype}{int} dbDelete(redisDb *db, robj *key) \{
00263     \textcolor{keywordflow}{return} server.lazyfree\_lazy\_server\_del ? dbAsyncDelete(db,key) :
00264                                              dbSyncDelete(db,key);
00265 \}
00266 
00267 \textcolor{comment}{/* Prepare the string object stored at 'key' to be modified destructively}
00268 \textcolor{comment}{ * to implement commands like SETBIT or APPEND.}
00269 \textcolor{comment}{ *}
00270 \textcolor{comment}{ * An object is usually ready to be modified unless one of the two conditions}
00271 \textcolor{comment}{ * are true:}
00272 \textcolor{comment}{ *}
00273 \textcolor{comment}{ * 1) The object 'o' is shared (refcount > 1), we don't want to affect}
00274 \textcolor{comment}{ *    other users.}
00275 \textcolor{comment}{ * 2) The object encoding is not "RAW".}
00276 \textcolor{comment}{ *}
00277 \textcolor{comment}{ * If the object is found in one of the above conditions (or both) by the}
00278 \textcolor{comment}{ * function, an unshared / not-encoded copy of the string object is stored}
00279 \textcolor{comment}{ * at 'key' in the specified 'db'. Otherwise the object 'o' itself is}
00280 \textcolor{comment}{ * returned.}
00281 \textcolor{comment}{ *}
00282 \textcolor{comment}{ * USAGE:}
00283 \textcolor{comment}{ *}
00284 \textcolor{comment}{ * The object 'o' is what the caller already obtained by looking up 'key'}
00285 \textcolor{comment}{ * in 'db', the usage pattern looks like this:}
00286 \textcolor{comment}{ *}
00287 \textcolor{comment}{ * o = lookupKeyWrite(db,key);}
00288 \textcolor{comment}{ * if (checkType(c,o,OBJ\_STRING)) return;}
00289 \textcolor{comment}{ * o = dbUnshareStringValue(db,key,o);}
00290 \textcolor{comment}{ *}
00291 \textcolor{comment}{ * At this point the caller is ready to modify the object, for example}
00292 \textcolor{comment}{ * using an sdscat() call to append some data, or anything else.}
00293 \textcolor{comment}{ */}
00294 robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o) \{
00295     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(o->type == \hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING});
00296     \textcolor{keywordflow}{if} (o->refcount != 1 || o->encoding != \hyperlink{server_8h_a148bc85e3074e324a6dc5eebcad1bcd5}{OBJ\_ENCODING\_RAW}) \{
00297         robj *decoded = getDecodedObject(o);
00298         o = createRawStringObject(decoded->ptr, sdslen(decoded->ptr));
00299         decrRefCount(decoded);
00300         dbOverwrite(db,key,o);
00301     \}
00302     \textcolor{keywordflow}{return} o;
00303 \}
00304 
00305 \textcolor{comment}{/* Remove all keys from all the databases in a Redis server.}
00306 \textcolor{comment}{ * If callback is given the function is called from time to time to}
00307 \textcolor{comment}{ * signal that work is in progress.}
00308 \textcolor{comment}{ *}
00309 \textcolor{comment}{ * The dbnum can be -1 if all teh DBs should be flushed, or the specified}
00310 \textcolor{comment}{ * DB number if we want to flush only a single Redis database number.}
00311 \textcolor{comment}{ *}
00312 \textcolor{comment}{ * Flags are be EMPTYDB\_NO\_FLAGS if no special flags are specified or}
00313 \textcolor{comment}{ * EMPTYDB\_ASYNC if we want the memory to be freed in a different thread}
00314 \textcolor{comment}{ * and the function to return ASAP.}
00315 \textcolor{comment}{ *}
00316 \textcolor{comment}{ * On success the fuction returns the number of keys removed from the}
00317 \textcolor{comment}{ * database(s). Otherwise -1 is returned in the specific case the}
00318 \textcolor{comment}{ * DB number is out of range, and errno is set to EINVAL. */}
00319 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} emptyDb(\textcolor{keywordtype}{int} dbnum, \textcolor{keywordtype}{int} flags, \textcolor{keywordtype}{void}(callback)(\textcolor{keywordtype}{void}*)) \{
00320     \textcolor{keywordtype}{int} j, async = (flags & \hyperlink{server_8h_a83bdc5c1a2af487191bb7ca716494ee7}{EMPTYDB\_ASYNC});
00321     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} removed = 0;
00322 
00323     \textcolor{keywordflow}{if} (dbnum < -1 || dbnum >= server.dbnum) \{
00324         errno = EINVAL;
00325         \textcolor{keywordflow}{return} -1;
00326     \}
00327 
00328     \textcolor{keywordflow}{for} (j = 0; j < server.dbnum; j++) \{
00329         \textcolor{keywordflow}{if} (dbnum != -1 && dbnum != j) \textcolor{keywordflow}{continue};
00330         removed += \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.db[j].dict);
00331         \textcolor{keywordflow}{if} (async) \{
00332             emptyDbAsync(&server.db[j]);
00333         \} \textcolor{keywordflow}{else} \{
00334             dictEmpty(server.db[j].dict,callback);
00335             dictEmpty(server.db[j].expires,callback);
00336         \}
00337     \}
00338     \textcolor{keywordflow}{if} (server.cluster\_enabled) \{
00339         \textcolor{keywordflow}{if} (async) \{
00340             slotToKeyFlushAsync();
00341         \} \textcolor{keywordflow}{else} \{
00342             slotToKeyFlush();
00343         \}
00344     \}
00345     \textcolor{keywordflow}{if} (dbnum == -1) flushSlaveKeysWithExpireList();
00346     \textcolor{keywordflow}{return} removed;
00347 \}
00348 
00349 \textcolor{keywordtype}{int} selectDb(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} id) \{
00350     \textcolor{keywordflow}{if} (id < 0 || id >= server.dbnum)
00351         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00352     c->db = &server.db[id];
00353     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00354 \}
00355 
00356 \textcolor{comment}{/*-----------------------------------------------------------------------------}
00357 \textcolor{comment}{ * Hooks for key space changes.}
00358 \textcolor{comment}{ *}
00359 \textcolor{comment}{ * Every time a key in the database is modified the function}
00360 \textcolor{comment}{ * signalModifiedKey() is called.}
00361 \textcolor{comment}{ *}
00362 \textcolor{comment}{ * Every time a DB is flushed the function signalFlushDb() is called.}
00363 \textcolor{comment}{ *----------------------------------------------------------------------------*/}
00364 
00365 \textcolor{keywordtype}{void} signalModifiedKey(redisDb *db, robj *key) \{
00366     touchWatchedKey(db,key);
00367 \}
00368 
00369 \textcolor{keywordtype}{void} signalFlushedDb(\textcolor{keywordtype}{int} dbid) \{
00370     touchWatchedKeysOnFlush(dbid);
00371 \}
00372 
00373 \textcolor{comment}{/*-----------------------------------------------------------------------------}
00374 \textcolor{comment}{ * Type agnostic commands operating on the key space}
00375 \textcolor{comment}{ *----------------------------------------------------------------------------*/}
00376 
00377 \textcolor{comment}{/* Return the set of flags to use for the emptyDb() call for FLUSHALL}
00378 \textcolor{comment}{ * and FLUSHDB commands.}
00379 \textcolor{comment}{ *}
00380 \textcolor{comment}{ * Currently the command just attempts to parse the "ASYNC" option. It}
00381 \textcolor{comment}{ * also checks if the command arity is wrong.}
00382 \textcolor{comment}{ *}
00383 \textcolor{comment}{ * On success C\_OK is returned and the flags are stored in *flags, otherwise}
00384 \textcolor{comment}{ * C\_ERR is returned and the function sends an error to the client. */}
00385 \textcolor{keywordtype}{int} getFlushCommandFlags(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} *flags) \{
00386     \textcolor{comment}{/* Parse the optional ASYNC option. */}
00387     \textcolor{keywordflow}{if} (c->argc > 1) \{
00388         \textcolor{keywordflow}{if} (c->argc > 2 || strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"async"})) \{
00389             addReply(c,shared.syntaxerr);
00390             \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00391         \}
00392         *flags = \hyperlink{server_8h_a83bdc5c1a2af487191bb7ca716494ee7}{EMPTYDB\_ASYNC};
00393     \} \textcolor{keywordflow}{else} \{
00394         *flags = \hyperlink{server_8h_a83a0ecde3a9f1f6bbcae9f4b966a509b}{EMPTYDB\_NO\_FLAGS};
00395     \}
00396     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00397 \}
00398 
00399 \textcolor{comment}{/* FLUSHDB [ASYNC]}
00400 \textcolor{comment}{ *}
00401 \textcolor{comment}{ * Flushes the currently SELECTed Redis DB. */}
00402 \textcolor{keywordtype}{void} flushdbCommand(\hyperlink{structclient}{client} *c) \{
00403     \textcolor{keywordtype}{int} flags;
00404 
00405     \textcolor{keywordflow}{if} (getFlushCommandFlags(c,&flags) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \textcolor{keywordflow}{return};
00406     signalFlushedDb(c->db->id);
00407     server.dirty += emptyDb(c->db->id,flags,NULL);
00408     addReply(c,shared.ok);
00409 \}
00410 
00411 \textcolor{comment}{/* FLUSHALL [ASYNC]}
00412 \textcolor{comment}{ *}
00413 \textcolor{comment}{ * Flushes the whole server data set. */}
00414 \textcolor{keywordtype}{void} flushallCommand(\hyperlink{structclient}{client} *c) \{
00415     \textcolor{keywordtype}{int} flags;
00416 
00417     \textcolor{keywordflow}{if} (getFlushCommandFlags(c,&flags) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \textcolor{keywordflow}{return};
00418     signalFlushedDb(-1);
00419     server.dirty += emptyDb(-1,flags,NULL);
00420     addReply(c,shared.ok);
00421     \textcolor{keywordflow}{if} (server.rdb\_child\_pid != -1) \{
00422         kill(server.rdb\_child\_pid,SIGUSR1);
00423         rdbRemoveTempFile(server.rdb\_child\_pid);
00424     \}
00425     \textcolor{keywordflow}{if} (server.saveparamslen > 0) \{
00426         \textcolor{comment}{/* Normally rdbSave() will reset dirty, but we don't want this here}
00427 \textcolor{comment}{         * as otherwise FLUSHALL will not be replicated nor put into the AOF. */}
00428         \textcolor{keywordtype}{int} saved\_dirty = server.dirty;
00429         rdbSaveInfo rsi, *rsiptr;
00430         rsiptr = rdbPopulateSaveInfo(&rsi);
00431         rdbSave(server.rdb\_filename,rsiptr);
00432         server.dirty = saved\_dirty;
00433     \}
00434     server.dirty++;
00435 \}
00436 
00437 \textcolor{comment}{/* This command implements DEL and LAZYDEL. */}
00438 \textcolor{keywordtype}{void} delGenericCommand(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} lazy) \{
00439     \textcolor{keywordtype}{int} numdel = 0, j;
00440 
00441     \textcolor{keywordflow}{for} (j = 1; j < c->argc; j++) \{
00442         expireIfNeeded(c->db,c->argv[j]);
00443         \textcolor{keywordtype}{int} deleted  = lazy ? dbAsyncDelete(c->db,c->argv[j]) :
00444                               dbSyncDelete(c->db,c->argv[j]);
00445         \textcolor{keywordflow}{if} (deleted) \{
00446             signalModifiedKey(c->db,c->argv[j]);
00447             notifyKeyspaceEvent(\hyperlink{server_8h_a9fa53dd1068e62365f3964ad3479eec2}{NOTIFY\_GENERIC},
00448                 \textcolor{stringliteral}{"del"},c->argv[j],c->db->id);
00449             server.dirty++;
00450             numdel++;
00451         \}
00452     \}
00453     addReplyLongLong(c,numdel);
00454 \}
00455 
00456 \textcolor{keywordtype}{void} delCommand(\hyperlink{structclient}{client} *c) \{
00457     delGenericCommand(c,0);
00458 \}
00459 
00460 \textcolor{keywordtype}{void} unlinkCommand(\hyperlink{structclient}{client} *c) \{
00461     delGenericCommand(c,1);
00462 \}
00463 
00464 \textcolor{comment}{/* EXISTS key1 key2 ... key\_N.}
00465 \textcolor{comment}{ * Return value is the number of keys existing. */}
00466 \textcolor{keywordtype}{void} existsCommand(\hyperlink{structclient}{client} *c) \{
00467     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} count = 0;
00468     \textcolor{keywordtype}{int} j;
00469 
00470     \textcolor{keywordflow}{for} (j = 1; j < c->argc; j++) \{
00471         expireIfNeeded(c->db,c->argv[j]);
00472         \textcolor{keywordflow}{if} (dbExists(c->db,c->argv[j])) count++;
00473     \}
00474     addReplyLongLong(c,count);
00475 \}
00476 
00477 \textcolor{keywordtype}{void} selectCommand(\hyperlink{structclient}{client} *c) \{
00478     \textcolor{keywordtype}{long} id;
00479 
00480     \textcolor{keywordflow}{if} (getLongFromObjectOrReply(c, c->argv[1], &id,
00481         \textcolor{stringliteral}{"invalid DB index"}) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
00482         \textcolor{keywordflow}{return};
00483 
00484     \textcolor{keywordflow}{if} (server.cluster\_enabled && id != 0) \{
00485         addReplyError(c,\textcolor{stringliteral}{"SELECT is not allowed in cluster mode"});
00486         \textcolor{keywordflow}{return};
00487     \}
00488     \textcolor{keywordflow}{if} (selectDb(c,id) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
00489         addReplyError(c,\textcolor{stringliteral}{"DB index is out of range"});
00490     \} \textcolor{keywordflow}{else} \{
00491         addReply(c,shared.ok);
00492     \}
00493 \}
00494 
00495 \textcolor{keywordtype}{void} randomkeyCommand(\hyperlink{structclient}{client} *c) \{
00496     robj *key;
00497 
00498     \textcolor{keywordflow}{if} ((key = dbRandomKey(c->db)) == NULL) \{
00499         addReply(c,shared.nullbulk);
00500         \textcolor{keywordflow}{return};
00501     \}
00502 
00503     addReplyBulk(c,key);
00504     decrRefCount(key);
00505 \}
00506 
00507 \textcolor{keywordtype}{void} keysCommand(\hyperlink{structclient}{client} *c) \{
00508     dictIterator *di;
00509     dictEntry *de;
00510     sds pattern = c->argv[1]->ptr;
00511     \textcolor{keywordtype}{int} plen = sdslen(pattern), allkeys;
00512     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} numkeys = 0;
00513     \textcolor{keywordtype}{void} *replylen = addDeferredMultiBulkLength(c);
00514 
00515     di = dictGetSafeIterator(c->db->dict);
00516     allkeys = (pattern[0] == \textcolor{stringliteral}{'*'} && pattern[1] == \textcolor{stringliteral}{'\(\backslash\)0'});
00517     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
00518         sds key = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
00519         robj *keyobj;
00520 
00521         \textcolor{keywordflow}{if} (allkeys || stringmatchlen(pattern,plen,key,sdslen(key),0)) \{
00522             keyobj = createStringObject(key,sdslen(key));
00523             \textcolor{keywordflow}{if} (expireIfNeeded(c->db,keyobj) == 0) \{
00524                 addReplyBulk(c,keyobj);
00525                 numkeys++;
00526             \}
00527             decrRefCount(keyobj);
00528         \}
00529     \}
00530     dictReleaseIterator(di);
00531     setDeferredMultiBulkLength(c,replylen,numkeys);
00532 \}
00533 
00534 \textcolor{comment}{/* This callback is used by scanGenericCommand in order to collect elements}
00535 \textcolor{comment}{ * returned by the dictionary iterator into a list. */}
00536 \textcolor{keywordtype}{void} scanCallback(\textcolor{keywordtype}{void} *privdata, \textcolor{keyword}{const} dictEntry *de) \{
00537     \textcolor{keywordtype}{void} **pd = (\textcolor{keywordtype}{void}**) privdata;
00538     list *keys = pd[0];
00539     robj *o = pd[1];
00540     robj *key, *val = NULL;
00541 
00542     \textcolor{keywordflow}{if} (o == NULL) \{
00543         sds sdskey = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
00544         key = createStringObject(sdskey, sdslen(sdskey));
00545     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET}) \{
00546         sds keysds = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
00547         key = createStringObject(keysds,sdslen(keysds));
00548     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH}) \{
00549         sds sdskey = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
00550         sds sdsval = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
00551         key = createStringObject(sdskey,sdslen(sdskey));
00552         val = createStringObject(sdsval,sdslen(sdsval));
00553     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}) \{
00554         sds sdskey = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
00555         key = createStringObject(sdskey,sdslen(sdskey));
00556         val = createStringObjectFromLongDouble(*(\textcolor{keywordtype}{double}*)\hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de),0);
00557     \} \textcolor{keywordflow}{else} \{
00558         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Type not handled in SCAN callback."});
00559     \}
00560 
00561     listAddNodeTail(keys, key);
00562     \textcolor{keywordflow}{if} (val) listAddNodeTail(keys, val);
00563 \}
00564 
00565 \textcolor{comment}{/* Try to parse a SCAN cursor stored at object 'o':}
00566 \textcolor{comment}{ * if the cursor is valid, store it as unsigned integer into *cursor and}
00567 \textcolor{comment}{ * returns C\_OK. Otherwise return C\_ERR and send an error to the}
00568 \textcolor{comment}{ * client. */}
00569 \textcolor{keywordtype}{int} parseScanCursorOrReply(\hyperlink{structclient}{client} *c, robj *o, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *cursor) \{
00570     \textcolor{keywordtype}{char} *eptr;
00571 
00572     \textcolor{comment}{/* Use strtoul() because we need an *unsigned* long, so}
00573 \textcolor{comment}{     * getLongLongFromObject() does not cover the whole cursor space. */}
00574     errno = 0;
00575     *cursor = strtoul(o->ptr, &eptr, 10);
00576     \textcolor{keywordflow}{if} (isspace(((\textcolor{keywordtype}{char}*)o->ptr)[0]) || eptr[0] != \textcolor{stringliteral}{'\(\backslash\)0'} || errno == ERANGE)
00577     \{
00578         addReplyError(c, \textcolor{stringliteral}{"invalid cursor"});
00579         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00580     \}
00581     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00582 \}
00583 
00584 \textcolor{comment}{/* This command implements SCAN, HSCAN and SSCAN commands.}
00585 \textcolor{comment}{ * If object 'o' is passed, then it must be a Hash or Set object, otherwise}
00586 \textcolor{comment}{ * if 'o' is NULL the command will operate on the dictionary associated with}
00587 \textcolor{comment}{ * the current database.}
00588 \textcolor{comment}{ *}
00589 \textcolor{comment}{ * When 'o' is not NULL the function assumes that the first argument in}
00590 \textcolor{comment}{ * the client arguments vector is a key so it skips it before iterating}
00591 \textcolor{comment}{ * in order to parse options.}
00592 \textcolor{comment}{ *}
00593 \textcolor{comment}{ * In the case of a Hash object the function returns both the field and value}
00594 \textcolor{comment}{ * of every element on the Hash. */}
00595 \textcolor{keywordtype}{void} scanGenericCommand(\hyperlink{structclient}{client} *c, robj *o, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} cursor) \{
00596     \textcolor{keywordtype}{int} i, j;
00597     list *keys = listCreate();
00598     listNode *node, *nextnode;
00599     \textcolor{keywordtype}{long} count = 10;
00600     sds pat = NULL;
00601     \textcolor{keywordtype}{int} patlen = 0, use\_pattern = 0;
00602     dict *ht;
00603 
00604     \textcolor{comment}{/* Object must be NULL (to iterate keys names), or the type of the object}
00605 \textcolor{comment}{     * must be Set, Sorted Set, or Hash. */}
00606     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(o == NULL || o->type == \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET} || o->type == 
      \hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH} ||
00607                 o->type == \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET});
00608 
00609     \textcolor{comment}{/* Set i to the first option argument. The previous one is the cursor. */}
00610     i = (o == NULL) ? 2 : 3; \textcolor{comment}{/* Skip the key argument if needed. */}
00611 
00612     \textcolor{comment}{/* Step 1: Parse options. */}
00613     \textcolor{keywordflow}{while} (i < c->argc) \{
00614         j = c->argc - i;
00615         \textcolor{keywordflow}{if} (!strcasecmp(c->argv[i]->ptr, \textcolor{stringliteral}{"count"}) && j >= 2) \{
00616             \textcolor{keywordflow}{if} (getLongFromObjectOrReply(c, c->argv[i+1], &count, NULL)
00617                 != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
00618             \{
00619                 \textcolor{keywordflow}{goto} cleanup;
00620             \}
00621 
00622             \textcolor{keywordflow}{if} (count < 1) \{
00623                 addReply(c,shared.syntaxerr);
00624                 \textcolor{keywordflow}{goto} cleanup;
00625             \}
00626 
00627             i += 2;
00628         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[i]->ptr, \textcolor{stringliteral}{"match"}) && j >= 2) \{
00629             pat = c->argv[i+1]->ptr;
00630             patlen = sdslen(pat);
00631 
00632             \textcolor{comment}{/* The pattern always matches if it is exactly "*", so it is}
00633 \textcolor{comment}{             * equivalent to disabling it. */}
00634             use\_pattern = !(pat[0] == \textcolor{stringliteral}{'*'} && patlen == 1);
00635 
00636             i += 2;
00637         \} \textcolor{keywordflow}{else} \{
00638             addReply(c,shared.syntaxerr);
00639             \textcolor{keywordflow}{goto} cleanup;
00640         \}
00641     \}
00642 
00643     \textcolor{comment}{/* Step 2: Iterate the collection.}
00644 \textcolor{comment}{     *}
00645 \textcolor{comment}{     * Note that if the object is encoded with a ziplist, intset, or any other}
00646 \textcolor{comment}{     * representation that is not a hash table, we are sure that it is also}
00647 \textcolor{comment}{     * composed of a small number of elements. So to avoid taking state we}
00648 \textcolor{comment}{     * just return everything inside the object in a single call, setting the}
00649 \textcolor{comment}{     * cursor to zero to signal the end of the iteration. */}
00650 
00651     \textcolor{comment}{/* Handle the case of a hash table. */}
00652     ht = NULL;
00653     \textcolor{keywordflow}{if} (o == NULL) \{
00654         ht = c->db->dict;
00655     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET} && o->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00656         ht = o->ptr;
00657     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH} && o->encoding == 
      \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00658         ht = o->ptr;
00659         count *= 2; \textcolor{comment}{/* We return key / value for this type. */}
00660     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET} && o->encoding == 
      \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
00661         zset *zs = o->ptr;
00662         ht = zs->dict;
00663         count *= 2; \textcolor{comment}{/* We return key / value for this type. */}
00664     \}
00665 
00666     \textcolor{keywordflow}{if} (ht) \{
00667         \textcolor{keywordtype}{void} *privdata[2];
00668         \textcolor{comment}{/* We set the max number of iterations to ten times the specified}
00669 \textcolor{comment}{         * COUNT, so if the hash table is in a pathological state (very}
00670 \textcolor{comment}{         * sparsely populated) we avoid to block too much time at the cost}
00671 \textcolor{comment}{         * of returning no or very few elements. */}
00672         \textcolor{keywordtype}{long} maxiterations = count*10;
00673 
00674         \textcolor{comment}{/* We pass two pointers to the callback: the list to which it will}
00675 \textcolor{comment}{         * add new elements, and the object containing the dictionary so that}
00676 \textcolor{comment}{         * it is possible to fetch more data in a type-dependent way. */}
00677         privdata[0] = keys;
00678         privdata[1] = o;
00679         \textcolor{keywordflow}{do} \{
00680             cursor = dictScan(ht, cursor, scanCallback, NULL, privdata);
00681         \} \textcolor{keywordflow}{while} (cursor &&
00682               maxiterations-- &&
00683               \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(keys) < (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})count);
00684     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET}) \{
00685         \textcolor{keywordtype}{int} pos = 0;
00686         int64\_t ll;
00687 
00688         \textcolor{keywordflow}{while}(intsetGet(o->ptr,pos++,&ll))
00689             listAddNodeTail(keys,createStringObjectFromLongLong(ll));
00690         cursor = 0;
00691     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH} || o->type == \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}) \{
00692         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p = ziplistIndex(o->ptr,0);
00693         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr;
00694         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen;
00695         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} vll;
00696 
00697         \textcolor{keywordflow}{while}(p) \{
00698             ziplistGet(p,&vstr,&vlen,&vll);
00699             listAddNodeTail(keys,
00700                 (vstr != NULL) ? createStringObject((\textcolor{keywordtype}{char}*)vstr,vlen) :
00701                                  createStringObjectFromLongLong(vll));
00702             p = ziplistNext(o->ptr,p);
00703         \}
00704         cursor = 0;
00705     \} \textcolor{keywordflow}{else} \{
00706         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Not handled encoding in SCAN."});
00707     \}
00708 
00709     \textcolor{comment}{/* Step 3: Filter elements. */}
00710     node = \hyperlink{adlist_8h_aa8dc514bbe217bb2e87c1c77cfa84690}{listFirst}(keys);
00711     \textcolor{keywordflow}{while} (node) \{
00712         robj *kobj = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(node);
00713         nextnode = \hyperlink{adlist_8h_a87e048b4eea3aa88f4101d59de50b0fc}{listNextNode}(node);
00714         \textcolor{keywordtype}{int} filter = 0;
00715 
00716         \textcolor{comment}{/* Filter element if it does not match the pattern. */}
00717         \textcolor{keywordflow}{if} (!filter && use\_pattern) \{
00718             \textcolor{keywordflow}{if} (\hyperlink{server_8h_afcfb5bd97af52d1dbce331745cae030c}{sdsEncodedObject}(kobj)) \{
00719                 \textcolor{keywordflow}{if} (!stringmatchlen(pat, patlen, kobj->ptr, sdslen(kobj->ptr), 0))
00720                     filter = 1;
00721             \} \textcolor{keywordflow}{else} \{
00722                 \textcolor{keywordtype}{char} buf[\hyperlink{server_8h_a39ec35278876f65fc1ef70b049856ca3}{LONG\_STR\_SIZE}];
00723                 \textcolor{keywordtype}{int} len;
00724 
00725                 \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(kobj->encoding == \hyperlink{server_8h_ae934cf008a0be0ef009c92c2d006a816}{OBJ\_ENCODING\_INT});
00726                 len = ll2string(buf,\textcolor{keyword}{sizeof}(buf),(\textcolor{keywordtype}{long})kobj->ptr);
00727                 \textcolor{keywordflow}{if} (!stringmatchlen(pat, patlen, buf, len, 0)) filter = 1;
00728             \}
00729         \}
00730 
00731         \textcolor{comment}{/* Filter element if it is an expired key. */}
00732         \textcolor{keywordflow}{if} (!filter && o == NULL && expireIfNeeded(c->db, kobj)) filter = 1;
00733 
00734         \textcolor{comment}{/* Remove the element and its associted value if needed. */}
00735         \textcolor{keywordflow}{if} (filter) \{
00736             decrRefCount(kobj);
00737             listDelNode(keys, node);
00738         \}
00739 
00740         \textcolor{comment}{/* If this is a hash or a sorted set, we have a flat list of}
00741 \textcolor{comment}{         * key-value elements, so if this element was filtered, remove the}
00742 \textcolor{comment}{         * value, or skip it if it was not filtered: we only match keys. */}
00743         \textcolor{keywordflow}{if} (o && (o->type == \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET} || o->type == \hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH})) \{
00744             node = nextnode;
00745             nextnode = \hyperlink{adlist_8h_a87e048b4eea3aa88f4101d59de50b0fc}{listNextNode}(node);
00746             \textcolor{keywordflow}{if} (filter) \{
00747                 kobj = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(node);
00748                 decrRefCount(kobj);
00749                 listDelNode(keys, node);
00750             \}
00751         \}
00752         node = nextnode;
00753     \}
00754 
00755     \textcolor{comment}{/* Step 4: Reply to the client. */}
00756     addReplyMultiBulkLen(c, 2);
00757     addReplyBulkLongLong(c,cursor);
00758 
00759     addReplyMultiBulkLen(c, \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(keys));
00760     \textcolor{keywordflow}{while} ((node = \hyperlink{adlist_8h_aa8dc514bbe217bb2e87c1c77cfa84690}{listFirst}(keys)) != NULL) \{
00761         robj *kobj = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(node);
00762         addReplyBulk(c, kobj);
00763         decrRefCount(kobj);
00764         listDelNode(keys, node);
00765     \}
00766 
00767 cleanup:
00768     \hyperlink{adlist_8h_a648e4a2d20decff3182a72a608b0b8f2}{listSetFreeMethod}(keys,decrRefCountVoid);
00769     listRelease(keys);
00770 \}
00771 
00772 \textcolor{comment}{/* The SCAN command completely relies on scanGenericCommand. */}
00773 \textcolor{keywordtype}{void} scanCommand(\hyperlink{structclient}{client} *c) \{
00774     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} cursor;
00775     \textcolor{keywordflow}{if} (parseScanCursorOrReply(c,c->argv[1],&cursor) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \textcolor{keywordflow}{return};
00776     scanGenericCommand(c,NULL,cursor);
00777 \}
00778 
00779 \textcolor{keywordtype}{void} dbsizeCommand(\hyperlink{structclient}{client} *c) \{
00780     addReplyLongLong(c,\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(c->db->dict));
00781 \}
00782 
00783 \textcolor{keywordtype}{void} lastsaveCommand(\hyperlink{structclient}{client} *c) \{
00784     addReplyLongLong(c,server.lastsave);
00785 \}
00786 
00787 \textcolor{keywordtype}{void} typeCommand(\hyperlink{structclient}{client} *c) \{
00788     robj *o;
00789     \textcolor{keywordtype}{char} *type;
00790 
00791     o = lookupKeyReadWithFlags(c->db,c->argv[1],\hyperlink{server_8h_aedc57e62fa05a1b438fa4ed16a803718}{LOOKUP\_NOTOUCH});
00792     \textcolor{keywordflow}{if} (o == NULL) \{
00793         type = \textcolor{stringliteral}{"none"};
00794     \} \textcolor{keywordflow}{else} \{
00795         \textcolor{keywordflow}{switch}(o->type) \{
00796         \textcolor{keywordflow}{case} \hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING}: type = \textcolor{stringliteral}{"string"}; \textcolor{keywordflow}{break};
00797         \textcolor{keywordflow}{case} \hyperlink{server_8h_a4a5f22a280949c97a0cb0d4213275126}{OBJ\_LIST}: type = \textcolor{stringliteral}{"list"}; \textcolor{keywordflow}{break};
00798         \textcolor{keywordflow}{case} \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET}: type = \textcolor{stringliteral}{"set"}; \textcolor{keywordflow}{break};
00799         \textcolor{keywordflow}{case} \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}: type = \textcolor{stringliteral}{"zset"}; \textcolor{keywordflow}{break};
00800         \textcolor{keywordflow}{case} \hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH}: type = \textcolor{stringliteral}{"hash"}; \textcolor{keywordflow}{break};
00801         \textcolor{keywordflow}{case} \hyperlink{server_8h_a2c2cc41300ca6b9daca7ea8a6d66edc6}{OBJ\_STREAM}: type = \textcolor{stringliteral}{"stream"}; \textcolor{keywordflow}{break};
00802         \textcolor{keywordflow}{case} \hyperlink{server_8h_a92c1fed85f709180fda0ff10d37d649b}{OBJ\_MODULE}: \{
00803             moduleValue *mv = o->ptr;
00804             type = mv->type->name;
00805         \}; \textcolor{keywordflow}{break};
00806         \textcolor{keywordflow}{default}: type = \textcolor{stringliteral}{"unknown"}; \textcolor{keywordflow}{break};
00807         \}
00808     \}
00809     addReplyStatus(c,type);
00810 \}
00811 
00812 \textcolor{keywordtype}{void} shutdownCommand(\hyperlink{structclient}{client} *c) \{
00813     \textcolor{keywordtype}{int} flags = 0;
00814 
00815     \textcolor{keywordflow}{if} (c->argc > 2) \{
00816         addReply(c,shared.syntaxerr);
00817         \textcolor{keywordflow}{return};
00818     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->argc == 2) \{
00819         \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"nosave"})) \{
00820             flags |= \hyperlink{server_8h_a834b7e50f783a1eeaa1feea05fce199e}{SHUTDOWN\_NOSAVE};
00821         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"save"})) \{
00822             flags |= \hyperlink{server_8h_ada761b94960fa20ff86d56b403b26861}{SHUTDOWN\_SAVE};
00823         \} \textcolor{keywordflow}{else} \{
00824             addReply(c,shared.syntaxerr);
00825             \textcolor{keywordflow}{return};
00826         \}
00827     \}
00828     \textcolor{comment}{/* When SHUTDOWN is called while the server is loading a dataset in}
00829 \textcolor{comment}{     * memory we need to make sure no attempt is performed to save}
00830 \textcolor{comment}{     * the dataset on shutdown (otherwise it could overwrite the current DB}
00831 \textcolor{comment}{     * with half-read data).}
00832 \textcolor{comment}{     *}
00833 \textcolor{comment}{     * Also when in Sentinel mode clear the SAVE flag and force NOSAVE. */}
00834     \textcolor{keywordflow}{if} (server.loading || server.sentinel\_mode)
00835         flags = (flags & ~\hyperlink{server_8h_ada761b94960fa20ff86d56b403b26861}{SHUTDOWN\_SAVE}) | \hyperlink{server_8h_a834b7e50f783a1eeaa1feea05fce199e}{SHUTDOWN\_NOSAVE};
00836     \textcolor{keywordflow}{if} (prepareForShutdown(flags) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) exit(0);
00837     addReplyError(c,\textcolor{stringliteral}{"Errors trying to SHUTDOWN. Check logs."});
00838 \}
00839 
00840 \textcolor{keywordtype}{void} renameGenericCommand(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} nx) \{
00841     robj *o;
00842     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} expire;
00843     \textcolor{keywordtype}{int} samekey = 0;
00844 
00845     \textcolor{comment}{/* When source and dest key is the same, no operation is performed,}
00846 \textcolor{comment}{     * if the key exists, however we still return an error on unexisting key. */}
00847     \textcolor{keywordflow}{if} (sdscmp(c->argv[1]->ptr,c->argv[2]->ptr) == 0) samekey = 1;
00848 
00849     \textcolor{keywordflow}{if} ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr)) == NULL)
00850         \textcolor{keywordflow}{return};
00851 
00852     \textcolor{keywordflow}{if} (samekey) \{
00853         addReply(c,nx ? shared.czero : shared.ok);
00854         \textcolor{keywordflow}{return};
00855     \}
00856 
00857     incrRefCount(o);
00858     expire = getExpire(c->db,c->argv[1]);
00859     \textcolor{keywordflow}{if} (lookupKeyWrite(c->db,c->argv[2]) != NULL) \{
00860         \textcolor{keywordflow}{if} (nx) \{
00861             decrRefCount(o);
00862             addReply(c,shared.czero);
00863             \textcolor{keywordflow}{return};
00864         \}
00865         \textcolor{comment}{/* Overwrite: delete the old key before creating the new one}
00866 \textcolor{comment}{         * with the same name. */}
00867         dbDelete(c->db,c->argv[2]);
00868     \}
00869     dbAdd(c->db,c->argv[2],o);
00870     \textcolor{keywordflow}{if} (expire != -1) setExpire(c,c->db,c->argv[2],expire);
00871     dbDelete(c->db,c->argv[1]);
00872     signalModifiedKey(c->db,c->argv[1]);
00873     signalModifiedKey(c->db,c->argv[2]);
00874     notifyKeyspaceEvent(\hyperlink{server_8h_a9fa53dd1068e62365f3964ad3479eec2}{NOTIFY\_GENERIC},\textcolor{stringliteral}{"rename\_from"},
00875         c->argv[1],c->db->id);
00876     notifyKeyspaceEvent(\hyperlink{server_8h_a9fa53dd1068e62365f3964ad3479eec2}{NOTIFY\_GENERIC},\textcolor{stringliteral}{"rename\_to"},
00877         c->argv[2],c->db->id);
00878     server.dirty++;
00879     addReply(c,nx ? shared.cone : shared.ok);
00880 \}
00881 
00882 \textcolor{keywordtype}{void} renameCommand(\hyperlink{structclient}{client} *c) \{
00883     renameGenericCommand(c,0);
00884 \}
00885 
00886 \textcolor{keywordtype}{void} renamenxCommand(\hyperlink{structclient}{client} *c) \{
00887     renameGenericCommand(c,1);
00888 \}
00889 
00890 \textcolor{keywordtype}{void} moveCommand(\hyperlink{structclient}{client} *c) \{
00891     robj *o;
00892     redisDb *src, *dst;
00893     \textcolor{keywordtype}{int} srcid;
00894     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} dbid, expire;
00895 
00896     \textcolor{keywordflow}{if} (server.cluster\_enabled) \{
00897         addReplyError(c,\textcolor{stringliteral}{"MOVE is not allowed in cluster mode"});
00898         \textcolor{keywordflow}{return};
00899     \}
00900 
00901     \textcolor{comment}{/* Obtain source and target DB pointers */}
00902     src = c->db;
00903     srcid = c->db->id;
00904 
00905     \textcolor{keywordflow}{if} (getLongLongFromObject(c->argv[2],&dbid) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR} ||
00906         dbid < INT\_MIN || dbid > INT\_MAX ||
00907         selectDb(c,dbid) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR})
00908     \{
00909         addReply(c,shared.outofrangeerr);
00910         \textcolor{keywordflow}{return};
00911     \}
00912     dst = c->db;
00913     selectDb(c,srcid); \textcolor{comment}{/* Back to the source DB */}
00914 
00915     \textcolor{comment}{/* If the user is moving using as target the same}
00916 \textcolor{comment}{     * DB as the source DB it is probably an error. */}
00917     \textcolor{keywordflow}{if} (src == dst) \{
00918         addReply(c,shared.sameobjecterr);
00919         \textcolor{keywordflow}{return};
00920     \}
00921 
00922     \textcolor{comment}{/* Check if the element exists and get a reference */}
00923     o = lookupKeyWrite(c->db,c->argv[1]);
00924     \textcolor{keywordflow}{if} (!o) \{
00925         addReply(c,shared.czero);
00926         \textcolor{keywordflow}{return};
00927     \}
00928     expire = getExpire(c->db,c->argv[1]);
00929 
00930     \textcolor{comment}{/* Return zero if the key already exists in the target DB */}
00931     \textcolor{keywordflow}{if} (lookupKeyWrite(dst,c->argv[1]) != NULL) \{
00932         addReply(c,shared.czero);
00933         \textcolor{keywordflow}{return};
00934     \}
00935     dbAdd(dst,c->argv[1],o);
00936     \textcolor{keywordflow}{if} (expire != -1) setExpire(c,dst,c->argv[1],expire);
00937     incrRefCount(o);
00938 
00939     \textcolor{comment}{/* OK! key moved, free the entry in the source DB */}
00940     dbDelete(src,c->argv[1]);
00941     server.dirty++;
00942     addReply(c,shared.cone);
00943 \}
00944 
00945 \textcolor{comment}{/* Helper function for dbSwapDatabases(): scans the list of keys that have}
00946 \textcolor{comment}{ * one or more blocked clients for B[LR]POP or other list blocking commands}
00947 \textcolor{comment}{ * and signal the keys are ready if they are lists. See the comment where}
00948 \textcolor{comment}{ * the function is used for more info. */}
00949 \textcolor{keywordtype}{void} scanDatabaseForReadyLists(redisDb *db) \{
00950     dictEntry *de;
00951     dictIterator *di = dictGetSafeIterator(db->blocking\_keys);
00952     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
00953         robj *key = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
00954         robj *value = lookupKey(db,key,\hyperlink{server_8h_aedc57e62fa05a1b438fa4ed16a803718}{LOOKUP\_NOTOUCH});
00955         \textcolor{keywordflow}{if} (value && (value->type == \hyperlink{server_8h_a4a5f22a280949c97a0cb0d4213275126}{OBJ\_LIST} || value->type == 
      \hyperlink{server_8h_a2c2cc41300ca6b9daca7ea8a6d66edc6}{OBJ\_STREAM}))
00956             signalKeyAsReady(db, key);
00957     \}
00958     dictReleaseIterator(di);
00959 \}
00960 
00961 \textcolor{comment}{/* Swap two databases at runtime so that all clients will magically see}
00962 \textcolor{comment}{ * the new database even if already connected. Note that the client}
00963 \textcolor{comment}{ * structure c->db points to a given DB, so we need to be smarter and}
00964 \textcolor{comment}{ * swap the underlying referenced structures, otherwise we would need}
00965 \textcolor{comment}{ * to fix all the references to the Redis DB structure.}
00966 \textcolor{comment}{ *}
00967 \textcolor{comment}{ * Returns C\_ERR if at least one of the DB ids are out of range, otherwise}
00968 \textcolor{comment}{ * C\_OK is returned. */}
00969 \textcolor{keywordtype}{int} dbSwapDatabases(\textcolor{keywordtype}{int} id1, \textcolor{keywordtype}{int} id2) \{
00970     \textcolor{keywordflow}{if} (id1 < 0 || id1 >= server.dbnum ||
00971         id2 < 0 || id2 >= server.dbnum) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00972     \textcolor{keywordflow}{if} (id1 == id2) \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00973     redisDb aux = server.db[id1];
00974     redisDb *db1 = &server.db[id1], *db2 = &server.db[id2];
00975 
00976     \textcolor{comment}{/* Swap hash tables. Note that we don't swap blocking\_keys,}
00977 \textcolor{comment}{     * ready\_keys and watched\_keys, since we want clients to}
00978 \textcolor{comment}{     * remain in the same DB they were. */}
00979     db1->dict = db2->dict;
00980     db1->expires = db2->expires;
00981     db1->avg\_ttl = db2->avg\_ttl;
00982 
00983     db2->dict = aux.dict;
00984     db2->expires = aux.expires;
00985     db2->avg\_ttl = aux.avg\_ttl;
00986 
00987     \textcolor{comment}{/* Now we need to handle clients blocked on lists: as an effect}
00988 \textcolor{comment}{     * of swapping the two DBs, a client that was waiting for list}
00989 \textcolor{comment}{     * X in a given DB, may now actually be unblocked if X happens}
00990 \textcolor{comment}{     * to exist in the new version of the DB, after the swap.}
00991 \textcolor{comment}{     *}
00992 \textcolor{comment}{     * However normally we only do this check for efficiency reasons}
00993 \textcolor{comment}{     * in dbAdd() when a list is created. So here we need to rescan}
00994 \textcolor{comment}{     * the list of clients blocked on lists and signal lists as ready}
00995 \textcolor{comment}{     * if needed. */}
00996     scanDatabaseForReadyLists(db1);
00997     scanDatabaseForReadyLists(db2);
00998     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00999 \}
01000 
01001 \textcolor{comment}{/* SWAPDB db1 db2 */}
01002 \textcolor{keywordtype}{void} swapdbCommand(\hyperlink{structclient}{client} *c) \{
01003     \textcolor{keywordtype}{long} id1, id2;
01004 
01005     \textcolor{comment}{/* Not allowed in cluster mode: we have just DB 0 there. */}
01006     \textcolor{keywordflow}{if} (server.cluster\_enabled) \{
01007         addReplyError(c,\textcolor{stringliteral}{"SWAPDB is not allowed in cluster mode"});
01008         \textcolor{keywordflow}{return};
01009     \}
01010 
01011     \textcolor{comment}{/* Get the two DBs indexes. */}
01012     \textcolor{keywordflow}{if} (getLongFromObjectOrReply(c, c->argv[1], &id1,
01013         \textcolor{stringliteral}{"invalid first DB index"}) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
01014         \textcolor{keywordflow}{return};
01015 
01016     \textcolor{keywordflow}{if} (getLongFromObjectOrReply(c, c->argv[2], &id2,
01017         \textcolor{stringliteral}{"invalid second DB index"}) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
01018         \textcolor{keywordflow}{return};
01019 
01020     \textcolor{comment}{/* Swap... */}
01021     \textcolor{keywordflow}{if} (dbSwapDatabases(id1,id2) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
01022         addReplyError(c,\textcolor{stringliteral}{"DB index is out of range"});
01023         \textcolor{keywordflow}{return};
01024     \} \textcolor{keywordflow}{else} \{
01025         server.dirty++;
01026         addReply(c,shared.ok);
01027     \}
01028 \}
01029 
01030 \textcolor{comment}{/*-----------------------------------------------------------------------------}
01031 \textcolor{comment}{ * Expires API}
01032 \textcolor{comment}{ *----------------------------------------------------------------------------*/}
01033 
01034 \textcolor{keywordtype}{int} removeExpire(redisDb *db, robj *key) \{
01035     \textcolor{comment}{/* An expire may only be removed if there is a corresponding entry in the}
01036 \textcolor{comment}{     * main dict. Otherwise, the key will never be freed. */}
01037     \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(NULL,key,dictFind(db->dict,key->ptr) != NULL);
01038     \textcolor{keywordflow}{return} dictDelete(db->expires,key->ptr) == \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK};
01039 \}
01040 
01041 \textcolor{comment}{/* Set an expire to the specified key. If the expire is set in the context}
01042 \textcolor{comment}{ * of an user calling a command 'c' is the client, otherwise 'c' is set}
01043 \textcolor{comment}{ * to NULL. The 'when' parameter is the absolute unix time in milliseconds}
01044 \textcolor{comment}{ * after which the key will no longer be considered valid. */}
01045 \textcolor{keywordtype}{void} setExpire(\hyperlink{structclient}{client} *c, redisDb *db, robj *key, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} when) \{
01046     dictEntry *kde, *de;
01047 
01048     \textcolor{comment}{/* Reuse the sds from the main dict in the expire dict */}
01049     kde = dictFind(db->dict,key->ptr);
01050     \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(NULL,key,kde != NULL);
01051     de = dictAddOrFind(db->expires,\hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(kde));
01052     \hyperlink{dict_8h_a712bcfafed90e7d5ffeba5f6bf027a2c}{dictSetSignedIntegerVal}(de,when);
01053 
01054     \textcolor{keywordtype}{int} writable\_slave = server.masterhost && server.repl\_slave\_ro == 0;
01055     \textcolor{keywordflow}{if} (c && writable\_slave && !(c->flags & \hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER}))
01056         rememberSlaveKeyWithExpire(db,key);
01057 \}
01058 
01059 \textcolor{comment}{/* Return the expire time of the specified key, or -1 if no expire}
01060 \textcolor{comment}{ * is associated with this key (i.e. the key is non volatile) */}
01061 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} getExpire(redisDb *db, robj *key) \{
01062     dictEntry *de;
01063 
01064     \textcolor{comment}{/* No expire? return ASAP */}
01065     \textcolor{keywordflow}{if} (\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(db->expires) == 0 ||
01066        (de = dictFind(db->expires,key->ptr)) == NULL) \textcolor{keywordflow}{return} -1;
01067 
01068     \textcolor{comment}{/* The entry was found in the expire dict, this means it should also}
01069 \textcolor{comment}{     * be present in the main dict (safety check). */}
01070     \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(NULL,key,dictFind(db->dict,key->ptr) != NULL);
01071     \textcolor{keywordflow}{return} \hyperlink{dict_8h_a31f34bf34a743e3ebf122fa231b28d57}{dictGetSignedIntegerVal}(de);
01072 \}
01073 
01074 \textcolor{comment}{/* Propagate expires into slaves and the AOF file.}
01075 \textcolor{comment}{ * When a key expires in the master, a DEL operation for this key is sent}
01076 \textcolor{comment}{ * to all the slaves and the AOF file if enabled.}
01077 \textcolor{comment}{ *}
01078 \textcolor{comment}{ * This way the key expiry is centralized in one place, and since both}
01079 \textcolor{comment}{ * AOF and the master->slave link guarantee operation ordering, everything}
01080 \textcolor{comment}{ * will be consistent even if we allow write operations against expiring}
01081 \textcolor{comment}{ * keys. */}
01082 \textcolor{keywordtype}{void} propagateExpire(redisDb *db, robj *key, \textcolor{keywordtype}{int} lazy) \{
01083     robj *argv[2];
01084 
01085     argv[0] = lazy ? shared.unlink : shared.del;
01086     argv[1] = key;
01087     incrRefCount(argv[0]);
01088     incrRefCount(argv[1]);
01089 
01090     \textcolor{keywordflow}{if} (server.aof\_state != \hyperlink{server_8h_a5226306fbcebcb6d5d02e0fef3c213c2}{AOF\_OFF})
01091         feedAppendOnlyFile(server.delCommand,db->id,argv,2);
01092     replicationFeedSlaves(server.slaves,db->id,argv,2);
01093 
01094     decrRefCount(argv[0]);
01095     decrRefCount(argv[1]);
01096 \}
01097 
01098 \textcolor{keywordtype}{int} expireIfNeeded(redisDb *db, robj *key) \{
01099     mstime\_t when = getExpire(db,key);
01100     mstime\_t now;
01101 
01102     \textcolor{keywordflow}{if} (when < 0) \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* No expire for this key */}
01103 
01104     \textcolor{comment}{/* Don't expire anything while loading. It will be done later. */}
01105     \textcolor{keywordflow}{if} (server.loading) \textcolor{keywordflow}{return} 0;
01106 
01107     \textcolor{comment}{/* If we are in the context of a Lua script, we claim that time is}
01108 \textcolor{comment}{     * blocked to when the Lua script started. This way a key can expire}
01109 \textcolor{comment}{     * only the first time it is accessed and not in the middle of the}
01110 \textcolor{comment}{     * script execution, making propagation to slaves / AOF consistent.}
01111 \textcolor{comment}{     * See issue #1525 on Github for more information. */}
01112     now = server.lua\_caller ? server.lua\_time\_start : mstime();
01113 
01114     \textcolor{comment}{/* If we are running in the context of a slave, return ASAP:}
01115 \textcolor{comment}{     * the slave key expiration is controlled by the master that will}
01116 \textcolor{comment}{     * send us synthesized DEL operations for expired keys.}
01117 \textcolor{comment}{     *}
01118 \textcolor{comment}{     * Still we try to return the right information to the caller,}
01119 \textcolor{comment}{     * that is, 0 if we think the key should be still valid, 1 if}
01120 \textcolor{comment}{     * we think the key is expired at this time. */}
01121     \textcolor{keywordflow}{if} (server.masterhost != NULL) \textcolor{keywordflow}{return} now > when;
01122 
01123     \textcolor{comment}{/* Return when this key has not expired */}
01124     \textcolor{keywordflow}{if} (now <= when) \textcolor{keywordflow}{return} 0;
01125 
01126     \textcolor{comment}{/* Delete the key */}
01127     server.stat\_expiredkeys++;
01128     propagateExpire(db,key,server.lazyfree\_lazy\_expire);
01129     notifyKeyspaceEvent(\hyperlink{server_8h_a6b6b55f4f6ffcd0b1648395fea5fafc1}{NOTIFY\_EXPIRED},
01130         \textcolor{stringliteral}{"expired"},key,db->id);
01131     \textcolor{keywordflow}{return} server.lazyfree\_lazy\_expire ? dbAsyncDelete(db,key) :
01132                                          dbSyncDelete(db,key);
01133 \}
01134 
01135 \textcolor{comment}{/* -----------------------------------------------------------------------------}
01136 \textcolor{comment}{ * API to get key arguments from commands}
01137 \textcolor{comment}{ * ---------------------------------------------------------------------------*/}
01138 
01139 \textcolor{comment}{/* The base case is to use the keys position as given in the command table}
01140 \textcolor{comment}{ * (firstkey, lastkey, step). */}
01141 \textcolor{keywordtype}{int} *getKeysUsingCommandTable(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd,robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} *numkeys
      ) \{
01142     \textcolor{keywordtype}{int} j, i = 0, last, *keys;
01143     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(argv);
01144 
01145     \textcolor{keywordflow}{if} (cmd->firstkey == 0) \{
01146         *numkeys = 0;
01147         \textcolor{keywordflow}{return} NULL;
01148     \}
01149 
01150     last = cmd->lastkey;
01151     \textcolor{keywordflow}{if} (last < 0) last = argc+last;
01152     keys = zmalloc(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int})*((last - cmd->firstkey)+1));
01153     \textcolor{keywordflow}{for} (j = cmd->firstkey; j <= last; j += cmd->keystep) \{
01154         \textcolor{keywordflow}{if} (j >= argc) \{
01155             \textcolor{comment}{/* Modules command do not have dispatch time arity checks, so}
01156 \textcolor{comment}{             * we need to handle the case where the user passed an invalid}
01157 \textcolor{comment}{             * number of arguments here. In this case we return no keys}
01158 \textcolor{comment}{             * and expect the module command to report an arity error. */}
01159             \textcolor{keywordflow}{if} (cmd->flags & \hyperlink{server_8h_accabd32f20281543986166c219124f9e}{CMD\_MODULE}) \{
01160                 zfree(keys);
01161                 *numkeys = 0;
01162                 \textcolor{keywordflow}{return} NULL;
01163             \} \textcolor{keywordflow}{else} \{
01164                 \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Redis built-in command declared keys positions not matching
       the arity requirements."});
01165             \}
01166         \}
01167         keys[i++] = j;
01168     \}
01169     *numkeys = i;
01170     \textcolor{keywordflow}{return} keys;
01171 \}
01172 
01173 \textcolor{comment}{/* Return all the arguments that are keys in the command passed via argc / argv.}
01174 \textcolor{comment}{ *}
01175 \textcolor{comment}{ * The command returns the positions of all the key arguments inside the array,}
01176 \textcolor{comment}{ * so the actual return value is an heap allocated array of integers. The}
01177 \textcolor{comment}{ * length of the array is returned by reference into *numkeys.}
01178 \textcolor{comment}{ *}
01179 \textcolor{comment}{ * 'cmd' must be point to the corresponding entry into the redisCommand}
01180 \textcolor{comment}{ * table, according to the command name in argv[0].}
01181 \textcolor{comment}{ *}
01182 \textcolor{comment}{ * This function uses the command table if a command-specific helper function}
01183 \textcolor{comment}{ * is not required, otherwise it calls the command-specific function. */}
01184 \textcolor{keywordtype}{int} *getKeysFromCommand(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} *numkeys) \{
01185     \textcolor{keywordflow}{if} (cmd->flags & \hyperlink{server_8h_a612a8681d1a25cd86faf4139d161316a}{CMD\_MODULE\_GETKEYS}) \{
01186         \textcolor{keywordflow}{return} moduleGetCommandKeysViaAPI(cmd,argv,argc,numkeys);
01187     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!(cmd->flags & \hyperlink{server_8h_accabd32f20281543986166c219124f9e}{CMD\_MODULE}) && cmd->getkeys\_proc) \{
01188         \textcolor{keywordflow}{return} cmd->getkeys\_proc(cmd,argv,argc,numkeys);
01189     \} \textcolor{keywordflow}{else} \{
01190         \textcolor{keywordflow}{return} getKeysUsingCommandTable(cmd,argv,argc,numkeys);
01191     \}
01192 \}
01193 
01194 \textcolor{comment}{/* Free the result of getKeysFromCommand. */}
01195 \textcolor{keywordtype}{void} getKeysFreeResult(\textcolor{keywordtype}{int} *result) \{
01196     zfree(result);
01197 \}
01198 
01199 \textcolor{comment}{/* Helper function to extract keys from following commands:}
01200 \textcolor{comment}{ * ZUNIONSTORE <destkey> <num-keys> <key> <key> ... <key> <options>}
01201 \textcolor{comment}{ * ZINTERSTORE <destkey> <num-keys> <key> <key> ... <key> <options> */}
01202 \textcolor{keywordtype}{int} *zunionInterGetKeys(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} *numkeys) \{
01203     \textcolor{keywordtype}{int} i, num, *keys;
01204     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(cmd);
01205 
01206     num = atoi(argv[2]->ptr);
01207     \textcolor{comment}{/* Sanity check. Don't return any key if the command is going to}
01208 \textcolor{comment}{     * reply with syntax error. */}
01209     \textcolor{keywordflow}{if} (num > (argc-3)) \{
01210         *numkeys = 0;
01211         \textcolor{keywordflow}{return} NULL;
01212     \}
01213 
01214     \textcolor{comment}{/* Keys in z\{union,inter\}store come from two places:}
01215 \textcolor{comment}{     * argv[1] = storage key,}
01216 \textcolor{comment}{     * argv[3...n] = keys to intersect */}
01217     keys = zmalloc(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int})*(num+1));
01218 
01219     \textcolor{comment}{/* Add all key positions for argv[3...n] to keys[] */}
01220     \textcolor{keywordflow}{for} (i = 0; i < num; i++) keys[i] = 3+i;
01221 
01222     \textcolor{comment}{/* Finally add the argv[1] key position (the storage key target). */}
01223     keys[num] = 1;
01224     *numkeys = num+1;  \textcolor{comment}{/* Total keys = \{union,inter\} keys + storage key */}
01225     \textcolor{keywordflow}{return} keys;
01226 \}
01227 
01228 \textcolor{comment}{/* Helper function to extract keys from the following commands:}
01229 \textcolor{comment}{ * EVAL <script> <num-keys> <key> <key> ... <key> [more stuff]}
01230 \textcolor{comment}{ * EVALSHA <script> <num-keys> <key> <key> ... <key> [more stuff] */}
01231 \textcolor{keywordtype}{int} *evalGetKeys(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} *numkeys) \{
01232     \textcolor{keywordtype}{int} i, num, *keys;
01233     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(cmd);
01234 
01235     num = atoi(argv[2]->ptr);
01236     \textcolor{comment}{/* Sanity check. Don't return any key if the command is going to}
01237 \textcolor{comment}{     * reply with syntax error. */}
01238     \textcolor{keywordflow}{if} (num > (argc-3)) \{
01239         *numkeys = 0;
01240         \textcolor{keywordflow}{return} NULL;
01241     \}
01242 
01243     keys = zmalloc(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int})*num);
01244     *numkeys = num;
01245 
01246     \textcolor{comment}{/* Add all key positions for argv[3...n] to keys[] */}
01247     \textcolor{keywordflow}{for} (i = 0; i < num; i++) keys[i] = 3+i;
01248 
01249     \textcolor{keywordflow}{return} keys;
01250 \}
01251 
01252 \textcolor{comment}{/* Helper function to extract keys from the SORT command.}
01253 \textcolor{comment}{ *}
01254 \textcolor{comment}{ * SORT <sort-key> ... STORE <store-key> ...}
01255 \textcolor{comment}{ *}
01256 \textcolor{comment}{ * The first argument of SORT is always a key, however a list of options}
01257 \textcolor{comment}{ * follow in SQL-alike style. Here we parse just the minimum in order to}
01258 \textcolor{comment}{ * correctly identify keys in the "STORE" option. */}
01259 \textcolor{keywordtype}{int} *sortGetKeys(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} *numkeys) \{
01260     \textcolor{keywordtype}{int} i, j, num, *keys, found\_store = 0;
01261     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(cmd);
01262 
01263     num = 0;
01264     keys = zmalloc(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int})*2); \textcolor{comment}{/* Alloc 2 places for the worst case. */}
01265 
01266     keys[num++] = 1; \textcolor{comment}{/* <sort-key> is always present. */}
01267 
01268     \textcolor{comment}{/* Search for STORE option. By default we consider options to don't}
01269 \textcolor{comment}{     * have arguments, so if we find an unknown option name we scan the}
01270 \textcolor{comment}{     * next. However there are options with 1 or 2 arguments, so we}
01271 \textcolor{comment}{     * provide a list here in order to skip the right number of args. */}
01272     \textcolor{keyword}{struct} \{
01273         \textcolor{keywordtype}{char} *name;
01274         \textcolor{keywordtype}{int} skip;
01275     \} skiplist[] = \{
01276         \{\textcolor{stringliteral}{"limit"}, 2\},
01277         \{\textcolor{stringliteral}{"get"}, 1\},
01278         \{\textcolor{stringliteral}{"by"}, 1\},
01279         \{NULL, 0\} \textcolor{comment}{/* End of elements. */}
01280     \};
01281 
01282     \textcolor{keywordflow}{for} (i = 2; i < argc; i++) \{
01283         \textcolor{keywordflow}{for} (j = 0; skiplist[j].name != NULL; j++) \{
01284             \textcolor{keywordflow}{if} (!strcasecmp(argv[i]->ptr,skiplist[j].name)) \{
01285                 i += skiplist[j].skip;
01286                 \textcolor{keywordflow}{break};
01287             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(argv[i]->ptr,\textcolor{stringliteral}{"store"}) && i+1 < argc) \{
01288                 \textcolor{comment}{/* Note: we don't increment "num" here and continue the loop}
01289 \textcolor{comment}{                 * to be sure to process the *last* "STORE" option if multiple}
01290 \textcolor{comment}{                 * ones are provided. This is same behavior as SORT. */}
01291                 found\_store = 1;
01292                 keys[num] = i+1; \textcolor{comment}{/* <store-key> */}
01293                 \textcolor{keywordflow}{break};
01294             \}
01295         \}
01296     \}
01297     *numkeys = num + found\_store;
01298     \textcolor{keywordflow}{return} keys;
01299 \}
01300 
01301 \textcolor{keywordtype}{int} *migrateGetKeys(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} *numkeys) \{
01302     \textcolor{keywordtype}{int} i, num, first, *keys;
01303     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(cmd);
01304 
01305     \textcolor{comment}{/* Assume the obvious form. */}
01306     first = 3;
01307     num = 1;
01308 
01309     \textcolor{comment}{/* But check for the extended one with the KEYS option. */}
01310     \textcolor{keywordflow}{if} (argc > 6) \{
01311         \textcolor{keywordflow}{for} (i = 6; i < argc; i++) \{
01312             \textcolor{keywordflow}{if} (!strcasecmp(argv[i]->ptr,\textcolor{stringliteral}{"keys"}) &&
01313                 sdslen(argv[3]->ptr) == 0)
01314             \{
01315                 first = i+1;
01316                 num = argc-first;
01317                 \textcolor{keywordflow}{break};
01318             \}
01319         \}
01320     \}
01321 
01322     keys = zmalloc(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int})*num);
01323     \textcolor{keywordflow}{for} (i = 0; i < num; i++) keys[i] = first+i;
01324     *numkeys = num;
01325     \textcolor{keywordflow}{return} keys;
01326 \}
01327 
01328 \textcolor{comment}{/* Helper function to extract keys from following commands:}
01329 \textcolor{comment}{ * GEORADIUS key x y radius unit [WITHDIST] [WITHHASH] [WITHCOORD] [ASC|DESC]}
01330 \textcolor{comment}{ *                             [COUNT count] [STORE key] [STOREDIST key]}
01331 \textcolor{comment}{ * GEORADIUSBYMEMBER key member radius unit ... options ... */}
01332 \textcolor{keywordtype}{int} *georadiusGetKeys(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} *numkeys) \{
01333     \textcolor{keywordtype}{int} i, num, *keys;
01334     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(cmd);
01335 
01336     \textcolor{comment}{/* Check for the presence of the stored key in the command */}
01337     \textcolor{keywordtype}{int} stored\_key = -1;
01338     \textcolor{keywordflow}{for} (i = 5; i < argc; i++) \{
01339         \textcolor{keywordtype}{char} *arg = argv[i]->ptr;
01340         \textcolor{comment}{/* For the case when user specifies both "store" and "storedist" options, the}
01341 \textcolor{comment}{         * second key specified would override the first key. This behavior is kept }
01342 \textcolor{comment}{         * the same as in georadiusCommand method.}
01343 \textcolor{comment}{         */}
01344         \textcolor{keywordflow}{if} ((!strcasecmp(arg, \textcolor{stringliteral}{"store"}) || !strcasecmp(arg, \textcolor{stringliteral}{"storedist"})) && ((i+1) < argc)) \{
01345             stored\_key = i+1;
01346             i++;
01347         \}
01348     \}
01349     num = 1 + (stored\_key == -1 ? 0 : 1);
01350 
01351     \textcolor{comment}{/* Keys in the command come from two places:}
01352 \textcolor{comment}{     * argv[1] = key,}
01353 \textcolor{comment}{     * argv[5...n] = stored key if present}
01354 \textcolor{comment}{     */}
01355     keys = zmalloc(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}) * num);
01356 
01357     \textcolor{comment}{/* Add all key positions to keys[] */}
01358     keys[0] = 1;
01359     \textcolor{keywordflow}{if}(num > 1) \{
01360          keys[1] = stored\_key;
01361     \}
01362     *numkeys = num;
01363     \textcolor{keywordflow}{return} keys;
01364 \}
01365 
01366 \textcolor{comment}{/* XREAD [BLOCK <milliseconds>] [COUNT <count>] [GROUP <groupname> <ttl>]}
01367 \textcolor{comment}{ *       [RETRY <milliseconds> <ttl>] STREAMS key\_1 key\_2 ... key\_N}
01368 \textcolor{comment}{ *       ID\_1 ID\_2 ... ID\_N */}
01369 \textcolor{keywordtype}{int} *xreadGetKeys(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} *numkeys) \{
01370     \textcolor{keywordtype}{int} i, num, *keys;
01371     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(cmd);
01372 
01373     \textcolor{comment}{/* We need to seek the last argument that contains "STREAMS", because other}
01374 \textcolor{comment}{     * arguments before may contain it (for example the group name). */}
01375     \textcolor{keywordtype}{int} streams\_pos = -1;
01376     \textcolor{keywordflow}{for} (i = 1; i < argc; i++) \{
01377         \textcolor{keywordtype}{char} *arg = argv[i]->ptr;
01378         \textcolor{keywordflow}{if} (!strcasecmp(arg, \textcolor{stringliteral}{"streams"})) streams\_pos = i;
01379     \}
01380     \textcolor{keywordflow}{if} (streams\_pos != -1) num = argc - streams\_pos - 1;
01381 
01382     \textcolor{comment}{/* Syntax error. */}
01383     \textcolor{keywordflow}{if} (streams\_pos == -1 || num % 2 != 0) \{
01384         *numkeys = 0;
01385         \textcolor{keywordflow}{return} NULL;
01386     \}
01387     num /= 2; \textcolor{comment}{/* We have half the keys as there are arguments because}
01388 \textcolor{comment}{                 there are also the IDs, one per key. */}
01389 
01390     keys = zmalloc(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}) * num);
01391     \textcolor{keywordflow}{for} (i = streams\_pos+1; i < argc; i++) keys[i-streams\_pos-1] = i;
01392     *numkeys = num;
01393     \textcolor{keywordflow}{return} keys;
01394 \}
01395 
01396 \textcolor{comment}{/* Slot to Key API. This is used by Redis Cluster in order to obtain in}
01397 \textcolor{comment}{ * a fast way a key that belongs to a specified hash slot. This is useful}
01398 \textcolor{comment}{ * while rehashing the cluster and in other conditions when we need to}
01399 \textcolor{comment}{ * understand if we have keys for a given hash slot. */}
01400 \textcolor{keywordtype}{void} slotToKeyUpdateKey(robj *key, \textcolor{keywordtype}{int} add) \{
01401     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} hashslot = keyHashSlot(key->ptr,sdslen(key->ptr));
01402     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[64];
01403     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *indexed = buf;
01404     size\_t keylen = sdslen(key->ptr);
01405 
01406     server.cluster->slots\_keys\_count[hashslot] += add ? 1 : -1;
01407     \textcolor{keywordflow}{if} (keylen+2 > 64) indexed = zmalloc(keylen+2);
01408     indexed[0] = (hashslot >> 8) & 0xff;
01409     indexed[1] = hashslot & 0xff;
01410     memcpy(indexed+2,key->ptr,keylen);
01411     \textcolor{keywordflow}{if} (add) \{
01412         raxInsert(server.cluster->slots\_to\_keys,indexed,keylen+2,NULL,NULL);
01413     \} \textcolor{keywordflow}{else} \{
01414         raxRemove(server.cluster->slots\_to\_keys,indexed,keylen+2,NULL);
01415     \}
01416     \textcolor{keywordflow}{if} (indexed != buf) zfree(indexed);
01417 \}
01418 
01419 \textcolor{keywordtype}{void} slotToKeyAdd(robj *key) \{
01420     slotToKeyUpdateKey(key,1);
01421 \}
01422 
01423 \textcolor{keywordtype}{void} slotToKeyDel(robj *key) \{
01424     slotToKeyUpdateKey(key,0);
01425 \}
01426 
01427 \textcolor{keywordtype}{void} slotToKeyFlush(\textcolor{keywordtype}{void}) \{
01428     raxFree(server.cluster->slots\_to\_keys);
01429     server.cluster->slots\_to\_keys = raxNew();
01430     memset(server.cluster->slots\_keys\_count,0,
01431            \textcolor{keyword}{sizeof}(server.cluster->slots\_keys\_count));
01432 \}
01433 
01434 \textcolor{comment}{/* Pupulate the specified array of objects with keys in the specified slot.}
01435 \textcolor{comment}{ * New objects are returned to represent keys, it's up to the caller to}
01436 \textcolor{comment}{ * decrement the reference count to release the keys names. */}
01437 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} getKeysInSlot(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} hashslot, robj **keys, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} count) \{
01438     \hyperlink{structraxIterator}{raxIterator} iter;
01439     \textcolor{keywordtype}{int} j = 0;
01440     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} indexed[2];
01441 
01442     indexed[0] = (hashslot >> 8) & 0xff;
01443     indexed[1] = hashslot & 0xff;
01444     raxStart(&iter,server.cluster->slots\_to\_keys);
01445     raxSeek(&iter,\textcolor{stringliteral}{">="},indexed,2);
01446     \textcolor{keywordflow}{while}(count-- && raxNext(&iter)) \{
01447         \textcolor{keywordflow}{if} (iter.key[0] != indexed[0] || iter.key[1] != indexed[1]) \textcolor{keywordflow}{break};
01448         keys[j++] = createStringObject((\textcolor{keywordtype}{char}*)iter.key+2,iter.key\_len-2);
01449     \}
01450     raxStop(&iter);
01451     \textcolor{keywordflow}{return} j;
01452 \}
01453 
01454 \textcolor{comment}{/* Remove all the keys in the specified hash slot.}
01455 \textcolor{comment}{ * The number of removed items is returned. */}
01456 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} delKeysInSlot(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} hashslot) \{
01457     \hyperlink{structraxIterator}{raxIterator} iter;
01458     \textcolor{keywordtype}{int} j = 0;
01459     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} indexed[2];
01460 
01461     indexed[0] = (hashslot >> 8) & 0xff;
01462     indexed[1] = hashslot & 0xff;
01463     raxStart(&iter,server.cluster->slots\_to\_keys);
01464     \textcolor{keywordflow}{while}(server.cluster->slots\_keys\_count[hashslot]) \{
01465         raxSeek(&iter,\textcolor{stringliteral}{">="},indexed,2);
01466         raxNext(&iter);
01467 
01468         robj *key = createStringObject((\textcolor{keywordtype}{char}*)iter.key+2,iter.key\_len-2);
01469         dbDelete(&server.db[0],key);
01470         decrRefCount(key);
01471         j++;
01472     \}
01473     raxStop(&iter);
01474     \textcolor{keywordflow}{return} j;
01475 \}
01476 
01477 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} countKeysInSlot(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} hashslot) \{
01478     \textcolor{keywordflow}{return} server.cluster->slots\_keys\_count[hashslot];
01479 \}
\end{DoxyCode}
