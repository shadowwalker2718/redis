\hypertarget{intset_8c_source}{}\section{intset.\+c}
\label{intset_8c_source}\index{src/intset.\+c@{src/intset.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>}
00003 \textcolor{comment}{ * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>}
00004 \textcolor{comment}{ * All rights reserved.}
00005 \textcolor{comment}{ *}
00006 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00007 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00008 \textcolor{comment}{ *}
00009 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00010 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00011 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00012 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00013 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00014 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00015 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00016 \textcolor{comment}{ *     specific prior written permission.}
00017 \textcolor{comment}{ *}
00018 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00019 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00020 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00021 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00022 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00023 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00024 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00025 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00026 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00027 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00028 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00029 \textcolor{comment}{ */}
00030 
00031 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdio}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00032 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdlib}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00033 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{string}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00034 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{intset_8h}{"intset.h"}
00035 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{zmalloc_8h}{"zmalloc.h"}
00036 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{endianconv_8h}{"endianconv.h"}
00037 
00038 \textcolor{comment}{/* Note that these encodings are ordered, so:}
00039 \textcolor{comment}{ * INTSET\_ENC\_INT16 < INTSET\_ENC\_INT32 < INTSET\_ENC\_INT64. */}
00040 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{INTSET\_ENC\_INT16} \textcolor{preprocessor}{(}\textcolor{keyword}{sizeof}\textcolor{preprocessor}{(}\textcolor{preprocessor}{int16\_t}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00041 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{INTSET\_ENC\_INT32} \textcolor{preprocessor}{(}\textcolor{keyword}{sizeof}\textcolor{preprocessor}{(}\textcolor{preprocessor}{int32\_t}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00042 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{INTSET\_ENC\_INT64} \textcolor{preprocessor}{(}\textcolor{keyword}{sizeof}\textcolor{preprocessor}{(}\textcolor{preprocessor}{int64\_t}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00043 
00044 \textcolor{comment}{/* Return the required encoding for the provided value. */}
00045 \textcolor{keyword}{static} uint8\_t \_intsetValueEncoding(int64\_t v) \{
00046     \textcolor{keywordflow}{if} (v < INT32\_MIN || v > INT32\_MAX)
00047         \textcolor{keywordflow}{return} \hyperlink{intset_8c_a813ff1fc109e585be5fef8f605101064}{INTSET\_ENC\_INT64};
00048     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (v < INT16\_MIN || v > INT16\_MAX)
00049         \textcolor{keywordflow}{return} \hyperlink{intset_8c_aa1aa222f55313754dadfb15b2a328f6b}{INTSET\_ENC\_INT32};
00050     \textcolor{keywordflow}{else}
00051         \textcolor{keywordflow}{return} \hyperlink{intset_8c_a60abb5e9fff1225d1f540718895eae90}{INTSET\_ENC\_INT16};
00052 \}
00053 
00054 \textcolor{comment}{/* Return the value at pos, given an encoding. */}
00055 \textcolor{keyword}{static} int64\_t \_intsetGetEncoded(intset *is, \textcolor{keywordtype}{int} pos, uint8\_t enc) \{
00056     int64\_t v64;
00057     int32\_t v32;
00058     int16\_t v16;
00059 
00060     \textcolor{keywordflow}{if} (enc == \hyperlink{intset_8c_a813ff1fc109e585be5fef8f605101064}{INTSET\_ENC\_INT64}) \{
00061         memcpy(&v64,((int64\_t*)is->contents)+pos,\textcolor{keyword}{sizeof}(v64));
00062         \hyperlink{endianconv_8h_aa311b9f944c3b988f3601698a95890c1}{memrev64ifbe}(&v64);
00063         \textcolor{keywordflow}{return} v64;
00064     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (enc == \hyperlink{intset_8c_aa1aa222f55313754dadfb15b2a328f6b}{INTSET\_ENC\_INT32}) \{
00065         memcpy(&v32,((int32\_t*)is->contents)+pos,\textcolor{keyword}{sizeof}(v32));
00066         \hyperlink{endianconv_8h_a771f3656eb7d11a1e7f7294b657d8978}{memrev32ifbe}(&v32);
00067         \textcolor{keywordflow}{return} v32;
00068     \} \textcolor{keywordflow}{else} \{
00069         memcpy(&v16,((int16\_t*)is->contents)+pos,\textcolor{keyword}{sizeof}(v16));
00070         \hyperlink{endianconv_8h_a49372891e83ab7a970f0d98dda1870d9}{memrev16ifbe}(&v16);
00071         \textcolor{keywordflow}{return} v16;
00072     \}
00073 \}
00074 
00075 \textcolor{comment}{/* Return the value at pos, using the configured encoding. */}
00076 \textcolor{keyword}{static} int64\_t \_intsetGet(intset *is, \textcolor{keywordtype}{int} pos) \{
00077     \textcolor{keywordflow}{return} \_intsetGetEncoded(is,pos,\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->encoding));
00078 \}
00079 
00080 \textcolor{comment}{/* Set the value at pos, using the configured encoding. */}
00081 \textcolor{keyword}{static} \textcolor{keywordtype}{void} \_intsetSet(intset *is, \textcolor{keywordtype}{int} pos, int64\_t value) \{
00082     uint32\_t encoding = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->encoding);
00083 
00084     \textcolor{keywordflow}{if} (encoding == \hyperlink{intset_8c_a813ff1fc109e585be5fef8f605101064}{INTSET\_ENC\_INT64}) \{
00085         ((int64\_t*)is->contents)[pos] = value;
00086         \hyperlink{endianconv_8h_aa311b9f944c3b988f3601698a95890c1}{memrev64ifbe}(((int64\_t*)is->contents)+pos);
00087     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (encoding == \hyperlink{intset_8c_aa1aa222f55313754dadfb15b2a328f6b}{INTSET\_ENC\_INT32}) \{
00088         ((int32\_t*)is->contents)[pos] = value;
00089         \hyperlink{endianconv_8h_a771f3656eb7d11a1e7f7294b657d8978}{memrev32ifbe}(((int32\_t*)is->contents)+pos);
00090     \} \textcolor{keywordflow}{else} \{
00091         ((int16\_t*)is->contents)[pos] = value;
00092         \hyperlink{endianconv_8h_a49372891e83ab7a970f0d98dda1870d9}{memrev16ifbe}(((int16\_t*)is->contents)+pos);
00093     \}
00094 \}
00095 
00096 \textcolor{comment}{/* Create an empty intset. */}
00097 intset *intsetNew(\textcolor{keywordtype}{void}) \{
00098     intset *is = zmalloc(\textcolor{keyword}{sizeof}(intset));
00099     is->encoding = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{intset_8c_a60abb5e9fff1225d1f540718895eae90}{INTSET\_ENC\_INT16});
00100     is->length = 0;
00101     \textcolor{keywordflow}{return} is;
00102 \}
00103 
00104 \textcolor{comment}{/* Resize the intset */}
00105 \textcolor{keyword}{static} intset *intsetResize(intset *is, uint32\_t len) \{
00106     uint32\_t size = len*\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->encoding);
00107     is = zrealloc(is,\textcolor{keyword}{sizeof}(intset)+size);
00108     \textcolor{keywordflow}{return} is;
00109 \}
00110 
00111 \textcolor{comment}{/* Search for the position of "value". Return 1 when the value was found and}
00112 \textcolor{comment}{ * sets "pos" to the position of the value within the intset. Return 0 when}
00113 \textcolor{comment}{ * the value is not present in the intset and sets "pos" to the position}
00114 \textcolor{comment}{ * where "value" can be inserted. */}
00115 \textcolor{keyword}{static} uint8\_t intsetSearch(intset *is, int64\_t value, uint32\_t *pos) \{
00116     \textcolor{keywordtype}{int} min = 0, max = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->length)-1, mid = -1;
00117     int64\_t cur = -1;
00118 
00119     \textcolor{comment}{/* The value can never be found when the set is empty */}
00120     \textcolor{keywordflow}{if} (\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->length) == 0) \{
00121         \textcolor{keywordflow}{if} (pos) *pos = 0;
00122         \textcolor{keywordflow}{return} 0;
00123     \} \textcolor{keywordflow}{else} \{
00124         \textcolor{comment}{/* Check for the case where we know we cannot find the value,}
00125 \textcolor{comment}{         * but do know the insert position. */}
00126         \textcolor{keywordflow}{if} (value > \_intsetGet(is,\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->length)-1)) \{
00127             \textcolor{keywordflow}{if} (pos) *pos = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->length);
00128             \textcolor{keywordflow}{return} 0;
00129         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value < \_intsetGet(is,0)) \{
00130             \textcolor{keywordflow}{if} (pos) *pos = 0;
00131             \textcolor{keywordflow}{return} 0;
00132         \}
00133     \}
00134 
00135     \textcolor{keywordflow}{while}(max >= min) \{
00136         mid = ((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})min + (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})max) >> 1;
00137         cur = \_intsetGet(is,mid);
00138         \textcolor{keywordflow}{if} (value > cur) \{
00139             min = mid+1;
00140         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value < cur) \{
00141             max = mid-1;
00142         \} \textcolor{keywordflow}{else} \{
00143             \textcolor{keywordflow}{break};
00144         \}
00145     \}
00146 
00147     \textcolor{keywordflow}{if} (value == cur) \{
00148         \textcolor{keywordflow}{if} (pos) *pos = mid;
00149         \textcolor{keywordflow}{return} 1;
00150     \} \textcolor{keywordflow}{else} \{
00151         \textcolor{keywordflow}{if} (pos) *pos = min;
00152         \textcolor{keywordflow}{return} 0;
00153     \}
00154 \}
00155 
00156 \textcolor{comment}{/* Upgrades the intset to a larger encoding and inserts the given integer. */}
00157 \textcolor{keyword}{static} intset *intsetUpgradeAndAdd(intset *is, int64\_t value) \{
00158     uint8\_t curenc = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->encoding);
00159     uint8\_t newenc = \_intsetValueEncoding(value);
00160     \textcolor{keywordtype}{int} length = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->length);
00161     \textcolor{keywordtype}{int} prepend = value < 0 ? 1 : 0;
00162 
00163     \textcolor{comment}{/* First set new encoding and resize */}
00164     is->encoding = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(newenc);
00165     is = intsetResize(is,\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->length)+1);
00166 
00167     \textcolor{comment}{/* Upgrade back-to-front so we don't overwrite values.}
00168 \textcolor{comment}{     * Note that the "prepend" variable is used to make sure we have an empty}
00169 \textcolor{comment}{     * space at either the beginning or the end of the intset. */}
00170     \textcolor{keywordflow}{while}(length--)
00171         \_intsetSet(is,length+prepend,\_intsetGetEncoded(is,length,curenc));
00172 
00173     \textcolor{comment}{/* Set the value at the beginning or the end. */}
00174     \textcolor{keywordflow}{if} (prepend)
00175         \_intsetSet(is,0,value);
00176     \textcolor{keywordflow}{else}
00177         \_intsetSet(is,\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->length),value);
00178     is->length = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->length)+1);
00179     \textcolor{keywordflow}{return} is;
00180 \}
00181 
00182 \textcolor{keyword}{static} \textcolor{keywordtype}{void} intsetMoveTail(intset *is, uint32\_t from, uint32\_t to) \{
00183     \textcolor{keywordtype}{void} *src, *dst;
00184     uint32\_t bytes = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->length)-from;
00185     uint32\_t encoding = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->encoding);
00186 
00187     \textcolor{keywordflow}{if} (encoding == \hyperlink{intset_8c_a813ff1fc109e585be5fef8f605101064}{INTSET\_ENC\_INT64}) \{
00188         src = (int64\_t*)is->contents+from;
00189         dst = (int64\_t*)is->contents+to;
00190         bytes *= \textcolor{keyword}{sizeof}(int64\_t);
00191     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (encoding == \hyperlink{intset_8c_aa1aa222f55313754dadfb15b2a328f6b}{INTSET\_ENC\_INT32}) \{
00192         src = (int32\_t*)is->contents+from;
00193         dst = (int32\_t*)is->contents+to;
00194         bytes *= \textcolor{keyword}{sizeof}(int32\_t);
00195     \} \textcolor{keywordflow}{else} \{
00196         src = (int16\_t*)is->contents+from;
00197         dst = (int16\_t*)is->contents+to;
00198         bytes *= \textcolor{keyword}{sizeof}(int16\_t);
00199     \}
00200     memmove(dst,src,bytes);
00201 \}
00202 
00203 \textcolor{comment}{/* Insert an integer in the intset */}
00204 intset *intsetAdd(intset *is, int64\_t value, uint8\_t *success) \{
00205     uint8\_t valenc = \_intsetValueEncoding(value);
00206     uint32\_t pos;
00207     \textcolor{keywordflow}{if} (success) *success = 1;
00208 
00209     \textcolor{comment}{/* Upgrade encoding if necessary. If we need to upgrade, we know that}
00210 \textcolor{comment}{     * this value should be either appended (if > 0) or prepended (if < 0),}
00211 \textcolor{comment}{     * because it lies outside the range of existing values. */}
00212     \textcolor{keywordflow}{if} (valenc > \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->encoding)) \{
00213         \textcolor{comment}{/* This always succeeds, so we don't need to curry *success. */}
00214         \textcolor{keywordflow}{return} intsetUpgradeAndAdd(is,value);
00215     \} \textcolor{keywordflow}{else} \{
00216         \textcolor{comment}{/* Abort if the value is already present in the set.}
00217 \textcolor{comment}{         * This call will populate "pos" with the right position to insert}
00218 \textcolor{comment}{         * the value when it cannot be found. */}
00219         \textcolor{keywordflow}{if} (intsetSearch(is,value,&pos)) \{
00220             \textcolor{keywordflow}{if} (success) *success = 0;
00221             \textcolor{keywordflow}{return} is;
00222         \}
00223 
00224         is = intsetResize(is,\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->length)+1);
00225         \textcolor{keywordflow}{if} (pos < \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->length)) intsetMoveTail(is,pos,pos+1);
00226     \}
00227 
00228     \_intsetSet(is,pos,value);
00229     is->length = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->length)+1);
00230     \textcolor{keywordflow}{return} is;
00231 \}
00232 
00233 \textcolor{comment}{/* Delete integer from intset */}
00234 intset *intsetRemove(intset *is, int64\_t value, \textcolor{keywordtype}{int} *success) \{
00235     uint8\_t valenc = \_intsetValueEncoding(value);
00236     uint32\_t pos;
00237     \textcolor{keywordflow}{if} (success) *success = 0;
00238 
00239     \textcolor{keywordflow}{if} (valenc <= \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->encoding) && intsetSearch(is,value,&pos)) \{
00240         uint32\_t len = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->length);
00241 
00242         \textcolor{comment}{/* We know we can delete */}
00243         \textcolor{keywordflow}{if} (success) *success = 1;
00244 
00245         \textcolor{comment}{/* Overwrite value with tail and update length */}
00246         \textcolor{keywordflow}{if} (pos < (len-1)) intsetMoveTail(is,pos+1,pos);
00247         is = intsetResize(is,len-1);
00248         is->length = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(len-1);
00249     \}
00250     \textcolor{keywordflow}{return} is;
00251 \}
00252 
00253 \textcolor{comment}{/* Determine whether a value belongs to this set */}
00254 uint8\_t intsetFind(intset *is, int64\_t value) \{
00255     uint8\_t valenc = \_intsetValueEncoding(value);
00256     \textcolor{keywordflow}{return} valenc <= \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->encoding) && intsetSearch(is,value,NULL);
00257 \}
00258 
00259 \textcolor{comment}{/* Return random member */}
00260 int64\_t intsetRandom(intset *is) \{
00261     \textcolor{keywordflow}{return} \_intsetGet(is,rand()%\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->length));
00262 \}
00263 
00264 \textcolor{comment}{/* Get the value at the given position. When this position is}
00265 \textcolor{comment}{ * out of range the function returns 0, when in range it returns 1. */}
00266 uint8\_t intsetGet(intset *is, uint32\_t pos, int64\_t *value) \{
00267     \textcolor{keywordflow}{if} (pos < \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->length)) \{
00268         *value = \_intsetGet(is,pos);
00269         \textcolor{keywordflow}{return} 1;
00270     \}
00271     \textcolor{keywordflow}{return} 0;
00272 \}
00273 
00274 \textcolor{comment}{/* Return intset length */}
00275 uint32\_t intsetLen(\textcolor{keyword}{const} intset *is) \{
00276     \textcolor{keywordflow}{return} \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->length);
00277 \}
00278 
00279 \textcolor{comment}{/* Return intset blob size in bytes. */}
00280 size\_t intsetBlobLen(intset *is) \{
00281     \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}(intset)+\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->length)*\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(is->encoding);
00282 \}
00283 
00284 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \textcolor{preprocessor}{REDIS\_TEST}
00285 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{time}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00286 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{time}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00287 
00288 \textcolor{preprocessor}{#}\textcolor{preprocessor}{if} 0
00289 \textcolor{keyword}{static} \textcolor{keywordtype}{void} intsetRepr(intset *is) \{
00290     \textcolor{keywordflow}{for} (uint32\_t i = 0; i < intrev32ifbe(is->length); i++) \{
00291         printf(\textcolor{stringliteral}{"%lld\(\backslash\)n"}, (uint64\_t)\_intsetGet(is,i));
00292     \}
00293     printf(\textcolor{stringliteral}{"\(\backslash\)n"});
00294 \}
00295 
00296 \textcolor{keyword}{static} \textcolor{keywordtype}{void} error(\textcolor{keywordtype}{char} *err) \{
00297     printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, err);
00298     exit(1);
00299 \}
00300 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
00301 
00302 \textcolor{keyword}{static} \textcolor{keywordtype}{void} ok(\textcolor{keywordtype}{void}) \{
00303     printf(\textcolor{stringliteral}{"OK\(\backslash\)n"});
00304 \}
00305 
00306 \textcolor{keyword}{static} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} usec(\textcolor{keywordtype}{void}) \{
00307     \textcolor{keyword}{struct} timeval tv;
00308     gettimeofday(&tv,NULL);
00309     \textcolor{keywordflow}{return} (((\textcolor{keywordtype}{long} \textcolor{keywordtype}{long})tv.tv\_sec)*1000000)+tv.tv\_usec;
00310 \}
00311 
00312 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{assert}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_e}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_e}\textcolor{preprocessor}{)}\textcolor{preprocessor}{?}\textcolor{preprocessor}{(}\textcolor{preprocessor}{void}\textcolor{preprocessor}{)}0\textcolor{preprocessor}{:}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_assert}\textcolor{preprocessor}{(}\textcolor{preprocessor}{#}\textcolor{preprocessor}{\_e}\textcolor{preprocessor}{,}\textcolor{preprocessor}{\_\_FILE\_\_}\textcolor{preprocessor}{,}\textcolor{preprocessor}{\_\_LINE\_\_}\textcolor{preprocessor}{)}\textcolor{preprocessor}{,}\textcolor{preprocessor}{exit}\textcolor{preprocessor}{(}1\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00313 \textcolor{keyword}{static} \textcolor{keywordtype}{void} \_assert(\textcolor{keywordtype}{char} *estr, \textcolor{keywordtype}{char} *file, \textcolor{keywordtype}{int} line) \{
00314     printf(\textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n=== ASSERTION FAILED ===\(\backslash\)n"});
00315     printf(\textcolor{stringliteral}{"==> %s:%d '%s' is not true\(\backslash\)n"},file,line,estr);
00316 \}
00317 
00318 \textcolor{keyword}{static} intset *createSet(\textcolor{keywordtype}{int} bits, \textcolor{keywordtype}{int} size) \{
00319     uint64\_t mask = (1<<bits)-1;
00320     uint64\_t value;
00321     intset *is = intsetNew();
00322 
00323     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < size; i++) \{
00324         \textcolor{keywordflow}{if} (bits > 32) \{
00325             value = (rand()*rand()) & mask;
00326         \} \textcolor{keywordflow}{else} \{
00327             value = rand() & mask;
00328         \}
00329         is = intsetAdd(is,value,NULL);
00330     \}
00331     \textcolor{keywordflow}{return} is;
00332 \}
00333 
00334 \textcolor{keyword}{static} \textcolor{keywordtype}{void} checkConsistency(intset *is) \{
00335     \textcolor{keywordflow}{for} (uint32\_t i = 0; i < (intrev32ifbe(is->length)-1); i++) \{
00336         uint32\_t encoding = intrev32ifbe(is->encoding);
00337 
00338         \textcolor{keywordflow}{if} (encoding == INTSET\_ENC\_INT16) \{
00339             int16\_t *i16 = (int16\_t*)is->contents;
00340             assert(i16[i] < i16[i+1]);
00341         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (encoding == INTSET\_ENC\_INT32) \{
00342             int32\_t *i32 = (int32\_t*)is->contents;
00343             assert(i32[i] < i32[i+1]);
00344         \} \textcolor{keywordflow}{else} \{
00345             int64\_t *i64 = (int64\_t*)is->contents;
00346             assert(i64[i] < i64[i+1]);
00347         \}
00348     \}
00349 \}
00350 
00351 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{UNUSED}\textcolor{preprocessor}{(}\textcolor{preprocessor}{x}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{void}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{preprocessor}{x}\textcolor{preprocessor}{)}
00352 \textcolor{keywordtype}{int} intsetTest(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
00353     uint8\_t success;
00354     \textcolor{keywordtype}{int} i;
00355     intset *is;
00356     srand(time(NULL));
00357 
00358     UNUSED(argc);
00359     UNUSED(argv);
00360 
00361     printf(\textcolor{stringliteral}{"Value encodings: "}); \{
00362         assert(\_intsetValueEncoding(-32768) == INTSET\_ENC\_INT16);
00363         assert(\_intsetValueEncoding(+32767) == INTSET\_ENC\_INT16);
00364         assert(\_intsetValueEncoding(-32769) == INTSET\_ENC\_INT32);
00365         assert(\_intsetValueEncoding(+32768) == INTSET\_ENC\_INT32);
00366         assert(\_intsetValueEncoding(-2147483648) == INTSET\_ENC\_INT32);
00367         assert(\_intsetValueEncoding(+2147483647) == INTSET\_ENC\_INT32);
00368         assert(\_intsetValueEncoding(-2147483649) == INTSET\_ENC\_INT64);
00369         assert(\_intsetValueEncoding(+2147483648) == INTSET\_ENC\_INT64);
00370         assert(\_intsetValueEncoding(-9223372036854775808ull) ==
00371                     INTSET\_ENC\_INT64);
00372         assert(\_intsetValueEncoding(+9223372036854775807ull) ==
00373                     INTSET\_ENC\_INT64);
00374         ok();
00375     \}
00376 
00377     printf(\textcolor{stringliteral}{"Basic adding: "}); \{
00378         is = intsetNew();
00379         is = intsetAdd(is,5,&success); assert(success);
00380         is = intsetAdd(is,6,&success); assert(success);
00381         is = intsetAdd(is,4,&success); assert(success);
00382         is = intsetAdd(is,4,&success); assert(!success);
00383         ok();
00384     \}
00385 
00386     printf(\textcolor{stringliteral}{"Large number of random adds: "}); \{
00387         uint32\_t inserts = 0;
00388         is = intsetNew();
00389         \textcolor{keywordflow}{for} (i = 0; i < 1024; i++) \{
00390             is = intsetAdd(is,rand()%0x800,&success);
00391             \textcolor{keywordflow}{if} (success) inserts++;
00392         \}
00393         assert(intrev32ifbe(is->length) == inserts);
00394         checkConsistency(is);
00395         ok();
00396     \}
00397 
00398     printf(\textcolor{stringliteral}{"Upgrade from int16 to int32: "}); \{
00399         is = intsetNew();
00400         is = intsetAdd(is,32,NULL);
00401         assert(intrev32ifbe(is->encoding) == INTSET\_ENC\_INT16);
00402         is = intsetAdd(is,65535,NULL);
00403         assert(intrev32ifbe(is->encoding) == INTSET\_ENC\_INT32);
00404         assert(intsetFind(is,32));
00405         assert(intsetFind(is,65535));
00406         checkConsistency(is);
00407 
00408         is = intsetNew();
00409         is = intsetAdd(is,32,NULL);
00410         assert(intrev32ifbe(is->encoding) == INTSET\_ENC\_INT16);
00411         is = intsetAdd(is,-65535,NULL);
00412         assert(intrev32ifbe(is->encoding) == INTSET\_ENC\_INT32);
00413         assert(intsetFind(is,32));
00414         assert(intsetFind(is,-65535));
00415         checkConsistency(is);
00416         ok();
00417     \}
00418 
00419     printf(\textcolor{stringliteral}{"Upgrade from int16 to int64: "}); \{
00420         is = intsetNew();
00421         is = intsetAdd(is,32,NULL);
00422         assert(intrev32ifbe(is->encoding) == INTSET\_ENC\_INT16);
00423         is = intsetAdd(is,4294967295,NULL);
00424         assert(intrev32ifbe(is->encoding) == INTSET\_ENC\_INT64);
00425         assert(intsetFind(is,32));
00426         assert(intsetFind(is,4294967295));
00427         checkConsistency(is);
00428 
00429         is = intsetNew();
00430         is = intsetAdd(is,32,NULL);
00431         assert(intrev32ifbe(is->encoding) == INTSET\_ENC\_INT16);
00432         is = intsetAdd(is,-4294967295,NULL);
00433         assert(intrev32ifbe(is->encoding) == INTSET\_ENC\_INT64);
00434         assert(intsetFind(is,32));
00435         assert(intsetFind(is,-4294967295));
00436         checkConsistency(is);
00437         ok();
00438     \}
00439 
00440     printf(\textcolor{stringliteral}{"Upgrade from int32 to int64: "}); \{
00441         is = intsetNew();
00442         is = intsetAdd(is,65535,NULL);
00443         assert(intrev32ifbe(is->encoding) == INTSET\_ENC\_INT32);
00444         is = intsetAdd(is,4294967295,NULL);
00445         assert(intrev32ifbe(is->encoding) == INTSET\_ENC\_INT64);
00446         assert(intsetFind(is,65535));
00447         assert(intsetFind(is,4294967295));
00448         checkConsistency(is);
00449 
00450         is = intsetNew();
00451         is = intsetAdd(is,65535,NULL);
00452         assert(intrev32ifbe(is->encoding) == INTSET\_ENC\_INT32);
00453         is = intsetAdd(is,-4294967295,NULL);
00454         assert(intrev32ifbe(is->encoding) == INTSET\_ENC\_INT64);
00455         assert(intsetFind(is,65535));
00456         assert(intsetFind(is,-4294967295));
00457         checkConsistency(is);
00458         ok();
00459     \}
00460 
00461     printf(\textcolor{stringliteral}{"Stress lookups: "}); \{
00462         \textcolor{keywordtype}{long} num = 100000, size = 10000;
00463         \textcolor{keywordtype}{int} i, bits = 20;
00464         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} start;
00465         is = createSet(bits,size);
00466         checkConsistency(is);
00467 
00468         start = usec();
00469         \textcolor{keywordflow}{for} (i = 0; i < num; i++) intsetSearch(is,rand() % ((1<<bits)-1),NULL);
00470         printf(\textcolor{stringliteral}{"%ld lookups, %ld element set, %lldusec\(\backslash\)n"},
00471                num,size,usec()-start);
00472     \}
00473 
00474     printf(\textcolor{stringliteral}{"Stress add+delete: "}); \{
00475         \textcolor{keywordtype}{int} i, v1, v2;
00476         is = intsetNew();
00477         \textcolor{keywordflow}{for} (i = 0; i < 0xffff; i++) \{
00478             v1 = rand() % 0xfff;
00479             is = intsetAdd(is,v1,NULL);
00480             assert(intsetFind(is,v1));
00481 
00482             v2 = rand() % 0xfff;
00483             is = intsetRemove(is,v2,NULL);
00484             assert(!intsetFind(is,v2));
00485         \}
00486         checkConsistency(is);
00487         ok();
00488     \}
00489 
00490     \textcolor{keywordflow}{return} 0;
00491 \}
00492 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
\end{DoxyCode}
