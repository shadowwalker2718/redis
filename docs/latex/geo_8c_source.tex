\hypertarget{geo_8c_source}{}\section{geo.\+c}
\label{geo_8c_source}\index{src/geo.\+c@{src/geo.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ * Copyright (c) 2014, Matt Stancliff <matt@genges.com>.}
00003 \textcolor{comment}{ * Copyright (c) 2015-2016, Salvatore Sanfilippo <antirez@gmail.com>.}
00004 \textcolor{comment}{ * All rights reserved.}
00005 \textcolor{comment}{ *}
00006 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00007 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00008 \textcolor{comment}{ *}
00009 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00010 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00011 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00012 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00013 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00014 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00015 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00016 \textcolor{comment}{ *     specific prior written permission.}
00017 \textcolor{comment}{ *}
00018 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00019 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00020 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00021 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00022 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00023 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00024 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00025 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00026 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00027 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00028 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00029 \textcolor{comment}{ */}
00030 
00031 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{geo_8h}{"geo.h"}
00032 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{geohash__helper_8h}{"geohash\_helper.h"}
00033 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{debugmacro_8h}{"debugmacro.h"}
00034 
00035 \textcolor{comment}{/* Things exported from t\_zset.c only for geo.c, since it is the only other}
00036 \textcolor{comment}{ * part of Redis that requires close zset introspection. */}
00037 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zzlFirstInRange(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, zrangespec *range);
00038 \textcolor{keywordtype}{int} zslValueLteMax(\textcolor{keywordtype}{double} value, zrangespec *spec);
00039 
00040 \textcolor{comment}{/* ====================================================================}
00041 \textcolor{comment}{ * This file implements the following commands:}
00042 \textcolor{comment}{ *}
00043 \textcolor{comment}{ *   - geoadd - add coordinates for value to geoset}
00044 \textcolor{comment}{ *   - georadius - search radius by coordinates in geoset}
00045 \textcolor{comment}{ *   - georadiusbymember - search radius based on geoset member position}
00046 \textcolor{comment}{ * ==================================================================== */}
00047 
00048 \textcolor{comment}{/* ====================================================================}
00049 \textcolor{comment}{ * geoArray implementation}
00050 \textcolor{comment}{ * ==================================================================== */}
00051 
00052 \textcolor{comment}{/* Create a new array of geoPoints. */}
00053 \hyperlink{structgeoArray}{geoArray} *geoArrayCreate(\textcolor{keywordtype}{void}) \{
00054     \hyperlink{structgeoArray}{geoArray} *ga = zmalloc(\textcolor{keyword}{sizeof}(*ga));
00055     \textcolor{comment}{/* It gets allocated on first geoArrayAppend() call. */}
00056     ga->array = NULL;
00057     ga->buckets = 0;
00058     ga->used = 0;
00059     \textcolor{keywordflow}{return} ga;
00060 \}
00061 
00062 \textcolor{comment}{/* Add a new entry and return its pointer so that the caller can populate}
00063 \textcolor{comment}{ * it with data. */}
00064 geoPoint *geoArrayAppend(\hyperlink{structgeoArray}{geoArray} *ga) \{
00065     \textcolor{keywordflow}{if} (ga->used == ga->buckets) \{
00066         ga->buckets = (ga->buckets == 0) ? 8 : ga->buckets*2;
00067         ga->array = zrealloc(ga->array,\textcolor{keyword}{sizeof}(geoPoint)*ga->buckets);
00068     \}
00069     geoPoint *gp = ga->array+ga->used;
00070     ga->used++;
00071     \textcolor{keywordflow}{return} gp;
00072 \}
00073 
00074 \textcolor{comment}{/* Destroy a geoArray created with geoArrayCreate(). */}
00075 \textcolor{keywordtype}{void} geoArrayFree(\hyperlink{structgeoArray}{geoArray} *ga) \{
00076     size\_t i;
00077     \textcolor{keywordflow}{for} (i = 0; i < ga->used; i++) sdsfree(ga->array[i].member);
00078     zfree(ga->array);
00079     zfree(ga);
00080 \}
00081 
00082 \textcolor{comment}{/* ====================================================================}
00083 \textcolor{comment}{ * Helpers}
00084 \textcolor{comment}{ * ==================================================================== */}
00085 \textcolor{keywordtype}{int} decodeGeohash(\textcolor{keywordtype}{double} bits, \textcolor{keywordtype}{double} *xy) \{
00086     GeoHashBits hash = \{ .bits = (uint64\_t)bits, .step = \hyperlink{geohash_8h_a4c2e31e393c541a34939f7b4ae1d23d3}{GEO\_STEP\_MAX} \};
00087     \textcolor{keywordflow}{return} geohashDecodeToLongLatWGS84(hash, xy);
00088 \}
00089 
00090 \textcolor{comment}{/* Input Argument Helper */}
00091 \textcolor{comment}{/* Take a pointer to the latitude arg then use the next arg for longitude.}
00092 \textcolor{comment}{ * On parse error C\_ERR is returned, otherwise C\_OK. */}
00093 \textcolor{keywordtype}{int} extractLongLatOrReply(\hyperlink{structclient}{client} *c, robj **argv, \textcolor{keywordtype}{double} *xy) \{
00094     \textcolor{keywordtype}{int} i;
00095     \textcolor{keywordflow}{for} (i = 0; i < 2; i++) \{
00096         \textcolor{keywordflow}{if} (getDoubleFromObjectOrReply(c, argv[i], xy + i, NULL) !=
00097             \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
00098             \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00099         \}
00100     \}
00101     \textcolor{keywordflow}{if} (xy[0] < \hyperlink{geohash_8h_abf32454c8db6da7cf595d5ac092bb313}{GEO\_LONG\_MIN} || xy[0] > \hyperlink{geohash_8h_a86a07918583c89467cf3e459adf513f5}{GEO\_LONG\_MAX} ||
00102         xy[1] < \hyperlink{geohash_8h_a7da01a8f44929d11f00b2966c834a9b9}{GEO\_LAT\_MIN}  || xy[1] > \hyperlink{geohash_8h_a831d966c99458d47620ea66a4c6768ab}{GEO\_LAT\_MAX}) \{
00103         addReplySds(c, sdscatprintf(sdsempty(),
00104             \textcolor{stringliteral}{"-ERR invalid longitude,latitude pair %f,%f\(\backslash\)r\(\backslash\)n"},xy[0],xy[1]));
00105         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00106     \}
00107     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00108 \}
00109 
00110 \textcolor{comment}{/* Input Argument Helper */}
00111 \textcolor{comment}{/* Decode lat/long from a zset member's score.}
00112 \textcolor{comment}{ * Returns C\_OK on successful decoding, otherwise C\_ERR is returned. */}
00113 \textcolor{keywordtype}{int} longLatFromMember(robj *zobj, robj *member, \textcolor{keywordtype}{double} *xy) \{
00114     \textcolor{keywordtype}{double} score = 0;
00115 
00116     \textcolor{keywordflow}{if} (zsetScore(zobj, member->ptr, &score) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00117     \textcolor{keywordflow}{if} (!decodeGeohash(score, xy)) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00118     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00119 \}
00120 
00121 \textcolor{comment}{/* Check that the unit argument matches one of the known units, and returns}
00122 \textcolor{comment}{ * the conversion factor to meters (you need to divide meters by the conversion}
00123 \textcolor{comment}{ * factor to convert to the right unit).}
00124 \textcolor{comment}{ *}
00125 \textcolor{comment}{ * If the unit is not valid, an error is reported to the client, and a value}
00126 \textcolor{comment}{ * less than zero is returned. */}
00127 \textcolor{keywordtype}{double} extractUnitOrReply(\hyperlink{structclient}{client} *c, robj *unit) \{
00128     \textcolor{keywordtype}{char} *u = unit->ptr;
00129 
00130     \textcolor{keywordflow}{if} (!strcmp(u, \textcolor{stringliteral}{"m"})) \{
00131         \textcolor{keywordflow}{return} 1;
00132     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcmp(u, \textcolor{stringliteral}{"km"})) \{
00133         \textcolor{keywordflow}{return} 1000;
00134     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcmp(u, \textcolor{stringliteral}{"ft"})) \{
00135         \textcolor{keywordflow}{return} 0.3048;
00136     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcmp(u, \textcolor{stringliteral}{"mi"})) \{
00137         \textcolor{keywordflow}{return} 1609.34;
00138     \} \textcolor{keywordflow}{else} \{
00139         addReplyError(c,
00140             \textcolor{stringliteral}{"unsupported unit provided. please use m, km, ft, mi"});
00141         \textcolor{keywordflow}{return} -1;
00142     \}
00143 \}
00144 
00145 \textcolor{comment}{/* Input Argument Helper.}
00146 \textcolor{comment}{ * Extract the dinstance from the specified two arguments starting at 'argv'}
00147 \textcolor{comment}{ * that shouldbe in the form: <number> <unit> and return the dinstance in the}
00148 \textcolor{comment}{ * specified unit on success. *conversino is populated with the coefficient}
00149 \textcolor{comment}{ * to use in order to convert meters to the unit.}
00150 \textcolor{comment}{ *}
00151 \textcolor{comment}{ * On error a value less than zero is returned. */}
00152 \textcolor{keywordtype}{double} extractDistanceOrReply(\hyperlink{structclient}{client} *c, robj **argv,
00153                                      \textcolor{keywordtype}{double} *conversion) \{
00154     \textcolor{keywordtype}{double} distance;
00155     \textcolor{keywordflow}{if} (getDoubleFromObjectOrReply(c, argv[0], &distance,
00156                                    \textcolor{stringliteral}{"need numeric radius"}) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
00157         \textcolor{keywordflow}{return} -1;
00158     \}
00159 
00160     \textcolor{keywordflow}{if} (distance < 0) \{
00161         addReplyError(c,\textcolor{stringliteral}{"radius cannot be negative"});
00162         \textcolor{keywordflow}{return} -1;
00163     \}
00164 
00165     \textcolor{keywordtype}{double} to\_meters = extractUnitOrReply(c,argv[1]);
00166     \textcolor{keywordflow}{if} (to\_meters < 0) \{
00167         \textcolor{keywordflow}{return} -1;
00168     \}
00169 
00170     \textcolor{keywordflow}{if} (conversion) *conversion = to\_meters;
00171     \textcolor{keywordflow}{return} distance * to\_meters;
00172 \}
00173 
00174 \textcolor{comment}{/* The default addReplyDouble has too much accuracy.  We use this}
00175 \textcolor{comment}{ * for returning location distances. "5.2145 meters away" is nicer}
00176 \textcolor{comment}{ * than "5.2144992818115 meters away." We provide 4 digits after the dot}
00177 \textcolor{comment}{ * so that the returned value is decently accurate even when the unit is}
00178 \textcolor{comment}{ * the kilometer. */}
00179 \textcolor{keywordtype}{void} addReplyDoubleDistance(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{double} d) \{
00180     \textcolor{keywordtype}{char} dbuf[128];
00181     \textcolor{keywordtype}{int} dlen = snprintf(dbuf, \textcolor{keyword}{sizeof}(dbuf), \textcolor{stringliteral}{"%.4f"}, d);
00182     addReplyBulkCBuffer(c, dbuf, dlen);
00183 \}
00184 
00185 \textcolor{comment}{/* Helper function for geoGetPointsInRange(): given a sorted set score}
00186 \textcolor{comment}{ * representing a point, and another point (the center of our search) and}
00187 \textcolor{comment}{ * a radius, appends this entry as a geoPoint into the specified geoArray}
00188 \textcolor{comment}{ * only if the point is within the search area.}
00189 \textcolor{comment}{ *}
00190 \textcolor{comment}{ * returns C\_OK if the point is included, or REIDS\_ERR if it is outside. */}
00191 \textcolor{keywordtype}{int} geoAppendIfWithinRadius(\hyperlink{structgeoArray}{geoArray} *ga, \textcolor{keywordtype}{double} lon, \textcolor{keywordtype}{double} lat, \textcolor{keywordtype}{double} radius, \textcolor{keywordtype}{double} score,
       sds member) \{
00192     \textcolor{keywordtype}{double} distance, xy[2];
00193 
00194     \textcolor{keywordflow}{if} (!decodeGeohash(score,xy)) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}; \textcolor{comment}{/* Can't decode. */}
00195     \textcolor{comment}{/* Note that geohashGetDistanceIfInRadiusWGS84() takes arguments in}
00196 \textcolor{comment}{     * reverse order: longitude first, latitude later. */}
00197     \textcolor{keywordflow}{if} (!geohashGetDistanceIfInRadiusWGS84(lon,lat, xy[0], xy[1],
00198                                            radius, &distance))
00199     \{
00200         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00201     \}
00202 
00203     \textcolor{comment}{/* Append the new element. */}
00204     geoPoint *gp = geoArrayAppend(ga);
00205     gp->longitude = xy[0];
00206     gp->latitude = xy[1];
00207     gp->dist = distance;
00208     gp->member = member;
00209     gp->score = score;
00210     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00211 \}
00212 
00213 \textcolor{comment}{/* Query a Redis sorted set to extract all the elements between 'min' and}
00214 \textcolor{comment}{ * 'max', appending them into the array of geoPoint structures 'gparray'.}
00215 \textcolor{comment}{ * The command returns the number of elements added to the array.}
00216 \textcolor{comment}{ *}
00217 \textcolor{comment}{ * Elements which are farest than 'radius' from the specified 'x' and 'y'}
00218 \textcolor{comment}{ * coordinates are not included.}
00219 \textcolor{comment}{ *}
00220 \textcolor{comment}{ * The ability of this function to append to an existing set of points is}
00221 \textcolor{comment}{ * important for good performances because querying by radius is performed}
00222 \textcolor{comment}{ * using multiple queries to the sorted set, that we later need to sort}
00223 \textcolor{comment}{ * via qsort. Similarly we need to be able to reject points outside the search}
00224 \textcolor{comment}{ * radius area ASAP in order to allocate and process more points than needed. */}
00225 \textcolor{keywordtype}{int} geoGetPointsInRange(robj *zobj, \textcolor{keywordtype}{double} min, \textcolor{keywordtype}{double} max, \textcolor{keywordtype}{double} lon, \textcolor{keywordtype}{double} lat, \textcolor{keywordtype}{double} radius, 
      \hyperlink{structgeoArray}{geoArray} *ga) \{
00226     \textcolor{comment}{/* minex 0 = include min in range; maxex 1 = exclude max in range */}
00227     \textcolor{comment}{/* That's: min <= val < max */}
00228     zrangespec range = \{ .min = min, .max = max, .minex = 0, .maxex = 1 \};
00229     size\_t origincount = ga->used;
00230     sds member;
00231 
00232     \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
00233         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl = zobj->ptr;
00234         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr, *sptr;
00235         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr = NULL;
00236         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen = 0;
00237         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} vlong = 0;
00238         \textcolor{keywordtype}{double} score = 0;
00239 
00240         \textcolor{keywordflow}{if} ((eptr = zzlFirstInRange(zl, &range)) == NULL) \{
00241             \textcolor{comment}{/* Nothing exists starting at our min.  No results. */}
00242             \textcolor{keywordflow}{return} 0;
00243         \}
00244 
00245         sptr = ziplistNext(zl, eptr);
00246         \textcolor{keywordflow}{while} (eptr) \{
00247             score = zzlGetScore(sptr);
00248 
00249             \textcolor{comment}{/* If we fell out of range, break. */}
00250             \textcolor{keywordflow}{if} (!zslValueLteMax(score, &range))
00251                 \textcolor{keywordflow}{break};
00252 
00253             \textcolor{comment}{/* We know the element exists. ziplistGet should always succeed */}
00254             ziplistGet(eptr, &vstr, &vlen, &vlong);
00255             member = (vstr == NULL) ? sdsfromlonglong(vlong) :
00256                                       sdsnewlen(vstr,vlen);
00257             \textcolor{keywordflow}{if} (geoAppendIfWithinRadius(ga,lon,lat,radius,score,member)
00258                 == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) sdsfree(member);
00259             zzlNext(zl, &eptr, &sptr);
00260         \}
00261     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
00262         zset *zs = zobj->ptr;
00263         zskiplist *zsl = zs->zsl;
00264         zskiplistNode *ln;
00265 
00266         \textcolor{keywordflow}{if} ((ln = zslFirstInRange(zsl, &range)) == NULL) \{
00267             \textcolor{comment}{/* Nothing exists starting at our min.  No results. */}
00268             \textcolor{keywordflow}{return} 0;
00269         \}
00270 
00271         \textcolor{keywordflow}{while} (ln) \{
00272             sds ele = ln->ele;
00273             \textcolor{comment}{/* Abort when the node is no longer in range. */}
00274             \textcolor{keywordflow}{if} (!zslValueLteMax(ln->score, &range))
00275                 \textcolor{keywordflow}{break};
00276 
00277             ele = sdsdup(ele);
00278             \textcolor{keywordflow}{if} (geoAppendIfWithinRadius(ga,lon,lat,radius,ln->score,ele)
00279                 == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) sdsfree(ele);
00280             ln = ln->level[0].forward;
00281         \}
00282     \}
00283     \textcolor{keywordflow}{return} ga->used - origincount;
00284 \}
00285 
00286 \textcolor{comment}{/* Compute the sorted set scores min (inclusive), max (exclusive) we should}
00287 \textcolor{comment}{ * query in order to retrieve all the elements inside the specified area}
00288 \textcolor{comment}{ * 'hash'. The two scores are returned by reference in *min and *max. */}
00289 \textcolor{keywordtype}{void} scoresOfGeoHashBox(GeoHashBits hash, GeoHashFix52Bits *min, GeoHashFix52Bits *max) \{
00290     \textcolor{comment}{/* We want to compute the sorted set scores that will include all the}
00291 \textcolor{comment}{     * elements inside the specified Geohash 'hash', which has as many}
00292 \textcolor{comment}{     * bits as specified by hash.step * 2.}
00293 \textcolor{comment}{     *}
00294 \textcolor{comment}{     * So if step is, for example, 3, and the hash value in binary}
00295 \textcolor{comment}{     * is 101010, since our score is 52 bits we want every element which}
00296 \textcolor{comment}{     * is in binary: 101010?????????????????????????????????????????????}
00297 \textcolor{comment}{     * Where ? can be 0 or 1.}
00298 \textcolor{comment}{     *}
00299 \textcolor{comment}{     * To get the min score we just use the initial hash value left}
00300 \textcolor{comment}{     * shifted enough to get the 52 bit value. Later we increment the}
00301 \textcolor{comment}{     * 6 bit prefis (see the hash.bits++ statement), and get the new}
00302 \textcolor{comment}{     * prefix: 101011, which we align again to 52 bits to get the maximum}
00303 \textcolor{comment}{     * value (which is excluded from the search). So we get everything}
00304 \textcolor{comment}{     * between the two following scores (represented in binary):}
00305 \textcolor{comment}{     *}
00306 \textcolor{comment}{     * 1010100000000000000000000000000000000000000000000000 (included)}
00307 \textcolor{comment}{     * and}
00308 \textcolor{comment}{     * 1010110000000000000000000000000000000000000000000000 (excluded).}
00309 \textcolor{comment}{     */}
00310     *min = geohashAlign52Bits(hash);
00311     hash.bits++;
00312     *max = geohashAlign52Bits(hash);
00313 \}
00314 
00315 \textcolor{comment}{/* Obtain all members between the min/max of this geohash bounding box.}
00316 \textcolor{comment}{ * Populate a geoArray of GeoPoints by calling geoGetPointsInRange().}
00317 \textcolor{comment}{ * Return the number of points added to the array. */}
00318 \textcolor{keywordtype}{int} membersOfGeoHashBox(robj *zobj, GeoHashBits hash, \hyperlink{structgeoArray}{geoArray} *ga, \textcolor{keywordtype}{double} lon, \textcolor{keywordtype}{double} lat, \textcolor{keywordtype}{
      double} radius) \{
00319     GeoHashFix52Bits min, max;
00320 
00321     scoresOfGeoHashBox(hash,&min,&max);
00322     \textcolor{keywordflow}{return} geoGetPointsInRange(zobj, min, max, lon, lat, radius, ga);
00323 \}
00324 
00325 \textcolor{comment}{/* Search all eight neighbors + self geohash box */}
00326 \textcolor{keywordtype}{int} membersOfAllNeighbors(robj *zobj, GeoHashRadius n, \textcolor{keywordtype}{double} lon, \textcolor{keywordtype}{double} lat, \textcolor{keywordtype}{double} radius, 
      \hyperlink{structgeoArray}{geoArray} *ga) \{
00327     GeoHashBits neighbors[9];
00328     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i, count = 0, last\_processed = 0;
00329     \textcolor{keywordtype}{int} debugmsg = 0;
00330 
00331     neighbors[0] = n.hash;
00332     neighbors[1] = n.neighbors.north;
00333     neighbors[2] = n.neighbors.south;
00334     neighbors[3] = n.neighbors.east;
00335     neighbors[4] = n.neighbors.west;
00336     neighbors[5] = n.neighbors.north\_east;
00337     neighbors[6] = n.neighbors.north\_west;
00338     neighbors[7] = n.neighbors.south\_east;
00339     neighbors[8] = n.neighbors.south\_west;
00340 
00341     \textcolor{comment}{/* For each neighbor (*and* our own hashbox), get all the matching}
00342 \textcolor{comment}{     * members and add them to the potential result list. */}
00343     \textcolor{keywordflow}{for} (i = 0; i < \textcolor{keyword}{sizeof}(neighbors) / \textcolor{keyword}{sizeof}(*neighbors); i++) \{
00344         \textcolor{keywordflow}{if} (\hyperlink{geohash_8h_a097b8152f901ce8d8537f70b7108d9d4}{HASHISZERO}(neighbors[i])) \{
00345             \textcolor{keywordflow}{if} (debugmsg) \hyperlink{debugmacro_8h_a74021f021dcdfbb22891787b79c5529d}{D}(\textcolor{stringliteral}{"neighbors[%d] is zero"},i);
00346             \textcolor{keywordflow}{continue};
00347         \}
00348 
00349         \textcolor{comment}{/* Debugging info. */}
00350         \textcolor{keywordflow}{if} (debugmsg) \{
00351             GeoHashRange long\_range, lat\_range;
00352             geohashGetCoordRange(&long\_range,&lat\_range);
00353             GeoHashArea myarea = \{\{0\}\};
00354             geohashDecode(long\_range, lat\_range, neighbors[i], &myarea);
00355 
00356             \textcolor{comment}{/* Dump center square. */}
00357             \hyperlink{debugmacro_8h_a74021f021dcdfbb22891787b79c5529d}{D}(\textcolor{stringliteral}{"neighbors[%d]:\(\backslash\)n"},i);
00358             \hyperlink{debugmacro_8h_a74021f021dcdfbb22891787b79c5529d}{D}(\textcolor{stringliteral}{"area.longitude.min: %f\(\backslash\)n"}, myarea.longitude.min);
00359             \hyperlink{debugmacro_8h_a74021f021dcdfbb22891787b79c5529d}{D}(\textcolor{stringliteral}{"area.longitude.max: %f\(\backslash\)n"}, myarea.longitude.max);
00360             \hyperlink{debugmacro_8h_a74021f021dcdfbb22891787b79c5529d}{D}(\textcolor{stringliteral}{"area.latitude.min: %f\(\backslash\)n"}, myarea.latitude.min);
00361             \hyperlink{debugmacro_8h_a74021f021dcdfbb22891787b79c5529d}{D}(\textcolor{stringliteral}{"area.latitude.max: %f\(\backslash\)n"}, myarea.latitude.max);
00362             \hyperlink{debugmacro_8h_a74021f021dcdfbb22891787b79c5529d}{D}(\textcolor{stringliteral}{"\(\backslash\)n"});
00363         \}
00364 
00365         \textcolor{comment}{/* When a huge Radius (in the 5000 km range or more) is used,}
00366 \textcolor{comment}{         * adjacent neighbors can be the same, leading to duplicated}
00367 \textcolor{comment}{         * elements. Skip every range which is the same as the one}
00368 \textcolor{comment}{         * processed previously. */}
00369         \textcolor{keywordflow}{if} (last\_processed &&
00370             neighbors[i].bits == neighbors[last\_processed].bits &&
00371             neighbors[i].step == neighbors[last\_processed].step)
00372         \{
00373             \textcolor{keywordflow}{if} (debugmsg)
00374                 \hyperlink{debugmacro_8h_a74021f021dcdfbb22891787b79c5529d}{D}(\textcolor{stringliteral}{"Skipping processing of %d, same as previous\(\backslash\)n"},i);
00375             \textcolor{keywordflow}{continue};
00376         \}
00377         count += membersOfGeoHashBox(zobj, neighbors[i], ga, lon, lat, radius);
00378         last\_processed = i;
00379     \}
00380     \textcolor{keywordflow}{return} count;
00381 \}
00382 
00383 \textcolor{comment}{/* Sort comparators for qsort() */}
00384 \textcolor{keyword}{static} \textcolor{keywordtype}{int} sort\_gp\_asc(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *a, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *b) \{
00385     \textcolor{keyword}{const} \textcolor{keyword}{struct} \hyperlink{structgeoPoint}{geoPoint} *gpa = a, *gpb = b;
00386     \textcolor{comment}{/* We can't do adist - bdist because they are doubles and}
00387 \textcolor{comment}{     * the comparator returns an int. */}
00388     \textcolor{keywordflow}{if} (gpa->dist > gpb->dist)
00389         \textcolor{keywordflow}{return} 1;
00390     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (gpa->dist == gpb->dist)
00391         \textcolor{keywordflow}{return} 0;
00392     \textcolor{keywordflow}{else}
00393         \textcolor{keywordflow}{return} -1;
00394 \}
00395 
00396 \textcolor{keyword}{static} \textcolor{keywordtype}{int} sort\_gp\_desc(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *a, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *b) \{
00397     \textcolor{keywordflow}{return} -sort\_gp\_asc(a, b);
00398 \}
00399 
00400 \textcolor{comment}{/* ====================================================================}
00401 \textcolor{comment}{ * Commands}
00402 \textcolor{comment}{ * ==================================================================== */}
00403 
00404 \textcolor{comment}{/* GEOADD key long lat name [long2 lat2 name2 ... longN latN nameN] */}
00405 \textcolor{keywordtype}{void} geoaddCommand(\hyperlink{structclient}{client} *c) \{
00406     \textcolor{comment}{/* Check arguments number for sanity. */}
00407     \textcolor{keywordflow}{if} ((c->argc - 2) % 3 != 0) \{
00408         \textcolor{comment}{/* Need an odd number of arguments if we got this far... */}
00409         addReplyError(c, \textcolor{stringliteral}{"syntax error. Try GEOADD key [x1] [y1] [name1] "}
00410                          \textcolor{stringliteral}{"[x2] [y2] [name2] ... "});
00411         \textcolor{keywordflow}{return};
00412     \}
00413 
00414     \textcolor{keywordtype}{int} elements = (c->argc - 2) / 3;
00415     \textcolor{keywordtype}{int} argc = 2+elements*2; \textcolor{comment}{/* ZADD key score ele ... */}
00416     robj **argv = zcalloc(argc*\textcolor{keyword}{sizeof}(robj*));
00417     argv[0] = createRawStringObject(\textcolor{stringliteral}{"zadd"},4);
00418     argv[1] = c->argv[1]; \textcolor{comment}{/* key */}
00419     incrRefCount(argv[1]);
00420 
00421     \textcolor{comment}{/* Create the argument vector to call ZADD in order to add all}
00422 \textcolor{comment}{     * the score,value pairs to the requested zset, where score is actually}
00423 \textcolor{comment}{     * an encoded version of lat,long. */}
00424     \textcolor{keywordtype}{int} i;
00425     \textcolor{keywordflow}{for} (i = 0; i < elements; i++) \{
00426         \textcolor{keywordtype}{double} xy[2];
00427 
00428         \textcolor{keywordflow}{if} (extractLongLatOrReply(c, (c->argv+2)+(i*3),xy) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
00429             \textcolor{keywordflow}{for} (i = 0; i < argc; i++)
00430                 \textcolor{keywordflow}{if} (argv[i]) decrRefCount(argv[i]);
00431             zfree(argv);
00432             \textcolor{keywordflow}{return};
00433         \}
00434 
00435         \textcolor{comment}{/* Turn the coordinates into the score of the element. */}
00436         GeoHashBits hash;
00437         geohashEncodeWGS84(xy[0], xy[1], \hyperlink{geohash_8h_a4c2e31e393c541a34939f7b4ae1d23d3}{GEO\_STEP\_MAX}, &hash);
00438         GeoHashFix52Bits bits = geohashAlign52Bits(hash);
00439         robj *score = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING}, sdsfromlonglong(bits));
00440         robj *val = c->argv[2 + i * 3 + 2];
00441         argv[2+i*2] = score;
00442         argv[3+i*2] = val;
00443         incrRefCount(val);
00444     \}
00445 
00446     \textcolor{comment}{/* Finally call ZADD that will do the work for us. */}
00447     replaceClientCommandVector(c,argc,argv);
00448     zaddCommand(c);
00449 \}
00450 
00451 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SORT\_NONE} 0
00452 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SORT\_ASC} 1
00453 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SORT\_DESC} 2
00454 
00455 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{RADIUS\_COORDS} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)}    \textcolor{comment}{/* Search around coordinates. */}
00456 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{RADIUS\_MEMBER} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}1\textcolor{preprocessor}{)}    \textcolor{comment}{/* Search around member. */}
00457 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{RADIUS\_NOSTORE} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}2\textcolor{preprocessor}{)}   \textcolor{comment}{/* Do not acceot STORE/STOREDIST option. */}
00458 
00459 \textcolor{comment}{/* GEORADIUS key x y radius unit [WITHDIST] [WITHHASH] [WITHCOORD] [ASC|DESC]}
00460 \textcolor{comment}{ *                               [COUNT count] [STORE key] [STOREDIST key]}
00461 \textcolor{comment}{ * GEORADIUSBYMEMBER key member radius unit ... options ... */}
00462 \textcolor{keywordtype}{void} georadiusGeneric(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} flags) \{
00463     robj *key = c->argv[1];
00464     robj *storekey = NULL;
00465     \textcolor{keywordtype}{int} storedist = 0; \textcolor{comment}{/* 0 for STORE, 1 for STOREDIST. */}
00466 
00467     \textcolor{comment}{/* Look up the requested zset */}
00468     robj *zobj = NULL;
00469     \textcolor{keywordflow}{if} ((zobj = lookupKeyReadOrReply(c, key, shared.emptymultibulk)) == NULL ||
00470         checkType(c, zobj, \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET})) \{
00471         \textcolor{keywordflow}{return};
00472     \}
00473 
00474     \textcolor{comment}{/* Find long/lat to use for radius search based on inquiry type */}
00475     \textcolor{keywordtype}{int} base\_args;
00476     \textcolor{keywordtype}{double} xy[2] = \{ 0 \};
00477     \textcolor{keywordflow}{if} (flags & \hyperlink{geo_8c_a81d5eea6d1e3b777aa5fb123bc0e02a0}{RADIUS\_COORDS}) \{
00478         base\_args = 6;
00479         \textcolor{keywordflow}{if} (extractLongLatOrReply(c, c->argv + 2, xy) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR})
00480             \textcolor{keywordflow}{return};
00481     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (flags & \hyperlink{geo_8c_ac9a2d1a380b6e56d2c1dabe19085a9ba}{RADIUS\_MEMBER}) \{
00482         base\_args = 5;
00483         robj *member = c->argv[2];
00484         \textcolor{keywordflow}{if} (longLatFromMember(zobj, member, xy) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
00485             addReplyError(c, \textcolor{stringliteral}{"could not decode requested zset member"});
00486             \textcolor{keywordflow}{return};
00487         \}
00488     \} \textcolor{keywordflow}{else} \{
00489         addReplyError(c, \textcolor{stringliteral}{"Unknown georadius search type"});
00490         \textcolor{keywordflow}{return};
00491     \}
00492 
00493     \textcolor{comment}{/* Extract radius and units from arguments */}
00494     \textcolor{keywordtype}{double} radius\_meters = 0, conversion = 1;
00495     \textcolor{keywordflow}{if} ((radius\_meters = extractDistanceOrReply(c, c->argv + base\_args - 2,
00496                                                 &conversion)) < 0) \{
00497         \textcolor{keywordflow}{return};
00498     \}
00499 
00500     \textcolor{comment}{/* Discover and populate all optional parameters. */}
00501     \textcolor{keywordtype}{int} withdist = 0, withhash = 0, withcoords = 0;
00502     \textcolor{keywordtype}{int} sort = \hyperlink{geo_8c_ac14be771411e01611e9e539c87567be4}{SORT\_NONE};
00503     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} count = 0;
00504     \textcolor{keywordflow}{if} (c->argc > base\_args) \{
00505         \textcolor{keywordtype}{int} remaining = c->argc - base\_args;
00506         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < remaining; i++) \{
00507             \textcolor{keywordtype}{char} *arg = c->argv[base\_args + i]->ptr;
00508             \textcolor{keywordflow}{if} (!strcasecmp(arg, \textcolor{stringliteral}{"withdist"})) \{
00509                 withdist = 1;
00510             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(arg, \textcolor{stringliteral}{"withhash"})) \{
00511                 withhash = 1;
00512             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(arg, \textcolor{stringliteral}{"withcoord"})) \{
00513                 withcoords = 1;
00514             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(arg, \textcolor{stringliteral}{"asc"})) \{
00515                 sort = \hyperlink{geo_8c_a4cc2ef7982bc374e2ba1832ace8338b7}{SORT\_ASC};
00516             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(arg, \textcolor{stringliteral}{"desc"})) \{
00517                 sort = \hyperlink{geo_8c_ad337a9ccff0b910f5a05d97cb5f3231e}{SORT\_DESC};
00518             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(arg, \textcolor{stringliteral}{"count"}) && (i+1) < remaining) \{
00519                 \textcolor{keywordflow}{if} (getLongLongFromObjectOrReply(c, c->argv[base\_args+i+1],
00520                     &count, NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \textcolor{keywordflow}{return};
00521                 \textcolor{keywordflow}{if} (count <= 0) \{
00522                     addReplyError(c,\textcolor{stringliteral}{"COUNT must be > 0"});
00523                     \textcolor{keywordflow}{return};
00524                 \}
00525                 i++;
00526             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(arg, \textcolor{stringliteral}{"store"}) &&
00527                        (i+1) < remaining &&
00528                        !(flags & \hyperlink{geo_8c_a0207f8145c258dfb559a8c0a1c960a2c}{RADIUS\_NOSTORE}))
00529             \{
00530                 storekey = c->argv[base\_args+i+1];
00531                 storedist = 0;
00532                 i++;
00533             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(arg, \textcolor{stringliteral}{"storedist"}) &&
00534                        (i+1) < remaining &&
00535                        !(flags & \hyperlink{geo_8c_a0207f8145c258dfb559a8c0a1c960a2c}{RADIUS\_NOSTORE}))
00536             \{
00537                 storekey = c->argv[base\_args+i+1];
00538                 storedist = 1;
00539                 i++;
00540             \} \textcolor{keywordflow}{else} \{
00541                 addReply(c, shared.syntaxerr);
00542                 \textcolor{keywordflow}{return};
00543             \}
00544         \}
00545     \}
00546 
00547     \textcolor{comment}{/* Trap options not compatible with STORE and STOREDIST. */}
00548     \textcolor{keywordflow}{if} (storekey && (withdist || withhash || withcoords)) \{
00549         addReplyError(c,
00550             \textcolor{stringliteral}{"STORE option in GEORADIUS is not compatible with "}
00551             \textcolor{stringliteral}{"WITHDIST, WITHHASH and WITHCOORDS options"});
00552         \textcolor{keywordflow}{return};
00553     \}
00554 
00555     \textcolor{comment}{/* COUNT without ordering does not make much sense, force ASC}
00556 \textcolor{comment}{     * ordering if COUNT was specified but no sorting was requested. */}
00557     \textcolor{keywordflow}{if} (count != 0 && sort == \hyperlink{geo_8c_ac14be771411e01611e9e539c87567be4}{SORT\_NONE}) sort = \hyperlink{geo_8c_a4cc2ef7982bc374e2ba1832ace8338b7}{SORT\_ASC};
00558 
00559     \textcolor{comment}{/* Get all neighbor geohash boxes for our radius search */}
00560     GeoHashRadius georadius =
00561         geohashGetAreasByRadiusWGS84(xy[0], xy[1], radius\_meters);
00562 
00563     \textcolor{comment}{/* Search the zset for all matching points */}
00564     \hyperlink{structgeoArray}{geoArray} *ga = geoArrayCreate();
00565     membersOfAllNeighbors(zobj, georadius, xy[0], xy[1], radius\_meters, ga);
00566 
00567     \textcolor{comment}{/* If no matching results, the user gets an empty reply. */}
00568     \textcolor{keywordflow}{if} (ga->used == 0 && storekey == NULL) \{
00569         addReply(c, shared.emptymultibulk);
00570         geoArrayFree(ga);
00571         \textcolor{keywordflow}{return};
00572     \}
00573 
00574     \textcolor{keywordtype}{long} result\_length = ga->used;
00575     \textcolor{keywordtype}{long} returned\_items = (count == 0 || result\_length < count) ?
00576                           result\_length : count;
00577     \textcolor{keywordtype}{long} option\_length = 0;
00578 
00579     \textcolor{comment}{/* Process [optional] requested sorting */}
00580     \textcolor{keywordflow}{if} (sort == \hyperlink{geo_8c_a4cc2ef7982bc374e2ba1832ace8338b7}{SORT\_ASC}) \{
00581         qsort(ga->array, result\_length, \textcolor{keyword}{sizeof}(geoPoint), sort\_gp\_asc);
00582     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (sort == \hyperlink{geo_8c_ad337a9ccff0b910f5a05d97cb5f3231e}{SORT\_DESC}) \{
00583         qsort(ga->array, result\_length, \textcolor{keyword}{sizeof}(geoPoint), sort\_gp\_desc);
00584     \}
00585 
00586     \textcolor{keywordflow}{if} (storekey == NULL) \{
00587         \textcolor{comment}{/* No target key, return results to user. */}
00588 
00589         \textcolor{comment}{/* Our options are self-contained nested multibulk replies, so we}
00590 \textcolor{comment}{         * only need to track how many of those nested replies we return. */}
00591         \textcolor{keywordflow}{if} (withdist)
00592             option\_length++;
00593 
00594         \textcolor{keywordflow}{if} (withcoords)
00595             option\_length++;
00596 
00597         \textcolor{keywordflow}{if} (withhash)
00598             option\_length++;
00599 
00600         \textcolor{comment}{/* The multibulk len we send is exactly result\_length. The result is}
00601 \textcolor{comment}{         * either all strings of just zset members  *or* a nested multi-bulk}
00602 \textcolor{comment}{         * reply containing the zset member string \_and\_ all the additional}
00603 \textcolor{comment}{         * options the user enabled for this request. */}
00604         addReplyMultiBulkLen(c, returned\_items);
00605 
00606         \textcolor{comment}{/* Finally send results back to the caller */}
00607         \textcolor{keywordtype}{int} i;
00608         \textcolor{keywordflow}{for} (i = 0; i < returned\_items; i++) \{
00609             geoPoint *gp = ga->array+i;
00610             gp->dist /= conversion; \textcolor{comment}{/* Fix according to unit. */}
00611 
00612             \textcolor{comment}{/* If we have options in option\_length, return each sub-result}
00613 \textcolor{comment}{             * as a nested multi-bulk.  Add 1 to account for result value}
00614 \textcolor{comment}{             * itself. */}
00615             \textcolor{keywordflow}{if} (option\_length)
00616                 addReplyMultiBulkLen(c, option\_length + 1);
00617 
00618             addReplyBulkSds(c,gp->member);
00619             gp->member = NULL;
00620 
00621             \textcolor{keywordflow}{if} (withdist)
00622                 addReplyDoubleDistance(c, gp->dist);
00623 
00624             \textcolor{keywordflow}{if} (withhash)
00625                 addReplyLongLong(c, gp->score);
00626 
00627             \textcolor{keywordflow}{if} (withcoords) \{
00628                 addReplyMultiBulkLen(c, 2);
00629                 addReplyHumanLongDouble(c, gp->longitude);
00630                 addReplyHumanLongDouble(c, gp->latitude);
00631             \}
00632         \}
00633     \} \textcolor{keywordflow}{else} \{
00634         \textcolor{comment}{/* Target key, create a sorted set with the results. */}
00635         robj *zobj;
00636         zset *zs;
00637         \textcolor{keywordtype}{int} i;
00638         size\_t maxelelen = 0;
00639 
00640         \textcolor{keywordflow}{if} (returned\_items) \{
00641             zobj = createZsetObject();
00642             zs = zobj->ptr;
00643         \}
00644 
00645         \textcolor{keywordflow}{for} (i = 0; i < returned\_items; i++) \{
00646             zskiplistNode *znode;
00647             geoPoint *gp = ga->array+i;
00648             gp->dist /= conversion; \textcolor{comment}{/* Fix according to unit. */}
00649             \textcolor{keywordtype}{double} score = storedist ? gp->dist : gp->score;
00650             size\_t elelen = sdslen(gp->member);
00651 
00652             \textcolor{keywordflow}{if} (maxelelen < elelen) maxelelen = elelen;
00653             znode = zslInsert(zs->zsl,score,gp->member);
00654             \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(dictAdd(zs->dict,gp->member,&znode->score) == 
      \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK});
00655             gp->member = NULL;
00656         \}
00657 
00658         \textcolor{keywordflow}{if} (returned\_items) \{
00659             zsetConvertToZiplistIfNeeded(zobj,maxelelen);
00660             setKey(c->db,storekey,zobj);
00661             decrRefCount(zobj);
00662             notifyKeyspaceEvent(\hyperlink{server_8h_a1c0b64c84b0e66dff3554ffe3e2ec4c8}{NOTIFY\_LIST},\textcolor{stringliteral}{"georadiusstore"},storekey,
00663                                 c->db->id);
00664             server.dirty += returned\_items;
00665         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (dbDelete(c->db,storekey)) \{
00666             signalModifiedKey(c->db,storekey);
00667             notifyKeyspaceEvent(\hyperlink{server_8h_a9fa53dd1068e62365f3964ad3479eec2}{NOTIFY\_GENERIC},\textcolor{stringliteral}{"del"},storekey,c->db->id);
00668             server.dirty++;
00669         \}
00670         addReplyLongLong(c, returned\_items);
00671     \}
00672     geoArrayFree(ga);
00673 \}
00674 
00675 \textcolor{comment}{/* GEORADIUS wrapper function. */}
00676 \textcolor{keywordtype}{void} georadiusCommand(\hyperlink{structclient}{client} *c) \{
00677     georadiusGeneric(c, \hyperlink{geo_8c_a81d5eea6d1e3b777aa5fb123bc0e02a0}{RADIUS\_COORDS});
00678 \}
00679 
00680 \textcolor{comment}{/* GEORADIUSBYMEMBER wrapper function. */}
00681 \textcolor{keywordtype}{void} georadiusbymemberCommand(\hyperlink{structclient}{client} *c) \{
00682     georadiusGeneric(c, \hyperlink{geo_8c_ac9a2d1a380b6e56d2c1dabe19085a9ba}{RADIUS\_MEMBER});
00683 \}
00684 
00685 \textcolor{comment}{/* GEORADIUS\_RO wrapper function. */}
00686 \textcolor{keywordtype}{void} georadiusroCommand(\hyperlink{structclient}{client} *c) \{
00687     georadiusGeneric(c, \hyperlink{geo_8c_a81d5eea6d1e3b777aa5fb123bc0e02a0}{RADIUS\_COORDS}|\hyperlink{geo_8c_a0207f8145c258dfb559a8c0a1c960a2c}{RADIUS\_NOSTORE});
00688 \}
00689 
00690 \textcolor{comment}{/* GEORADIUSBYMEMBER\_RO wrapper function. */}
00691 \textcolor{keywordtype}{void} georadiusbymemberroCommand(\hyperlink{structclient}{client} *c) \{
00692     georadiusGeneric(c, \hyperlink{geo_8c_ac9a2d1a380b6e56d2c1dabe19085a9ba}{RADIUS\_MEMBER}|\hyperlink{geo_8c_a0207f8145c258dfb559a8c0a1c960a2c}{RADIUS\_NOSTORE});
00693 \}
00694 
00695 \textcolor{comment}{/* GEOHASH key ele1 ele2 ... eleN}
00696 \textcolor{comment}{ *}
00697 \textcolor{comment}{ * Returns an array with an 11 characters geohash representation of the}
00698 \textcolor{comment}{ * position of the specified elements. */}
00699 \textcolor{keywordtype}{void} geohashCommand(\hyperlink{structclient}{client} *c) \{
00700     \textcolor{keywordtype}{char} *geoalphabet= \textcolor{stringliteral}{"0123456789bcdefghjkmnpqrstuvwxyz"};
00701     \textcolor{keywordtype}{int} j;
00702 
00703     \textcolor{comment}{/* Look up the requested zset */}
00704     robj *zobj = lookupKeyRead(c->db, c->argv[1]);
00705     \textcolor{keywordflow}{if} (zobj && checkType(c, zobj, \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET})) \textcolor{keywordflow}{return};
00706 
00707     \textcolor{comment}{/* Geohash elements one after the other, using a null bulk reply for}
00708 \textcolor{comment}{     * missing elements. */}
00709     addReplyMultiBulkLen(c,c->argc-2);
00710     \textcolor{keywordflow}{for} (j = 2; j < c->argc; j++) \{
00711         \textcolor{keywordtype}{double} score;
00712         \textcolor{keywordflow}{if} (!zobj || zsetScore(zobj, c->argv[j]->ptr, &score) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
00713             addReply(c,shared.nullbulk);
00714         \} \textcolor{keywordflow}{else} \{
00715             \textcolor{comment}{/* The internal format we use for geocoding is a bit different}
00716 \textcolor{comment}{             * than the standard, since we use as initial latitude range}
00717 \textcolor{comment}{             * -85,85, while the normal geohashing algorithm uses -90,90.}
00718 \textcolor{comment}{             * So we have to decode our position and re-encode using the}
00719 \textcolor{comment}{             * standard ranges in order to output a valid geohash string. */}
00720 
00721             \textcolor{comment}{/* Decode... */}
00722             \textcolor{keywordtype}{double} xy[2];
00723             \textcolor{keywordflow}{if} (!decodeGeohash(score,xy)) \{
00724                 addReply(c,shared.nullbulk);
00725                 \textcolor{keywordflow}{continue};
00726             \}
00727 
00728             \textcolor{comment}{/* Re-encode */}
00729             GeoHashRange r[2];
00730             GeoHashBits hash;
00731             r[0].min = -180;
00732             r[0].max = 180;
00733             r[1].min = -90;
00734             r[1].max = 90;
00735             geohashEncode(&r[0],&r[1],xy[0],xy[1],26,&hash);
00736 
00737             \textcolor{keywordtype}{char} buf[12];
00738             \textcolor{keywordtype}{int} i;
00739             \textcolor{keywordflow}{for} (i = 0; i < 11; i++) \{
00740                 \textcolor{keywordtype}{int} idx = (hash.bits >> (52-((i+1)*5))) & 0x1f;
00741                 buf[i] = geoalphabet[idx];
00742             \}
00743             buf[11] = \textcolor{stringliteral}{'\(\backslash\)0'};
00744             addReplyBulkCBuffer(c,buf,11);
00745         \}
00746     \}
00747 \}
00748 
00749 \textcolor{comment}{/* GEOPOS key ele1 ele2 ... eleN}
00750 \textcolor{comment}{ *}
00751 \textcolor{comment}{ * Returns an array of two-items arrays representing the x,y position of each}
00752 \textcolor{comment}{ * element specified in the arguments. For missing elements NULL is returned. */}
00753 \textcolor{keywordtype}{void} geoposCommand(\hyperlink{structclient}{client} *c) \{
00754     \textcolor{keywordtype}{int} j;
00755 
00756     \textcolor{comment}{/* Look up the requested zset */}
00757     robj *zobj = lookupKeyRead(c->db, c->argv[1]);
00758     \textcolor{keywordflow}{if} (zobj && checkType(c, zobj, \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET})) \textcolor{keywordflow}{return};
00759 
00760     \textcolor{comment}{/* Report elements one after the other, using a null bulk reply for}
00761 \textcolor{comment}{     * missing elements. */}
00762     addReplyMultiBulkLen(c,c->argc-2);
00763     \textcolor{keywordflow}{for} (j = 2; j < c->argc; j++) \{
00764         \textcolor{keywordtype}{double} score;
00765         \textcolor{keywordflow}{if} (!zobj || zsetScore(zobj, c->argv[j]->ptr, &score) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
00766             addReply(c,shared.nullmultibulk);
00767         \} \textcolor{keywordflow}{else} \{
00768             \textcolor{comment}{/* Decode... */}
00769             \textcolor{keywordtype}{double} xy[2];
00770             \textcolor{keywordflow}{if} (!decodeGeohash(score,xy)) \{
00771                 addReply(c,shared.nullmultibulk);
00772                 \textcolor{keywordflow}{continue};
00773             \}
00774             addReplyMultiBulkLen(c,2);
00775             addReplyHumanLongDouble(c,xy[0]);
00776             addReplyHumanLongDouble(c,xy[1]);
00777         \}
00778     \}
00779 \}
00780 
00781 \textcolor{comment}{/* GEODIST key ele1 ele2 [unit]}
00782 \textcolor{comment}{ *}
00783 \textcolor{comment}{ * Return the distance, in meters by default, otherwise accordig to "unit",}
00784 \textcolor{comment}{ * between points ele1 and ele2. If one or more elements are missing NULL}
00785 \textcolor{comment}{ * is returned. */}
00786 \textcolor{keywordtype}{void} geodistCommand(\hyperlink{structclient}{client} *c) \{
00787     \textcolor{keywordtype}{double} to\_meter = 1;
00788 
00789     \textcolor{comment}{/* Check if there is the unit to extract, otherwise assume meters. */}
00790     \textcolor{keywordflow}{if} (c->argc == 5) \{
00791         to\_meter = extractUnitOrReply(c,c->argv[4]);
00792         \textcolor{keywordflow}{if} (to\_meter < 0) \textcolor{keywordflow}{return};
00793     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->argc > 5) \{
00794         addReply(c,shared.syntaxerr);
00795         \textcolor{keywordflow}{return};
00796     \}
00797 
00798     \textcolor{comment}{/* Look up the requested zset */}
00799     robj *zobj = NULL;
00800     \textcolor{keywordflow}{if} ((zobj = lookupKeyReadOrReply(c, c->argv[1], shared.nullbulk))
00801         == NULL || checkType(c, zobj, \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET})) \textcolor{keywordflow}{return};
00802 
00803     \textcolor{comment}{/* Get the scores. We need both otherwise NULL is returned. */}
00804     \textcolor{keywordtype}{double} score1, score2, xyxy[4];
00805     \textcolor{keywordflow}{if} (zsetScore(zobj, c->argv[2]->ptr, &score1) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR} ||
00806         zsetScore(zobj, c->argv[3]->ptr, &score2) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR})
00807     \{
00808         addReply(c,shared.nullbulk);
00809         \textcolor{keywordflow}{return};
00810     \}
00811 
00812     \textcolor{comment}{/* Decode & compute the distance. */}
00813     \textcolor{keywordflow}{if} (!decodeGeohash(score1,xyxy) || !decodeGeohash(score2,xyxy+2))
00814         addReply(c,shared.nullbulk);
00815     \textcolor{keywordflow}{else}
00816         addReplyDoubleDistance(c,
00817             geohashGetDistance(xyxy[0],xyxy[1],xyxy[2],xyxy[3]) / to\_meter);
00818 \}
\end{DoxyCode}
