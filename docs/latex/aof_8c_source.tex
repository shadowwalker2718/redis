\hypertarget{aof_8c_source}{}\section{aof.\+c}
\label{aof_8c_source}\index{src/aof.\+c@{src/aof.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>}
00003 \textcolor{comment}{ * All rights reserved.}
00004 \textcolor{comment}{ *}
00005 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00006 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00007 \textcolor{comment}{ *}
00008 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00009 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00010 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00011 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00012 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00013 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00014 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00015 \textcolor{comment}{ *     specific prior written permission.}
00016 \textcolor{comment}{ *}
00017 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00018 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00019 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00020 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00021 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00022 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00023 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00024 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00025 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00026 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00027 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00028 \textcolor{comment}{ */}
00029 
00030 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{server_8h}{"server.h"}
00031 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{bio_8h}{"bio.h"}
00032 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{rio_8h}{"rio.h"}
00033 
00034 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{signal}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00035 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{fcntl}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00036 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{stat}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00037 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{types}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00038 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{time}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00039 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{resource}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00040 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{wait}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00041 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{param}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00042 
00043 \textcolor{keywordtype}{void} aofUpdateCurrentSize(\textcolor{keywordtype}{void});
00044 \textcolor{keywordtype}{void} aofClosePipes(\textcolor{keywordtype}{void});
00045 
00046 \textcolor{comment}{/* ----------------------------------------------------------------------------}
00047 \textcolor{comment}{ * AOF rewrite buffer implementation.}
00048 \textcolor{comment}{ *}
00049 \textcolor{comment}{ * The following code implement a simple buffer used in order to accumulate}
00050 \textcolor{comment}{ * changes while the background process is rewriting the AOF file.}
00051 \textcolor{comment}{ *}
00052 \textcolor{comment}{ * We only need to append, but can't just use realloc with a large block}
00053 \textcolor{comment}{ * because 'huge' reallocs are not always handled as one could expect}
00054 \textcolor{comment}{ * (via remapping of pages at OS level) but may involve copying data.}
00055 \textcolor{comment}{ *}
00056 \textcolor{comment}{ * For this reason we use a list of blocks, every block is}
00057 \textcolor{comment}{ * AOF\_RW\_BUF\_BLOCK\_SIZE bytes.}
00058 \textcolor{comment}{ * ------------------------------------------------------------------------- */}
00059 
00060 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{AOF\_RW\_BUF\_BLOCK\_SIZE} \textcolor{preprocessor}{(}1024\textcolor{preprocessor}{*}1024\textcolor{preprocessor}{*}10\textcolor{preprocessor}{)}    \textcolor{comment}{/* 10 MB per block */}
00061 
\Hypertarget{aof_8c_source_l00062}\hyperlink{structaofrwblock}{00062} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structaofrwblock}{aofrwblock} \{
00063     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} used, free;
00064     \textcolor{keywordtype}{char} buf[\hyperlink{aof_8c_a44139ff5d81f229e77d843b17ada505e}{AOF\_RW\_BUF\_BLOCK\_SIZE}];
00065 \} aofrwblock;
00066 
00067 \textcolor{comment}{/* This function free the old AOF rewrite buffer if needed, and initialize}
00068 \textcolor{comment}{ * a fresh new one. It tests for server.aof\_rewrite\_buf\_blocks equal to NULL}
00069 \textcolor{comment}{ * so can be used for the first initialization as well. */}
00070 \textcolor{keywordtype}{void} aofRewriteBufferReset(\textcolor{keywordtype}{void}) \{
00071     \textcolor{keywordflow}{if} (server.aof\_rewrite\_buf\_blocks)
00072         listRelease(server.aof\_rewrite\_buf\_blocks);
00073 
00074     server.aof\_rewrite\_buf\_blocks = listCreate();
00075     \hyperlink{adlist_8h_a648e4a2d20decff3182a72a608b0b8f2}{listSetFreeMethod}(server.aof\_rewrite\_buf\_blocks,zfree);
00076 \}
00077 
00078 \textcolor{comment}{/* Return the current size of the AOF rewrite buffer. */}
00079 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} aofRewriteBufferSize(\textcolor{keywordtype}{void}) \{
00080     listNode *ln;
00081     listIter li;
00082     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} size = 0;
00083 
00084     listRewind(server.aof\_rewrite\_buf\_blocks,&li);
00085     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
00086         aofrwblock *block = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
00087         size += block->used;
00088     \}
00089     \textcolor{keywordflow}{return} size;
00090 \}
00091 
00092 \textcolor{comment}{/* Event handler used to send data to the child process doing the AOF}
00093 \textcolor{comment}{ * rewrite. We send pieces of our AOF differences buffer so that the final}
00094 \textcolor{comment}{ * write when the child finishes the rewrite will be small. */}
00095 \textcolor{keywordtype}{void} aofChildWriteDiffData(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask) \{
00096     listNode *ln;
00097     aofrwblock *block;
00098     ssize\_t nwritten;
00099     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(el);
00100     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(fd);
00101     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(privdata);
00102     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(mask);
00103 
00104     \textcolor{keywordflow}{while}(1) \{
00105         ln = \hyperlink{adlist_8h_aa8dc514bbe217bb2e87c1c77cfa84690}{listFirst}(server.aof\_rewrite\_buf\_blocks);
00106         block = ln ? ln->value : NULL;
00107         \textcolor{keywordflow}{if} (server.aof\_stop\_sending\_diff || !block) \{
00108             aeDeleteFileEvent(server.el,server.aof\_pipe\_write\_data\_to\_child,
00109                               \hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE});
00110             \textcolor{keywordflow}{return};
00111         \}
00112         \textcolor{keywordflow}{if} (block->used > 0) \{
00113             nwritten = write(server.aof\_pipe\_write\_data\_to\_child,
00114                              block->buf,block->used);
00115             \textcolor{keywordflow}{if} (nwritten <= 0) \textcolor{keywordflow}{return};
00116             memmove(block->buf,block->buf+nwritten,block->used-nwritten);
00117             block->used -= nwritten;
00118             block->free += nwritten;
00119         \}
00120         \textcolor{keywordflow}{if} (block->used == 0) listDelNode(server.aof\_rewrite\_buf\_blocks,ln);
00121     \}
00122 \}
00123 
00124 \textcolor{comment}{/* Append data to the AOF rewrite buffer, allocating new blocks if needed. */}
00125 \textcolor{keywordtype}{void} aofRewriteBufferAppend(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *s, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} len) \{
00126     listNode *ln = \hyperlink{adlist_8h_a5e0fad60032ef0fe9adcf9811e2f2fba}{listLast}(server.aof\_rewrite\_buf\_blocks);
00127     aofrwblock *block = ln ? ln->value : NULL;
00128 
00129     \textcolor{keywordflow}{while}(len) \{
00130         \textcolor{comment}{/* If we already got at least an allocated block, try appending}
00131 \textcolor{comment}{         * at least some piece into it. */}
00132         \textcolor{keywordflow}{if} (block) \{
00133             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} thislen = (block->free < len) ? block->free : len;
00134             \textcolor{keywordflow}{if} (thislen) \{  \textcolor{comment}{/* The current block is not already full. */}
00135                 memcpy(block->buf+block->used, s, thislen);
00136                 block->used += thislen;
00137                 block->free -= thislen;
00138                 s += thislen;
00139                 len -= thislen;
00140             \}
00141         \}
00142 
00143         \textcolor{keywordflow}{if} (len) \{ \textcolor{comment}{/* First block to allocate, or need another block. */}
00144             \textcolor{keywordtype}{int} numblocks;
00145 
00146             block = zmalloc(\textcolor{keyword}{sizeof}(*block));
00147             block->free = \hyperlink{aof_8c_a44139ff5d81f229e77d843b17ada505e}{AOF\_RW\_BUF\_BLOCK\_SIZE};
00148             block->used = 0;
00149             listAddNodeTail(server.aof\_rewrite\_buf\_blocks,block);
00150 
00151             \textcolor{comment}{/* Log every time we cross more 10 or 100 blocks, respectively}
00152 \textcolor{comment}{             * as a notice or warning. */}
00153             numblocks = \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.aof\_rewrite\_buf\_blocks);
00154             \textcolor{keywordflow}{if} (((numblocks+1) % 10) == 0) \{
00155                 \textcolor{keywordtype}{int} level = ((numblocks+1) % 100) == 0 ? \hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING} :
00156                                                          \hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE};
00157                 serverLog(level,\textcolor{stringliteral}{"Background AOF buffer size: %lu MB"},
00158                     aofRewriteBufferSize()/(1024*1024));
00159             \}
00160         \}
00161     \}
00162 
00163     \textcolor{comment}{/* Install a file event to send data to the rewrite child if there is}
00164 \textcolor{comment}{     * not one already. */}
00165     \textcolor{keywordflow}{if} (aeGetFileEvents(server.el,server.aof\_pipe\_write\_data\_to\_child) == 0) \{
00166         aeCreateFileEvent(server.el, server.aof\_pipe\_write\_data\_to\_child,
00167             \hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE}, aofChildWriteDiffData, NULL);
00168     \}
00169 \}
00170 
00171 \textcolor{comment}{/* Write the buffer (possibly composed of multiple blocks) into the specified}
00172 \textcolor{comment}{ * fd. If a short write or any other error happens -1 is returned,}
00173 \textcolor{comment}{ * otherwise the number of bytes written is returned. */}
00174 ssize\_t aofRewriteBufferWrite(\textcolor{keywordtype}{int} fd) \{
00175     listNode *ln;
00176     listIter li;
00177     ssize\_t count = 0;
00178 
00179     listRewind(server.aof\_rewrite\_buf\_blocks,&li);
00180     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
00181         aofrwblock *block = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
00182         ssize\_t nwritten;
00183 
00184         \textcolor{keywordflow}{if} (block->used) \{
00185             nwritten = write(fd,block->buf,block->used);
00186             \textcolor{keywordflow}{if} (nwritten != (ssize\_t)block->used) \{
00187                 \textcolor{keywordflow}{if} (nwritten == 0) errno = EIO;
00188                 \textcolor{keywordflow}{return} -1;
00189             \}
00190             count += nwritten;
00191         \}
00192     \}
00193     \textcolor{keywordflow}{return} count;
00194 \}
00195 
00196 \textcolor{comment}{/* ----------------------------------------------------------------------------}
00197 \textcolor{comment}{ * AOF file implementation}
00198 \textcolor{comment}{ * ------------------------------------------------------------------------- */}
00199 
00200 \textcolor{comment}{/* Starts a background task that performs fsync() against the specified}
00201 \textcolor{comment}{ * file descriptor (the one of the AOF file) in another thread. */}
00202 \textcolor{keywordtype}{void} aof\_background\_fsync(\textcolor{keywordtype}{int} fd) \{
00203     bioCreateBackgroundJob(\hyperlink{bio_8h_a5d03c967316addafc61b7ed5d957984f}{BIO\_AOF\_FSYNC},(\textcolor{keywordtype}{void}*)(\textcolor{keywordtype}{long})fd,NULL,NULL);
00204 \}
00205 
00206 \textcolor{comment}{/* Called when the user switches from "appendonly yes" to "appendonly no"}
00207 \textcolor{comment}{ * at runtime using the CONFIG command. */}
00208 \textcolor{keywordtype}{void} stopAppendOnly(\textcolor{keywordtype}{void}) \{
00209     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(server.aof\_state != \hyperlink{server_8h_a5226306fbcebcb6d5d02e0fef3c213c2}{AOF\_OFF});
00210     flushAppendOnlyFile(1);
00211     \hyperlink{config_8h_af5994c643c434574580bb7816af82cad}{aof\_fsync}(server.aof\_fd);
00212     close(server.aof\_fd);
00213 
00214     server.aof\_fd = -1;
00215     server.aof\_selected\_db = -1;
00216     server.aof\_state = \hyperlink{server_8h_a5226306fbcebcb6d5d02e0fef3c213c2}{AOF\_OFF};
00217     \textcolor{comment}{/* rewrite operation in progress? kill it, wait child exit */}
00218     \textcolor{keywordflow}{if} (server.aof\_child\_pid != -1) \{
00219         \textcolor{keywordtype}{int} statloc;
00220 
00221         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Killing running AOF rewrite child: %ld"},
00222             (\textcolor{keywordtype}{long}) server.aof\_child\_pid);
00223         \textcolor{keywordflow}{if} (kill(server.aof\_child\_pid,SIGUSR1) != -1) \{
00224             \textcolor{keywordflow}{while}(wait3(&statloc,0,NULL) != server.aof\_child\_pid);
00225         \}
00226         \textcolor{comment}{/* reset the buffer accumulating changes while the child saves */}
00227         aofRewriteBufferReset();
00228         aofRemoveTempFile(server.aof\_child\_pid);
00229         server.aof\_child\_pid = -1;
00230         server.aof\_rewrite\_time\_start = -1;
00231         \textcolor{comment}{/* close pipes used for IPC between the two processes. */}
00232         aofClosePipes();
00233     \}
00234 \}
00235 
00236 \textcolor{comment}{/* Called when the user switches from "appendonly no" to "appendonly yes"}
00237 \textcolor{comment}{ * at runtime using the CONFIG command. */}
00238 \textcolor{keywordtype}{int} startAppendOnly(\textcolor{keywordtype}{void}) \{
00239     \textcolor{keywordtype}{char} cwd[MAXPATHLEN]; \textcolor{comment}{/* Current working dir path for error messages. */}
00240     \textcolor{keywordtype}{int} newfd;
00241 
00242     newfd = open(server.aof\_filename,O\_WRONLY|O\_APPEND|O\_CREAT,0644);
00243     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(server.aof\_state == \hyperlink{server_8h_a5226306fbcebcb6d5d02e0fef3c213c2}{AOF\_OFF});
00244     \textcolor{keywordflow}{if} (newfd == -1) \{
00245         \textcolor{keywordtype}{char} *cwdp = getcwd(cwd,MAXPATHLEN);
00246 
00247         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
00248             \textcolor{stringliteral}{"Redis needs to enable the AOF but can't open the "}
00249             \textcolor{stringliteral}{"append only file %s (in server root dir %s): %s"},
00250             server.aof\_filename,
00251             cwdp ? cwdp : \textcolor{stringliteral}{"unknown"},
00252             strerror(errno));
00253         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00254     \}
00255     \textcolor{keywordflow}{if} (server.rdb\_child\_pid != -1) \{
00256         server.aof\_rewrite\_scheduled = 1;
00257         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"AOF was enabled but there is already a child process saving an
       RDB file on disk. An AOF background was scheduled to start when possible."});
00258     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rewriteAppendOnlyFileBackground() == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
00259         close(newfd);
00260         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Redis needs to enable the AOF but can't trigger a background
       AOF rewrite operation. Check the above logs for more info about the error."});
00261         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00262     \}
00263     \textcolor{comment}{/* We correctly switched on AOF, now wait for the rewrite to be complete}
00264 \textcolor{comment}{     * in order to append data on disk. */}
00265     server.aof\_state = \hyperlink{server_8h_a7d4b86c89be4d951fbf048130431a16a}{AOF\_WAIT\_REWRITE};
00266     server.aof\_last\_fsync = server.unixtime;
00267     server.aof\_fd = newfd;
00268     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00269 \}
00270 
00271 \textcolor{comment}{/* This is a wrapper to the write syscall in order to retry on short writes}
00272 \textcolor{comment}{ * or if the syscall gets interrupted. It could look strange that we retry}
00273 \textcolor{comment}{ * on short writes given that we are writing to a block device: normally if}
00274 \textcolor{comment}{ * the first call is short, there is a end-of-space condition, so the next}
00275 \textcolor{comment}{ * is likely to fail. However apparently in modern systems this is no longer}
00276 \textcolor{comment}{ * true, and in general it looks just more resilient to retry the write. If}
00277 \textcolor{comment}{ * there is an actual error condition we'll get it at the next try. */}
00278 ssize\_t aofWrite(\textcolor{keywordtype}{int} fd, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *buf, size\_t len) \{
00279     ssize\_t nwritten = 0, totwritten = 0;
00280 
00281     \textcolor{keywordflow}{while}(len) \{
00282         nwritten = write(fd, buf, len);
00283 
00284         \textcolor{keywordflow}{if} (nwritten < 0) \{
00285             \textcolor{keywordflow}{if} (errno == EINTR) \{
00286                 \textcolor{keywordflow}{continue};
00287             \}
00288             \textcolor{keywordflow}{return} totwritten ? totwritten : -1;
00289         \}
00290 
00291         len -= nwritten;
00292         buf += nwritten;
00293         totwritten += nwritten;
00294     \}
00295 
00296     \textcolor{keywordflow}{return} totwritten;
00297 \}
00298 
00299 \textcolor{comment}{/* Write the append only file buffer on disk.}
00300 \textcolor{comment}{ *}
00301 \textcolor{comment}{ * Since we are required to write the AOF before replying to the client,}
00302 \textcolor{comment}{ * and the only way the client socket can get a write is entering when the}
00303 \textcolor{comment}{ * the event loop, we accumulate all the AOF writes in a memory}
00304 \textcolor{comment}{ * buffer and write it on disk using this function just before entering}
00305 \textcolor{comment}{ * the event loop again.}
00306 \textcolor{comment}{ *}
00307 \textcolor{comment}{ * About the 'force' argument:}
00308 \textcolor{comment}{ *}
00309 \textcolor{comment}{ * When the fsync policy is set to 'everysec' we may delay the flush if there}
00310 \textcolor{comment}{ * is still an fsync() going on in the background thread, since for instance}
00311 \textcolor{comment}{ * on Linux write(2) will be blocked by the background fsync anyway.}
00312 \textcolor{comment}{ * When this happens we remember that there is some aof buffer to be}
00313 \textcolor{comment}{ * flushed ASAP, and will try to do that in the serverCron() function.}
00314 \textcolor{comment}{ *}
00315 \textcolor{comment}{ * However if force is set to 1 we'll write regardless of the background}
00316 \textcolor{comment}{ * fsync. */}
00317 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{AOF\_WRITE\_LOG\_ERROR\_RATE} 30 \textcolor{comment}{/* Seconds between errors logging. */}
00318 \textcolor{keywordtype}{void} flushAppendOnlyFile(\textcolor{keywordtype}{int} force) \{
00319     ssize\_t nwritten;
00320     \textcolor{keywordtype}{int} sync\_in\_progress = 0;
00321     mstime\_t latency;
00322 
00323     \textcolor{keywordflow}{if} (sdslen(server.aof\_buf) == 0) \textcolor{keywordflow}{return};
00324 
00325     \textcolor{keywordflow}{if} (server.\hyperlink{config_8h_af5994c643c434574580bb7816af82cad}{aof\_fsync} == \hyperlink{server_8h_a9784233b87ec796d0343556106fb778e}{AOF\_FSYNC\_EVERYSEC})
00326         sync\_in\_progress = bioPendingJobsOfType(\hyperlink{bio_8h_a5d03c967316addafc61b7ed5d957984f}{BIO\_AOF\_FSYNC}) != 0;
00327 
00328     \textcolor{keywordflow}{if} (server.\hyperlink{config_8h_af5994c643c434574580bb7816af82cad}{aof\_fsync} == \hyperlink{server_8h_a9784233b87ec796d0343556106fb778e}{AOF\_FSYNC\_EVERYSEC} && !force) \{
00329         \textcolor{comment}{/* With this append fsync policy we do background fsyncing.}
00330 \textcolor{comment}{         * If the fsync is still in progress we can try to delay}
00331 \textcolor{comment}{         * the write for a couple of seconds. */}
00332         \textcolor{keywordflow}{if} (sync\_in\_progress) \{
00333             \textcolor{keywordflow}{if} (server.aof\_flush\_postponed\_start == 0) \{
00334                 \textcolor{comment}{/* No previous write postponing, remember that we are}
00335 \textcolor{comment}{                 * postponing the flush and return. */}
00336                 server.aof\_flush\_postponed\_start = server.unixtime;
00337                 \textcolor{keywordflow}{return};
00338             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.unixtime - server.aof\_flush\_postponed\_start < 2) \{
00339                 \textcolor{comment}{/* We were already waiting for fsync to finish, but for less}
00340 \textcolor{comment}{                 * than two seconds this is still ok. Postpone again. */}
00341                 \textcolor{keywordflow}{return};
00342             \}
00343             \textcolor{comment}{/* Otherwise fall trough, and go write since we can't wait}
00344 \textcolor{comment}{             * over two seconds. */}
00345             server.aof\_delayed\_fsync++;
00346             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Asynchronous AOF fsync is taking too long (disk is busy?).
       Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis."});
00347         \}
00348     \}
00349     \textcolor{comment}{/* We want to perform a single write. This should be guaranteed atomic}
00350 \textcolor{comment}{     * at least if the filesystem we are writing is a real physical one.}
00351 \textcolor{comment}{     * While this will save us against the server being killed I don't think}
00352 \textcolor{comment}{     * there is much to do about the whole server stopping for power problems}
00353 \textcolor{comment}{     * or alike */}
00354 
00355     \hyperlink{latency_8h_a87d7b5b368dad97457f13466d760b0e1}{latencyStartMonitor}(latency);
00356     nwritten = aofWrite(server.aof\_fd,server.aof\_buf,sdslen(server.aof\_buf));
00357     \hyperlink{latency_8h_a88461aee20da0a648fe3332b5f068df7}{latencyEndMonitor}(latency);
00358     \textcolor{comment}{/* We want to capture different events for delayed writes:}
00359 \textcolor{comment}{     * when the delay happens with a pending fsync, or with a saving child}
00360 \textcolor{comment}{     * active, and when the above two conditions are missing.}
00361 \textcolor{comment}{     * We also use an additional event name to save all samples which is}
00362 \textcolor{comment}{     * useful for graphing / monitoring purposes. */}
00363     \textcolor{keywordflow}{if} (sync\_in\_progress) \{
00364         \hyperlink{latency_8h_a77922ab34035890c90f98831a9071359}{latencyAddSampleIfNeeded}(\textcolor{stringliteral}{"aof-write-pending-fsync"},latency);
00365     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.aof\_child\_pid != -1 || server.rdb\_child\_pid != -1) \{
00366         \hyperlink{latency_8h_a77922ab34035890c90f98831a9071359}{latencyAddSampleIfNeeded}(\textcolor{stringliteral}{"aof-write-active-child"},latency);
00367     \} \textcolor{keywordflow}{else} \{
00368         \hyperlink{latency_8h_a77922ab34035890c90f98831a9071359}{latencyAddSampleIfNeeded}(\textcolor{stringliteral}{"aof-write-alone"},latency);
00369     \}
00370     \hyperlink{latency_8h_a77922ab34035890c90f98831a9071359}{latencyAddSampleIfNeeded}(\textcolor{stringliteral}{"aof-write"},latency);
00371 
00372     \textcolor{comment}{/* We performed the write so reset the postponed flush sentinel to zero. */}
00373     server.aof\_flush\_postponed\_start = 0;
00374 
00375     \textcolor{keywordflow}{if} (nwritten != (ssize\_t)sdslen(server.aof\_buf)) \{
00376         \textcolor{keyword}{static} time\_t last\_write\_error\_log = 0;
00377         \textcolor{keywordtype}{int} can\_log = 0;
00378 
00379         \textcolor{comment}{/* Limit logging rate to 1 line per AOF\_WRITE\_LOG\_ERROR\_RATE seconds. */}
00380         \textcolor{keywordflow}{if} ((server.unixtime - last\_write\_error\_log) > 
      \hyperlink{aof_8c_acffdc721a3cb2f3d8d8817c3ab88c9b0}{AOF\_WRITE\_LOG\_ERROR\_RATE}) \{
00381             can\_log = 1;
00382             last\_write\_error\_log = server.unixtime;
00383         \}
00384 
00385         \textcolor{comment}{/* Log the AOF write error and record the error code. */}
00386         \textcolor{keywordflow}{if} (nwritten == -1) \{
00387             \textcolor{keywordflow}{if} (can\_log) \{
00388                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Error writing to the AOF file: %s"},
00389                     strerror(errno));
00390                 server.aof\_last\_write\_errno = errno;
00391             \}
00392         \} \textcolor{keywordflow}{else} \{
00393             \textcolor{keywordflow}{if} (can\_log) \{
00394                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Short write while writing to "}
00395                                        \textcolor{stringliteral}{"the AOF file: (nwritten=%lld, "}
00396                                        \textcolor{stringliteral}{"expected=%lld)"},
00397                                        (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long})nwritten,
00398                                        (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long})sdslen(server.aof\_buf));
00399             \}
00400 
00401             \textcolor{keywordflow}{if} (ftruncate(server.aof\_fd, server.aof\_current\_size) == -1) \{
00402                 \textcolor{keywordflow}{if} (can\_log) \{
00403                     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"Could not remove short write "}
00404                              \textcolor{stringliteral}{"from the append-only file.  Redis may refuse "}
00405                              \textcolor{stringliteral}{"to load the AOF the next time it starts.  "}
00406                              \textcolor{stringliteral}{"ftruncate: %s"}, strerror(errno));
00407                 \}
00408             \} \textcolor{keywordflow}{else} \{
00409                 \textcolor{comment}{/* If the ftruncate() succeeded we can set nwritten to}
00410 \textcolor{comment}{                 * -1 since there is no longer partial data into the AOF. */}
00411                 nwritten = -1;
00412             \}
00413             server.aof\_last\_write\_errno = ENOSPC;
00414         \}
00415 
00416         \textcolor{comment}{/* Handle the AOF write error. */}
00417         \textcolor{keywordflow}{if} (server.\hyperlink{config_8h_af5994c643c434574580bb7816af82cad}{aof\_fsync} == \hyperlink{server_8h_a83bfec10b7b4be60ec6d5868cadc73bb}{AOF\_FSYNC\_ALWAYS}) \{
00418             \textcolor{comment}{/* We can't recover when the fsync policy is ALWAYS since the}
00419 \textcolor{comment}{             * reply for the client is already in the output buffers, and we}
00420 \textcolor{comment}{             * have the contract with the user that on acknowledged write data}
00421 \textcolor{comment}{             * is synced on disk. */}
00422             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Can't recover from AOF write error when the AOF fsync
       policy is 'always'. Exiting..."});
00423             exit(1);
00424         \} \textcolor{keywordflow}{else} \{
00425             \textcolor{comment}{/* Recover from failed write leaving data into the buffer. However}
00426 \textcolor{comment}{             * set an error to stop accepting writes as long as the error}
00427 \textcolor{comment}{             * condition is not cleared. */}
00428             server.aof\_last\_write\_status = \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00429 
00430             \textcolor{comment}{/* Trim the sds buffer if there was a partial write, and there}
00431 \textcolor{comment}{             * was no way to undo it with ftruncate(2). */}
00432             \textcolor{keywordflow}{if} (nwritten > 0) \{
00433                 server.aof\_current\_size += nwritten;
00434                 sdsrange(server.aof\_buf,nwritten,-1);
00435             \}
00436             \textcolor{keywordflow}{return}; \textcolor{comment}{/* We'll try again on the next call... */}
00437         \}
00438     \} \textcolor{keywordflow}{else} \{
00439         \textcolor{comment}{/* Successful write(2). If AOF was in error state, restore the}
00440 \textcolor{comment}{         * OK state and log the event. */}
00441         \textcolor{keywordflow}{if} (server.aof\_last\_write\_status == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
00442             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
00443                 \textcolor{stringliteral}{"AOF write error looks solved, Redis can write again."});
00444             server.aof\_last\_write\_status = \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00445         \}
00446     \}
00447     server.aof\_current\_size += nwritten;
00448 
00449     \textcolor{comment}{/* Re-use AOF buffer when it is small enough. The maximum comes from the}
00450 \textcolor{comment}{     * arena size of 4k minus some overhead (but is otherwise arbitrary). */}
00451     \textcolor{keywordflow}{if} ((sdslen(server.aof\_buf)+sdsavail(server.aof\_buf)) < 4000) \{
00452         sdsclear(server.aof\_buf);
00453     \} \textcolor{keywordflow}{else} \{
00454         sdsfree(server.aof\_buf);
00455         server.aof\_buf = sdsempty();
00456     \}
00457 
00458     \textcolor{comment}{/* Don't fsync if no-appendfsync-on-rewrite is set to yes and there are}
00459 \textcolor{comment}{     * children doing I/O in the background. */}
00460     \textcolor{keywordflow}{if} (server.aof\_no\_fsync\_on\_rewrite &&
00461         (server.aof\_child\_pid != -1 || server.rdb\_child\_pid != -1))
00462             \textcolor{keywordflow}{return};
00463 
00464     \textcolor{comment}{/* Perform the fsync if needed. */}
00465     \textcolor{keywordflow}{if} (server.\hyperlink{config_8h_af5994c643c434574580bb7816af82cad}{aof\_fsync} == \hyperlink{server_8h_a83bfec10b7b4be60ec6d5868cadc73bb}{AOF\_FSYNC\_ALWAYS}) \{
00466         \textcolor{comment}{/* aof\_fsync is defined as fdatasync() for Linux in order to avoid}
00467 \textcolor{comment}{         * flushing metadata. */}
00468         \hyperlink{latency_8h_a87d7b5b368dad97457f13466d760b0e1}{latencyStartMonitor}(latency);
00469         \hyperlink{config_8h_af5994c643c434574580bb7816af82cad}{aof\_fsync}(server.aof\_fd); \textcolor{comment}{/* Let's try to get this data on the disk */}
00470         \hyperlink{latency_8h_a88461aee20da0a648fe3332b5f068df7}{latencyEndMonitor}(latency);
00471         \hyperlink{latency_8h_a77922ab34035890c90f98831a9071359}{latencyAddSampleIfNeeded}(\textcolor{stringliteral}{"aof-fsync-always"},latency);
00472         server.aof\_last\_fsync = server.unixtime;
00473     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((server.\hyperlink{config_8h_af5994c643c434574580bb7816af82cad}{aof\_fsync} == \hyperlink{server_8h_a9784233b87ec796d0343556106fb778e}{AOF\_FSYNC\_EVERYSEC} &&
00474                 server.unixtime > server.aof\_last\_fsync)) \{
00475         \textcolor{keywordflow}{if} (!sync\_in\_progress) aof\_background\_fsync(server.aof\_fd);
00476         server.aof\_last\_fsync = server.unixtime;
00477     \}
00478 \}
00479 
00480 sds catAppendOnlyGenericCommand(sds dst, \textcolor{keywordtype}{int} argc, robj **argv) \{
00481     \textcolor{keywordtype}{char} buf[32];
00482     \textcolor{keywordtype}{int} len, j;
00483     robj *o;
00484 
00485     buf[0] = \textcolor{stringliteral}{'*'};
00486     len = 1+ll2string(buf+1,\textcolor{keyword}{sizeof}(buf)-1,argc);
00487     buf[len++] = \textcolor{stringliteral}{'\(\backslash\)r'};
00488     buf[len++] = \textcolor{stringliteral}{'\(\backslash\)n'};
00489     dst = sdscatlen(dst,buf,len);
00490 
00491     \textcolor{keywordflow}{for} (j = 0; j < argc; j++) \{
00492         o = getDecodedObject(argv[j]);
00493         buf[0] = \textcolor{stringliteral}{'$'};
00494         len = 1+ll2string(buf+1,\textcolor{keyword}{sizeof}(buf)-1,sdslen(o->ptr));
00495         buf[len++] = \textcolor{stringliteral}{'\(\backslash\)r'};
00496         buf[len++] = \textcolor{stringliteral}{'\(\backslash\)n'};
00497         dst = sdscatlen(dst,buf,len);
00498         dst = sdscatlen(dst,o->ptr,sdslen(o->ptr));
00499         dst = sdscatlen(dst,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"},2);
00500         decrRefCount(o);
00501     \}
00502     \textcolor{keywordflow}{return} dst;
00503 \}
00504 
00505 \textcolor{comment}{/* Create the sds representation of an PEXPIREAT command, using}
00506 \textcolor{comment}{ * 'seconds' as time to live and 'cmd' to understand what command}
00507 \textcolor{comment}{ * we are translating into a PEXPIREAT.}
00508 \textcolor{comment}{ *}
00509 \textcolor{comment}{ * This command is used in order to translate EXPIRE and PEXPIRE commands}
00510 \textcolor{comment}{ * into PEXPIREAT command so that we retain precision in the append only}
00511 \textcolor{comment}{ * file, and the time is always absolute and not relative. */}
00512 sds catAppendOnlyExpireAtCommand(sds buf, \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, robj *key, robj *
      seconds) \{
00513     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} when;
00514     robj *argv[3];
00515 
00516     \textcolor{comment}{/* Make sure we can use strtoll */}
00517     seconds = getDecodedObject(seconds);
00518     when = strtoll(seconds->ptr,NULL,10);
00519     \textcolor{comment}{/* Convert argument into milliseconds for EXPIRE, SETEX, EXPIREAT */}
00520     \textcolor{keywordflow}{if} (cmd->proc == expireCommand || cmd->proc == setexCommand ||
00521         cmd->proc == expireatCommand)
00522     \{
00523         when *= 1000;
00524     \}
00525     \textcolor{comment}{/* Convert into absolute time for EXPIRE, PEXPIRE, SETEX, PSETEX */}
00526     \textcolor{keywordflow}{if} (cmd->proc == expireCommand || cmd->proc == pexpireCommand ||
00527         cmd->proc == setexCommand || cmd->proc == psetexCommand)
00528     \{
00529         when += mstime();
00530     \}
00531     decrRefCount(seconds);
00532 
00533     argv[0] = createStringObject(\textcolor{stringliteral}{"PEXPIREAT"},9);
00534     argv[1] = key;
00535     argv[2] = createStringObjectFromLongLong(when);
00536     buf = catAppendOnlyGenericCommand(buf, 3, argv);
00537     decrRefCount(argv[0]);
00538     decrRefCount(argv[2]);
00539     \textcolor{keywordflow}{return} buf;
00540 \}
00541 
00542 \textcolor{keywordtype}{void} feedAppendOnlyFile(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, \textcolor{keywordtype}{int} dictid, robj **argv, \textcolor{keywordtype}{int} argc) \{
00543     sds buf = sdsempty();
00544     robj *tmpargv[3];
00545 
00546     \textcolor{comment}{/* The DB this command was targeting is not the same as the last command}
00547 \textcolor{comment}{     * we appended. To issue a SELECT command is needed. */}
00548     \textcolor{keywordflow}{if} (dictid != server.aof\_selected\_db) \{
00549         \textcolor{keywordtype}{char} seldb[64];
00550 
00551         snprintf(seldb,\textcolor{keyword}{sizeof}(seldb),\textcolor{stringliteral}{"%d"},dictid);
00552         buf = sdscatprintf(buf,\textcolor{stringliteral}{"*2\(\backslash\)r\(\backslash\)n$6\(\backslash\)r\(\backslash\)nSELECT\(\backslash\)r\(\backslash\)n$%lu\(\backslash\)r\(\backslash\)n%s\(\backslash\)r\(\backslash\)n"},
00553             (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})strlen(seldb),seldb);
00554         server.aof\_selected\_db = dictid;
00555     \}
00556 
00557     \textcolor{keywordflow}{if} (cmd->proc == expireCommand || cmd->proc == pexpireCommand ||
00558         cmd->proc == expireatCommand) \{
00559         \textcolor{comment}{/* Translate EXPIRE/PEXPIRE/EXPIREAT into PEXPIREAT */}
00560         buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[1],argv[2]);
00561     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cmd->proc == setexCommand || cmd->proc == psetexCommand) \{
00562         \textcolor{comment}{/* Translate SETEX/PSETEX to SET and PEXPIREAT */}
00563         tmpargv[0] = createStringObject(\textcolor{stringliteral}{"SET"},3);
00564         tmpargv[1] = argv[1];
00565         tmpargv[2] = argv[3];
00566         buf = catAppendOnlyGenericCommand(buf,3,tmpargv);
00567         decrRefCount(tmpargv[0]);
00568         buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[1],argv[2]);
00569     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cmd->proc == setCommand && argc > 3) \{
00570         \textcolor{keywordtype}{int} i;
00571         robj *exarg = NULL, *pxarg = NULL;
00572         \textcolor{comment}{/* Translate SET [EX seconds][PX milliseconds] to SET and PEXPIREAT */}
00573         buf = catAppendOnlyGenericCommand(buf,3,argv);
00574         \textcolor{keywordflow}{for} (i = 3; i < argc; i ++) \{
00575             \textcolor{keywordflow}{if} (!strcasecmp(argv[i]->ptr, \textcolor{stringliteral}{"ex"})) exarg = argv[i+1];
00576             \textcolor{keywordflow}{if} (!strcasecmp(argv[i]->ptr, \textcolor{stringliteral}{"px"})) pxarg = argv[i+1];
00577         \}
00578         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(!(exarg && pxarg));
00579         \textcolor{keywordflow}{if} (exarg)
00580             buf = catAppendOnlyExpireAtCommand(buf,server.expireCommand,argv[1],
00581                                                exarg);
00582         \textcolor{keywordflow}{if} (pxarg)
00583             buf = catAppendOnlyExpireAtCommand(buf,server.pexpireCommand,argv[1],
00584                                                pxarg);
00585     \} \textcolor{keywordflow}{else} \{
00586         \textcolor{comment}{/* All the other commands don't need translation or need the}
00587 \textcolor{comment}{         * same translation already operated in the command vector}
00588 \textcolor{comment}{         * for the replication itself. */}
00589         buf = catAppendOnlyGenericCommand(buf,argc,argv);
00590     \}
00591 
00592     \textcolor{comment}{/* Append to the AOF buffer. This will be flushed on disk just before}
00593 \textcolor{comment}{     * of re-entering the event loop, so before the client will get a}
00594 \textcolor{comment}{     * positive reply about the operation performed. */}
00595     \textcolor{keywordflow}{if} (server.aof\_state == \hyperlink{server_8h_af6b151c9dced28e94c19479197113a83}{AOF\_ON})
00596         server.aof\_buf = sdscatlen(server.aof\_buf,buf,sdslen(buf));
00597 
00598     \textcolor{comment}{/* If a background append only file rewriting is in progress we want to}
00599 \textcolor{comment}{     * accumulate the differences between the child DB and the current one}
00600 \textcolor{comment}{     * in a buffer, so that when the child process will do its work we}
00601 \textcolor{comment}{     * can append the differences to the new append only file. */}
00602     \textcolor{keywordflow}{if} (server.aof\_child\_pid != -1)
00603         aofRewriteBufferAppend((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)buf,sdslen(buf));
00604 
00605     sdsfree(buf);
00606 \}
00607 
00608 \textcolor{comment}{/* ----------------------------------------------------------------------------}
00609 \textcolor{comment}{ * AOF loading}
00610 \textcolor{comment}{ * ------------------------------------------------------------------------- */}
00611 
00612 \textcolor{comment}{/* In Redis commands are always executed in the context of a client, so in}
00613 \textcolor{comment}{ * order to load the append only file we need to create a fake client. */}
00614 \textcolor{keyword}{struct} \hyperlink{structclient}{client} *createFakeClient(\textcolor{keywordtype}{void}) \{
00615     \textcolor{keyword}{struct} \hyperlink{structclient}{client} *c = zmalloc(\textcolor{keyword}{sizeof}(*c));
00616 
00617     selectDb(c,0);
00618     c->fd = -1;
00619     c->name = NULL;
00620     c->querybuf = sdsempty();
00621     c->querybuf\_peak = 0;
00622     c->argc = 0;
00623     c->argv = NULL;
00624     c->bufpos = 0;
00625     c->flags = 0;
00626     c->btype = \hyperlink{server_8h_a89cf259b265c26cd1e09de67ade457dc}{BLOCKED\_NONE};
00627     \textcolor{comment}{/* We set the fake client as a slave waiting for the synchronization}
00628 \textcolor{comment}{     * so that Redis will not try to send replies to this client. */}
00629     c->replstate = \hyperlink{server_8h_a170ee2dd8cfefaf0d112edcc3152f8d7}{SLAVE\_STATE\_WAIT\_BGSAVE\_START};
00630     c->reply = listCreate();
00631     c->reply\_bytes = 0;
00632     c->obuf\_soft\_limit\_reached\_time = 0;
00633     c->watched\_keys = listCreate();
00634     c->peerid = NULL;
00635     \hyperlink{adlist_8h_a648e4a2d20decff3182a72a608b0b8f2}{listSetFreeMethod}(c->reply,decrRefCountVoid);
00636     \hyperlink{adlist_8h_ab575839d09f454c02e06bcec5addb06b}{listSetDupMethod}(c->reply,dupClientReplyValue);
00637     initClientMultiState(c);
00638     \textcolor{keywordflow}{return} c;
00639 \}
00640 
00641 \textcolor{keywordtype}{void} freeFakeClientArgv(\textcolor{keyword}{struct} \hyperlink{structclient}{client} *c) \{
00642     \textcolor{keywordtype}{int} j;
00643 
00644     \textcolor{keywordflow}{for} (j = 0; j < c->argc; j++)
00645         decrRefCount(c->argv[j]);
00646     zfree(c->argv);
00647 \}
00648 
00649 \textcolor{keywordtype}{void} freeFakeClient(\textcolor{keyword}{struct} \hyperlink{structclient}{client} *c) \{
00650     sdsfree(c->querybuf);
00651     listRelease(c->reply);
00652     listRelease(c->watched\_keys);
00653     freeClientMultiState(c);
00654     zfree(c);
00655 \}
00656 
00657 \textcolor{comment}{/* Replay the append log file. On success C\_OK is returned. On non fatal}
00658 \textcolor{comment}{ * error (the append only file is zero-length) C\_ERR is returned. On}
00659 \textcolor{comment}{ * fatal error an error message is logged and the program exists. */}
00660 \textcolor{keywordtype}{int} loadAppendOnlyFile(\textcolor{keywordtype}{char} *filename) \{
00661     \textcolor{keyword}{struct} \hyperlink{structclient}{client} *fakeClient;
00662     FILE *fp = fopen(filename,\textcolor{stringliteral}{"r"});
00663     \textcolor{keyword}{struct} \hyperlink{config_8h_ae18037d20ab1bc7c716ea0bcb506f7af}{redis\_stat} sb;
00664     \textcolor{keywordtype}{int} old\_aof\_state = server.aof\_state;
00665     \textcolor{keywordtype}{long} loops = 0;
00666     off\_t valid\_up\_to = 0; \textcolor{comment}{/* Offset of latest well-formed command loaded. */}
00667 
00668     \textcolor{keywordflow}{if} (fp == NULL) \{
00669         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Fatal error: can't open the append log file for reading: %s"},
      strerror(errno));
00670         exit(1);
00671     \}
00672 
00673     \textcolor{comment}{/* Handle a zero-length AOF file as a special case. An emtpy AOF file}
00674 \textcolor{comment}{     * is a valid AOF because an empty server with AOF enabled will create}
00675 \textcolor{comment}{     * a zero length file at startup, that will remain like that if no write}
00676 \textcolor{comment}{     * operation is received. */}
00677     \textcolor{keywordflow}{if} (fp && \hyperlink{config_8h_a7fb7329d05a6b4d1b1e7a3fac44c0668}{redis\_fstat}(fileno(fp),&sb) != -1 && sb.st\_size == 0) \{
00678         server.aof\_current\_size = 0;
00679         fclose(fp);
00680         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00681     \}
00682 
00683     \textcolor{comment}{/* Temporarily disable AOF, to prevent EXEC from feeding a MULTI}
00684 \textcolor{comment}{     * to the same file we're about to read. */}
00685     server.aof\_state = \hyperlink{server_8h_a5226306fbcebcb6d5d02e0fef3c213c2}{AOF\_OFF};
00686 
00687     fakeClient = createFakeClient();
00688     startLoading(fp);
00689 
00690     \textcolor{comment}{/* Check if this AOF file has an RDB preamble. In that case we need to}
00691 \textcolor{comment}{     * load the RDB file and later continue loading the AOF tail. */}
00692     \textcolor{keywordtype}{char} sig[5]; \textcolor{comment}{/* "REDIS" */}
00693     \textcolor{keywordflow}{if} (fread(sig,1,5,fp) != 5 || memcmp(sig,\textcolor{stringliteral}{"REDIS"},5) != 0) \{
00694         \textcolor{comment}{/* No RDB preamble, seek back at 0 offset. */}
00695         \textcolor{keywordflow}{if} (fseek(fp,0,SEEK\_SET) == -1) \textcolor{keywordflow}{goto} readerr;
00696     \} \textcolor{keywordflow}{else} \{
00697         \textcolor{comment}{/* RDB preamble. Pass loading the RDB functions. */}
00698         rio rdb;
00699 
00700         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Reading RDB preamble from AOF file..."});
00701         \textcolor{keywordflow}{if} (fseek(fp,0,SEEK\_SET) == -1) \textcolor{keywordflow}{goto} readerr;
00702         rioInitWithFile(&rdb,fp);
00703         \textcolor{keywordflow}{if} (rdbLoadRio(&rdb,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
00704             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Error reading the RDB preamble of the AOF file, AOF
       loading aborted"});
00705             \textcolor{keywordflow}{goto} readerr;
00706         \} \textcolor{keywordflow}{else} \{
00707             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Reading the remaining AOF tail..."});
00708         \}
00709     \}
00710 
00711     \textcolor{comment}{/* Read the actual AOF file, in REPL format, command by command. */}
00712     \textcolor{keywordflow}{while}(1) \{
00713         \textcolor{keywordtype}{int} argc, j;
00714         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} len;
00715         robj **argv;
00716         \textcolor{keywordtype}{char} buf[128];
00717         sds argsds;
00718         \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd;
00719 
00720         \textcolor{comment}{/* Serve the clients from time to time */}
00721         \textcolor{keywordflow}{if} (!(loops++ % 1000)) \{
00722             loadingProgress(ftello(fp));
00723             processEventsWhileBlocked();
00724         \}
00725 
00726         \textcolor{keywordflow}{if} (fgets(buf,\textcolor{keyword}{sizeof}(buf),fp) == NULL) \{
00727             \textcolor{keywordflow}{if} (feof(fp))
00728                 \textcolor{keywordflow}{break};
00729             \textcolor{keywordflow}{else}
00730                 \textcolor{keywordflow}{goto} readerr;
00731         \}
00732         \textcolor{keywordflow}{if} (buf[0] != \textcolor{stringliteral}{'*'}) \textcolor{keywordflow}{goto} fmterr;
00733         \textcolor{keywordflow}{if} (buf[1] == \textcolor{stringliteral}{'\(\backslash\)0'}) \textcolor{keywordflow}{goto} readerr;
00734         argc = atoi(buf+1);
00735         \textcolor{keywordflow}{if} (argc < 1) \textcolor{keywordflow}{goto} fmterr;
00736 
00737         argv = zmalloc(\textcolor{keyword}{sizeof}(robj*)*argc);
00738         fakeClient->argc = argc;
00739         fakeClient->argv = argv;
00740 
00741         \textcolor{keywordflow}{for} (j = 0; j < argc; j++) \{
00742             \textcolor{keywordflow}{if} (fgets(buf,\textcolor{keyword}{sizeof}(buf),fp) == NULL) \{
00743                 fakeClient->argc = j; \textcolor{comment}{/* Free up to j-1. */}
00744                 freeFakeClientArgv(fakeClient);
00745                 \textcolor{keywordflow}{goto} readerr;
00746             \}
00747             \textcolor{keywordflow}{if} (buf[0] != \textcolor{stringliteral}{'$'}) \textcolor{keywordflow}{goto} fmterr;
00748             len = strtol(buf+1,NULL,10);
00749             argsds = sdsnewlen(NULL,len);
00750             \textcolor{keywordflow}{if} (len && fread(argsds,len,1,fp) == 0) \{
00751                 sdsfree(argsds);
00752                 fakeClient->argc = j; \textcolor{comment}{/* Free up to j-1. */}
00753                 freeFakeClientArgv(fakeClient);
00754                 \textcolor{keywordflow}{goto} readerr;
00755             \}
00756             argv[j] = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},argsds);
00757             \textcolor{keywordflow}{if} (fread(buf,2,1,fp) == 0) \{
00758                 fakeClient->argc = j+1; \textcolor{comment}{/* Free up to j. */}
00759                 freeFakeClientArgv(fakeClient);
00760                 \textcolor{keywordflow}{goto} readerr; \textcolor{comment}{/* discard CRLF */}
00761             \}
00762         \}
00763 
00764         \textcolor{comment}{/* Command lookup */}
00765         cmd = lookupCommand(argv[0]->ptr);
00766         \textcolor{keywordflow}{if} (!cmd) \{
00767             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Unknown command '%s' reading the append only file"}, (\textcolor{keywordtype}{char}*
      )argv[0]->ptr);
00768             exit(1);
00769         \}
00770 
00771         \textcolor{comment}{/* Run the command in the context of a fake client */}
00772         fakeClient->cmd = cmd;
00773         cmd->proc(fakeClient);
00774 
00775         \textcolor{comment}{/* The fake client should not have a reply */}
00776         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(fakeClient->bufpos == 0 && \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(fakeClient->reply) ==
       0);
00777         \textcolor{comment}{/* The fake client should never get blocked */}
00778         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}((fakeClient->flags & \hyperlink{server_8h_a503ad979164a52f0f5e2a63e4c7da3a0}{CLIENT\_BLOCKED}) == 0);
00779 
00780         \textcolor{comment}{/* Clean up. Command code may have changed argv/argc so we use the}
00781 \textcolor{comment}{         * argv/argc of the client instead of the local variables. */}
00782         freeFakeClientArgv(fakeClient);
00783         fakeClient->cmd = NULL;
00784         \textcolor{keywordflow}{if} (server.aof\_load\_truncated) valid\_up\_to = ftello(fp);
00785     \}
00786 
00787     \textcolor{comment}{/* This point can only be reached when EOF is reached without errors.}
00788 \textcolor{comment}{     * If the client is in the middle of a MULTI/EXEC, log error and quit. */}
00789     \textcolor{keywordflow}{if} (fakeClient->flags & \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI}) \textcolor{keywordflow}{goto} uxeof;
00790 
00791 loaded\_ok: \textcolor{comment}{/* DB loaded, cleanup and return C\_OK to the caller. */}
00792     fclose(fp);
00793     freeFakeClient(fakeClient);
00794     server.aof\_state = old\_aof\_state;
00795     stopLoading();
00796     aofUpdateCurrentSize();
00797     server.aof\_rewrite\_base\_size = server.aof\_current\_size;
00798     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00799 
00800 readerr: \textcolor{comment}{/* Read error. If feof(fp) is true, fall through to unexpected EOF. */}
00801     \textcolor{keywordflow}{if} (!feof(fp)) \{
00802         \textcolor{keywordflow}{if} (fakeClient) freeFakeClient(fakeClient); \textcolor{comment}{/* avoid valgrind warning */}
00803         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Unrecoverable error reading the append only file: %s"}, 
      strerror(errno));
00804         exit(1);
00805     \}
00806 
00807 uxeof: \textcolor{comment}{/* Unexpected AOF end of file. */}
00808     \textcolor{keywordflow}{if} (server.aof\_load\_truncated) \{
00809         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"!!! Warning: short read while loading the AOF file !!!"});
00810         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"!!! Truncating the AOF at offset %llu !!!"},
00811             (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) valid\_up\_to);
00812         \textcolor{keywordflow}{if} (valid\_up\_to == -1 || truncate(filename,valid\_up\_to) == -1) \{
00813             \textcolor{keywordflow}{if} (valid\_up\_to == -1) \{
00814                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Last valid command offset is invalid"});
00815             \} \textcolor{keywordflow}{else} \{
00816                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Error truncating the AOF file: %s"},
00817                     strerror(errno));
00818             \}
00819         \} \textcolor{keywordflow}{else} \{
00820             \textcolor{comment}{/* Make sure the AOF file descriptor points to the end of the}
00821 \textcolor{comment}{             * file after the truncate call. */}
00822             \textcolor{keywordflow}{if} (server.aof\_fd != -1 && lseek(server.aof\_fd,0,SEEK\_END) == -1) \{
00823                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Can't seek the end of the AOF file: %s"},
00824                     strerror(errno));
00825             \} \textcolor{keywordflow}{else} \{
00826                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
00827                     \textcolor{stringliteral}{"AOF loaded anyway because aof-load-truncated is enabled"});
00828                 \textcolor{keywordflow}{goto} loaded\_ok;
00829             \}
00830         \}
00831     \}
00832     \textcolor{keywordflow}{if} (fakeClient) freeFakeClient(fakeClient); \textcolor{comment}{/* avoid valgrind warning */}
00833     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Unexpected end of file reading the append only file. You can: 1)
       Make a backup of your AOF file, then use ./redis-check-aof --fix <filename>. 2) Alternatively you can set the
       'aof-load-truncated' configuration option to yes and restart the server."});
00834     exit(1);
00835 
00836 fmterr: \textcolor{comment}{/* Format error. */}
00837     \textcolor{keywordflow}{if} (fakeClient) freeFakeClient(fakeClient); \textcolor{comment}{/* avoid valgrind warning */}
00838     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Bad file format reading the append only file: make a backup of
       your AOF file, then use ./redis-check-aof --fix <filename>"});
00839     exit(1);
00840 \}
00841 
00842 \textcolor{comment}{/* ----------------------------------------------------------------------------}
00843 \textcolor{comment}{ * AOF rewrite}
00844 \textcolor{comment}{ * ------------------------------------------------------------------------- */}
00845 
00846 \textcolor{comment}{/* Delegate writing an object to writing a bulk string or bulk long long.}
00847 \textcolor{comment}{ * This is not placed in rio.c since that adds the server.h dependency. */}
00848 \textcolor{keywordtype}{int} rioWriteBulkObject(rio *r, robj *obj) \{
00849     \textcolor{comment}{/* Avoid using getDecodedObject to help copy-on-write (we are often}
00850 \textcolor{comment}{     * in a child process when this function is called). */}
00851     \textcolor{keywordflow}{if} (obj->encoding == \hyperlink{server_8h_ae934cf008a0be0ef009c92c2d006a816}{OBJ\_ENCODING\_INT}) \{
00852         \textcolor{keywordflow}{return} rioWriteBulkLongLong(r,(\textcolor{keywordtype}{long})obj->ptr);
00853     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{server_8h_afcfb5bd97af52d1dbce331745cae030c}{sdsEncodedObject}(obj)) \{
00854         \textcolor{keywordflow}{return} rioWriteBulkString(r,obj->ptr,sdslen(obj->ptr));
00855     \} \textcolor{keywordflow}{else} \{
00856         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown string encoding"});
00857     \}
00858 \}
00859 
00860 \textcolor{comment}{/* Emit the commands needed to rebuild a list object.}
00861 \textcolor{comment}{ * The function returns 0 on error, 1 on success. */}
00862 \textcolor{keywordtype}{int} rewriteListObject(rio *r, robj *key, robj *o) \{
00863     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} count = 0, items = listTypeLength(o);
00864 
00865     \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_aec792aeed6d4bf83966672e6a23043b8}{OBJ\_ENCODING\_QUICKLIST}) \{
00866         quicklist *list = o->ptr;
00867         quicklistIter *li = quicklistGetIterator(list, \hyperlink{adlist_8h_a353f032fdd7e66abe9f194fa7c89560b}{AL\_START\_HEAD});
00868         quicklistEntry entry;
00869 
00870         \textcolor{keywordflow}{while} (quicklistNext(li,&entry)) \{
00871             \textcolor{keywordflow}{if} (count == 0) \{
00872                 \textcolor{keywordtype}{int} cmd\_items = (items > \hyperlink{server_8h_a437bda3214c8acb2835f49eb68919507}{AOF\_REWRITE\_ITEMS\_PER\_CMD}) ?
00873                     \hyperlink{server_8h_a437bda3214c8acb2835f49eb68919507}{AOF\_REWRITE\_ITEMS\_PER\_CMD} : items;
00874                 \textcolor{keywordflow}{if} (rioWriteBulkCount(r,\textcolor{stringliteral}{'*'},2+cmd\_items) == 0) \textcolor{keywordflow}{return} 0;
00875                 \textcolor{keywordflow}{if} (rioWriteBulkString(r,\textcolor{stringliteral}{"RPUSH"},5) == 0) \textcolor{keywordflow}{return} 0;
00876                 \textcolor{keywordflow}{if} (rioWriteBulkObject(r,key) == 0) \textcolor{keywordflow}{return} 0;
00877             \}
00878 
00879             \textcolor{keywordflow}{if} (entry.value) \{
00880                 \textcolor{keywordflow}{if} (rioWriteBulkString(r,(\textcolor{keywordtype}{char}*)entry.value,entry.sz) == 0) \textcolor{keywordflow}{return} 0;
00881             \} \textcolor{keywordflow}{else} \{
00882                 \textcolor{keywordflow}{if} (rioWriteBulkLongLong(r,entry.longval) == 0) \textcolor{keywordflow}{return} 0;
00883             \}
00884             \textcolor{keywordflow}{if} (++count == \hyperlink{server_8h_a437bda3214c8acb2835f49eb68919507}{AOF\_REWRITE\_ITEMS\_PER\_CMD}) count = 0;
00885             items--;
00886         \}
00887         quicklistReleaseIterator(li);
00888     \} \textcolor{keywordflow}{else} \{
00889         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown list encoding"});
00890     \}
00891     \textcolor{keywordflow}{return} 1;
00892 \}
00893 
00894 \textcolor{comment}{/* Emit the commands needed to rebuild a set object.}
00895 \textcolor{comment}{ * The function returns 0 on error, 1 on success. */}
00896 \textcolor{keywordtype}{int} rewriteSetObject(rio *r, robj *key, robj *o) \{
00897     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} count = 0, items = setTypeSize(o);
00898 
00899     \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
00900         \textcolor{keywordtype}{int} ii = 0;
00901         int64\_t llval;
00902 
00903         \textcolor{keywordflow}{while}(intsetGet(o->ptr,ii++,&llval)) \{
00904             \textcolor{keywordflow}{if} (count == 0) \{
00905                 \textcolor{keywordtype}{int} cmd\_items = (items > \hyperlink{server_8h_a437bda3214c8acb2835f49eb68919507}{AOF\_REWRITE\_ITEMS\_PER\_CMD}) ?
00906                     \hyperlink{server_8h_a437bda3214c8acb2835f49eb68919507}{AOF\_REWRITE\_ITEMS\_PER\_CMD} : items;
00907 
00908                 \textcolor{keywordflow}{if} (rioWriteBulkCount(r,\textcolor{stringliteral}{'*'},2+cmd\_items) == 0) \textcolor{keywordflow}{return} 0;
00909                 \textcolor{keywordflow}{if} (rioWriteBulkString(r,\textcolor{stringliteral}{"SADD"},4) == 0) \textcolor{keywordflow}{return} 0;
00910                 \textcolor{keywordflow}{if} (rioWriteBulkObject(r,key) == 0) \textcolor{keywordflow}{return} 0;
00911             \}
00912             \textcolor{keywordflow}{if} (rioWriteBulkLongLong(r,llval) == 0) \textcolor{keywordflow}{return} 0;
00913             \textcolor{keywordflow}{if} (++count == \hyperlink{server_8h_a437bda3214c8acb2835f49eb68919507}{AOF\_REWRITE\_ITEMS\_PER\_CMD}) count = 0;
00914             items--;
00915         \}
00916     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00917         dictIterator *di = dictGetIterator(o->ptr);
00918         dictEntry *de;
00919 
00920         \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
00921             sds ele = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
00922             \textcolor{keywordflow}{if} (count == 0) \{
00923                 \textcolor{keywordtype}{int} cmd\_items = (items > \hyperlink{server_8h_a437bda3214c8acb2835f49eb68919507}{AOF\_REWRITE\_ITEMS\_PER\_CMD}) ?
00924                     \hyperlink{server_8h_a437bda3214c8acb2835f49eb68919507}{AOF\_REWRITE\_ITEMS\_PER\_CMD} : items;
00925 
00926                 \textcolor{keywordflow}{if} (rioWriteBulkCount(r,\textcolor{stringliteral}{'*'},2+cmd\_items) == 0) \textcolor{keywordflow}{return} 0;
00927                 \textcolor{keywordflow}{if} (rioWriteBulkString(r,\textcolor{stringliteral}{"SADD"},4) == 0) \textcolor{keywordflow}{return} 0;
00928                 \textcolor{keywordflow}{if} (rioWriteBulkObject(r,key) == 0) \textcolor{keywordflow}{return} 0;
00929             \}
00930             \textcolor{keywordflow}{if} (rioWriteBulkString(r,ele,sdslen(ele)) == 0) \textcolor{keywordflow}{return} 0;
00931             \textcolor{keywordflow}{if} (++count == \hyperlink{server_8h_a437bda3214c8acb2835f49eb68919507}{AOF\_REWRITE\_ITEMS\_PER\_CMD}) count = 0;
00932             items--;
00933         \}
00934         dictReleaseIterator(di);
00935     \} \textcolor{keywordflow}{else} \{
00936         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown set encoding"});
00937     \}
00938     \textcolor{keywordflow}{return} 1;
00939 \}
00940 
00941 \textcolor{comment}{/* Emit the commands needed to rebuild a sorted set object.}
00942 \textcolor{comment}{ * The function returns 0 on error, 1 on success. */}
00943 \textcolor{keywordtype}{int} rewriteSortedSetObject(rio *r, robj *key, robj *o) \{
00944     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} count = 0, items = zsetLength(o);
00945 
00946     \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
00947         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl = o->ptr;
00948         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr, *sptr;
00949         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr;
00950         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen;
00951         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} vll;
00952         \textcolor{keywordtype}{double} score;
00953 
00954         eptr = ziplistIndex(zl,0);
00955         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(eptr != NULL);
00956         sptr = ziplistNext(zl,eptr);
00957         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(sptr != NULL);
00958 
00959         \textcolor{keywordflow}{while} (eptr != NULL) \{
00960             \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(ziplistGet(eptr,&vstr,&vlen,&vll));
00961             score = zzlGetScore(sptr);
00962 
00963             \textcolor{keywordflow}{if} (count == 0) \{
00964                 \textcolor{keywordtype}{int} cmd\_items = (items > \hyperlink{server_8h_a437bda3214c8acb2835f49eb68919507}{AOF\_REWRITE\_ITEMS\_PER\_CMD}) ?
00965                     \hyperlink{server_8h_a437bda3214c8acb2835f49eb68919507}{AOF\_REWRITE\_ITEMS\_PER\_CMD} : items;
00966 
00967                 \textcolor{keywordflow}{if} (rioWriteBulkCount(r,\textcolor{stringliteral}{'*'},2+cmd\_items*2) == 0) \textcolor{keywordflow}{return} 0;
00968                 \textcolor{keywordflow}{if} (rioWriteBulkString(r,\textcolor{stringliteral}{"ZADD"},4) == 0) \textcolor{keywordflow}{return} 0;
00969                 \textcolor{keywordflow}{if} (rioWriteBulkObject(r,key) == 0) \textcolor{keywordflow}{return} 0;
00970             \}
00971             \textcolor{keywordflow}{if} (rioWriteBulkDouble(r,score) == 0) \textcolor{keywordflow}{return} 0;
00972             \textcolor{keywordflow}{if} (vstr != NULL) \{
00973                 \textcolor{keywordflow}{if} (rioWriteBulkString(r,(\textcolor{keywordtype}{char}*)vstr,vlen) == 0) \textcolor{keywordflow}{return} 0;
00974             \} \textcolor{keywordflow}{else} \{
00975                 \textcolor{keywordflow}{if} (rioWriteBulkLongLong(r,vll) == 0) \textcolor{keywordflow}{return} 0;
00976             \}
00977             zzlNext(zl,&eptr,&sptr);
00978             \textcolor{keywordflow}{if} (++count == \hyperlink{server_8h_a437bda3214c8acb2835f49eb68919507}{AOF\_REWRITE\_ITEMS\_PER\_CMD}) count = 0;
00979             items--;
00980         \}
00981     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
00982         zset *zs = o->ptr;
00983         dictIterator *di = dictGetIterator(zs->dict);
00984         dictEntry *de;
00985 
00986         \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
00987             sds ele = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
00988             \textcolor{keywordtype}{double} *score = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
00989 
00990             \textcolor{keywordflow}{if} (count == 0) \{
00991                 \textcolor{keywordtype}{int} cmd\_items = (items > \hyperlink{server_8h_a437bda3214c8acb2835f49eb68919507}{AOF\_REWRITE\_ITEMS\_PER\_CMD}) ?
00992                     \hyperlink{server_8h_a437bda3214c8acb2835f49eb68919507}{AOF\_REWRITE\_ITEMS\_PER\_CMD} : items;
00993 
00994                 \textcolor{keywordflow}{if} (rioWriteBulkCount(r,\textcolor{stringliteral}{'*'},2+cmd\_items*2) == 0) \textcolor{keywordflow}{return} 0;
00995                 \textcolor{keywordflow}{if} (rioWriteBulkString(r,\textcolor{stringliteral}{"ZADD"},4) == 0) \textcolor{keywordflow}{return} 0;
00996                 \textcolor{keywordflow}{if} (rioWriteBulkObject(r,key) == 0) \textcolor{keywordflow}{return} 0;
00997             \}
00998             \textcolor{keywordflow}{if} (rioWriteBulkDouble(r,*score) == 0) \textcolor{keywordflow}{return} 0;
00999             \textcolor{keywordflow}{if} (rioWriteBulkString(r,ele,sdslen(ele)) == 0) \textcolor{keywordflow}{return} 0;
01000             \textcolor{keywordflow}{if} (++count == \hyperlink{server_8h_a437bda3214c8acb2835f49eb68919507}{AOF\_REWRITE\_ITEMS\_PER\_CMD}) count = 0;
01001             items--;
01002         \}
01003         dictReleaseIterator(di);
01004     \} \textcolor{keywordflow}{else} \{
01005         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted zset encoding"});
01006     \}
01007     \textcolor{keywordflow}{return} 1;
01008 \}
01009 
01010 \textcolor{comment}{/* Write either the key or the value of the currently selected item of a hash.}
01011 \textcolor{comment}{ * The 'hi' argument passes a valid Redis hash iterator.}
01012 \textcolor{comment}{ * The 'what' filed specifies if to write a key or a value and can be}
01013 \textcolor{comment}{ * either OBJ\_HASH\_KEY or OBJ\_HASH\_VALUE.}
01014 \textcolor{comment}{ *}
01015 \textcolor{comment}{ * The function returns 0 on error, non-zero on success. */}
01016 \textcolor{keyword}{static} \textcolor{keywordtype}{int} rioWriteHashIteratorCursor(rio *r, hashTypeIterator *hi, \textcolor{keywordtype}{int} what) \{
01017     \textcolor{keywordflow}{if} (hi->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
01018         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr = NULL;
01019         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen = UINT\_MAX;
01020         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} vll = LLONG\_MAX;
01021 
01022         hashTypeCurrentFromZiplist(hi, what, &vstr, &vlen, &vll);
01023         \textcolor{keywordflow}{if} (vstr)
01024             \textcolor{keywordflow}{return} rioWriteBulkString(r, (\textcolor{keywordtype}{char}*)vstr, vlen);
01025         \textcolor{keywordflow}{else}
01026             \textcolor{keywordflow}{return} rioWriteBulkLongLong(r, vll);
01027     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (hi->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
01028         sds value = hashTypeCurrentFromHashTable(hi, what);
01029         \textcolor{keywordflow}{return} rioWriteBulkString(r, value, sdslen(value));
01030     \}
01031 
01032     \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown hash encoding"});
01033     \textcolor{keywordflow}{return} 0;
01034 \}
01035 
01036 \textcolor{comment}{/* Emit the commands needed to rebuild a hash object.}
01037 \textcolor{comment}{ * The function returns 0 on error, 1 on success. */}
01038 \textcolor{keywordtype}{int} rewriteHashObject(rio *r, robj *key, robj *o) \{
01039     hashTypeIterator *hi;
01040     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} count = 0, items = hashTypeLength(o);
01041 
01042     hi = hashTypeInitIterator(o);
01043     \textcolor{keywordflow}{while} (hashTypeNext(hi) != \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
01044         \textcolor{keywordflow}{if} (count == 0) \{
01045             \textcolor{keywordtype}{int} cmd\_items = (items > \hyperlink{server_8h_a437bda3214c8acb2835f49eb68919507}{AOF\_REWRITE\_ITEMS\_PER\_CMD}) ?
01046                 \hyperlink{server_8h_a437bda3214c8acb2835f49eb68919507}{AOF\_REWRITE\_ITEMS\_PER\_CMD} : items;
01047 
01048             \textcolor{keywordflow}{if} (rioWriteBulkCount(r,\textcolor{stringliteral}{'*'},2+cmd\_items*2) == 0) \textcolor{keywordflow}{return} 0;
01049             \textcolor{keywordflow}{if} (rioWriteBulkString(r,\textcolor{stringliteral}{"HMSET"},5) == 0) \textcolor{keywordflow}{return} 0;
01050             \textcolor{keywordflow}{if} (rioWriteBulkObject(r,key) == 0) \textcolor{keywordflow}{return} 0;
01051         \}
01052 
01053         \textcolor{keywordflow}{if} (rioWriteHashIteratorCursor(r, hi, \hyperlink{server_8h_aede46b2a96d6f19aff38ccdac76598ac}{OBJ\_HASH\_KEY}) == 0) \textcolor{keywordflow}{return} 0;
01054         \textcolor{keywordflow}{if} (rioWriteHashIteratorCursor(r, hi, \hyperlink{server_8h_a1f87a280688b29cd45aa3aa0dceac7c7}{OBJ\_HASH\_VALUE}) == 0) \textcolor{keywordflow}{return} 0;
01055         \textcolor{keywordflow}{if} (++count == \hyperlink{server_8h_a437bda3214c8acb2835f49eb68919507}{AOF\_REWRITE\_ITEMS\_PER\_CMD}) count = 0;
01056         items--;
01057     \}
01058 
01059     hashTypeReleaseIterator(hi);
01060 
01061     \textcolor{keywordflow}{return} 1;
01062 \}
01063 
01064 \textcolor{comment}{/* Emit the commands needed to rebuild a stream object.}
01065 \textcolor{comment}{ * The function returns 0 on error, 1 on success. */}
01066 \textcolor{keywordtype}{int} rewriteStreamObject(rio *r, robj *key, robj *o) \{
01067     \hyperlink{structstreamIterator}{streamIterator} si;
01068     streamIteratorStart(&si,o->ptr,NULL,NULL,0);
01069     streamID id;
01070     int64\_t numfields;
01071 
01072     \textcolor{keywordflow}{while}(streamIteratorGetID(&si,&id,&numfields)) \{
01073         \textcolor{comment}{/* Emit a two elements array for each item. The first is}
01074 \textcolor{comment}{         * the ID, the second is an array of field-value pairs. */}
01075 
01076         \textcolor{comment}{/* Emit the XADD <key> <id> ...fields... command. */}
01077         \textcolor{keywordflow}{if} (rioWriteBulkCount(r,\textcolor{stringliteral}{'*'},3+numfields*2) == 0) \textcolor{keywordflow}{return} 0;
01078         \textcolor{keywordflow}{if} (rioWriteBulkString(r,\textcolor{stringliteral}{"XADD"},4) == 0) \textcolor{keywordflow}{return} 0;
01079         \textcolor{keywordflow}{if} (rioWriteBulkObject(r,key) == 0) \textcolor{keywordflow}{return} 0;
01080         sds replyid = sdscatfmt(sdsempty(),\textcolor{stringliteral}{"%U.%U"},id.ms,id.seq);
01081         \textcolor{keywordflow}{if} (rioWriteBulkString(r,replyid,sdslen(replyid)) == 0) \textcolor{keywordflow}{return} 0;
01082         sdsfree(replyid);
01083         \textcolor{keywordflow}{while}(numfields--) \{
01084             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *field, *value;
01085             int64\_t field\_len, value\_len;
01086             streamIteratorGetField(&si,&field,&value,&field\_len,&value\_len);
01087             \textcolor{keywordflow}{if} (rioWriteBulkString(r,(\textcolor{keywordtype}{char}*)field,field\_len) == 0) \textcolor{keywordflow}{return} 0;
01088             \textcolor{keywordflow}{if} (rioWriteBulkString(r,(\textcolor{keywordtype}{char}*)value,value\_len) == 0) \textcolor{keywordflow}{return} 0;
01089         \}
01090     \}
01091     streamIteratorStop(&si);
01092     \textcolor{keywordflow}{return} 1;
01093 \}
01094 
01095 \textcolor{comment}{/* Call the module type callback in order to rewrite a data type}
01096 \textcolor{comment}{ * that is exported by a module and is not handled by Redis itself.}
01097 \textcolor{comment}{ * The function returns 0 on error, 1 on success. */}
01098 \textcolor{keywordtype}{int} rewriteModuleObject(rio *r, robj *key, robj *o) \{
01099     \hyperlink{structRedisModuleIO}{RedisModuleIO} io;
01100     moduleValue *mv = o->ptr;
01101     moduleType *mt = mv->type;
01102     \hyperlink{server_8h_abe94415e34ee463788c4c863dc029908}{moduleInitIOContext}(io,mt,r);
01103     mt->aof\_rewrite(&io,key,mv->value);
01104     \textcolor{keywordflow}{if} (io.ctx) \{
01105         moduleFreeContext(io.ctx);
01106         zfree(io.ctx);
01107     \}
01108     \textcolor{keywordflow}{return} io.error ? 0 : 1;
01109 \}
01110 
01111 \textcolor{comment}{/* This function is called by the child rewriting the AOF file to read}
01112 \textcolor{comment}{ * the difference accumulated from the parent into a buffer, that is}
01113 \textcolor{comment}{ * concatenated at the end of the rewrite. */}
01114 ssize\_t aofReadDiffFromParent(\textcolor{keywordtype}{void}) \{
01115     \textcolor{keywordtype}{char} buf[65536]; \textcolor{comment}{/* Default pipe buffer size on most Linux systems. */}
01116     ssize\_t nread, total = 0;
01117 
01118     \textcolor{keywordflow}{while} ((nread =
01119             read(server.aof\_pipe\_read\_data\_from\_parent,buf,\textcolor{keyword}{sizeof}(buf))) > 0) \{
01120         server.aof\_child\_diff = sdscatlen(server.aof\_child\_diff,buf,nread);
01121         total += nread;
01122     \}
01123     \textcolor{keywordflow}{return} total;
01124 \}
01125 
01126 \textcolor{keywordtype}{int} rewriteAppendOnlyFileRio(rio *aof) \{
01127     dictIterator *di = NULL;
01128     dictEntry *de;
01129     size\_t processed = 0;
01130     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} now = mstime();
01131     \textcolor{keywordtype}{int} j;
01132 
01133     \textcolor{keywordflow}{for} (j = 0; j < server.dbnum; j++) \{
01134         \textcolor{keywordtype}{char} selectcmd[] = \textcolor{stringliteral}{"*2\(\backslash\)r\(\backslash\)n$6\(\backslash\)r\(\backslash\)nSELECT\(\backslash\)r\(\backslash\)n"};
01135         redisDb *db = server.db+j;
01136         dict *d = db->dict;
01137         \textcolor{keywordflow}{if} (\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(d) == 0) \textcolor{keywordflow}{continue};
01138         di = dictGetSafeIterator(d);
01139 
01140         \textcolor{comment}{/* SELECT the new DB */}
01141         \textcolor{keywordflow}{if} (rioWrite(aof,selectcmd,\textcolor{keyword}{sizeof}(selectcmd)-1) == 0) \textcolor{keywordflow}{goto} werr;
01142         \textcolor{keywordflow}{if} (rioWriteBulkLongLong(aof,j) == 0) \textcolor{keywordflow}{goto} werr;
01143 
01144         \textcolor{comment}{/* Iterate this DB writing every entry */}
01145         \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
01146             sds keystr;
01147             robj key, *o;
01148             \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} expiretime;
01149 
01150             keystr = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
01151             o = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
01152             \hyperlink{server_8h_abb4d561af9c6476a52e9236bcae5408d}{initStaticStringObject}(key,keystr);
01153 
01154             expiretime = getExpire(db,&key);
01155 
01156             \textcolor{comment}{/* If this key is already expired skip it */}
01157             \textcolor{keywordflow}{if} (expiretime != -1 && expiretime < now) \textcolor{keywordflow}{continue};
01158 
01159             \textcolor{comment}{/* Save the key and associated value */}
01160             \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING}) \{
01161                 \textcolor{comment}{/* Emit a SET command */}
01162                 \textcolor{keywordtype}{char} cmd[]=\textcolor{stringliteral}{"*3\(\backslash\)r\(\backslash\)n$3\(\backslash\)r\(\backslash\)nSET\(\backslash\)r\(\backslash\)n"};
01163                 \textcolor{keywordflow}{if} (rioWrite(aof,cmd,\textcolor{keyword}{sizeof}(cmd)-1) == 0) \textcolor{keywordflow}{goto} werr;
01164                 \textcolor{comment}{/* Key and value */}
01165                 \textcolor{keywordflow}{if} (rioWriteBulkObject(aof,&key) == 0) \textcolor{keywordflow}{goto} werr;
01166                 \textcolor{keywordflow}{if} (rioWriteBulkObject(aof,o) == 0) \textcolor{keywordflow}{goto} werr;
01167             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a4a5f22a280949c97a0cb0d4213275126}{OBJ\_LIST}) \{
01168                 \textcolor{keywordflow}{if} (rewriteListObject(aof,&key,o) == 0) \textcolor{keywordflow}{goto} werr;
01169             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET}) \{
01170                 \textcolor{keywordflow}{if} (rewriteSetObject(aof,&key,o) == 0) \textcolor{keywordflow}{goto} werr;
01171             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}) \{
01172                 \textcolor{keywordflow}{if} (rewriteSortedSetObject(aof,&key,o) == 0) \textcolor{keywordflow}{goto} werr;
01173             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH}) \{
01174                 \textcolor{keywordflow}{if} (rewriteHashObject(aof,&key,o) == 0) \textcolor{keywordflow}{goto} werr;
01175             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a2c2cc41300ca6b9daca7ea8a6d66edc6}{OBJ\_STREAM}) \{
01176                 \textcolor{keywordflow}{if} (rewriteStreamObject(aof,&key,o) == 0) \textcolor{keywordflow}{goto} werr;
01177             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a92c1fed85f709180fda0ff10d37d649b}{OBJ\_MODULE}) \{
01178                 \textcolor{keywordflow}{if} (rewriteModuleObject(aof,&key,o) == 0) \textcolor{keywordflow}{goto} werr;
01179             \} \textcolor{keywordflow}{else} \{
01180                 \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown object type"});
01181             \}
01182             \textcolor{comment}{/* Save the expire time */}
01183             \textcolor{keywordflow}{if} (expiretime != -1) \{
01184                 \textcolor{keywordtype}{char} cmd[]=\textcolor{stringliteral}{"*3\(\backslash\)r\(\backslash\)n$9\(\backslash\)r\(\backslash\)nPEXPIREAT\(\backslash\)r\(\backslash\)n"};
01185                 \textcolor{keywordflow}{if} (rioWrite(aof,cmd,\textcolor{keyword}{sizeof}(cmd)-1) == 0) \textcolor{keywordflow}{goto} werr;
01186                 \textcolor{keywordflow}{if} (rioWriteBulkObject(aof,&key) == 0) \textcolor{keywordflow}{goto} werr;
01187                 \textcolor{keywordflow}{if} (rioWriteBulkLongLong(aof,expiretime) == 0) \textcolor{keywordflow}{goto} werr;
01188             \}
01189             \textcolor{comment}{/* Read some diff from the parent process from time to time. */}
01190             \textcolor{keywordflow}{if} (aof->processed\_bytes > processed+
      \hyperlink{server_8h_a0044e793bf429aa6921aa7924a2b62e5}{AOF\_READ\_DIFF\_INTERVAL\_BYTES}) \{
01191                 processed = aof->processed\_bytes;
01192                 aofReadDiffFromParent();
01193             \}
01194         \}
01195         dictReleaseIterator(di);
01196         di = NULL;
01197     \}
01198     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01199 
01200 werr:
01201     \textcolor{keywordflow}{if} (di) dictReleaseIterator(di);
01202     \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01203 \}
01204 
01205 \textcolor{comment}{/* Write a sequence of commands able to fully rebuild the dataset into}
01206 \textcolor{comment}{ * "filename". Used both by REWRITEAOF and BGREWRITEAOF.}
01207 \textcolor{comment}{ *}
01208 \textcolor{comment}{ * In order to minimize the number of commands needed in the rewritten}
01209 \textcolor{comment}{ * log Redis uses variadic commands when possible, such as RPUSH, SADD}
01210 \textcolor{comment}{ * and ZADD. However at max AOF\_REWRITE\_ITEMS\_PER\_CMD items per time}
01211 \textcolor{comment}{ * are inserted using a single command. */}
01212 \textcolor{keywordtype}{int} rewriteAppendOnlyFile(\textcolor{keywordtype}{char} *filename) \{
01213     rio aof;
01214     FILE *fp;
01215     \textcolor{keywordtype}{char} tmpfile[256];
01216     \textcolor{keywordtype}{char} byte;
01217 
01218     \textcolor{comment}{/* Note that we have to use a different temp name here compared to the}
01219 \textcolor{comment}{     * one used by rewriteAppendOnlyFileBackground() function. */}
01220     snprintf(tmpfile,256,\textcolor{stringliteral}{"temp-rewriteaof-%d.aof"}, (\textcolor{keywordtype}{int}) getpid());
01221     fp = fopen(tmpfile,\textcolor{stringliteral}{"w"});
01222     \textcolor{keywordflow}{if} (!fp) \{
01223         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"Opening the temp file for AOF rewrite in
       rewriteAppendOnlyFile(): %s"}, strerror(errno));
01224         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01225     \}
01226 
01227     server.aof\_child\_diff = sdsempty();
01228     rioInitWithFile(&aof,fp);
01229 
01230     \textcolor{keywordflow}{if} (server.aof\_rewrite\_incremental\_fsync)
01231         rioSetAutoSync(&aof,\hyperlink{server_8h_a953d4b2370e4b9accbfa596a022a8979}{AOF\_AUTOSYNC\_BYTES});
01232 
01233     \textcolor{keywordflow}{if} (server.aof\_use\_rdb\_preamble) \{
01234         \textcolor{keywordtype}{int} error;
01235         \textcolor{keywordflow}{if} (rdbSaveRio(&aof,&error,\hyperlink{rdb_8h_a0bafda4fc4a08ebf980ba8e2a1bd3b78}{RDB\_SAVE\_AOF\_PREAMBLE},NULL) == 
      \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
01236             errno = error;
01237             \textcolor{keywordflow}{goto} werr;
01238         \}
01239     \} \textcolor{keywordflow}{else} \{
01240         \textcolor{keywordflow}{if} (rewriteAppendOnlyFileRio(&aof) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \textcolor{keywordflow}{goto} werr;
01241     \}
01242 
01243     \textcolor{comment}{/* Do an initial slow fsync here while the parent is still sending}
01244 \textcolor{comment}{     * data, in order to make the next final fsync faster. */}
01245     \textcolor{keywordflow}{if} (fflush(fp) == EOF) \textcolor{keywordflow}{goto} werr;
01246     \textcolor{keywordflow}{if} (fsync(fileno(fp)) == -1) \textcolor{keywordflow}{goto} werr;
01247 
01248     \textcolor{comment}{/* Read again a few times to get more data from the parent.}
01249 \textcolor{comment}{     * We can't read forever (the server may receive data from clients}
01250 \textcolor{comment}{     * faster than it is able to send data to the child), so we try to read}
01251 \textcolor{comment}{     * some more data in a loop as soon as there is a good chance more data}
01252 \textcolor{comment}{     * will come. If it looks like we are wasting time, we abort (this}
01253 \textcolor{comment}{     * happens after 20 ms without new data). */}
01254     \textcolor{keywordtype}{int} nodata = 0;
01255     mstime\_t start = mstime();
01256     \textcolor{keywordflow}{while}(mstime()-start < 1000 && nodata < 20) \{
01257         \textcolor{keywordflow}{if} (aeWait(server.aof\_pipe\_read\_data\_from\_parent, \hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE}, 1) <= 0)
01258         \{
01259             nodata++;
01260             \textcolor{keywordflow}{continue};
01261         \}
01262         nodata = 0; \textcolor{comment}{/* Start counting from zero, we stop on N *contiguous*}
01263 \textcolor{comment}{                       timeouts. */}
01264         aofReadDiffFromParent();
01265     \}
01266 
01267     \textcolor{comment}{/* Ask the master to stop sending diffs. */}
01268     \textcolor{keywordflow}{if} (write(server.aof\_pipe\_write\_ack\_to\_parent,\textcolor{stringliteral}{"!"},1) != 1) \textcolor{keywordflow}{goto} werr;
01269     \textcolor{keywordflow}{if} (anetNonBlock(NULL,server.aof\_pipe\_read\_ack\_from\_parent) != \hyperlink{anet_8h_a25fb91ccc6457153f6d2e21380d4c6cf}{ANET\_OK})
01270         \textcolor{keywordflow}{goto} werr;
01271     \textcolor{comment}{/* We read the ACK from the server using a 10 seconds timeout. Normally}
01272 \textcolor{comment}{     * it should reply ASAP, but just in case we lose its reply, we are sure}
01273 \textcolor{comment}{     * the child will eventually get terminated. */}
01274     \textcolor{keywordflow}{if} (syncRead(server.aof\_pipe\_read\_ack\_from\_parent,&byte,1,5000) != 1 ||
01275         byte != \textcolor{stringliteral}{'!'}) \textcolor{keywordflow}{goto} werr;
01276     serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Parent agreed to stop sending diffs. Finalizing AOF..."});
01277 
01278     \textcolor{comment}{/* Read the final diff if any. */}
01279     aofReadDiffFromParent();
01280 
01281     \textcolor{comment}{/* Write the received diff to the file. */}
01282     serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01283         \textcolor{stringliteral}{"Concatenating %.2f MB of AOF diff received from parent."},
01284         (\textcolor{keywordtype}{double}) sdslen(server.aof\_child\_diff) / (1024*1024));
01285     \textcolor{keywordflow}{if} (rioWrite(&aof,server.aof\_child\_diff,sdslen(server.aof\_child\_diff)) == 0)
01286         \textcolor{keywordflow}{goto} werr;
01287 
01288     \textcolor{comment}{/* Make sure data will not remain on the OS's output buffers */}
01289     \textcolor{keywordflow}{if} (fflush(fp) == EOF) \textcolor{keywordflow}{goto} werr;
01290     \textcolor{keywordflow}{if} (fsync(fileno(fp)) == -1) \textcolor{keywordflow}{goto} werr;
01291     \textcolor{keywordflow}{if} (fclose(fp) == EOF) \textcolor{keywordflow}{goto} werr;
01292 
01293     \textcolor{comment}{/* Use RENAME to make sure the DB file is changed atomically only}
01294 \textcolor{comment}{     * if the generate DB file is ok. */}
01295     \textcolor{keywordflow}{if} (rename(tmpfile,filename) == -1) \{
01296         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Error moving temp append only file on the final destination:
       %s"}, strerror(errno));
01297         unlink(tmpfile);
01298         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01299     \}
01300     serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"SYNC append only file rewrite performed"});
01301     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01302 
01303 werr:
01304     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Write error writing append only file on disk: %s"}, strerror(errno)
      );
01305     fclose(fp);
01306     unlink(tmpfile);
01307     \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01308 \}
01309 
01310 \textcolor{comment}{/* ----------------------------------------------------------------------------}
01311 \textcolor{comment}{ * AOF rewrite pipes for IPC}
01312 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
01313 
01314 \textcolor{comment}{/* This event handler is called when the AOF rewriting child sends us a}
01315 \textcolor{comment}{ * single '!' char to signal we should stop sending buffer diffs. The}
01316 \textcolor{comment}{ * parent sends a '!' as well to acknowledge. */}
01317 \textcolor{keywordtype}{void} aofChildPipeReadable(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask) \{
01318     \textcolor{keywordtype}{char} byte;
01319     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(el);
01320     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(privdata);
01321     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(mask);
01322 
01323     \textcolor{keywordflow}{if} (read(fd,&byte,1) == 1 && byte == \textcolor{stringliteral}{'!'}) \{
01324         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"AOF rewrite child asks to stop sending diffs."});
01325         server.aof\_stop\_sending\_diff = 1;
01326         \textcolor{keywordflow}{if} (write(server.aof\_pipe\_write\_ack\_to\_child,\textcolor{stringliteral}{"!"},1) != 1) \{
01327             \textcolor{comment}{/* If we can't send the ack, inform the user, but don't try again}
01328 \textcolor{comment}{             * since in the other side the children will use a timeout if the}
01329 \textcolor{comment}{             * kernel can't buffer our write, or, the children was}
01330 \textcolor{comment}{             * terminated. */}
01331             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Can't send ACK to AOF child: %s"},
01332                 strerror(errno));
01333         \}
01334     \}
01335     \textcolor{comment}{/* Remove the handler since this can be called only one time during a}
01336 \textcolor{comment}{     * rewrite. */}
01337     aeDeleteFileEvent(server.el,server.aof\_pipe\_read\_ack\_from\_child,
      \hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE});
01338 \}
01339 
01340 \textcolor{comment}{/* Create the pipes used for parent - child process IPC during rewrite.}
01341 \textcolor{comment}{ * We have a data pipe used to send AOF incremental diffs to the child,}
01342 \textcolor{comment}{ * and two other pipes used by the children to signal it finished with}
01343 \textcolor{comment}{ * the rewrite so no more data should be written, and another for the}
01344 \textcolor{comment}{ * parent to acknowledge it understood this new condition. */}
01345 \textcolor{keywordtype}{int} aofCreatePipes(\textcolor{keywordtype}{void}) \{
01346     \textcolor{keywordtype}{int} fds[6] = \{-1, -1, -1, -1, -1, -1\};
01347     \textcolor{keywordtype}{int} j;
01348 
01349     \textcolor{keywordflow}{if} (pipe(fds) == -1) \textcolor{keywordflow}{goto} error; \textcolor{comment}{/* parent -> children data. */}
01350     \textcolor{keywordflow}{if} (pipe(fds+2) == -1) \textcolor{keywordflow}{goto} error; \textcolor{comment}{/* children -> parent ack. */}
01351     \textcolor{keywordflow}{if} (pipe(fds+4) == -1) \textcolor{keywordflow}{goto} error; \textcolor{comment}{/* children -> parent ack. */}
01352     \textcolor{comment}{/* Parent -> children data is non blocking. */}
01353     \textcolor{keywordflow}{if} (anetNonBlock(NULL,fds[0]) != \hyperlink{anet_8h_a25fb91ccc6457153f6d2e21380d4c6cf}{ANET\_OK}) \textcolor{keywordflow}{goto} error;
01354     \textcolor{keywordflow}{if} (anetNonBlock(NULL,fds[1]) != \hyperlink{anet_8h_a25fb91ccc6457153f6d2e21380d4c6cf}{ANET\_OK}) \textcolor{keywordflow}{goto} error;
01355     \textcolor{keywordflow}{if} (aeCreateFileEvent(server.el, fds[2], \hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE}, aofChildPipeReadable, NULL) == 
      \hyperlink{ae_8h_aa16dcf7effdf8f8df97f51b1cb51a9df}{AE\_ERR}) \textcolor{keywordflow}{goto} error;
01356 
01357     server.aof\_pipe\_write\_data\_to\_child = fds[1];
01358     server.aof\_pipe\_read\_data\_from\_parent = fds[0];
01359     server.aof\_pipe\_write\_ack\_to\_parent = fds[3];
01360     server.aof\_pipe\_read\_ack\_from\_child = fds[2];
01361     server.aof\_pipe\_write\_ack\_to\_child = fds[5];
01362     server.aof\_pipe\_read\_ack\_from\_parent = fds[4];
01363     server.aof\_stop\_sending\_diff = 0;
01364     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01365 
01366 error:
01367     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Error opening /setting AOF rewrite IPC pipes: %s"},
01368         strerror(errno));
01369     \textcolor{keywordflow}{for} (j = 0; j < 6; j++) \textcolor{keywordflow}{if}(fds[j] != -1) close(fds[j]);
01370     \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01371 \}
01372 
01373 \textcolor{keywordtype}{void} aofClosePipes(\textcolor{keywordtype}{void}) \{
01374     aeDeleteFileEvent(server.el,server.aof\_pipe\_read\_ack\_from\_child,
      \hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE});
01375     aeDeleteFileEvent(server.el,server.aof\_pipe\_write\_data\_to\_child,
      \hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE});
01376     close(server.aof\_pipe\_write\_data\_to\_child);
01377     close(server.aof\_pipe\_read\_data\_from\_parent);
01378     close(server.aof\_pipe\_write\_ack\_to\_parent);
01379     close(server.aof\_pipe\_read\_ack\_from\_child);
01380     close(server.aof\_pipe\_write\_ack\_to\_child);
01381     close(server.aof\_pipe\_read\_ack\_from\_parent);
01382 \}
01383 
01384 \textcolor{comment}{/* ----------------------------------------------------------------------------}
01385 \textcolor{comment}{ * AOF background rewrite}
01386 \textcolor{comment}{ * ------------------------------------------------------------------------- */}
01387 
01388 \textcolor{comment}{/* This is how rewriting of the append only file in background works:}
01389 \textcolor{comment}{ *}
01390 \textcolor{comment}{ * 1) The user calls BGREWRITEAOF}
01391 \textcolor{comment}{ * 2) Redis calls this function, that forks():}
01392 \textcolor{comment}{ *    2a) the child rewrite the append only file in a temp file.}
01393 \textcolor{comment}{ *    2b) the parent accumulates differences in server.aof\_rewrite\_buf.}
01394 \textcolor{comment}{ * 3) When the child finished '2a' exists.}
01395 \textcolor{comment}{ * 4) The parent will trap the exit code, if it's OK, will append the}
01396 \textcolor{comment}{ *    data accumulated into server.aof\_rewrite\_buf into the temp file, and}
01397 \textcolor{comment}{ *    finally will rename(2) the temp file in the actual file name.}
01398 \textcolor{comment}{ *    The the new file is reopened as the new append only file. Profit!}
01399 \textcolor{comment}{ */}
01400 \textcolor{keywordtype}{int} rewriteAppendOnlyFileBackground(\textcolor{keywordtype}{void}) \{
01401     pid\_t childpid;
01402     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} start;
01403 
01404     \textcolor{keywordflow}{if} (server.aof\_child\_pid != -1 || server.rdb\_child\_pid != -1) \textcolor{keywordflow}{return} 
      \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01405     \textcolor{keywordflow}{if} (aofCreatePipes() != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01406     openChildInfoPipe();
01407     start = ustime();
01408     \textcolor{keywordflow}{if} ((childpid = fork()) == 0) \{
01409         \textcolor{keywordtype}{char} tmpfile[256];
01410 
01411         \textcolor{comment}{/* Child */}
01412         closeListeningSockets(0);
01413         redisSetProcTitle(\textcolor{stringliteral}{"redis-aof-rewrite"});
01414         snprintf(tmpfile,256,\textcolor{stringliteral}{"temp-rewriteaof-bg-%d.aof"}, (\textcolor{keywordtype}{int}) getpid());
01415         \textcolor{keywordflow}{if} (rewriteAppendOnlyFile(tmpfile) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
01416             size\_t private\_dirty = zmalloc\_get\_private\_dirty(-1);
01417 
01418             \textcolor{keywordflow}{if} (private\_dirty) \{
01419                 serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01420                     \textcolor{stringliteral}{"AOF rewrite: %zu MB of memory used by copy-on-write"},
01421                     private\_dirty/(1024*1024));
01422             \}
01423 
01424             server.child\_info\_data.cow\_size = private\_dirty;
01425             sendChildInfo(\hyperlink{server_8h_a9b759a9f6c6f785433572ab86a3ed214}{CHILD\_INFO\_TYPE\_AOF});
01426             exitFromChild(0);
01427         \} \textcolor{keywordflow}{else} \{
01428             exitFromChild(1);
01429         \}
01430     \} \textcolor{keywordflow}{else} \{
01431         \textcolor{comment}{/* Parent */}
01432         server.stat\_fork\_time = ustime()-start;
01433         server.stat\_fork\_rate = (\textcolor{keywordtype}{double}) zmalloc\_used\_memory() * 1000000 / server.stat\_fork\_time / (
      1024*1024*1024); \textcolor{comment}{/* GB per second. */}
01434         \hyperlink{latency_8h_a77922ab34035890c90f98831a9071359}{latencyAddSampleIfNeeded}(\textcolor{stringliteral}{"fork"},server.stat\_fork\_time/1000);
01435         \textcolor{keywordflow}{if} (childpid == -1) \{
01436             closeChildInfoPipe();
01437             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01438                 \textcolor{stringliteral}{"Can't rewrite append only file in background: fork: %s"},
01439                 strerror(errno));
01440             aofClosePipes();
01441             \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01442         \}
01443         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01444             \textcolor{stringliteral}{"Background append only file rewriting started by pid %d"},childpid);
01445         server.aof\_rewrite\_scheduled = 0;
01446         server.aof\_rewrite\_time\_start = time(NULL);
01447         server.aof\_child\_pid = childpid;
01448         updateDictResizePolicy();
01449         \textcolor{comment}{/* We set appendseldb to -1 in order to force the next call to the}
01450 \textcolor{comment}{         * feedAppendOnlyFile() to issue a SELECT command, so the differences}
01451 \textcolor{comment}{         * accumulated by the parent into server.aof\_rewrite\_buf will start}
01452 \textcolor{comment}{         * with a SELECT statement and it will be safe to merge. */}
01453         server.aof\_selected\_db = -1;
01454         replicationScriptCacheFlush();
01455         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01456     \}
01457     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}; \textcolor{comment}{/* unreached */}
01458 \}
01459 
01460 \textcolor{keywordtype}{void} bgrewriteaofCommand(\hyperlink{structclient}{client} *c) \{
01461     \textcolor{keywordflow}{if} (server.aof\_child\_pid != -1) \{
01462         addReplyError(c,\textcolor{stringliteral}{"Background append only file rewriting already in progress"});
01463     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.rdb\_child\_pid != -1) \{
01464         server.aof\_rewrite\_scheduled = 1;
01465         addReplyStatus(c,\textcolor{stringliteral}{"Background append only file rewriting scheduled"});
01466     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rewriteAppendOnlyFileBackground() == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
01467         addReplyStatus(c,\textcolor{stringliteral}{"Background append only file rewriting started"});
01468     \} \textcolor{keywordflow}{else} \{
01469         addReply(c,shared.err);
01470     \}
01471 \}
01472 
01473 \textcolor{keywordtype}{void} aofRemoveTempFile(pid\_t childpid) \{
01474     \textcolor{keywordtype}{char} tmpfile[256];
01475 
01476     snprintf(tmpfile,256,\textcolor{stringliteral}{"temp-rewriteaof-bg-%d.aof"}, (\textcolor{keywordtype}{int}) childpid);
01477     unlink(tmpfile);
01478 \}
01479 
01480 \textcolor{comment}{/* Update the server.aof\_current\_size field explicitly using stat(2)}
01481 \textcolor{comment}{ * to check the size of the file. This is useful after a rewrite or after}
01482 \textcolor{comment}{ * a restart, normally the size is updated just adding the write length}
01483 \textcolor{comment}{ * to the current length, that is much faster. */}
01484 \textcolor{keywordtype}{void} aofUpdateCurrentSize(\textcolor{keywordtype}{void}) \{
01485     \textcolor{keyword}{struct} \hyperlink{config_8h_ae18037d20ab1bc7c716ea0bcb506f7af}{redis\_stat} sb;
01486     mstime\_t latency;
01487 
01488     \hyperlink{latency_8h_a87d7b5b368dad97457f13466d760b0e1}{latencyStartMonitor}(latency);
01489     \textcolor{keywordflow}{if} (\hyperlink{config_8h_a7fb7329d05a6b4d1b1e7a3fac44c0668}{redis\_fstat}(server.aof\_fd,&sb) == -1) \{
01490         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Unable to obtain the AOF file length. stat: %s"},
01491             strerror(errno));
01492     \} \textcolor{keywordflow}{else} \{
01493         server.aof\_current\_size = sb.st\_size;
01494     \}
01495     \hyperlink{latency_8h_a88461aee20da0a648fe3332b5f068df7}{latencyEndMonitor}(latency);
01496     \hyperlink{latency_8h_a77922ab34035890c90f98831a9071359}{latencyAddSampleIfNeeded}(\textcolor{stringliteral}{"aof-fstat"},latency);
01497 \}
01498 
01499 \textcolor{comment}{/* A background append only file rewriting (BGREWRITEAOF) terminated its work.}
01500 \textcolor{comment}{ * Handle this. */}
01501 \textcolor{keywordtype}{void} backgroundRewriteDoneHandler(\textcolor{keywordtype}{int} exitcode, \textcolor{keywordtype}{int} bysignal) \{
01502     \textcolor{keywordflow}{if} (!bysignal && exitcode == 0) \{
01503         \textcolor{keywordtype}{int} newfd, oldfd;
01504         \textcolor{keywordtype}{char} tmpfile[256];
01505         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} now = ustime();
01506         mstime\_t latency;
01507 
01508         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01509             \textcolor{stringliteral}{"Background AOF rewrite terminated with success"});
01510 
01511         \textcolor{comment}{/* Flush the differences accumulated by the parent to the}
01512 \textcolor{comment}{         * rewritten AOF. */}
01513         \hyperlink{latency_8h_a87d7b5b368dad97457f13466d760b0e1}{latencyStartMonitor}(latency);
01514         snprintf(tmpfile,256,\textcolor{stringliteral}{"temp-rewriteaof-bg-%d.aof"},
01515             (\textcolor{keywordtype}{int})server.aof\_child\_pid);
01516         newfd = open(tmpfile,O\_WRONLY|O\_APPEND);
01517         \textcolor{keywordflow}{if} (newfd == -1) \{
01518             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01519                 \textcolor{stringliteral}{"Unable to open the temporary AOF produced by the child: %s"}, strerror(errno));
01520             \textcolor{keywordflow}{goto} cleanup;
01521         \}
01522 
01523         \textcolor{keywordflow}{if} (aofRewriteBufferWrite(newfd) == -1) \{
01524             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01525                 \textcolor{stringliteral}{"Error trying to flush the parent diff to the rewritten AOF: %s"}, strerror(errno));
01526             close(newfd);
01527             \textcolor{keywordflow}{goto} cleanup;
01528         \}
01529         \hyperlink{latency_8h_a88461aee20da0a648fe3332b5f068df7}{latencyEndMonitor}(latency);
01530         \hyperlink{latency_8h_a77922ab34035890c90f98831a9071359}{latencyAddSampleIfNeeded}(\textcolor{stringliteral}{"aof-rewrite-diff-write"},latency);
01531 
01532         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01533             \textcolor{stringliteral}{"Residual parent diff successfully flushed to the rewritten AOF (%.2f MB)"}, (\textcolor{keywordtype}{double}) 
      aofRewriteBufferSize() / (1024*1024));
01534 
01535         \textcolor{comment}{/* The only remaining thing to do is to rename the temporary file to}
01536 \textcolor{comment}{         * the configured file and switch the file descriptor used to do AOF}
01537 \textcolor{comment}{         * writes. We don't want close(2) or rename(2) calls to block the}
01538 \textcolor{comment}{         * server on old file deletion.}
01539 \textcolor{comment}{         *}
01540 \textcolor{comment}{         * There are two possible scenarios:}
01541 \textcolor{comment}{         *}
01542 \textcolor{comment}{         * 1) AOF is DISABLED and this was a one time rewrite. The temporary}
01543 \textcolor{comment}{         * file will be renamed to the configured file. When this file already}
01544 \textcolor{comment}{         * exists, it will be unlinked, which may block the server.}
01545 \textcolor{comment}{         *}
01546 \textcolor{comment}{         * 2) AOF is ENABLED and the rewritten AOF will immediately start}
01547 \textcolor{comment}{         * receiving writes. After the temporary file is renamed to the}
01548 \textcolor{comment}{         * configured file, the original AOF file descriptor will be closed.}
01549 \textcolor{comment}{         * Since this will be the last reference to that file, closing it}
01550 \textcolor{comment}{         * causes the underlying file to be unlinked, which may block the}
01551 \textcolor{comment}{         * server.}
01552 \textcolor{comment}{         *}
01553 \textcolor{comment}{         * To mitigate the blocking effect of the unlink operation (either}
01554 \textcolor{comment}{         * caused by rename(2) in scenario 1, or by close(2) in scenario 2), we}
01555 \textcolor{comment}{         * use a background thread to take care of this. First, we}
01556 \textcolor{comment}{         * make scenario 1 identical to scenario 2 by opening the target file}
01557 \textcolor{comment}{         * when it exists. The unlink operation after the rename(2) will then}
01558 \textcolor{comment}{         * be executed upon calling close(2) for its descriptor. Everything to}
01559 \textcolor{comment}{         * guarantee atomicity for this switch has already happened by then, so}
01560 \textcolor{comment}{         * we don't care what the outcome or duration of that close operation}
01561 \textcolor{comment}{         * is, as long as the file descriptor is released again. */}
01562         \textcolor{keywordflow}{if} (server.aof\_fd == -1) \{
01563             \textcolor{comment}{/* AOF disabled */}
01564 
01565              \textcolor{comment}{/* Don't care if this fails: oldfd will be -1 and we handle that.}
01566 \textcolor{comment}{              * One notable case of -1 return is if the old file does}
01567 \textcolor{comment}{              * not exist. */}
01568              oldfd = open(server.aof\_filename,O\_RDONLY|O\_NONBLOCK);
01569         \} \textcolor{keywordflow}{else} \{
01570             \textcolor{comment}{/* AOF enabled */}
01571             oldfd = -1; \textcolor{comment}{/* We'll set this to the current AOF filedes later. */}
01572         \}
01573 
01574         \textcolor{comment}{/* Rename the temporary file. This will not unlink the target file if}
01575 \textcolor{comment}{         * it exists, because we reference it with "oldfd". */}
01576         \hyperlink{latency_8h_a87d7b5b368dad97457f13466d760b0e1}{latencyStartMonitor}(latency);
01577         \textcolor{keywordflow}{if} (rename(tmpfile,server.aof\_filename) == -1) \{
01578             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01579                 \textcolor{stringliteral}{"Error trying to rename the temporary AOF file %s into %s: %s"},
01580                 tmpfile,
01581                 server.aof\_filename,
01582                 strerror(errno));
01583             close(newfd);
01584             \textcolor{keywordflow}{if} (oldfd != -1) close(oldfd);
01585             \textcolor{keywordflow}{goto} cleanup;
01586         \}
01587         \hyperlink{latency_8h_a88461aee20da0a648fe3332b5f068df7}{latencyEndMonitor}(latency);
01588         \hyperlink{latency_8h_a77922ab34035890c90f98831a9071359}{latencyAddSampleIfNeeded}(\textcolor{stringliteral}{"aof-rename"},latency);
01589 
01590         \textcolor{keywordflow}{if} (server.aof\_fd == -1) \{
01591             \textcolor{comment}{/* AOF disabled, we don't need to set the AOF file descriptor}
01592 \textcolor{comment}{             * to this new file, so we can close it. */}
01593             close(newfd);
01594         \} \textcolor{keywordflow}{else} \{
01595             \textcolor{comment}{/* AOF enabled, replace the old fd with the new one. */}
01596             oldfd = server.aof\_fd;
01597             server.aof\_fd = newfd;
01598             \textcolor{keywordflow}{if} (server.\hyperlink{config_8h_af5994c643c434574580bb7816af82cad}{aof\_fsync} == \hyperlink{server_8h_a83bfec10b7b4be60ec6d5868cadc73bb}{AOF\_FSYNC\_ALWAYS})
01599                 \hyperlink{config_8h_af5994c643c434574580bb7816af82cad}{aof\_fsync}(newfd);
01600             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.\hyperlink{config_8h_af5994c643c434574580bb7816af82cad}{aof\_fsync} == \hyperlink{server_8h_a9784233b87ec796d0343556106fb778e}{AOF\_FSYNC\_EVERYSEC})
01601                 aof\_background\_fsync(newfd);
01602             server.aof\_selected\_db = -1; \textcolor{comment}{/* Make sure SELECT is re-issued */}
01603             aofUpdateCurrentSize();
01604             server.aof\_rewrite\_base\_size = server.aof\_current\_size;
01605 
01606             \textcolor{comment}{/* Clear regular AOF buffer since its contents was just written to}
01607 \textcolor{comment}{             * the new AOF from the background rewrite buffer. */}
01608             sdsfree(server.aof\_buf);
01609             server.aof\_buf = sdsempty();
01610         \}
01611 
01612         server.aof\_lastbgrewrite\_status = \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01613 
01614         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE}, \textcolor{stringliteral}{"Background AOF rewrite finished successfully"});
01615         \textcolor{comment}{/* Change state from WAIT\_REWRITE to ON if needed */}
01616         \textcolor{keywordflow}{if} (server.aof\_state == \hyperlink{server_8h_a7d4b86c89be4d951fbf048130431a16a}{AOF\_WAIT\_REWRITE})
01617             server.aof\_state = \hyperlink{server_8h_af6b151c9dced28e94c19479197113a83}{AOF\_ON};
01618 
01619         \textcolor{comment}{/* Asynchronously close the overwritten AOF. */}
01620         \textcolor{keywordflow}{if} (oldfd != -1) bioCreateBackgroundJob(\hyperlink{bio_8h_ac5890d1af5c5d32376c47ad6b83c2af4}{BIO\_CLOSE\_FILE},(\textcolor{keywordtype}{void}*)(\textcolor{keywordtype}{long})oldfd,NULL,
      NULL);
01621 
01622         serverLog(\hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE},
01623             \textcolor{stringliteral}{"Background AOF rewrite signal handler took %lldus"}, ustime()-now);
01624     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!bysignal && exitcode != 0) \{
01625         \textcolor{comment}{/* SIGUSR1 is whitelisted, so we have a way to kill a child without}
01626 \textcolor{comment}{         * tirggering an error conditon. */}
01627         \textcolor{keywordflow}{if} (bysignal != SIGUSR1)
01628             server.aof\_lastbgrewrite\_status = \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01629         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01630             \textcolor{stringliteral}{"Background AOF rewrite terminated with error"});
01631     \} \textcolor{keywordflow}{else} \{
01632         server.aof\_lastbgrewrite\_status = \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01633 
01634         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01635             \textcolor{stringliteral}{"Background AOF rewrite terminated by signal %d"}, bysignal);
01636     \}
01637 
01638 cleanup:
01639     aofClosePipes();
01640     aofRewriteBufferReset();
01641     aofRemoveTempFile(server.aof\_child\_pid);
01642     server.aof\_child\_pid = -1;
01643     server.aof\_rewrite\_time\_last = time(NULL)-server.aof\_rewrite\_time\_start;
01644     server.aof\_rewrite\_time\_start = -1;
01645     \textcolor{comment}{/* Schedule a new rewrite if we are waiting for it to switch the AOF ON. */}
01646     \textcolor{keywordflow}{if} (server.aof\_state == \hyperlink{server_8h_a7d4b86c89be4d951fbf048130431a16a}{AOF\_WAIT\_REWRITE})
01647         server.aof\_rewrite\_scheduled = 1;
01648 \}
\end{DoxyCode}
