\hypertarget{sds_8c_source}{}\section{sds.\+c}
\label{sds_8c_source}\index{src/sds.\+c@{src/sds.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* SDSLib 2.0 -- A C dynamic strings library}
00002 \textcolor{comment}{ *}
00003 \textcolor{comment}{ * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>}
00004 \textcolor{comment}{ * Copyright (c) 2015, Oran Agra}
00005 \textcolor{comment}{ * Copyright (c) 2015, Redis Labs, Inc}
00006 \textcolor{comment}{ * All rights reserved.}
00007 \textcolor{comment}{ *}
00008 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00009 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00010 \textcolor{comment}{ *}
00011 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00012 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00013 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00014 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00015 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00016 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00017 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00018 \textcolor{comment}{ *     specific prior written permission.}
00019 \textcolor{comment}{ *}
00020 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00021 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00022 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00023 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00024 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00025 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00026 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00027 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00028 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00029 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00030 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00031 \textcolor{comment}{ */}
00032 
00033 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdio}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00034 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdlib}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00035 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{string}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00036 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{ctype}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00037 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{assert}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00038 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{limits}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00039 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{sds_8h}{"sds.h"}
00040 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{sdsalloc_8h}{"sdsalloc.h"}
00041 
00042 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} sdsHdrSize(\textcolor{keywordtype}{char} type) \{
00043     \textcolor{keywordflow}{switch}(type&\hyperlink{sds_8h_a07564783f389fdd7772a8f61d55d9ddf}{SDS\_TYPE\_MASK}) \{
00044         \textcolor{keywordflow}{case} \hyperlink{sds_8h_a3b7b67f1efa75f6b78ae18ea853b1a91}{SDS\_TYPE\_5}:
00045             \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} sdshdr5);
00046         \textcolor{keywordflow}{case} \hyperlink{sds_8h_a504136356f04bfa2fd616dd4c8fdd71c}{SDS\_TYPE\_8}:
00047             \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} sdshdr8);
00048         \textcolor{keywordflow}{case} \hyperlink{sds_8h_aa54044bf70a30824caeb1bab3615bff2}{SDS\_TYPE\_16}:
00049             \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} sdshdr16);
00050         \textcolor{keywordflow}{case} \hyperlink{sds_8h_a0ad2103bbdaa2fe5511ce3279cb42293}{SDS\_TYPE\_32}:
00051             \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} sdshdr32);
00052         \textcolor{keywordflow}{case} \hyperlink{sds_8h_ad03c6e0fdab3a871e10cce347e8bb4e6}{SDS\_TYPE\_64}:
00053             \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} sdshdr64);
00054     \}
00055     \textcolor{keywordflow}{return} 0;
00056 \}
00057 
00058 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{char} sdsReqType(size\_t string\_size) \{
00059     \textcolor{keywordflow}{if} (string\_size < 1<<5)
00060         \textcolor{keywordflow}{return} \hyperlink{sds_8h_a3b7b67f1efa75f6b78ae18ea853b1a91}{SDS\_TYPE\_5};
00061     \textcolor{keywordflow}{if} (string\_size < 1<<8)
00062         \textcolor{keywordflow}{return} \hyperlink{sds_8h_a504136356f04bfa2fd616dd4c8fdd71c}{SDS\_TYPE\_8};
00063     \textcolor{keywordflow}{if} (string\_size < 1<<16)
00064         \textcolor{keywordflow}{return} \hyperlink{sds_8h_aa54044bf70a30824caeb1bab3615bff2}{SDS\_TYPE\_16};
00065 \textcolor{preprocessor}{#}\textcolor{preprocessor}{if} \textcolor{preprocessor}{(}\textcolor{preprocessor}{LONG\_MAX} \textcolor{preprocessor}{==} LLONG\_MAX\textcolor{preprocessor}{)}
00066     \textcolor{keywordflow}{if} (string\_size < 1ll<<32)
00067         \textcolor{keywordflow}{return} SDS\_TYPE\_32;
00068 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
00069     \textcolor{keywordflow}{return} \hyperlink{sds_8h_ad03c6e0fdab3a871e10cce347e8bb4e6}{SDS\_TYPE\_64};
00070 \}
00071 
00072 \textcolor{comment}{/* Create a new sds string with the content specified by the 'init' pointer}
00073 \textcolor{comment}{ * and 'initlen'.}
00074 \textcolor{comment}{ * If NULL is used for 'init' the string is initialized with zero bytes.}
00075 \textcolor{comment}{ *}
00076 \textcolor{comment}{ * The string is always null-termined (all the sds strings are, always) so}
00077 \textcolor{comment}{ * even if you create an sds string with:}
00078 \textcolor{comment}{ *}
00079 \textcolor{comment}{ * mystring = sdsnewlen("abc",3);}
00080 \textcolor{comment}{ *}
00081 \textcolor{comment}{ * You can print the string with printf() as there is an implicit \(\backslash\)0 at the}
00082 \textcolor{comment}{ * end of the string. However the string is binary safe and can contain}
00083 \textcolor{comment}{ * \(\backslash\)0 characters in the middle, as the length is stored in the sds header. */}
00084 sds sdsnewlen(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *init, size\_t initlen) \{
00085     \textcolor{keywordtype}{void} *sh;
00086     sds s;
00087     \textcolor{keywordtype}{char} type = sdsReqType(initlen);
00088     \textcolor{comment}{/* Empty strings are usually created in order to append. Use type 8}
00089 \textcolor{comment}{     * since type 5 is not good at this. */}
00090     \textcolor{keywordflow}{if} (type == \hyperlink{sds_8h_a3b7b67f1efa75f6b78ae18ea853b1a91}{SDS\_TYPE\_5} && initlen == 0) type = \hyperlink{sds_8h_a504136356f04bfa2fd616dd4c8fdd71c}{SDS\_TYPE\_8};
00091     \textcolor{keywordtype}{int} hdrlen = sdsHdrSize(type);
00092     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *fp; \textcolor{comment}{/* flags pointer. */}
00093 
00094     sh = \hyperlink{sdsalloc_8h_a41e8c1188dca30db85c410c25fb417b6}{s\_malloc}(hdrlen+initlen+1);
00095     \textcolor{keywordflow}{if} (!init)
00096         memset(sh, 0, hdrlen+initlen+1);
00097     \textcolor{keywordflow}{if} (sh == NULL) \textcolor{keywordflow}{return} NULL;
00098     s = (\textcolor{keywordtype}{char}*)sh+hdrlen;
00099     fp = ((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)s)-1;
00100     \textcolor{keywordflow}{switch}(type) \{
00101         \textcolor{keywordflow}{case} \hyperlink{sds_8h_a3b7b67f1efa75f6b78ae18ea853b1a91}{SDS\_TYPE\_5}: \{
00102             *fp = type | (initlen << \hyperlink{sds_8h_aab3be62faa5a2354242a1c1036450a40}{SDS\_TYPE\_BITS});
00103             \textcolor{keywordflow}{break};
00104         \}
00105         \textcolor{keywordflow}{case} \hyperlink{sds_8h_a504136356f04bfa2fd616dd4c8fdd71c}{SDS\_TYPE\_8}: \{
00106             \hyperlink{sds_8h_a79b76920d1d9bc010926b7af167de89b}{SDS\_HDR\_VAR}(8,s);
00107             sh->len = initlen;
00108             sh->alloc = initlen;
00109             *fp = type;
00110             \textcolor{keywordflow}{break};
00111         \}
00112         \textcolor{keywordflow}{case} \hyperlink{sds_8h_aa54044bf70a30824caeb1bab3615bff2}{SDS\_TYPE\_16}: \{
00113             \hyperlink{sds_8h_a79b76920d1d9bc010926b7af167de89b}{SDS\_HDR\_VAR}(16,s);
00114             sh->len = initlen;
00115             sh->alloc = initlen;
00116             *fp = type;
00117             \textcolor{keywordflow}{break};
00118         \}
00119         \textcolor{keywordflow}{case} \hyperlink{sds_8h_a0ad2103bbdaa2fe5511ce3279cb42293}{SDS\_TYPE\_32}: \{
00120             \hyperlink{sds_8h_a79b76920d1d9bc010926b7af167de89b}{SDS\_HDR\_VAR}(32,s);
00121             sh->len = initlen;
00122             sh->alloc = initlen;
00123             *fp = type;
00124             \textcolor{keywordflow}{break};
00125         \}
00126         \textcolor{keywordflow}{case} \hyperlink{sds_8h_ad03c6e0fdab3a871e10cce347e8bb4e6}{SDS\_TYPE\_64}: \{
00127             \hyperlink{sds_8h_a79b76920d1d9bc010926b7af167de89b}{SDS\_HDR\_VAR}(64,s);
00128             sh->len = initlen;
00129             sh->alloc = initlen;
00130             *fp = type;
00131             \textcolor{keywordflow}{break};
00132         \}
00133     \}
00134     \textcolor{keywordflow}{if} (initlen && init)
00135         memcpy(s, init, initlen);
00136     s[initlen] = \textcolor{stringliteral}{'\(\backslash\)0'};
00137     \textcolor{keywordflow}{return} s;
00138 \}
00139 
00140 \textcolor{comment}{/* Create an empty (zero length) sds string. Even in this case the string}
00141 \textcolor{comment}{ * always has an implicit null term. */}
00142 sds sdsempty(\textcolor{keywordtype}{void}) \{
00143     \textcolor{keywordflow}{return} sdsnewlen(\textcolor{stringliteral}{""},0);
00144 \}
00145 
00146 \textcolor{comment}{/* Create a new sds string starting from a null terminated C string. */}
00147 sds sdsnew(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *init) \{
00148     size\_t initlen = (init == NULL) ? 0 : strlen(init);
00149     \textcolor{keywordflow}{return} sdsnewlen(init, initlen);
00150 \}
00151 
00152 \textcolor{comment}{/* Duplicate an sds string. */}
00153 sds sdsdup(\textcolor{keyword}{const} sds s) \{
00154     \textcolor{keywordflow}{return} sdsnewlen(s, sdslen(s));
00155 \}
00156 
00157 \textcolor{comment}{/* Free an sds string. No operation is performed if 's' is NULL. */}
00158 \textcolor{keywordtype}{void} sdsfree(sds s) \{
00159     \textcolor{keywordflow}{if} (s == NULL) \textcolor{keywordflow}{return};
00160     \hyperlink{sdsalloc_8h_aa06cb49194c292098a753d87e2ac6b71}{s\_free}((\textcolor{keywordtype}{char}*)s-sdsHdrSize(s[-1]));
00161 \}
00162 
00163 \textcolor{comment}{/* Set the sds string length to the length as obtained with strlen(), so}
00164 \textcolor{comment}{ * considering as content only up to the first null term character.}
00165 \textcolor{comment}{ *}
00166 \textcolor{comment}{ * This function is useful when the sds string is hacked manually in some}
00167 \textcolor{comment}{ * way, like in the following example:}
00168 \textcolor{comment}{ *}
00169 \textcolor{comment}{ * s = sdsnew("foobar");}
00170 \textcolor{comment}{ * s[2] = '\(\backslash\)0';}
00171 \textcolor{comment}{ * sdsupdatelen(s);}
00172 \textcolor{comment}{ * printf("%d\(\backslash\)n", sdslen(s));}
00173 \textcolor{comment}{ *}
00174 \textcolor{comment}{ * The output will be "2", but if we comment out the call to sdsupdatelen()}
00175 \textcolor{comment}{ * the output will be "6" as the string was modified but the logical length}
00176 \textcolor{comment}{ * remains 6 bytes. */}
00177 \textcolor{keywordtype}{void} sdsupdatelen(sds s) \{
00178     \textcolor{keywordtype}{int} reallen = strlen(s);
00179     sdssetlen(s, reallen);
00180 \}
00181 
00182 \textcolor{comment}{/* Modify an sds string in-place to make it empty (zero length).}
00183 \textcolor{comment}{ * However all the existing buffer is not discarded but set as free space}
00184 \textcolor{comment}{ * so that next append operations will not require allocations up to the}
00185 \textcolor{comment}{ * number of bytes previously available. */}
00186 \textcolor{keywordtype}{void} sdsclear(sds s) \{
00187     sdssetlen(s, 0);
00188     s[0] = \textcolor{stringliteral}{'\(\backslash\)0'};
00189 \}
00190 
00191 \textcolor{comment}{/* Enlarge the free space at the end of the sds string so that the caller}
00192 \textcolor{comment}{ * is sure that after calling this function can overwrite up to addlen}
00193 \textcolor{comment}{ * bytes after the end of the string, plus one more byte for nul term.}
00194 \textcolor{comment}{ *}
00195 \textcolor{comment}{ * Note: this does not change the *length* of the sds string as returned}
00196 \textcolor{comment}{ * by sdslen(), but only the free buffer space we have. */}
00197 sds sdsMakeRoomFor(sds s, size\_t addlen) \{
00198     \textcolor{keywordtype}{void} *sh, *newsh;
00199     size\_t avail = sdsavail(s);
00200     size\_t len, newlen;
00201     \textcolor{keywordtype}{char} type, oldtype = s[-1] & \hyperlink{sds_8h_a07564783f389fdd7772a8f61d55d9ddf}{SDS\_TYPE\_MASK};
00202     \textcolor{keywordtype}{int} hdrlen;
00203 
00204     \textcolor{comment}{/* Return ASAP if there is enough space left. */}
00205     \textcolor{keywordflow}{if} (avail >= addlen) \textcolor{keywordflow}{return} s;
00206 
00207     len = sdslen(s);
00208     sh = (\textcolor{keywordtype}{char}*)s-sdsHdrSize(oldtype);
00209     newlen = (len+addlen);
00210     \textcolor{keywordflow}{if} (newlen < \hyperlink{sds_8h_a49abc7d19cee5062aa831429592cea71}{SDS\_MAX\_PREALLOC})
00211         newlen *= 2;
00212     \textcolor{keywordflow}{else}
00213         newlen += \hyperlink{sds_8h_a49abc7d19cee5062aa831429592cea71}{SDS\_MAX\_PREALLOC};
00214 
00215     type = sdsReqType(newlen);
00216 
00217     \textcolor{comment}{/* Don't use type 5: the user is appending to the string and type 5 is}
00218 \textcolor{comment}{     * not able to remember empty space, so sdsMakeRoomFor() must be called}
00219 \textcolor{comment}{     * at every appending operation. */}
00220     \textcolor{keywordflow}{if} (type == \hyperlink{sds_8h_a3b7b67f1efa75f6b78ae18ea853b1a91}{SDS\_TYPE\_5}) type = \hyperlink{sds_8h_a504136356f04bfa2fd616dd4c8fdd71c}{SDS\_TYPE\_8};
00221 
00222     hdrlen = sdsHdrSize(type);
00223     \textcolor{keywordflow}{if} (oldtype==type) \{
00224         newsh = \hyperlink{sdsalloc_8h_a86d1b352c4e2c2848948649747bd296a}{s\_realloc}(sh, hdrlen+newlen+1);
00225         \textcolor{keywordflow}{if} (newsh == NULL) \textcolor{keywordflow}{return} NULL;
00226         s = (\textcolor{keywordtype}{char}*)newsh+hdrlen;
00227     \} \textcolor{keywordflow}{else} \{
00228         \textcolor{comment}{/* Since the header size changes, need to move the string forward,}
00229 \textcolor{comment}{         * and can't use realloc */}
00230         newsh = \hyperlink{sdsalloc_8h_a41e8c1188dca30db85c410c25fb417b6}{s\_malloc}(hdrlen+newlen+1);
00231         \textcolor{keywordflow}{if} (newsh == NULL) \textcolor{keywordflow}{return} NULL;
00232         memcpy((\textcolor{keywordtype}{char}*)newsh+hdrlen, s, len+1);
00233         \hyperlink{sdsalloc_8h_aa06cb49194c292098a753d87e2ac6b71}{s\_free}(sh);
00234         s = (\textcolor{keywordtype}{char}*)newsh+hdrlen;
00235         s[-1] = type;
00236         sdssetlen(s, len);
00237     \}
00238     sdssetalloc(s, newlen);
00239     \textcolor{keywordflow}{return} s;
00240 \}
00241 
00242 \textcolor{comment}{/* Reallocate the sds string so that it has no free space at the end. The}
00243 \textcolor{comment}{ * contained string remains not altered, but next concatenation operations}
00244 \textcolor{comment}{ * will require a reallocation.}
00245 \textcolor{comment}{ *}
00246 \textcolor{comment}{ * After the call, the passed sds string is no longer valid and all the}
00247 \textcolor{comment}{ * references must be substituted with the new pointer returned by the call. */}
00248 sds sdsRemoveFreeSpace(sds s) \{
00249     \textcolor{keywordtype}{void} *sh, *newsh;
00250     \textcolor{keywordtype}{char} type, oldtype = s[-1] & \hyperlink{sds_8h_a07564783f389fdd7772a8f61d55d9ddf}{SDS\_TYPE\_MASK};
00251     \textcolor{keywordtype}{int} hdrlen, oldhdrlen = sdsHdrSize(oldtype);
00252     size\_t len = sdslen(s);
00253     sh = (\textcolor{keywordtype}{char}*)s-oldhdrlen;
00254 
00255     \textcolor{comment}{/* Check what would be the minimum SDS header that is just good enough to}
00256 \textcolor{comment}{     * fit this string. */}
00257     type = sdsReqType(len);
00258     hdrlen = sdsHdrSize(type);
00259 
00260     \textcolor{comment}{/* If the type is the same, or at least a large enough type is still}
00261 \textcolor{comment}{     * required, we just realloc(), letting the allocator to do the copy}
00262 \textcolor{comment}{     * only if really needed. Otherwise if the change is huge, we manually}
00263 \textcolor{comment}{     * reallocate the string to use the different header type. */}
00264     \textcolor{keywordflow}{if} (oldtype==type || type > \hyperlink{sds_8h_a504136356f04bfa2fd616dd4c8fdd71c}{SDS\_TYPE\_8}) \{
00265         newsh = \hyperlink{sdsalloc_8h_a86d1b352c4e2c2848948649747bd296a}{s\_realloc}(sh, oldhdrlen+len+1);
00266         \textcolor{keywordflow}{if} (newsh == NULL) \textcolor{keywordflow}{return} NULL;
00267         s = (\textcolor{keywordtype}{char}*)newsh+oldhdrlen;
00268     \} \textcolor{keywordflow}{else} \{
00269         newsh = \hyperlink{sdsalloc_8h_a41e8c1188dca30db85c410c25fb417b6}{s\_malloc}(hdrlen+len+1);
00270         \textcolor{keywordflow}{if} (newsh == NULL) \textcolor{keywordflow}{return} NULL;
00271         memcpy((\textcolor{keywordtype}{char}*)newsh+hdrlen, s, len+1);
00272         \hyperlink{sdsalloc_8h_aa06cb49194c292098a753d87e2ac6b71}{s\_free}(sh);
00273         s = (\textcolor{keywordtype}{char}*)newsh+hdrlen;
00274         s[-1] = type;
00275         sdssetlen(s, len);
00276     \}
00277     sdssetalloc(s, len);
00278     \textcolor{keywordflow}{return} s;
00279 \}
00280 
00281 \textcolor{comment}{/* Return the total size of the allocation of the specifed sds string,}
00282 \textcolor{comment}{ * including:}
00283 \textcolor{comment}{ * 1) The sds header before the pointer.}
00284 \textcolor{comment}{ * 2) The string.}
00285 \textcolor{comment}{ * 3) The free buffer at the end if any.}
00286 \textcolor{comment}{ * 4) The implicit null term.}
00287 \textcolor{comment}{ */}
00288 size\_t sdsAllocSize(sds s) \{
00289     size\_t alloc = sdsalloc(s);
00290     \textcolor{keywordflow}{return} sdsHdrSize(s[-1])+alloc+1;
00291 \}
00292 
00293 \textcolor{comment}{/* Return the pointer of the actual SDS allocation (normally SDS strings}
00294 \textcolor{comment}{ * are referenced by the start of the string buffer). */}
00295 \textcolor{keywordtype}{void} *sdsAllocPtr(sds s) \{
00296     \textcolor{keywordflow}{return} (\textcolor{keywordtype}{void}*) (s-sdsHdrSize(s[-1]));
00297 \}
00298 
00299 \textcolor{comment}{/* Increment the sds length and decrements the left free space at the}
00300 \textcolor{comment}{ * end of the string according to 'incr'. Also set the null term}
00301 \textcolor{comment}{ * in the new end of the string.}
00302 \textcolor{comment}{ *}
00303 \textcolor{comment}{ * This function is used in order to fix the string length after the}
00304 \textcolor{comment}{ * user calls sdsMakeRoomFor(), writes something after the end of}
00305 \textcolor{comment}{ * the current string, and finally needs to set the new length.}
00306 \textcolor{comment}{ *}
00307 \textcolor{comment}{ * Note: it is possible to use a negative increment in order to}
00308 \textcolor{comment}{ * right-trim the string.}
00309 \textcolor{comment}{ *}
00310 \textcolor{comment}{ * Usage example:}
00311 \textcolor{comment}{ *}
00312 \textcolor{comment}{ * Using sdsIncrLen() and sdsMakeRoomFor() it is possible to mount the}
00313 \textcolor{comment}{ * following schema, to cat bytes coming from the kernel to the end of an}
00314 \textcolor{comment}{ * sds string without copying into an intermediate buffer:}
00315 \textcolor{comment}{ *}
00316 \textcolor{comment}{ * oldlen = sdslen(s);}
00317 \textcolor{comment}{ * s = sdsMakeRoomFor(s, BUFFER\_SIZE);}
00318 \textcolor{comment}{ * nread = read(fd, s+oldlen, BUFFER\_SIZE);}
00319 \textcolor{comment}{ * ... check for nread <= 0 and handle it ...}
00320 \textcolor{comment}{ * sdsIncrLen(s, nread);}
00321 \textcolor{comment}{ */}
00322 \textcolor{keywordtype}{void} sdsIncrLen(sds s, \textcolor{keywordtype}{int} incr) \{
00323     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} flags = s[-1];
00324     size\_t len;
00325     \textcolor{keywordflow}{switch}(flags&\hyperlink{sds_8h_a07564783f389fdd7772a8f61d55d9ddf}{SDS\_TYPE\_MASK}) \{
00326         \textcolor{keywordflow}{case} \hyperlink{sds_8h_a3b7b67f1efa75f6b78ae18ea853b1a91}{SDS\_TYPE\_5}: \{
00327             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *fp = ((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)s)-1;
00328             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} oldlen = \hyperlink{sds_8h_a387aebc42becc7d798cd1a33533da2de}{SDS\_TYPE\_5\_LEN}(flags);
00329             \hyperlink{redisassert_8h_a993abaa2c168852c1592879472938781}{assert}((incr > 0 && oldlen+incr < 32) || (incr < 0 && oldlen >= (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})(-incr
      )));
00330             *fp = \hyperlink{sds_8h_a3b7b67f1efa75f6b78ae18ea853b1a91}{SDS\_TYPE\_5} | ((oldlen+incr) << \hyperlink{sds_8h_aab3be62faa5a2354242a1c1036450a40}{SDS\_TYPE\_BITS});
00331             len = oldlen+incr;
00332             \textcolor{keywordflow}{break};
00333         \}
00334         \textcolor{keywordflow}{case} \hyperlink{sds_8h_a504136356f04bfa2fd616dd4c8fdd71c}{SDS\_TYPE\_8}: \{
00335             \hyperlink{sds_8h_a79b76920d1d9bc010926b7af167de89b}{SDS\_HDR\_VAR}(8,s);
00336             \hyperlink{redisassert_8h_a993abaa2c168852c1592879472938781}{assert}((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (\textcolor{keywordtype}{unsigned}
       \textcolor{keywordtype}{int})(-incr)));
00337             len = (sh->len += incr);
00338             \textcolor{keywordflow}{break};
00339         \}
00340         \textcolor{keywordflow}{case} \hyperlink{sds_8h_aa54044bf70a30824caeb1bab3615bff2}{SDS\_TYPE\_16}: \{
00341             \hyperlink{sds_8h_a79b76920d1d9bc010926b7af167de89b}{SDS\_HDR\_VAR}(16,s);
00342             \hyperlink{redisassert_8h_a993abaa2c168852c1592879472938781}{assert}((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (\textcolor{keywordtype}{unsigned}
       \textcolor{keywordtype}{int})(-incr)));
00343             len = (sh->len += incr);
00344             \textcolor{keywordflow}{break};
00345         \}
00346         \textcolor{keywordflow}{case} \hyperlink{sds_8h_a0ad2103bbdaa2fe5511ce3279cb42293}{SDS\_TYPE\_32}: \{
00347             \hyperlink{sds_8h_a79b76920d1d9bc010926b7af167de89b}{SDS\_HDR\_VAR}(32,s);
00348             \hyperlink{redisassert_8h_a993abaa2c168852c1592879472938781}{assert}((incr >= 0 && sh->alloc-sh->len >= (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})incr) || (incr < 0 && sh->
      len >= (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})(-incr)));
00349             len = (sh->len += incr);
00350             \textcolor{keywordflow}{break};
00351         \}
00352         \textcolor{keywordflow}{case} \hyperlink{sds_8h_ad03c6e0fdab3a871e10cce347e8bb4e6}{SDS\_TYPE\_64}: \{
00353             \hyperlink{sds_8h_a79b76920d1d9bc010926b7af167de89b}{SDS\_HDR\_VAR}(64,s);
00354             \hyperlink{redisassert_8h_a993abaa2c168852c1592879472938781}{assert}((incr >= 0 && sh->alloc-sh->len >= (uint64\_t)incr) || (incr < 0 && sh->len >=
       (uint64\_t)(-incr)));
00355             len = (sh->len += incr);
00356             \textcolor{keywordflow}{break};
00357         \}
00358         \textcolor{keywordflow}{default}: len = 0; \textcolor{comment}{/* Just to avoid compilation warnings. */}
00359     \}
00360     s[len] = \textcolor{stringliteral}{'\(\backslash\)0'};
00361 \}
00362 
00363 \textcolor{comment}{/* Grow the sds to have the specified length. Bytes that were not part of}
00364 \textcolor{comment}{ * the original length of the sds will be set to zero.}
00365 \textcolor{comment}{ *}
00366 \textcolor{comment}{ * if the specified length is smaller than the current length, no operation}
00367 \textcolor{comment}{ * is performed. */}
00368 sds sdsgrowzero(sds s, size\_t len) \{
00369     size\_t curlen = sdslen(s);
00370 
00371     \textcolor{keywordflow}{if} (len <= curlen) \textcolor{keywordflow}{return} s;
00372     s = sdsMakeRoomFor(s,len-curlen);
00373     \textcolor{keywordflow}{if} (s == NULL) \textcolor{keywordflow}{return} NULL;
00374 
00375     \textcolor{comment}{/* Make sure added region doesn't contain garbage */}
00376     memset(s+curlen,0,(len-curlen+1)); \textcolor{comment}{/* also set trailing \(\backslash\)0 byte */}
00377     sdssetlen(s, len);
00378     \textcolor{keywordflow}{return} s;
00379 \}
00380 
00381 \textcolor{comment}{/* Append the specified binary-safe string pointed by 't' of 'len' bytes to the}
00382 \textcolor{comment}{ * end of the specified sds string 's'.}
00383 \textcolor{comment}{ *}
00384 \textcolor{comment}{ * After the call, the passed sds string is no longer valid and all the}
00385 \textcolor{comment}{ * references must be substituted with the new pointer returned by the call. */}
00386 sds sdscatlen(sds s, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *t, size\_t len) \{
00387     size\_t curlen = sdslen(s);
00388 
00389     s = sdsMakeRoomFor(s,len);
00390     \textcolor{keywordflow}{if} (s == NULL) \textcolor{keywordflow}{return} NULL;
00391     memcpy(s+curlen, t, len);
00392     sdssetlen(s, curlen+len);
00393     s[curlen+len] = \textcolor{stringliteral}{'\(\backslash\)0'};
00394     \textcolor{keywordflow}{return} s;
00395 \}
00396 
00397 \textcolor{comment}{/* Append the specified null termianted C string to the sds string 's'.}
00398 \textcolor{comment}{ *}
00399 \textcolor{comment}{ * After the call, the passed sds string is no longer valid and all the}
00400 \textcolor{comment}{ * references must be substituted with the new pointer returned by the call. */}
00401 sds sdscat(sds s, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *t) \{
00402     \textcolor{keywordflow}{return} sdscatlen(s, t, strlen(t));
00403 \}
00404 
00405 \textcolor{comment}{/* Append the specified sds 't' to the existing sds 's'.}
00406 \textcolor{comment}{ *}
00407 \textcolor{comment}{ * After the call, the modified sds string is no longer valid and all the}
00408 \textcolor{comment}{ * references must be substituted with the new pointer returned by the call. */}
00409 sds sdscatsds(sds s, \textcolor{keyword}{const} sds t) \{
00410     \textcolor{keywordflow}{return} sdscatlen(s, t, sdslen(t));
00411 \}
00412 
00413 \textcolor{comment}{/* Destructively modify the sds string 's' to hold the specified binary}
00414 \textcolor{comment}{ * safe string pointed by 't' of length 'len' bytes. */}
00415 sds sdscpylen(sds s, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *t, size\_t len) \{
00416     \textcolor{keywordflow}{if} (sdsalloc(s) < len) \{
00417         s = sdsMakeRoomFor(s,len-sdslen(s));
00418         \textcolor{keywordflow}{if} (s == NULL) \textcolor{keywordflow}{return} NULL;
00419     \}
00420     memcpy(s, t, len);
00421     s[len] = \textcolor{stringliteral}{'\(\backslash\)0'};
00422     sdssetlen(s, len);
00423     \textcolor{keywordflow}{return} s;
00424 \}
00425 
00426 \textcolor{comment}{/* Like sdscpylen() but 't' must be a null-termined string so that the length}
00427 \textcolor{comment}{ * of the string is obtained with strlen(). */}
00428 sds sdscpy(sds s, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *t) \{
00429     \textcolor{keywordflow}{return} sdscpylen(s, t, strlen(t));
00430 \}
00431 
00432 \textcolor{comment}{/* Helper for sdscatlonglong() doing the actual number -> string}
00433 \textcolor{comment}{ * conversion. 's' must point to a string with room for at least}
00434 \textcolor{comment}{ * SDS\_LLSTR\_SIZE bytes.}
00435 \textcolor{comment}{ *}
00436 \textcolor{comment}{ * The function returns the length of the null-terminated string}
00437 \textcolor{comment}{ * representation stored at 's'. */}
00438 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SDS\_LLSTR\_SIZE} 21
00439 \textcolor{keywordtype}{int} sdsll2str(\textcolor{keywordtype}{char} *s, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value) \{
00440     \textcolor{keywordtype}{char} *p, aux;
00441     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} v;
00442     size\_t l;
00443 
00444     \textcolor{comment}{/* Generate the string representation, this method produces}
00445 \textcolor{comment}{     * an reversed string. */}
00446     v = (value < 0) ? -value : value;
00447     p = s;
00448     \textcolor{keywordflow}{do} \{
00449         *p++ = \textcolor{stringliteral}{'0'}+(v%10);
00450         v /= 10;
00451     \} \textcolor{keywordflow}{while}(v);
00452     \textcolor{keywordflow}{if} (value < 0) *p++ = \textcolor{stringliteral}{'-'};
00453 
00454     \textcolor{comment}{/* Compute length and add null term. */}
00455     l = p-s;
00456     *p = \textcolor{stringliteral}{'\(\backslash\)0'};
00457 
00458     \textcolor{comment}{/* Reverse the string. */}
00459     p--;
00460     \textcolor{keywordflow}{while}(s < p) \{
00461         aux = *s;
00462         *s = *p;
00463         *p = aux;
00464         s++;
00465         p--;
00466     \}
00467     \textcolor{keywordflow}{return} l;
00468 \}
00469 
00470 \textcolor{comment}{/* Identical sdsll2str(), but for unsigned long long type. */}
00471 \textcolor{keywordtype}{int} sdsull2str(\textcolor{keywordtype}{char} *s, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} v) \{
00472     \textcolor{keywordtype}{char} *p, aux;
00473     size\_t l;
00474 
00475     \textcolor{comment}{/* Generate the string representation, this method produces}
00476 \textcolor{comment}{     * an reversed string. */}
00477     p = s;
00478     \textcolor{keywordflow}{do} \{
00479         *p++ = \textcolor{stringliteral}{'0'}+(v%10);
00480         v /= 10;
00481     \} \textcolor{keywordflow}{while}(v);
00482 
00483     \textcolor{comment}{/* Compute length and add null term. */}
00484     l = p-s;
00485     *p = \textcolor{stringliteral}{'\(\backslash\)0'};
00486 
00487     \textcolor{comment}{/* Reverse the string. */}
00488     p--;
00489     \textcolor{keywordflow}{while}(s < p) \{
00490         aux = *s;
00491         *s = *p;
00492         *p = aux;
00493         s++;
00494         p--;
00495     \}
00496     \textcolor{keywordflow}{return} l;
00497 \}
00498 
00499 \textcolor{comment}{/* Create an sds string from a long long value. It is much faster than:}
00500 \textcolor{comment}{ *}
00501 \textcolor{comment}{ * sdscatprintf(sdsempty(),"%lld\(\backslash\)n", value);}
00502 \textcolor{comment}{ */}
00503 sds sdsfromlonglong(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value) \{
00504     \textcolor{keywordtype}{char} buf[\hyperlink{sds_8c_a81d5c6a677fb9cb9b5fb37fba6a2612d}{SDS\_LLSTR\_SIZE}];
00505     \textcolor{keywordtype}{int} len = sdsll2str(buf,value);
00506 
00507     \textcolor{keywordflow}{return} sdsnewlen(buf,len);
00508 \}
00509 
00510 \textcolor{comment}{/* Like sdscatprintf() but gets va\_list instead of being variadic. */}
00511 sds sdscatvprintf(sds s, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, va\_list ap) \{
00512     va\_list cpy;
00513     \textcolor{keywordtype}{char} staticbuf[1024], *buf = staticbuf, *t;
00514     size\_t buflen = strlen(fmt)*2;
00515 
00516     \textcolor{comment}{/* We try to start using a static buffer for speed.}
00517 \textcolor{comment}{     * If not possible we revert to heap allocation. */}
00518     \textcolor{keywordflow}{if} (buflen > \textcolor{keyword}{sizeof}(staticbuf)) \{
00519         buf = \hyperlink{sdsalloc_8h_a41e8c1188dca30db85c410c25fb417b6}{s\_malloc}(buflen);
00520         \textcolor{keywordflow}{if} (buf == NULL) \textcolor{keywordflow}{return} NULL;
00521     \} \textcolor{keywordflow}{else} \{
00522         buflen = \textcolor{keyword}{sizeof}(staticbuf);
00523     \}
00524 
00525     \textcolor{comment}{/* Try with buffers two times bigger every time we fail to}
00526 \textcolor{comment}{     * fit the string in the current buffer size. */}
00527     \textcolor{keywordflow}{while}(1) \{
00528         buf[buflen-2] = \textcolor{stringliteral}{'\(\backslash\)0'};
00529         va\_copy(cpy,ap);
00530         vsnprintf(buf, buflen, fmt, cpy);
00531         va\_end(cpy);
00532         \textcolor{keywordflow}{if} (buf[buflen-2] != \textcolor{stringliteral}{'\(\backslash\)0'}) \{
00533             \textcolor{keywordflow}{if} (buf != staticbuf) \hyperlink{sdsalloc_8h_aa06cb49194c292098a753d87e2ac6b71}{s\_free}(buf);
00534             buflen *= 2;
00535             buf = \hyperlink{sdsalloc_8h_a41e8c1188dca30db85c410c25fb417b6}{s\_malloc}(buflen);
00536             \textcolor{keywordflow}{if} (buf == NULL) \textcolor{keywordflow}{return} NULL;
00537             \textcolor{keywordflow}{continue};
00538         \}
00539         \textcolor{keywordflow}{break};
00540     \}
00541 
00542     \textcolor{comment}{/* Finally concat the obtained string to the SDS string and return it. */}
00543     t = sdscat(s, buf);
00544     \textcolor{keywordflow}{if} (buf != staticbuf) \hyperlink{sdsalloc_8h_aa06cb49194c292098a753d87e2ac6b71}{s\_free}(buf);
00545     \textcolor{keywordflow}{return} t;
00546 \}
00547 
00548 \textcolor{comment}{/* Append to the sds string 's' a string obtained using printf-alike format}
00549 \textcolor{comment}{ * specifier.}
00550 \textcolor{comment}{ *}
00551 \textcolor{comment}{ * After the call, the modified sds string is no longer valid and all the}
00552 \textcolor{comment}{ * references must be substituted with the new pointer returned by the call.}
00553 \textcolor{comment}{ *}
00554 \textcolor{comment}{ * Example:}
00555 \textcolor{comment}{ *}
00556 \textcolor{comment}{ * s = sdsnew("Sum is: ");}
00557 \textcolor{comment}{ * s = sdscatprintf(s,"%d+%d = %d",a,b,a+b).}
00558 \textcolor{comment}{ *}
00559 \textcolor{comment}{ * Often you need to create a string from scratch with the printf-alike}
00560 \textcolor{comment}{ * format. When this is the need, just use sdsempty() as the target string:}
00561 \textcolor{comment}{ *}
00562 \textcolor{comment}{ * s = sdscatprintf(sdsempty(), "... your format ...", args);}
00563 \textcolor{comment}{ */}
00564 sds sdscatprintf(sds s, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, ...) \{
00565     va\_list ap;
00566     \textcolor{keywordtype}{char} *t;
00567     va\_start(ap, fmt);
00568     t = sdscatvprintf(s,fmt,ap);
00569     va\_end(ap);
00570     \textcolor{keywordflow}{return} t;
00571 \}
00572 
00573 \textcolor{comment}{/* This function is similar to sdscatprintf, but much faster as it does}
00574 \textcolor{comment}{ * not rely on sprintf() family functions implemented by the libc that}
00575 \textcolor{comment}{ * are often very slow. Moreover directly handling the sds string as}
00576 \textcolor{comment}{ * new data is concatenated provides a performance improvement.}
00577 \textcolor{comment}{ *}
00578 \textcolor{comment}{ * However this function only handles an incompatible subset of printf-alike}
00579 \textcolor{comment}{ * format specifiers:}
00580 \textcolor{comment}{ *}
00581 \textcolor{comment}{ * %s - C String}
00582 \textcolor{comment}{ * %S - SDS string}
00583 \textcolor{comment}{ * %i - signed int}
00584 \textcolor{comment}{ * %I - 64 bit signed integer (long long, int64\_t)}
00585 \textcolor{comment}{ * %u - unsigned int}
00586 \textcolor{comment}{ * %U - 64 bit unsigned integer (unsigned long long, uint64\_t)}
00587 \textcolor{comment}{ * %% - Verbatim "%" character.}
00588 \textcolor{comment}{ */}
00589 sds sdscatfmt(sds s, \textcolor{keywordtype}{char} \textcolor{keyword}{const} *fmt, ...) \{
00590     size\_t initlen = sdslen(s);
00591     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *f = fmt;
00592     \textcolor{keywordtype}{int} i;
00593     va\_list ap;
00594 
00595     va\_start(ap,fmt);
00596     f = fmt;    \textcolor{comment}{/* Next format specifier byte to process. */}
00597     i = initlen; \textcolor{comment}{/* Position of the next byte to write to dest str. */}
00598     \textcolor{keywordflow}{while}(*f) \{
00599         \textcolor{keywordtype}{char} next, *str;
00600         size\_t l;
00601         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} num;
00602         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} unum;
00603 
00604         \textcolor{comment}{/* Make sure there is always space for at least 1 char. */}
00605         \textcolor{keywordflow}{if} (sdsavail(s)==0) \{
00606             s = sdsMakeRoomFor(s,1);
00607         \}
00608 
00609         \textcolor{keywordflow}{switch}(*f) \{
00610         \textcolor{keywordflow}{case} \textcolor{stringliteral}{'%'}:
00611             next = *(f+1);
00612             f++;
00613             \textcolor{keywordflow}{switch}(next) \{
00614             \textcolor{keywordflow}{case} \textcolor{stringliteral}{'s'}:
00615             \textcolor{keywordflow}{case} \textcolor{stringliteral}{'S'}:
00616                 str = va\_arg(ap,\textcolor{keywordtype}{char}*);
00617                 l = (next == \textcolor{stringliteral}{'s'}) ? strlen(str) : sdslen(str);
00618                 \textcolor{keywordflow}{if} (sdsavail(s) < l) \{
00619                     s = sdsMakeRoomFor(s,l);
00620                 \}
00621                 memcpy(s+i,str,l);
00622                 sdsinclen(s,l);
00623                 i += l;
00624                 \textcolor{keywordflow}{break};
00625             \textcolor{keywordflow}{case} \textcolor{stringliteral}{'i'}:
00626             \textcolor{keywordflow}{case} \textcolor{stringliteral}{'I'}:
00627                 \textcolor{keywordflow}{if} (next == \textcolor{stringliteral}{'i'})
00628                     num = va\_arg(ap,\textcolor{keywordtype}{int});
00629                 \textcolor{keywordflow}{else}
00630                     num = va\_arg(ap,\textcolor{keywordtype}{long} \textcolor{keywordtype}{long});
00631                 \{
00632                     \textcolor{keywordtype}{char} buf[\hyperlink{sds_8c_a81d5c6a677fb9cb9b5fb37fba6a2612d}{SDS\_LLSTR\_SIZE}];
00633                     l = sdsll2str(buf,num);
00634                     \textcolor{keywordflow}{if} (sdsavail(s) < l) \{
00635                         s = sdsMakeRoomFor(s,l);
00636                     \}
00637                     memcpy(s+i,buf,l);
00638                     sdsinclen(s,l);
00639                     i += l;
00640                 \}
00641                 \textcolor{keywordflow}{break};
00642             \textcolor{keywordflow}{case} \textcolor{stringliteral}{'u'}:
00643             \textcolor{keywordflow}{case} \textcolor{stringliteral}{'U'}:
00644                 \textcolor{keywordflow}{if} (next == \textcolor{stringliteral}{'u'})
00645                     unum = va\_arg(ap,\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int});
00646                 \textcolor{keywordflow}{else}
00647                     unum = va\_arg(ap,\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long});
00648                 \{
00649                     \textcolor{keywordtype}{char} buf[\hyperlink{sds_8c_a81d5c6a677fb9cb9b5fb37fba6a2612d}{SDS\_LLSTR\_SIZE}];
00650                     l = sdsull2str(buf,unum);
00651                     \textcolor{keywordflow}{if} (sdsavail(s) < l) \{
00652                         s = sdsMakeRoomFor(s,l);
00653                     \}
00654                     memcpy(s+i,buf,l);
00655                     sdsinclen(s,l);
00656                     i += l;
00657                 \}
00658                 \textcolor{keywordflow}{break};
00659             \textcolor{keywordflow}{default}: \textcolor{comment}{/* Handle %% and generally %<unknown>. */}
00660                 s[i++] = next;
00661                 sdsinclen(s,1);
00662                 \textcolor{keywordflow}{break};
00663             \}
00664             \textcolor{keywordflow}{break};
00665         \textcolor{keywordflow}{default}:
00666             s[i++] = *f;
00667             sdsinclen(s,1);
00668             \textcolor{keywordflow}{break};
00669         \}
00670         f++;
00671     \}
00672     va\_end(ap);
00673 
00674     \textcolor{comment}{/* Add null-term */}
00675     s[i] = \textcolor{stringliteral}{'\(\backslash\)0'};
00676     \textcolor{keywordflow}{return} s;
00677 \}
00678 
00679 \textcolor{comment}{/* Remove the part of the string from left and from right composed just of}
00680 \textcolor{comment}{ * contiguous characters found in 'cset', that is a null terminted C string.}
00681 \textcolor{comment}{ *}
00682 \textcolor{comment}{ * After the call, the modified sds string is no longer valid and all the}
00683 \textcolor{comment}{ * references must be substituted with the new pointer returned by the call.}
00684 \textcolor{comment}{ *}
00685 \textcolor{comment}{ * Example:}
00686 \textcolor{comment}{ *}
00687 \textcolor{comment}{ * s = sdsnew("AA...AA.a.aa.aHelloWorld     :::");}
00688 \textcolor{comment}{ * s = sdstrim(s,"Aa. :");}
00689 \textcolor{comment}{ * printf("%s\(\backslash\)n", s);}
00690 \textcolor{comment}{ *}
00691 \textcolor{comment}{ * Output will be just "Hello World".}
00692 \textcolor{comment}{ */}
00693 sds sdstrim(sds s, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *cset) \{
00694     \textcolor{keywordtype}{char} *start, *end, *sp, *ep;
00695     size\_t len;
00696 
00697     sp = start = s;
00698     ep = end = s+sdslen(s)-1;
00699     \textcolor{keywordflow}{while}(sp <= end && strchr(cset, *sp)) sp++;
00700     \textcolor{keywordflow}{while}(ep > sp && strchr(cset, *ep)) ep--;
00701     len = (sp > ep) ? 0 : ((ep-sp)+1);
00702     \textcolor{keywordflow}{if} (s != sp) memmove(s, sp, len);
00703     s[len] = \textcolor{stringliteral}{'\(\backslash\)0'};
00704     sdssetlen(s,len);
00705     \textcolor{keywordflow}{return} s;
00706 \}
00707 
00708 \textcolor{comment}{/* Turn the string into a smaller (or equal) string containing only the}
00709 \textcolor{comment}{ * substring specified by the 'start' and 'end' indexes.}
00710 \textcolor{comment}{ *}
00711 \textcolor{comment}{ * start and end can be negative, where -1 means the last character of the}
00712 \textcolor{comment}{ * string, -2 the penultimate character, and so forth.}
00713 \textcolor{comment}{ *}
00714 \textcolor{comment}{ * The interval is inclusive, so the start and end characters will be part}
00715 \textcolor{comment}{ * of the resulting string.}
00716 \textcolor{comment}{ *}
00717 \textcolor{comment}{ * The string is modified in-place.}
00718 \textcolor{comment}{ *}
00719 \textcolor{comment}{ * Example:}
00720 \textcolor{comment}{ *}
00721 \textcolor{comment}{ * s = sdsnew("Hello World");}
00722 \textcolor{comment}{ * sdsrange(s,1,-1); => "ello World"}
00723 \textcolor{comment}{ */}
00724 \textcolor{keywordtype}{void} sdsrange(sds s, \textcolor{keywordtype}{int} start, \textcolor{keywordtype}{int} end) \{
00725     size\_t newlen, len = sdslen(s);
00726 
00727     \textcolor{keywordflow}{if} (len == 0) \textcolor{keywordflow}{return};
00728     \textcolor{keywordflow}{if} (start < 0) \{
00729         start = len+start;
00730         \textcolor{keywordflow}{if} (start < 0) start = 0;
00731     \}
00732     \textcolor{keywordflow}{if} (end < 0) \{
00733         end = len+end;
00734         \textcolor{keywordflow}{if} (end < 0) end = 0;
00735     \}
00736     newlen = (start > end) ? 0 : (end-start)+1;
00737     \textcolor{keywordflow}{if} (newlen != 0) \{
00738         \textcolor{keywordflow}{if} (start >= (\textcolor{keywordtype}{signed})len) \{
00739             newlen = 0;
00740         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (end >= (\textcolor{keywordtype}{signed})len) \{
00741             end = len-1;
00742             newlen = (start > end) ? 0 : (end-start)+1;
00743         \}
00744     \} \textcolor{keywordflow}{else} \{
00745         start = 0;
00746     \}
00747     \textcolor{keywordflow}{if} (start && newlen) memmove(s, s+start, newlen);
00748     s[newlen] = 0;
00749     sdssetlen(s,newlen);
00750 \}
00751 
00752 \textcolor{comment}{/* Apply tolower() to every character of the sds string 's'. */}
00753 \textcolor{keywordtype}{void} sdstolower(sds s) \{
00754     \textcolor{keywordtype}{int} len = sdslen(s), j;
00755 
00756     \textcolor{keywordflow}{for} (j = 0; j < len; j++) s[j] = tolower(s[j]);
00757 \}
00758 
00759 \textcolor{comment}{/* Apply toupper() to every character of the sds string 's'. */}
00760 \textcolor{keywordtype}{void} sdstoupper(sds s) \{
00761     \textcolor{keywordtype}{int} len = sdslen(s), j;
00762 
00763     \textcolor{keywordflow}{for} (j = 0; j < len; j++) s[j] = toupper(s[j]);
00764 \}
00765 
00766 \textcolor{comment}{/* Compare two sds strings s1 and s2 with memcmp().}
00767 \textcolor{comment}{ *}
00768 \textcolor{comment}{ * Return value:}
00769 \textcolor{comment}{ *}
00770 \textcolor{comment}{ *     positive if s1 > s2.}
00771 \textcolor{comment}{ *     negative if s1 < s2.}
00772 \textcolor{comment}{ *     0 if s1 and s2 are exactly the same binary string.}
00773 \textcolor{comment}{ *}
00774 \textcolor{comment}{ * If two strings share exactly the same prefix, but one of the two has}
00775 \textcolor{comment}{ * additional characters, the longer string is considered to be greater than}
00776 \textcolor{comment}{ * the smaller one. */}
00777 \textcolor{keywordtype}{int} sdscmp(\textcolor{keyword}{const} sds s1, \textcolor{keyword}{const} sds s2) \{
00778     size\_t l1, l2, minlen;
00779     \textcolor{keywordtype}{int} cmp;
00780 
00781     l1 = sdslen(s1);
00782     l2 = sdslen(s2);
00783     minlen = (l1 < l2) ? l1 : l2;
00784     cmp = memcmp(s1,s2,minlen);
00785     \textcolor{keywordflow}{if} (cmp == 0) \textcolor{keywordflow}{return} l1-l2;
00786     \textcolor{keywordflow}{return} cmp;
00787 \}
00788 
00789 \textcolor{comment}{/* Split 's' with separator in 'sep'. An array}
00790 \textcolor{comment}{ * of sds strings is returned. *count will be set}
00791 \textcolor{comment}{ * by reference to the number of tokens returned.}
00792 \textcolor{comment}{ *}
00793 \textcolor{comment}{ * On out of memory, zero length string, zero length}
00794 \textcolor{comment}{ * separator, NULL is returned.}
00795 \textcolor{comment}{ *}
00796 \textcolor{comment}{ * Note that 'sep' is able to split a string using}
00797 \textcolor{comment}{ * a multi-character separator. For example}
00798 \textcolor{comment}{ * sdssplit("foo\_-\_bar","\_-\_"); will return two}
00799 \textcolor{comment}{ * elements "foo" and "bar".}
00800 \textcolor{comment}{ *}
00801 \textcolor{comment}{ * This version of the function is binary-safe but}
00802 \textcolor{comment}{ * requires length arguments. sdssplit() is just the}
00803 \textcolor{comment}{ * same function but for zero-terminated strings.}
00804 \textcolor{comment}{ */}
00805 sds *sdssplitlen(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, \textcolor{keywordtype}{int} len, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *sep, \textcolor{keywordtype}{int} seplen, \textcolor{keywordtype}{int} *count) \{
00806     \textcolor{keywordtype}{int} elements = 0, slots = 5, start = 0, j;
00807     sds *tokens;
00808 
00809     \textcolor{keywordflow}{if} (seplen < 1 || len < 0) \textcolor{keywordflow}{return} NULL;
00810 
00811     tokens = \hyperlink{sdsalloc_8h_a41e8c1188dca30db85c410c25fb417b6}{s\_malloc}(\textcolor{keyword}{sizeof}(sds)*slots);
00812     \textcolor{keywordflow}{if} (tokens == NULL) \textcolor{keywordflow}{return} NULL;
00813 
00814     \textcolor{keywordflow}{if} (len == 0) \{
00815         *count = 0;
00816         \textcolor{keywordflow}{return} tokens;
00817     \}
00818     \textcolor{keywordflow}{for} (j = 0; j < (len-(seplen-1)); j++) \{
00819         \textcolor{comment}{/* make sure there is room for the next element and the final one */}
00820         \textcolor{keywordflow}{if} (slots < elements+2) \{
00821             sds *newtokens;
00822 
00823             slots *= 2;
00824             newtokens = \hyperlink{sdsalloc_8h_a86d1b352c4e2c2848948649747bd296a}{s\_realloc}(tokens,\textcolor{keyword}{sizeof}(sds)*slots);
00825             \textcolor{keywordflow}{if} (newtokens == NULL) \textcolor{keywordflow}{goto} cleanup;
00826             tokens = newtokens;
00827         \}
00828         \textcolor{comment}{/* search the separator */}
00829         \textcolor{keywordflow}{if} ((seplen == 1 && *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) \{
00830             tokens[elements] = sdsnewlen(s+start,j-start);
00831             \textcolor{keywordflow}{if} (tokens[elements] == NULL) \textcolor{keywordflow}{goto} cleanup;
00832             elements++;
00833             start = j+seplen;
00834             j = j+seplen-1; \textcolor{comment}{/* skip the separator */}
00835         \}
00836     \}
00837     \textcolor{comment}{/* Add the final element. We are sure there is room in the tokens array. */}
00838     tokens[elements] = sdsnewlen(s+start,len-start);
00839     \textcolor{keywordflow}{if} (tokens[elements] == NULL) \textcolor{keywordflow}{goto} cleanup;
00840     elements++;
00841     *count = elements;
00842     \textcolor{keywordflow}{return} tokens;
00843 
00844 cleanup:
00845     \{
00846         \textcolor{keywordtype}{int} i;
00847         \textcolor{keywordflow}{for} (i = 0; i < elements; i++) sdsfree(tokens[i]);
00848         \hyperlink{sdsalloc_8h_aa06cb49194c292098a753d87e2ac6b71}{s\_free}(tokens);
00849         *count = 0;
00850         \textcolor{keywordflow}{return} NULL;
00851     \}
00852 \}
00853 
00854 \textcolor{comment}{/* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */}
00855 \textcolor{keywordtype}{void} sdsfreesplitres(sds *tokens, \textcolor{keywordtype}{int} count) \{
00856     \textcolor{keywordflow}{if} (!tokens) \textcolor{keywordflow}{return};
00857     \textcolor{keywordflow}{while}(count--)
00858         sdsfree(tokens[count]);
00859     \hyperlink{sdsalloc_8h_aa06cb49194c292098a753d87e2ac6b71}{s\_free}(tokens);
00860 \}
00861 
00862 \textcolor{comment}{/* Append to the sds string "s" an escaped string representation where}
00863 \textcolor{comment}{ * all the non-printable characters (tested with isprint()) are turned into}
00864 \textcolor{comment}{ * escapes in the form "\(\backslash\)n\(\backslash\)r\(\backslash\)a...." or "\(\backslash\)x<hex-number>".}
00865 \textcolor{comment}{ *}
00866 \textcolor{comment}{ * After the call, the modified sds string is no longer valid and all the}
00867 \textcolor{comment}{ * references must be substituted with the new pointer returned by the call. */}
00868 sds sdscatrepr(sds s, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *p, size\_t len) \{
00869     s = sdscatlen(s,\textcolor{stringliteral}{"\(\backslash\)""},1);
00870     \textcolor{keywordflow}{while}(len--) \{
00871         \textcolor{keywordflow}{switch}(*p) \{
00872         \textcolor{keywordflow}{case} \textcolor{stringliteral}{'\(\backslash\)\(\backslash\)'}:
00873         \textcolor{keywordflow}{case} \textcolor{stringliteral}{'"'}:
00874             s = sdscatprintf(s,\textcolor{stringliteral}{"\(\backslash\)\(\backslash\)%c"},*p);
00875             \textcolor{keywordflow}{break};
00876         \textcolor{keywordflow}{case} \textcolor{stringliteral}{'\(\backslash\)n'}: s = sdscatlen(s,\textcolor{stringliteral}{"\(\backslash\)\(\backslash\)n"},2); \textcolor{keywordflow}{break};
00877         \textcolor{keywordflow}{case} \textcolor{stringliteral}{'\(\backslash\)r'}: s = sdscatlen(s,\textcolor{stringliteral}{"\(\backslash\)\(\backslash\)r"},2); \textcolor{keywordflow}{break};
00878         \textcolor{keywordflow}{case} \textcolor{stringliteral}{'\(\backslash\)t'}: s = sdscatlen(s,\textcolor{stringliteral}{"\(\backslash\)\(\backslash\)t"},2); \textcolor{keywordflow}{break};
00879         \textcolor{keywordflow}{case} \textcolor{stringliteral}{'\(\backslash\)a'}: s = sdscatlen(s,\textcolor{stringliteral}{"\(\backslash\)\(\backslash\)a"},2); \textcolor{keywordflow}{break};
00880         \textcolor{keywordflow}{case} \textcolor{stringliteral}{'\(\backslash\)b'}: s = sdscatlen(s,\textcolor{stringliteral}{"\(\backslash\)\(\backslash\)b"},2); \textcolor{keywordflow}{break};
00881         \textcolor{keywordflow}{default}:
00882             \textcolor{keywordflow}{if} (isprint(*p))
00883                 s = sdscatprintf(s,\textcolor{stringliteral}{"%c"},*p);
00884             \textcolor{keywordflow}{else}
00885                 s = sdscatprintf(s,\textcolor{stringliteral}{"\(\backslash\)\(\backslash\)x%02x"},(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char})*p);
00886             \textcolor{keywordflow}{break};
00887         \}
00888         p++;
00889     \}
00890     \textcolor{keywordflow}{return} sdscatlen(s,\textcolor{stringliteral}{"\(\backslash\)""},1);
00891 \}
00892 
00893 \textcolor{comment}{/* Helper function for sdssplitargs() that returns non zero if 'c'}
00894 \textcolor{comment}{ * is a valid hex digit. */}
00895 \textcolor{keywordtype}{int} is\_hex\_digit(\textcolor{keywordtype}{char} c) \{
00896     \textcolor{keywordflow}{return} (c >= \textcolor{stringliteral}{'0'} && c <= \textcolor{stringliteral}{'9'}) || (c >= \textcolor{stringliteral}{'a'} && c <= \textcolor{stringliteral}{'f'}) ||
00897            (c >= \textcolor{stringliteral}{'A'} && c <= \textcolor{stringliteral}{'F'});
00898 \}
00899 
00900 \textcolor{comment}{/* Helper function for sdssplitargs() that converts a hex digit into an}
00901 \textcolor{comment}{ * integer from 0 to 15 */}
00902 \textcolor{keywordtype}{int} hex\_digit\_to\_int(\textcolor{keywordtype}{char} c) \{
00903     \textcolor{keywordflow}{switch}(c) \{
00904     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'0'}: \textcolor{keywordflow}{return} 0;
00905     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'1'}: \textcolor{keywordflow}{return} 1;
00906     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'2'}: \textcolor{keywordflow}{return} 2;
00907     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'3'}: \textcolor{keywordflow}{return} 3;
00908     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'4'}: \textcolor{keywordflow}{return} 4;
00909     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'5'}: \textcolor{keywordflow}{return} 5;
00910     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'6'}: \textcolor{keywordflow}{return} 6;
00911     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'7'}: \textcolor{keywordflow}{return} 7;
00912     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'8'}: \textcolor{keywordflow}{return} 8;
00913     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'9'}: \textcolor{keywordflow}{return} 9;
00914     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'a'}: \textcolor{keywordflow}{case} \textcolor{stringliteral}{'A'}: \textcolor{keywordflow}{return} 10;
00915     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'b'}: \textcolor{keywordflow}{case} \textcolor{stringliteral}{'B'}: \textcolor{keywordflow}{return} 11;
00916     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'c'}: \textcolor{keywordflow}{case} \textcolor{stringliteral}{'C'}: \textcolor{keywordflow}{return} 12;
00917     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'d'}: \textcolor{keywordflow}{case} \textcolor{stringliteral}{'D'}: \textcolor{keywordflow}{return} 13;
00918     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'e'}: \textcolor{keywordflow}{case} \textcolor{stringliteral}{'E'}: \textcolor{keywordflow}{return} 14;
00919     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'f'}: \textcolor{keywordflow}{case} \textcolor{stringliteral}{'F'}: \textcolor{keywordflow}{return} 15;
00920     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} 0;
00921     \}
00922 \}
00923 
00924 \textcolor{comment}{/* Split a line into arguments, where every argument can be in the}
00925 \textcolor{comment}{ * following programming-language REPL-alike form:}
00926 \textcolor{comment}{ *}
00927 \textcolor{comment}{ * foo bar "newline are supported\(\backslash\)n" and "\(\backslash\)xff\(\backslash\)x00otherstuff"}
00928 \textcolor{comment}{ *}
00929 \textcolor{comment}{ * The number of arguments is stored into *argc, and an array}
00930 \textcolor{comment}{ * of sds is returned.}
00931 \textcolor{comment}{ *}
00932 \textcolor{comment}{ * The caller should free the resulting array of sds strings with}
00933 \textcolor{comment}{ * sdsfreesplitres().}
00934 \textcolor{comment}{ *}
00935 \textcolor{comment}{ * Note that sdscatrepr() is able to convert back a string into}
00936 \textcolor{comment}{ * a quoted string in the same format sdssplitargs() is able to parse.}
00937 \textcolor{comment}{ *}
00938 \textcolor{comment}{ * The function returns the allocated tokens on success, even when the}
00939 \textcolor{comment}{ * input string is empty, or NULL if the input contains unbalanced}
00940 \textcolor{comment}{ * quotes or closed quotes followed by non space characters}
00941 \textcolor{comment}{ * as in: "foo"bar or "foo'}
00942 \textcolor{comment}{ */}
00943 sds *sdssplitargs(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *line, \textcolor{keywordtype}{int} *argc) \{
00944     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *p = line;
00945     \textcolor{keywordtype}{char} *current = NULL;
00946     \textcolor{keywordtype}{char} **vector = NULL;
00947 
00948     *argc = 0;
00949     \textcolor{keywordflow}{while}(1) \{
00950         \textcolor{comment}{/* skip blanks */}
00951         \textcolor{keywordflow}{while}(*p && isspace(*p)) p++;
00952         \textcolor{keywordflow}{if} (*p) \{
00953             \textcolor{comment}{/* get a token */}
00954             \textcolor{keywordtype}{int} inq=0;  \textcolor{comment}{/* set to 1 if we are in "quotes" */}
00955             \textcolor{keywordtype}{int} insq=0; \textcolor{comment}{/* set to 1 if we are in 'single quotes' */}
00956             \textcolor{keywordtype}{int} done=0;
00957 
00958             \textcolor{keywordflow}{if} (current == NULL) current = sdsempty();
00959             \textcolor{keywordflow}{while}(!done) \{
00960                 \textcolor{keywordflow}{if} (inq) \{
00961                     \textcolor{keywordflow}{if} (*p == \textcolor{stringliteral}{'\(\backslash\)\(\backslash\)'} && *(p+1) == \textcolor{stringliteral}{'x'} &&
00962                                              is\_hex\_digit(*(p+2)) &&
00963                                              is\_hex\_digit(*(p+3)))
00964                     \{
00965                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} byte;
00966 
00967                         byte = (hex\_digit\_to\_int(*(p+2))*16)+
00968                                 hex\_digit\_to\_int(*(p+3));
00969                         current = sdscatlen(current,(\textcolor{keywordtype}{char}*)&byte,1);
00970                         p += 3;
00971                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*p == \textcolor{stringliteral}{'\(\backslash\)\(\backslash\)'} && *(p+1)) \{
00972                         \textcolor{keywordtype}{char} c;
00973 
00974                         p++;
00975                         \textcolor{keywordflow}{switch}(*p) \{
00976                         \textcolor{keywordflow}{case} \textcolor{stringliteral}{'n'}: c = \textcolor{stringliteral}{'\(\backslash\)n'}; \textcolor{keywordflow}{break};
00977                         \textcolor{keywordflow}{case} \textcolor{stringliteral}{'r'}: c = \textcolor{stringliteral}{'\(\backslash\)r'}; \textcolor{keywordflow}{break};
00978                         \textcolor{keywordflow}{case} \textcolor{stringliteral}{'t'}: c = \textcolor{stringliteral}{'\(\backslash\)t'}; \textcolor{keywordflow}{break};
00979                         \textcolor{keywordflow}{case} \textcolor{stringliteral}{'b'}: c = \textcolor{stringliteral}{'\(\backslash\)b'}; \textcolor{keywordflow}{break};
00980                         \textcolor{keywordflow}{case} \textcolor{stringliteral}{'a'}: c = \textcolor{stringliteral}{'\(\backslash\)a'}; \textcolor{keywordflow}{break};
00981                         \textcolor{keywordflow}{default}: c = *p; \textcolor{keywordflow}{break};
00982                         \}
00983                         current = sdscatlen(current,&c,1);
00984                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*p == \textcolor{stringliteral}{'"'}) \{
00985                         \textcolor{comment}{/* closing quote must be followed by a space or}
00986 \textcolor{comment}{                         * nothing at all. */}
00987                         \textcolor{keywordflow}{if} (*(p+1) && !isspace(*(p+1))) \textcolor{keywordflow}{goto} err;
00988                         done=1;
00989                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!*p) \{
00990                         \textcolor{comment}{/* unterminated quotes */}
00991                         \textcolor{keywordflow}{goto} err;
00992                     \} \textcolor{keywordflow}{else} \{
00993                         current = sdscatlen(current,p,1);
00994                     \}
00995                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (insq) \{
00996                     \textcolor{keywordflow}{if} (*p == \textcolor{stringliteral}{'\(\backslash\)\(\backslash\)'} && *(p+1) == \textcolor{stringliteral}{'\(\backslash\)''}) \{
00997                         p++;
00998                         current = sdscatlen(current,\textcolor{stringliteral}{"'"},1);
00999                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*p == \textcolor{stringliteral}{'\(\backslash\)''}) \{
01000                         \textcolor{comment}{/* closing quote must be followed by a space or}
01001 \textcolor{comment}{                         * nothing at all. */}
01002                         \textcolor{keywordflow}{if} (*(p+1) && !isspace(*(p+1))) \textcolor{keywordflow}{goto} err;
01003                         done=1;
01004                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!*p) \{
01005                         \textcolor{comment}{/* unterminated quotes */}
01006                         \textcolor{keywordflow}{goto} err;
01007                     \} \textcolor{keywordflow}{else} \{
01008                         current = sdscatlen(current,p,1);
01009                     \}
01010                 \} \textcolor{keywordflow}{else} \{
01011                     \textcolor{keywordflow}{switch}(*p) \{
01012                     \textcolor{keywordflow}{case} \textcolor{stringliteral}{' '}:
01013                     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'\(\backslash\)n'}:
01014                     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'\(\backslash\)r'}:
01015                     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'\(\backslash\)t'}:
01016                     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'\(\backslash\)0'}:
01017                         done=1;
01018                         \textcolor{keywordflow}{break};
01019                     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'"'}:
01020                         inq=1;
01021                         \textcolor{keywordflow}{break};
01022                     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'\(\backslash\)''}:
01023                         insq=1;
01024                         \textcolor{keywordflow}{break};
01025                     \textcolor{keywordflow}{default}:
01026                         current = sdscatlen(current,p,1);
01027                         \textcolor{keywordflow}{break};
01028                     \}
01029                 \}
01030                 \textcolor{keywordflow}{if} (*p) p++;
01031             \}
01032             \textcolor{comment}{/* add the token to the vector */}
01033             vector = \hyperlink{sdsalloc_8h_a86d1b352c4e2c2848948649747bd296a}{s\_realloc}(vector,((*argc)+1)*\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char}*));
01034             vector[*argc] = current;
01035             (*argc)++;
01036             current = NULL;
01037         \} \textcolor{keywordflow}{else} \{
01038             \textcolor{comment}{/* Even on empty input string return something not NULL. */}
01039             \textcolor{keywordflow}{if} (vector == NULL) vector = \hyperlink{sdsalloc_8h_a41e8c1188dca30db85c410c25fb417b6}{s\_malloc}(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*));
01040             \textcolor{keywordflow}{return} vector;
01041         \}
01042     \}
01043 
01044 err:
01045     \textcolor{keywordflow}{while}((*argc)--)
01046         sdsfree(vector[*argc]);
01047     \hyperlink{sdsalloc_8h_aa06cb49194c292098a753d87e2ac6b71}{s\_free}(vector);
01048     \textcolor{keywordflow}{if} (current) sdsfree(current);
01049     *argc = 0;
01050     \textcolor{keywordflow}{return} NULL;
01051 \}
01052 
01053 \textcolor{comment}{/* Modify the string substituting all the occurrences of the set of}
01054 \textcolor{comment}{ * characters specified in the 'from' string to the corresponding character}
01055 \textcolor{comment}{ * in the 'to' array.}
01056 \textcolor{comment}{ *}
01057 \textcolor{comment}{ * For instance: sdsmapchars(mystring, "ho", "01", 2)}
01058 \textcolor{comment}{ * will have the effect of turning the string "hello" into "0ell1".}
01059 \textcolor{comment}{ *}
01060 \textcolor{comment}{ * The function returns the sds string pointer, that is always the same}
01061 \textcolor{comment}{ * as the input pointer since no resize is needed. */}
01062 sds sdsmapchars(sds s, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *from, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *to, size\_t setlen) \{
01063     size\_t j, i, l = sdslen(s);
01064 
01065     \textcolor{keywordflow}{for} (j = 0; j < l; j++) \{
01066         \textcolor{keywordflow}{for} (i = 0; i < setlen; i++) \{
01067             \textcolor{keywordflow}{if} (s[j] == from[i]) \{
01068                 s[j] = to[i];
01069                 \textcolor{keywordflow}{break};
01070             \}
01071         \}
01072     \}
01073     \textcolor{keywordflow}{return} s;
01074 \}
01075 
01076 \textcolor{comment}{/* Join an array of C strings using the specified separator (also a C string).}
01077 \textcolor{comment}{ * Returns the result as an sds string. */}
01078 sds sdsjoin(\textcolor{keywordtype}{char} **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *sep) \{
01079     sds join = sdsempty();
01080     \textcolor{keywordtype}{int} j;
01081 
01082     \textcolor{keywordflow}{for} (j = 0; j < argc; j++) \{
01083         join = sdscat(join, argv[j]);
01084         \textcolor{keywordflow}{if} (j != argc-1) join = sdscat(join,sep);
01085     \}
01086     \textcolor{keywordflow}{return} join;
01087 \}
01088 
01089 \textcolor{comment}{/* Like sdsjoin, but joins an array of SDS strings. */}
01090 sds sdsjoinsds(sds *argv, \textcolor{keywordtype}{int} argc, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *sep, size\_t seplen) \{
01091     sds join = sdsempty();
01092     \textcolor{keywordtype}{int} j;
01093 
01094     \textcolor{keywordflow}{for} (j = 0; j < argc; j++) \{
01095         join = sdscatsds(join, argv[j]);
01096         \textcolor{keywordflow}{if} (j != argc-1) join = sdscatlen(join,sep,seplen);
01097     \}
01098     \textcolor{keywordflow}{return} join;
01099 \}
01100 
01101 \textcolor{comment}{/* Wrappers to the allocators used by SDS. Note that SDS will actually}
01102 \textcolor{comment}{ * just use the macros defined into sdsalloc.h in order to avoid to pay}
01103 \textcolor{comment}{ * the overhead of function calls. Here we define these wrappers only for}
01104 \textcolor{comment}{ * the programs SDS is linked to, if they want to touch the SDS internals}
01105 \textcolor{comment}{ * even if they use a different allocator. */}
01106 \textcolor{keywordtype}{void} *sds\_malloc(size\_t size) \{ \textcolor{keywordflow}{return} \hyperlink{sdsalloc_8h_a41e8c1188dca30db85c410c25fb417b6}{s\_malloc}(size); \}
01107 \textcolor{keywordtype}{void} *sds\_realloc(\textcolor{keywordtype}{void} *ptr, size\_t size) \{ \textcolor{keywordflow}{return} \hyperlink{sdsalloc_8h_a86d1b352c4e2c2848948649747bd296a}{s\_realloc}(ptr,size); \}
01108 \textcolor{keywordtype}{void} sds\_free(\textcolor{keywordtype}{void} *ptr) \{ \hyperlink{sdsalloc_8h_aa06cb49194c292098a753d87e2ac6b71}{s\_free}(ptr); \}
01109 
01110 \textcolor{preprocessor}{#}\textcolor{preprocessor}{if} \textcolor{preprocessor}{defined}\textcolor{preprocessor}{(}\textcolor{preprocessor}{SDS\_TEST\_MAIN}\textcolor{preprocessor}{)}
01111 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdio}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
01112 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{stringliteral}{"testhelp.h"}
01113 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{stringliteral}{"limits.h"}
01114 
01115 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{UNUSED}\textcolor{preprocessor}{(}\textcolor{preprocessor}{x}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{void}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{preprocessor}{x}\textcolor{preprocessor}{)}
01116 \textcolor{keywordtype}{int} sdsTest(\textcolor{keywordtype}{void}) \{
01117     \{
01118         sds x = sdsnew(\textcolor{stringliteral}{"foo"}), y;
01119 
01120         test\_cond(\textcolor{stringliteral}{"Create a string and obtain the length"},
01121             sdslen(x) == 3 && memcmp(x,\textcolor{stringliteral}{"foo\(\backslash\)0"},4) == 0)
01122 
01123         sdsfree(x);
01124         x = sdsnewlen(\textcolor{stringliteral}{"foo"},2);
01125         test\_cond(\textcolor{stringliteral}{"Create a string with specified length"},
01126             sdslen(x) == 2 && memcmp(x,\textcolor{stringliteral}{"fo\(\backslash\)0"},3) == 0)
01127 
01128         x = sdscat(x,\textcolor{stringliteral}{"bar"});
01129         test\_cond(\textcolor{stringliteral}{"Strings concatenation"},
01130             sdslen(x) == 5 && memcmp(x,\textcolor{stringliteral}{"fobar\(\backslash\)0"},6) == 0);
01131 
01132         x = sdscpy(x,\textcolor{stringliteral}{"a"});
01133         test\_cond(\textcolor{stringliteral}{"sdscpy() against an originally longer string"},
01134             sdslen(x) == 1 && memcmp(x,\textcolor{stringliteral}{"a\(\backslash\)0"},2) == 0)
01135 
01136         x = sdscpy(x,\textcolor{stringliteral}{"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk"});
01137         test\_cond(\textcolor{stringliteral}{"sdscpy() against an originally shorter string"},
01138             sdslen(x) == 33 &&
01139             memcmp(x,\textcolor{stringliteral}{"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\(\backslash\)0"},33) == 0)
01140 
01141         sdsfree(x);
01142         x = sdscatprintf(sdsempty(),\textcolor{stringliteral}{"%d"},123);
01143         test\_cond(\textcolor{stringliteral}{"sdscatprintf() seems working in the base case"},
01144             sdslen(x) == 3 && memcmp(x,\textcolor{stringliteral}{"123\(\backslash\)0"},4) == 0)
01145 
01146         sdsfree(x);
01147         x = sdsnew(\textcolor{stringliteral}{"--"});
01148         x = sdscatfmt(x, \textcolor{stringliteral}{"Hello %s World %I,%I--"}, \textcolor{stringliteral}{"Hi!"}, LLONG\_MIN,LLONG\_MAX);
01149         test\_cond(\textcolor{stringliteral}{"sdscatfmt() seems working in the base case"},
01150             sdslen(x) == 60 &&
01151             memcmp(x,\textcolor{stringliteral}{"--Hello Hi! World -9223372036854775808,"}
01152                      \textcolor{stringliteral}{"9223372036854775807--"},60) == 0)
01153         printf(\textcolor{stringliteral}{"[%s]\(\backslash\)n"},x);
01154 
01155         sdsfree(x);
01156         x = sdsnew(\textcolor{stringliteral}{"--"});
01157         x = sdscatfmt(x, \textcolor{stringliteral}{"%u,%U--"}, UINT\_MAX, ULLONG\_MAX);
01158         test\_cond(\textcolor{stringliteral}{"sdscatfmt() seems working with unsigned numbers"},
01159             sdslen(x) == 35 &&
01160             memcmp(x,\textcolor{stringliteral}{"--4294967295,18446744073709551615--"},35) == 0)
01161 
01162         sdsfree(x);
01163         x = sdsnew(\textcolor{stringliteral}{" x "});
01164         sdstrim(x,\textcolor{stringliteral}{" x"});
01165         test\_cond(\textcolor{stringliteral}{"sdstrim() works when all chars match"},
01166             sdslen(x) == 0)
01167 
01168         sdsfree(x);
01169         x = sdsnew(\textcolor{stringliteral}{" x "});
01170         sdstrim(x,\textcolor{stringliteral}{" "});
01171         test\_cond(\textcolor{stringliteral}{"sdstrim() works when a single char remains"},
01172             sdslen(x) == 1 && x[0] == \textcolor{stringliteral}{'x'})
01173 
01174         sdsfree(x);
01175         x = sdsnew(\textcolor{stringliteral}{"xxciaoyyy"});
01176         sdstrim(x,\textcolor{stringliteral}{"xy"});
01177         test\_cond(\textcolor{stringliteral}{"sdstrim() correctly trims characters"},
01178             sdslen(x) == 4 && memcmp(x,\textcolor{stringliteral}{"ciao\(\backslash\)0"},5) == 0)
01179 
01180         y = sdsdup(x);
01181         sdsrange(y,1,1);
01182         test\_cond(\textcolor{stringliteral}{"sdsrange(...,1,1)"},
01183             sdslen(y) == 1 && memcmp(y,\textcolor{stringliteral}{"i\(\backslash\)0"},2) == 0)
01184 
01185         sdsfree(y);
01186         y = sdsdup(x);
01187         sdsrange(y,1,-1);
01188         test\_cond(\textcolor{stringliteral}{"sdsrange(...,1,-1)"},
01189             sdslen(y) == 3 && memcmp(y,\textcolor{stringliteral}{"iao\(\backslash\)0"},4) == 0)
01190 
01191         sdsfree(y);
01192         y = sdsdup(x);
01193         sdsrange(y,-2,-1);
01194         test\_cond(\textcolor{stringliteral}{"sdsrange(...,-2,-1)"},
01195             sdslen(y) == 2 && memcmp(y,\textcolor{stringliteral}{"ao\(\backslash\)0"},3) == 0)
01196 
01197         sdsfree(y);
01198         y = sdsdup(x);
01199         sdsrange(y,2,1);
01200         test\_cond(\textcolor{stringliteral}{"sdsrange(...,2,1)"},
01201             sdslen(y) == 0 && memcmp(y,\textcolor{stringliteral}{"\(\backslash\)0"},1) == 0)
01202 
01203         sdsfree(y);
01204         y = sdsdup(x);
01205         sdsrange(y,1,100);
01206         test\_cond(\textcolor{stringliteral}{"sdsrange(...,1,100)"},
01207             sdslen(y) == 3 && memcmp(y,\textcolor{stringliteral}{"iao\(\backslash\)0"},4) == 0)
01208 
01209         sdsfree(y);
01210         y = sdsdup(x);
01211         sdsrange(y,100,100);
01212         test\_cond(\textcolor{stringliteral}{"sdsrange(...,100,100)"},
01213             sdslen(y) == 0 && memcmp(y,\textcolor{stringliteral}{"\(\backslash\)0"},1) == 0)
01214 
01215         sdsfree(y);
01216         sdsfree(x);
01217         x = sdsnew(\textcolor{stringliteral}{"foo"});
01218         y = sdsnew(\textcolor{stringliteral}{"foa"});
01219         test\_cond(\textcolor{stringliteral}{"sdscmp(foo,foa)"}, sdscmp(x,y) > 0)
01220 
01221         sdsfree(y);
01222         sdsfree(x);
01223         x = sdsnew(\textcolor{stringliteral}{"bar"});
01224         y = sdsnew(\textcolor{stringliteral}{"bar"});
01225         test\_cond(\textcolor{stringliteral}{"sdscmp(bar,bar)"}, sdscmp(x,y) == 0)
01226 
01227         sdsfree(y);
01228         sdsfree(x);
01229         x = sdsnew(\textcolor{stringliteral}{"aar"});
01230         y = sdsnew(\textcolor{stringliteral}{"bar"});
01231         test\_cond(\textcolor{stringliteral}{"sdscmp(bar,bar)"}, sdscmp(x,y) < 0)
01232 
01233         sdsfree(y);
01234         sdsfree(x);
01235         x = sdsnewlen(\textcolor{stringliteral}{"\(\backslash\)a\(\backslash\)n\(\backslash\)0foo\(\backslash\)r"},7);
01236         y = sdscatrepr(sdsempty(),x,sdslen(x));
01237         test\_cond(\textcolor{stringliteral}{"sdscatrepr(...data...)"},
01238             memcmp(y,\textcolor{stringliteral}{"\(\backslash\)"\(\backslash\)\(\backslash\)a\(\backslash\)\(\backslash\)n\(\backslash\)\(\backslash\)x00foo\(\backslash\)\(\backslash\)r\(\backslash\)""},15) == 0)
01239 
01240         \{
01241             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} oldfree;
01242             \textcolor{keywordtype}{char} *p;
01243             \textcolor{keywordtype}{int} step = 10, j, i;
01244 
01245             sdsfree(x);
01246             sdsfree(y);
01247             x = sdsnew(\textcolor{stringliteral}{"0"});
01248             test\_cond(\textcolor{stringliteral}{"sdsnew() free/len buffers"}, sdslen(x) == 1 && sdsavail(x) == 0);
01249 
01250             \textcolor{comment}{/* Run the test a few times in order to hit the first two}
01251 \textcolor{comment}{             * SDS header types. */}
01252             \textcolor{keywordflow}{for} (i = 0; i < 10; i++) \{
01253                 \textcolor{keywordtype}{int} oldlen = sdslen(x);
01254                 x = sdsMakeRoomFor(x,step);
01255                 \textcolor{keywordtype}{int} type = x[-1]&SDS\_TYPE\_MASK;
01256 
01257                 test\_cond(\textcolor{stringliteral}{"sdsMakeRoomFor() len"}, sdslen(x) == oldlen);
01258                 \textcolor{keywordflow}{if} (type != SDS\_TYPE\_5) \{
01259                     test\_cond(\textcolor{stringliteral}{"sdsMakeRoomFor() free"}, sdsavail(x) >= step);
01260                     oldfree = sdsavail(x);
01261                 \}
01262                 p = x+oldlen;
01263                 \textcolor{keywordflow}{for} (j = 0; j < step; j++) \{
01264                     p[j] = \textcolor{stringliteral}{'A'}+j;
01265                 \}
01266                 sdsIncrLen(x,step);
01267             \}
01268             test\_cond(\textcolor{stringliteral}{"sdsMakeRoomFor() content"},
01269                 memcmp(\textcolor{stringliteral}{
      "0ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ"},x,101) == 0);
01270             test\_cond(\textcolor{stringliteral}{"sdsMakeRoomFor() final length"},sdslen(x)==101);
01271 
01272             sdsfree(x);
01273         \}
01274     \}
01275     test\_report()
01276     \textcolor{keywordflow}{return} 0;
01277 \}
01278 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
01279 
01280 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \textcolor{preprocessor}{SDS\_TEST\_MAIN}
01281 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{void}) \{
01282     \textcolor{keywordflow}{return} sdsTest();
01283 \}
01284 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
\end{DoxyCode}
