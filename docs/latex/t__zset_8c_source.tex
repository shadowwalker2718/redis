\hypertarget{t__zset_8c_source}{}\section{t\+\_\+zset.\+c}
\label{t__zset_8c_source}\index{src/t\+\_\+zset.\+c@{src/t\+\_\+zset.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>}
00003 \textcolor{comment}{ * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>}
00004 \textcolor{comment}{ * All rights reserved.}
00005 \textcolor{comment}{ *}
00006 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00007 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00008 \textcolor{comment}{ *}
00009 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00010 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00011 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00012 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00013 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00014 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00015 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00016 \textcolor{comment}{ *     specific prior written permission.}
00017 \textcolor{comment}{ *}
00018 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00019 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00020 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00021 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00022 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00023 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00024 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00025 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00026 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00027 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00028 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00029 \textcolor{comment}{ */}
00030 
00031 \textcolor{comment}{/*-----------------------------------------------------------------------------}
00032 \textcolor{comment}{ * Sorted set API}
00033 \textcolor{comment}{ *----------------------------------------------------------------------------*/}
00034 
00035 \textcolor{comment}{/* ZSETs are ordered sets using two data structures to hold the same elements}
00036 \textcolor{comment}{ * in order to get O(log(N)) INSERT and REMOVE operations into a sorted}
00037 \textcolor{comment}{ * data structure.}
00038 \textcolor{comment}{ *}
00039 \textcolor{comment}{ * The elements are added to a hash table mapping Redis objects to scores.}
00040 \textcolor{comment}{ * At the same time the elements are added to a skip list mapping scores}
00041 \textcolor{comment}{ * to Redis objects (so objects are sorted by scores in this "view").}
00042 \textcolor{comment}{ *}
00043 \textcolor{comment}{ * Note that the SDS string representing the element is the same in both}
00044 \textcolor{comment}{ * the hash table and skiplist in order to save memory. What we do in order}
00045 \textcolor{comment}{ * to manage the shared SDS string more easily is to free the SDS string}
00046 \textcolor{comment}{ * only in zslFreeNode(). The dictionary has no value free method set.}
00047 \textcolor{comment}{ * So we should always remove an element from the dictionary, and later from}
00048 \textcolor{comment}{ * the skiplist.}
00049 \textcolor{comment}{ *}
00050 \textcolor{comment}{ * This skiplist implementation is almost a C translation of the original}
00051 \textcolor{comment}{ * algorithm described by William Pugh in "Skip Lists: A Probabilistic}
00052 \textcolor{comment}{ * Alternative to Balanced Trees", modified in three ways:}
00053 \textcolor{comment}{ * a) this implementation allows for repeated scores.}
00054 \textcolor{comment}{ * b) the comparison is not just by key (our 'score') but by satellite data.}
00055 \textcolor{comment}{ * c) there is a back pointer, so it's a doubly linked list with the back}
00056 \textcolor{comment}{ * pointers being only at "level 1". This allows to traverse the list}
00057 \textcolor{comment}{ * from tail to head, useful for ZREVRANGE. */}
00058 
00059 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{server_8h}{"server.h"}
00060 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{math}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00061 
00062 \textcolor{comment}{/*-----------------------------------------------------------------------------}
00063 \textcolor{comment}{ * Skiplist implementation of the low level API}
00064 \textcolor{comment}{ *----------------------------------------------------------------------------*/}
00065 
00066 \textcolor{keywordtype}{int} zslLexValueGteMin(sds value, zlexrangespec *spec);
00067 \textcolor{keywordtype}{int} zslLexValueLteMax(sds value, zlexrangespec *spec);
00068 
00069 \textcolor{comment}{/* Create a skiplist node with the specified number of levels.}
00070 \textcolor{comment}{ * The SDS string 'ele' is referenced by the node after the call. */}
00071 zskiplistNode *zslCreateNode(\textcolor{keywordtype}{int} level, \textcolor{keywordtype}{double} score, sds ele) \{
00072     zskiplistNode *zn =
00073         zmalloc(\textcolor{keyword}{sizeof}(*zn)+level*\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} zskiplistLevel));
00074     zn->score = score;
00075     zn->ele = ele;
00076     \textcolor{keywordflow}{return} zn;
00077 \}
00078 
00079 \textcolor{comment}{/* Create a new skiplist. */}
00080 zskiplist *zslCreate(\textcolor{keywordtype}{void}) \{
00081     \textcolor{keywordtype}{int} j;
00082     zskiplist *zsl;
00083 
00084     zsl = zmalloc(\textcolor{keyword}{sizeof}(*zsl));
00085     zsl->level = 1;
00086     zsl->length = 0;
00087     zsl->header = zslCreateNode(\hyperlink{server_8h_a36822e3ce2740c64859068fd849e227b}{ZSKIPLIST\_MAXLEVEL},0,NULL);
00088     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{server_8h_a36822e3ce2740c64859068fd849e227b}{ZSKIPLIST\_MAXLEVEL}; j++) \{
00089         zsl->header->level[j].forward = NULL;
00090         zsl->header->level[j].span = 0;
00091     \}
00092     zsl->header->backward = NULL;
00093     zsl->tail = NULL;
00094     \textcolor{keywordflow}{return} zsl;
00095 \}
00096 
00097 \textcolor{comment}{/* Free the specified skiplist node. The referenced SDS string representation}
00098 \textcolor{comment}{ * of the element is freed too, unless node->ele is set to NULL before calling}
00099 \textcolor{comment}{ * this function. */}
00100 \textcolor{keywordtype}{void} zslFreeNode(zskiplistNode *node) \{
00101     sdsfree(node->ele);
00102     zfree(node);
00103 \}
00104 
00105 \textcolor{comment}{/* Free a whole skiplist. */}
00106 \textcolor{keywordtype}{void} zslFree(zskiplist *zsl) \{
00107     zskiplistNode *node = zsl->header->level[0].forward, *next;
00108 
00109     zfree(zsl->header);
00110     \textcolor{keywordflow}{while}(node) \{
00111         next = node->level[0].forward;
00112         zslFreeNode(node);
00113         node = next;
00114     \}
00115     zfree(zsl);
00116 \}
00117 
00118 \textcolor{comment}{/* Returns a random level for the new skiplist node we are going to create.}
00119 \textcolor{comment}{ * The return value of this function is between 1 and ZSKIPLIST\_MAXLEVEL}
00120 \textcolor{comment}{ * (both inclusive), with a powerlaw-alike distribution where higher}
00121 \textcolor{comment}{ * levels are less likely to be returned. */}
00122 \textcolor{keywordtype}{int} zslRandomLevel(\textcolor{keywordtype}{void}) \{
00123     \textcolor{keywordtype}{int} level = 1;
00124     \textcolor{keywordflow}{while} ((random()&0xFFFF) < (\hyperlink{server_8h_a6cb1a940e657f4a54397ed1f580fdccc}{ZSKIPLIST\_P} * 0xFFFF))
00125         level += 1;
00126     \textcolor{keywordflow}{return} (level<\hyperlink{server_8h_a36822e3ce2740c64859068fd849e227b}{ZSKIPLIST\_MAXLEVEL}) ? level : 
      \hyperlink{server_8h_a36822e3ce2740c64859068fd849e227b}{ZSKIPLIST\_MAXLEVEL};
00127 \}
00128 
00129 \textcolor{comment}{/* Insert a new node in the skiplist. Assumes the element does not already}
00130 \textcolor{comment}{ * exist (up to the caller to enforce that). The skiplist takes ownership}
00131 \textcolor{comment}{ * of the passed SDS string 'ele'. */}
00132 zskiplistNode *zslInsert(zskiplist *zsl, \textcolor{keywordtype}{double} score, sds ele) \{
00133     zskiplistNode *update[\hyperlink{server_8h_a36822e3ce2740c64859068fd849e227b}{ZSKIPLIST\_MAXLEVEL}], *x;
00134     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rank[\hyperlink{server_8h_a36822e3ce2740c64859068fd849e227b}{ZSKIPLIST\_MAXLEVEL}];
00135     \textcolor{keywordtype}{int} i, level;
00136 
00137     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(!isnan(score));
00138     x = zsl->header;
00139     \textcolor{keywordflow}{for} (i = zsl->level-1; i >= 0; i--) \{
00140         \textcolor{comment}{/* store rank that is crossed to reach the insert position */}
00141         rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];
00142         \textcolor{keywordflow}{while} (x->level[i].forward &&
00143                 (x->level[i].forward->score < score ||
00144                     (x->level[i].forward->score == score &&
00145                     sdscmp(x->level[i].forward->ele,ele) < 0)))
00146         \{
00147             rank[i] += x->level[i].span;
00148             x = x->level[i].forward;
00149         \}
00150         update[i] = x;
00151     \}
00152     \textcolor{comment}{/* we assume the element is not already inside, since we allow duplicated}
00153 \textcolor{comment}{     * scores, reinserting the same element should never happen since the}
00154 \textcolor{comment}{     * caller of zslInsert() should test in the hash table if the element is}
00155 \textcolor{comment}{     * already inside or not. */}
00156     level = zslRandomLevel();
00157     \textcolor{keywordflow}{if} (level > zsl->level) \{
00158         \textcolor{keywordflow}{for} (i = zsl->level; i < level; i++) \{
00159             rank[i] = 0;
00160             update[i] = zsl->header;
00161             update[i]->level[i].span = zsl->length;
00162         \}
00163         zsl->level = level;
00164     \}
00165     x = zslCreateNode(level,score,ele);
00166     \textcolor{keywordflow}{for} (i = 0; i < level; i++) \{
00167         x->level[i].forward = update[i]->level[i].forward;
00168         update[i]->level[i].forward = x;
00169 
00170         \textcolor{comment}{/* update span covered by update[i] as x is inserted here */}
00171         x->level[i].span = update[i]->level[i].span - (rank[0] - rank[i]);
00172         update[i]->level[i].span = (rank[0] - rank[i]) + 1;
00173     \}
00174 
00175     \textcolor{comment}{/* increment span for untouched levels */}
00176     \textcolor{keywordflow}{for} (i = level; i < zsl->level; i++) \{
00177         update[i]->level[i].span++;
00178     \}
00179 
00180     x->backward = (update[0] == zsl->header) ? NULL : update[0];
00181     \textcolor{keywordflow}{if} (x->level[0].forward)
00182         x->level[0].forward->backward = x;
00183     \textcolor{keywordflow}{else}
00184         zsl->tail = x;
00185     zsl->length++;
00186     \textcolor{keywordflow}{return} x;
00187 \}
00188 
00189 \textcolor{comment}{/* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */}
00190 \textcolor{keywordtype}{void} zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) \{
00191     \textcolor{keywordtype}{int} i;
00192     \textcolor{keywordflow}{for} (i = 0; i < zsl->level; i++) \{
00193         \textcolor{keywordflow}{if} (update[i]->level[i].forward == x) \{
00194             update[i]->level[i].span += x->level[i].span - 1;
00195             update[i]->level[i].forward = x->level[i].forward;
00196         \} \textcolor{keywordflow}{else} \{
00197             update[i]->level[i].span -= 1;
00198         \}
00199     \}
00200     \textcolor{keywordflow}{if} (x->level[0].forward) \{
00201         x->level[0].forward->backward = x->backward;
00202     \} \textcolor{keywordflow}{else} \{
00203         zsl->tail = x->backward;
00204     \}
00205     \textcolor{keywordflow}{while}(zsl->level > 1 && zsl->header->level[zsl->level-1].forward == NULL)
00206         zsl->level--;
00207     zsl->length--;
00208 \}
00209 
00210 \textcolor{comment}{/* Delete an element with matching score/element from the skiplist.}
00211 \textcolor{comment}{ * The function returns 1 if the node was found and deleted, otherwise}
00212 \textcolor{comment}{ * 0 is returned.}
00213 \textcolor{comment}{ *}
00214 \textcolor{comment}{ * If 'node' is NULL the deleted node is freed by zslFreeNode(), otherwise}
00215 \textcolor{comment}{ * it is not freed (but just unlinked) and *node is set to the node pointer,}
00216 \textcolor{comment}{ * so that it is possible for the caller to reuse the node (including the}
00217 \textcolor{comment}{ * referenced SDS string at node->ele). */}
00218 \textcolor{keywordtype}{int} zslDelete(zskiplist *zsl, \textcolor{keywordtype}{double} score, sds ele, zskiplistNode **node) \{
00219     zskiplistNode *update[\hyperlink{server_8h_a36822e3ce2740c64859068fd849e227b}{ZSKIPLIST\_MAXLEVEL}], *x;
00220     \textcolor{keywordtype}{int} i;
00221 
00222     x = zsl->header;
00223     \textcolor{keywordflow}{for} (i = zsl->level-1; i >= 0; i--) \{
00224         \textcolor{keywordflow}{while} (x->level[i].forward &&
00225                 (x->level[i].forward->score < score ||
00226                     (x->level[i].forward->score == score &&
00227                      sdscmp(x->level[i].forward->ele,ele) < 0)))
00228         \{
00229             x = x->level[i].forward;
00230         \}
00231         update[i] = x;
00232     \}
00233     \textcolor{comment}{/* We may have multiple elements with the same score, what we need}
00234 \textcolor{comment}{     * is to find the element with both the right score and object. */}
00235     x = x->level[0].forward;
00236     \textcolor{keywordflow}{if} (x && score == x->score && sdscmp(x->ele,ele) == 0) \{
00237         zslDeleteNode(zsl, x, update);
00238         \textcolor{keywordflow}{if} (!node)
00239             zslFreeNode(x);
00240         \textcolor{keywordflow}{else}
00241             *node = x;
00242         \textcolor{keywordflow}{return} 1;
00243     \}
00244     \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* not found */}
00245 \}
00246 
00247 \textcolor{keywordtype}{int} zslValueGteMin(\textcolor{keywordtype}{double} value, zrangespec *spec) \{
00248     \textcolor{keywordflow}{return} spec->minex ? (value > spec->min) : (value >= spec->min);
00249 \}
00250 
00251 \textcolor{keywordtype}{int} zslValueLteMax(\textcolor{keywordtype}{double} value, zrangespec *spec) \{
00252     \textcolor{keywordflow}{return} spec->maxex ? (value < spec->max) : (value <= spec->max);
00253 \}
00254 
00255 \textcolor{comment}{/* Returns if there is a part of the zset is in range. */}
00256 \textcolor{keywordtype}{int} zslIsInRange(zskiplist *zsl, zrangespec *range) \{
00257     zskiplistNode *x;
00258 
00259     \textcolor{comment}{/* Test for ranges that will always be empty. */}
00260     \textcolor{keywordflow}{if} (range->min > range->max ||
00261             (range->min == range->max && (range->minex || range->maxex)))
00262         \textcolor{keywordflow}{return} 0;
00263     x = zsl->tail;
00264     \textcolor{keywordflow}{if} (x == NULL || !zslValueGteMin(x->score,range))
00265         \textcolor{keywordflow}{return} 0;
00266     x = zsl->header->level[0].forward;
00267     \textcolor{keywordflow}{if} (x == NULL || !zslValueLteMax(x->score,range))
00268         \textcolor{keywordflow}{return} 0;
00269     \textcolor{keywordflow}{return} 1;
00270 \}
00271 
00272 \textcolor{comment}{/* Find the first node that is contained in the specified range.}
00273 \textcolor{comment}{ * Returns NULL when no element is contained in the range. */}
00274 zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) \{
00275     zskiplistNode *x;
00276     \textcolor{keywordtype}{int} i;
00277 
00278     \textcolor{comment}{/* If everything is out of range, return early. */}
00279     \textcolor{keywordflow}{if} (!zslIsInRange(zsl,range)) \textcolor{keywordflow}{return} NULL;
00280 
00281     x = zsl->header;
00282     \textcolor{keywordflow}{for} (i = zsl->level-1; i >= 0; i--) \{
00283         \textcolor{comment}{/* Go forward while *OUT* of range. */}
00284         \textcolor{keywordflow}{while} (x->level[i].forward &&
00285             !zslValueGteMin(x->level[i].forward->score,range))
00286                 x = x->level[i].forward;
00287     \}
00288 
00289     \textcolor{comment}{/* This is an inner range, so the next node cannot be NULL. */}
00290     x = x->level[0].forward;
00291     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(x != NULL);
00292 
00293     \textcolor{comment}{/* Check if score <= max. */}
00294     \textcolor{keywordflow}{if} (!zslValueLteMax(x->score,range)) \textcolor{keywordflow}{return} NULL;
00295     \textcolor{keywordflow}{return} x;
00296 \}
00297 
00298 \textcolor{comment}{/* Find the last node that is contained in the specified range.}
00299 \textcolor{comment}{ * Returns NULL when no element is contained in the range. */}
00300 zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) \{
00301     zskiplistNode *x;
00302     \textcolor{keywordtype}{int} i;
00303 
00304     \textcolor{comment}{/* If everything is out of range, return early. */}
00305     \textcolor{keywordflow}{if} (!zslIsInRange(zsl,range)) \textcolor{keywordflow}{return} NULL;
00306 
00307     x = zsl->header;
00308     \textcolor{keywordflow}{for} (i = zsl->level-1; i >= 0; i--) \{
00309         \textcolor{comment}{/* Go forward while *IN* range. */}
00310         \textcolor{keywordflow}{while} (x->level[i].forward &&
00311             zslValueLteMax(x->level[i].forward->score,range))
00312                 x = x->level[i].forward;
00313     \}
00314 
00315     \textcolor{comment}{/* This is an inner range, so this node cannot be NULL. */}
00316     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(x != NULL);
00317 
00318     \textcolor{comment}{/* Check if score >= min. */}
00319     \textcolor{keywordflow}{if} (!zslValueGteMin(x->score,range)) \textcolor{keywordflow}{return} NULL;
00320     \textcolor{keywordflow}{return} x;
00321 \}
00322 
00323 \textcolor{comment}{/* Delete all the elements with score between min and max from the skiplist.}
00324 \textcolor{comment}{ * Min and max are inclusive, so a score >= min || score <= max is deleted.}
00325 \textcolor{comment}{ * Note that this function takes the reference to the hash table view of the}
00326 \textcolor{comment}{ * sorted set, in order to remove the elements from the hash table too. */}
00327 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dict) \{
00328     zskiplistNode *update[\hyperlink{server_8h_a36822e3ce2740c64859068fd849e227b}{ZSKIPLIST\_MAXLEVEL}], *x;
00329     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} removed = 0;
00330     \textcolor{keywordtype}{int} i;
00331 
00332     x = zsl->header;
00333     \textcolor{keywordflow}{for} (i = zsl->level-1; i >= 0; i--) \{
00334         \textcolor{keywordflow}{while} (x->level[i].forward && (range->minex ?
00335             x->level[i].forward->score <= range->min :
00336             x->level[i].forward->score < range->min))
00337                 x = x->level[i].forward;
00338         update[i] = x;
00339     \}
00340 
00341     \textcolor{comment}{/* Current node is the last with score < or <= min. */}
00342     x = x->level[0].forward;
00343 
00344     \textcolor{comment}{/* Delete nodes while in range. */}
00345     \textcolor{keywordflow}{while} (x &&
00346            (range->maxex ? x->score < range->max : x->score <= range->max))
00347     \{
00348         zskiplistNode *next = x->level[0].forward;
00349         zslDeleteNode(zsl,x,update);
00350         dictDelete(dict,x->ele);
00351         zslFreeNode(x); \textcolor{comment}{/* Here is where x->ele is actually released. */}
00352         removed++;
00353         x = next;
00354     \}
00355     \textcolor{keywordflow}{return} removed;
00356 \}
00357 
00358 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} zslDeleteRangeByLex(zskiplist *zsl, zlexrangespec *range, dict *dict) \{
00359     zskiplistNode *update[\hyperlink{server_8h_a36822e3ce2740c64859068fd849e227b}{ZSKIPLIST\_MAXLEVEL}], *x;
00360     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} removed = 0;
00361     \textcolor{keywordtype}{int} i;
00362 
00363 
00364     x = zsl->header;
00365     \textcolor{keywordflow}{for} (i = zsl->level-1; i >= 0; i--) \{
00366         \textcolor{keywordflow}{while} (x->level[i].forward &&
00367             !zslLexValueGteMin(x->level[i].forward->ele,range))
00368                 x = x->level[i].forward;
00369         update[i] = x;
00370     \}
00371 
00372     \textcolor{comment}{/* Current node is the last with score < or <= min. */}
00373     x = x->level[0].forward;
00374 
00375     \textcolor{comment}{/* Delete nodes while in range. */}
00376     \textcolor{keywordflow}{while} (x && zslLexValueLteMax(x->ele,range)) \{
00377         zskiplistNode *next = x->level[0].forward;
00378         zslDeleteNode(zsl,x,update);
00379         dictDelete(dict,x->ele);
00380         zslFreeNode(x); \textcolor{comment}{/* Here is where x->ele is actually released. */}
00381         removed++;
00382         x = next;
00383     \}
00384     \textcolor{keywordflow}{return} removed;
00385 \}
00386 
00387 \textcolor{comment}{/* Delete all the elements with rank between start and end from the skiplist.}
00388 \textcolor{comment}{ * Start and end are inclusive. Note that start and end need to be 1-based */}
00389 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} zslDeleteRangeByRank(zskiplist *zsl, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} start, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} end, dict *dict) \{
00390     zskiplistNode *update[\hyperlink{server_8h_a36822e3ce2740c64859068fd849e227b}{ZSKIPLIST\_MAXLEVEL}], *x;
00391     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} traversed = 0, removed = 0;
00392     \textcolor{keywordtype}{int} i;
00393 
00394     x = zsl->header;
00395     \textcolor{keywordflow}{for} (i = zsl->level-1; i >= 0; i--) \{
00396         \textcolor{keywordflow}{while} (x->level[i].forward && (traversed + x->level[i].span) < start) \{
00397             traversed += x->level[i].span;
00398             x = x->level[i].forward;
00399         \}
00400         update[i] = x;
00401     \}
00402 
00403     traversed++;
00404     x = x->level[0].forward;
00405     \textcolor{keywordflow}{while} (x && traversed <= end) \{
00406         zskiplistNode *next = x->level[0].forward;
00407         zslDeleteNode(zsl,x,update);
00408         dictDelete(dict,x->ele);
00409         zslFreeNode(x);
00410         removed++;
00411         traversed++;
00412         x = next;
00413     \}
00414     \textcolor{keywordflow}{return} removed;
00415 \}
00416 
00417 \textcolor{comment}{/* Find the rank for an element by both score and key.}
00418 \textcolor{comment}{ * Returns 0 when the element cannot be found, rank otherwise.}
00419 \textcolor{comment}{ * Note that the rank is 1-based due to the span of zsl->header to the}
00420 \textcolor{comment}{ * first element. */}
00421 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} zslGetRank(zskiplist *zsl, \textcolor{keywordtype}{double} score, sds ele) \{
00422     zskiplistNode *x;
00423     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} rank = 0;
00424     \textcolor{keywordtype}{int} i;
00425 
00426     x = zsl->header;
00427     \textcolor{keywordflow}{for} (i = zsl->level-1; i >= 0; i--) \{
00428         \textcolor{keywordflow}{while} (x->level[i].forward &&
00429             (x->level[i].forward->score < score ||
00430                 (x->level[i].forward->score == score &&
00431                 sdscmp(x->level[i].forward->ele,ele) <= 0))) \{
00432             rank += x->level[i].span;
00433             x = x->level[i].forward;
00434         \}
00435 
00436         \textcolor{comment}{/* x might be equal to zsl->header, so test if obj is non-NULL */}
00437         \textcolor{keywordflow}{if} (x->ele && sdscmp(x->ele,ele) == 0) \{
00438             \textcolor{keywordflow}{return} rank;
00439         \}
00440     \}
00441     \textcolor{keywordflow}{return} 0;
00442 \}
00443 
00444 \textcolor{comment}{/* Finds an element by its rank. The rank argument needs to be 1-based. */}
00445 zskiplistNode* zslGetElementByRank(zskiplist *zsl, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} rank) \{
00446     zskiplistNode *x;
00447     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} traversed = 0;
00448     \textcolor{keywordtype}{int} i;
00449 
00450     x = zsl->header;
00451     \textcolor{keywordflow}{for} (i = zsl->level-1; i >= 0; i--) \{
00452         \textcolor{keywordflow}{while} (x->level[i].forward && (traversed + x->level[i].span) <= rank)
00453         \{
00454             traversed += x->level[i].span;
00455             x = x->level[i].forward;
00456         \}
00457         \textcolor{keywordflow}{if} (traversed == rank) \{
00458             \textcolor{keywordflow}{return} x;
00459         \}
00460     \}
00461     \textcolor{keywordflow}{return} NULL;
00462 \}
00463 
00464 \textcolor{comment}{/* Populate the rangespec according to the objects min and max. */}
00465 \textcolor{keyword}{static} \textcolor{keywordtype}{int} zslParseRange(robj *min, robj *max, zrangespec *spec) \{
00466     \textcolor{keywordtype}{char} *eptr;
00467     spec->minex = spec->maxex = 0;
00468 
00469     \textcolor{comment}{/* Parse the min-max interval. If one of the values is prefixed}
00470 \textcolor{comment}{     * by the "(" character, it's considered "open". For instance}
00471 \textcolor{comment}{     * ZRANGEBYSCORE zset (1.5 (2.5 will match min < x < max}
00472 \textcolor{comment}{     * ZRANGEBYSCORE zset 1.5 2.5 will instead match min <= x <= max */}
00473     \textcolor{keywordflow}{if} (min->encoding == \hyperlink{server_8h_ae934cf008a0be0ef009c92c2d006a816}{OBJ\_ENCODING\_INT}) \{
00474         spec->min = (\textcolor{keywordtype}{long})min->ptr;
00475     \} \textcolor{keywordflow}{else} \{
00476         \textcolor{keywordflow}{if} (((\textcolor{keywordtype}{char}*)min->ptr)[0] == \textcolor{stringliteral}{'('}) \{
00477             spec->min = strtod((\textcolor{keywordtype}{char}*)min->ptr+1,&eptr);
00478             \textcolor{keywordflow}{if} (eptr[0] != \textcolor{stringliteral}{'\(\backslash\)0'} || isnan(spec->min)) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00479             spec->minex = 1;
00480         \} \textcolor{keywordflow}{else} \{
00481             spec->min = strtod((\textcolor{keywordtype}{char}*)min->ptr,&eptr);
00482             \textcolor{keywordflow}{if} (eptr[0] != \textcolor{stringliteral}{'\(\backslash\)0'} || isnan(spec->min)) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00483         \}
00484     \}
00485     \textcolor{keywordflow}{if} (max->encoding == \hyperlink{server_8h_ae934cf008a0be0ef009c92c2d006a816}{OBJ\_ENCODING\_INT}) \{
00486         spec->max = (\textcolor{keywordtype}{long})max->ptr;
00487     \} \textcolor{keywordflow}{else} \{
00488         \textcolor{keywordflow}{if} (((\textcolor{keywordtype}{char}*)max->ptr)[0] == \textcolor{stringliteral}{'('}) \{
00489             spec->max = strtod((\textcolor{keywordtype}{char}*)max->ptr+1,&eptr);
00490             \textcolor{keywordflow}{if} (eptr[0] != \textcolor{stringliteral}{'\(\backslash\)0'} || isnan(spec->max)) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00491             spec->maxex = 1;
00492         \} \textcolor{keywordflow}{else} \{
00493             spec->max = strtod((\textcolor{keywordtype}{char}*)max->ptr,&eptr);
00494             \textcolor{keywordflow}{if} (eptr[0] != \textcolor{stringliteral}{'\(\backslash\)0'} || isnan(spec->max)) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00495         \}
00496     \}
00497 
00498     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00499 \}
00500 
00501 \textcolor{comment}{/* ------------------------ Lexicographic ranges ---------------------------- */}
00502 
00503 \textcolor{comment}{/* Parse max or min argument of ZRANGEBYLEX.}
00504 \textcolor{comment}{  * (foo means foo (open interval)}
00505 \textcolor{comment}{  * [foo means foo (closed interval)}
00506 \textcolor{comment}{  * - means the min string possible}
00507 \textcolor{comment}{  * + means the max string possible}
00508 \textcolor{comment}{  *}
00509 \textcolor{comment}{  * If the string is valid the *dest pointer is set to the redis object}
00510 \textcolor{comment}{  * that will be used for the comparision, and ex will be set to 0 or 1}
00511 \textcolor{comment}{  * respectively if the item is exclusive or inclusive. C\_OK will be}
00512 \textcolor{comment}{  * returned.}
00513 \textcolor{comment}{  *}
00514 \textcolor{comment}{  * If the string is not a valid range C\_ERR is returned, and the value}
00515 \textcolor{comment}{  * of *dest and *ex is undefined. */}
00516 \textcolor{keywordtype}{int} zslParseLexRangeItem(robj *item, sds *dest, \textcolor{keywordtype}{int} *ex) \{
00517     \textcolor{keywordtype}{char} *c = item->ptr;
00518 
00519     \textcolor{keywordflow}{switch}(c[0]) \{
00520     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'+'}:
00521         \textcolor{keywordflow}{if} (c[1] != \textcolor{stringliteral}{'\(\backslash\)0'}) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00522         *ex = 0;
00523         *dest = shared.maxstring;
00524         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00525     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'-'}:
00526         \textcolor{keywordflow}{if} (c[1] != \textcolor{stringliteral}{'\(\backslash\)0'}) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00527         *ex = 0;
00528         *dest = shared.minstring;
00529         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00530     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'('}:
00531         *ex = 1;
00532         *dest = sdsnewlen(c+1,sdslen(c)-1);
00533         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00534     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'['}:
00535         *ex = 0;
00536         *dest = sdsnewlen(c+1,sdslen(c)-1);
00537         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00538     \textcolor{keywordflow}{default}:
00539         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00540     \}
00541 \}
00542 
00543 \textcolor{comment}{/* Free a lex range structure, must be called only after zelParseLexRange()}
00544 \textcolor{comment}{ * populated the structure with success (C\_OK returned). */}
00545 \textcolor{keywordtype}{void} zslFreeLexRange(zlexrangespec *spec) \{
00546     \textcolor{keywordflow}{if} (spec->min != shared.minstring &&
00547         spec->min != shared.maxstring) sdsfree(spec->min);
00548     \textcolor{keywordflow}{if} (spec->max != shared.minstring &&
00549         spec->max != shared.maxstring) sdsfree(spec->max);
00550 \}
00551 
00552 \textcolor{comment}{/* Populate the lex rangespec according to the objects min and max.}
00553 \textcolor{comment}{ *}
00554 \textcolor{comment}{ * Return C\_OK on success. On error C\_ERR is returned.}
00555 \textcolor{comment}{ * When OK is returned the structure must be freed with zslFreeLexRange(),}
00556 \textcolor{comment}{ * otherwise no release is needed. */}
00557 \textcolor{keywordtype}{int} zslParseLexRange(robj *min, robj *max, zlexrangespec *spec) \{
00558     \textcolor{comment}{/* The range can't be valid if objects are integer encoded.}
00559 \textcolor{comment}{     * Every item must start with ( or [. */}
00560     \textcolor{keywordflow}{if} (min->encoding == \hyperlink{server_8h_ae934cf008a0be0ef009c92c2d006a816}{OBJ\_ENCODING\_INT} ||
00561         max->encoding == \hyperlink{server_8h_ae934cf008a0be0ef009c92c2d006a816}{OBJ\_ENCODING\_INT}) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00562 
00563     spec->min = spec->max = NULL;
00564     \textcolor{keywordflow}{if} (zslParseLexRangeItem(min, &spec->min, &spec->minex) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR} ||
00565         zslParseLexRangeItem(max, &spec->max, &spec->maxex) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
00566         zslFreeLexRange(spec);
00567         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00568     \} \textcolor{keywordflow}{else} \{
00569         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00570     \}
00571 \}
00572 
00573 \textcolor{comment}{/* This is just a wrapper to sdscmp() that is able to}
00574 \textcolor{comment}{ * handle shared.minstring and shared.maxstring as the equivalent of}
00575 \textcolor{comment}{ * -inf and +inf for strings */}
00576 \textcolor{keywordtype}{int} sdscmplex(sds a, sds b) \{
00577     \textcolor{keywordflow}{if} (a == b) \textcolor{keywordflow}{return} 0;
00578     \textcolor{keywordflow}{if} (a == shared.minstring || b == shared.maxstring) \textcolor{keywordflow}{return} -1;
00579     \textcolor{keywordflow}{if} (a == shared.maxstring || b == shared.minstring) \textcolor{keywordflow}{return} 1;
00580     \textcolor{keywordflow}{return} sdscmp(a,b);
00581 \}
00582 
00583 \textcolor{keywordtype}{int} zslLexValueGteMin(sds value, zlexrangespec *spec) \{
00584     \textcolor{keywordflow}{return} spec->minex ?
00585         (sdscmplex(value,spec->min) > 0) :
00586         (sdscmplex(value,spec->min) >= 0);
00587 \}
00588 
00589 \textcolor{keywordtype}{int} zslLexValueLteMax(sds value, zlexrangespec *spec) \{
00590     \textcolor{keywordflow}{return} spec->maxex ?
00591         (sdscmplex(value,spec->max) < 0) :
00592         (sdscmplex(value,spec->max) <= 0);
00593 \}
00594 
00595 \textcolor{comment}{/* Returns if there is a part of the zset is in the lex range. */}
00596 \textcolor{keywordtype}{int} zslIsInLexRange(zskiplist *zsl, zlexrangespec *range) \{
00597     zskiplistNode *x;
00598 
00599     \textcolor{comment}{/* Test for ranges that will always be empty. */}
00600     \textcolor{keywordflow}{if} (sdscmplex(range->min,range->max) > 1 ||
00601             (sdscmp(range->min,range->max) == 0 &&
00602             (range->minex || range->maxex)))
00603         \textcolor{keywordflow}{return} 0;
00604     x = zsl->tail;
00605     \textcolor{keywordflow}{if} (x == NULL || !zslLexValueGteMin(x->ele,range))
00606         \textcolor{keywordflow}{return} 0;
00607     x = zsl->header->level[0].forward;
00608     \textcolor{keywordflow}{if} (x == NULL || !zslLexValueLteMax(x->ele,range))
00609         \textcolor{keywordflow}{return} 0;
00610     \textcolor{keywordflow}{return} 1;
00611 \}
00612 
00613 \textcolor{comment}{/* Find the first node that is contained in the specified lex range.}
00614 \textcolor{comment}{ * Returns NULL when no element is contained in the range. */}
00615 zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range) \{
00616     zskiplistNode *x;
00617     \textcolor{keywordtype}{int} i;
00618 
00619     \textcolor{comment}{/* If everything is out of range, return early. */}
00620     \textcolor{keywordflow}{if} (!zslIsInLexRange(zsl,range)) \textcolor{keywordflow}{return} NULL;
00621 
00622     x = zsl->header;
00623     \textcolor{keywordflow}{for} (i = zsl->level-1; i >= 0; i--) \{
00624         \textcolor{comment}{/* Go forward while *OUT* of range. */}
00625         \textcolor{keywordflow}{while} (x->level[i].forward &&
00626             !zslLexValueGteMin(x->level[i].forward->ele,range))
00627                 x = x->level[i].forward;
00628     \}
00629 
00630     \textcolor{comment}{/* This is an inner range, so the next node cannot be NULL. */}
00631     x = x->level[0].forward;
00632     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(x != NULL);
00633 
00634     \textcolor{comment}{/* Check if score <= max. */}
00635     \textcolor{keywordflow}{if} (!zslLexValueLteMax(x->ele,range)) \textcolor{keywordflow}{return} NULL;
00636     \textcolor{keywordflow}{return} x;
00637 \}
00638 
00639 \textcolor{comment}{/* Find the last node that is contained in the specified range.}
00640 \textcolor{comment}{ * Returns NULL when no element is contained in the range. */}
00641 zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) \{
00642     zskiplistNode *x;
00643     \textcolor{keywordtype}{int} i;
00644 
00645     \textcolor{comment}{/* If everything is out of range, return early. */}
00646     \textcolor{keywordflow}{if} (!zslIsInLexRange(zsl,range)) \textcolor{keywordflow}{return} NULL;
00647 
00648     x = zsl->header;
00649     \textcolor{keywordflow}{for} (i = zsl->level-1; i >= 0; i--) \{
00650         \textcolor{comment}{/* Go forward while *IN* range. */}
00651         \textcolor{keywordflow}{while} (x->level[i].forward &&
00652             zslLexValueLteMax(x->level[i].forward->ele,range))
00653                 x = x->level[i].forward;
00654     \}
00655 
00656     \textcolor{comment}{/* This is an inner range, so this node cannot be NULL. */}
00657     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(x != NULL);
00658 
00659     \textcolor{comment}{/* Check if score >= min. */}
00660     \textcolor{keywordflow}{if} (!zslLexValueGteMin(x->ele,range)) \textcolor{keywordflow}{return} NULL;
00661     \textcolor{keywordflow}{return} x;
00662 \}
00663 
00664 \textcolor{comment}{/*-----------------------------------------------------------------------------}
00665 \textcolor{comment}{ * Ziplist-backed sorted set API}
00666 \textcolor{comment}{ *----------------------------------------------------------------------------*/}
00667 
00668 \textcolor{keywordtype}{double} zzlGetScore(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *sptr) \{
00669     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr;
00670     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen;
00671     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} vlong;
00672     \textcolor{keywordtype}{char} buf[128];
00673     \textcolor{keywordtype}{double} score;
00674 
00675     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(sptr != NULL);
00676     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(ziplistGet(sptr,&vstr,&vlen,&vlong));
00677 
00678     \textcolor{keywordflow}{if} (vstr) \{
00679         memcpy(buf,vstr,vlen);
00680         buf[vlen] = \textcolor{stringliteral}{'\(\backslash\)0'};
00681         score = strtod(buf,NULL);
00682     \} \textcolor{keywordflow}{else} \{
00683         score = vlong;
00684     \}
00685 
00686     \textcolor{keywordflow}{return} score;
00687 \}
00688 
00689 \textcolor{comment}{/* Return a ziplist element as an SDS string. */}
00690 sds ziplistGetObject(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *sptr) \{
00691     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr;
00692     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen;
00693     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} vlong;
00694 
00695     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(sptr != NULL);
00696     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(ziplistGet(sptr,&vstr,&vlen,&vlong));
00697 
00698     \textcolor{keywordflow}{if} (vstr) \{
00699         \textcolor{keywordflow}{return} sdsnewlen((\textcolor{keywordtype}{char}*)vstr,vlen);
00700     \} \textcolor{keywordflow}{else} \{
00701         \textcolor{keywordflow}{return} sdsfromlonglong(vlong);
00702     \}
00703 \}
00704 
00705 \textcolor{comment}{/* Compare element in sorted set with given element. */}
00706 \textcolor{keywordtype}{int} zzlCompareElements(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *cstr, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} clen) \{
00707     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr;
00708     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen;
00709     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} vlong;
00710     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} vbuf[32];
00711     \textcolor{keywordtype}{int} minlen, cmp;
00712 
00713     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(ziplistGet(eptr,&vstr,&vlen,&vlong));
00714     \textcolor{keywordflow}{if} (vstr == NULL) \{
00715         \textcolor{comment}{/* Store string representation of long long in buf. */}
00716         vlen = ll2string((\textcolor{keywordtype}{char}*)vbuf,\textcolor{keyword}{sizeof}(vbuf),vlong);
00717         vstr = vbuf;
00718     \}
00719 
00720     minlen = (vlen < clen) ? vlen : clen;
00721     cmp = memcmp(vstr,cstr,minlen);
00722     \textcolor{keywordflow}{if} (cmp == 0) \textcolor{keywordflow}{return} vlen-clen;
00723     \textcolor{keywordflow}{return} cmp;
00724 \}
00725 
00726 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} zzlLength(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl) \{
00727     \textcolor{keywordflow}{return} ziplistLen(zl)/2;
00728 \}
00729 
00730 \textcolor{comment}{/* Move to next entry based on the values in eptr and sptr. Both are set to}
00731 \textcolor{comment}{ * NULL when there is no next entry. */}
00732 \textcolor{keywordtype}{void} zzlNext(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **eptr, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **sptr) \{
00733     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *\_eptr, *\_sptr;
00734     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(*eptr != NULL && *sptr != NULL);
00735 
00736     \_eptr = ziplistNext(zl,*sptr);
00737     \textcolor{keywordflow}{if} (\_eptr != NULL) \{
00738         \_sptr = ziplistNext(zl,\_eptr);
00739         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(\_sptr != NULL);
00740     \} \textcolor{keywordflow}{else} \{
00741         \textcolor{comment}{/* No next entry. */}
00742         \_sptr = NULL;
00743     \}
00744 
00745     *eptr = \_eptr;
00746     *sptr = \_sptr;
00747 \}
00748 
00749 \textcolor{comment}{/* Move to the previous entry based on the values in eptr and sptr. Both are}
00750 \textcolor{comment}{ * set to NULL when there is no next entry. */}
00751 \textcolor{keywordtype}{void} zzlPrev(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **eptr, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **sptr) \{
00752     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *\_eptr, *\_sptr;
00753     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(*eptr != NULL && *sptr != NULL);
00754 
00755     \_sptr = ziplistPrev(zl,*eptr);
00756     \textcolor{keywordflow}{if} (\_sptr != NULL) \{
00757         \_eptr = ziplistPrev(zl,\_sptr);
00758         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(\_eptr != NULL);
00759     \} \textcolor{keywordflow}{else} \{
00760         \textcolor{comment}{/* No previous entry. */}
00761         \_eptr = NULL;
00762     \}
00763 
00764     *eptr = \_eptr;
00765     *sptr = \_sptr;
00766 \}
00767 
00768 \textcolor{comment}{/* Returns if there is a part of the zset is in range. Should only be used}
00769 \textcolor{comment}{ * internally by zzlFirstInRange and zzlLastInRange. */}
00770 \textcolor{keywordtype}{int} zzlIsInRange(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, zrangespec *range) \{
00771     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p;
00772     \textcolor{keywordtype}{double} score;
00773 
00774     \textcolor{comment}{/* Test for ranges that will always be empty. */}
00775     \textcolor{keywordflow}{if} (range->min > range->max ||
00776             (range->min == range->max && (range->minex || range->maxex)))
00777         \textcolor{keywordflow}{return} 0;
00778 
00779     p = ziplistIndex(zl,-1); \textcolor{comment}{/* Last score. */}
00780     \textcolor{keywordflow}{if} (p == NULL) \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* Empty sorted set */}
00781     score = zzlGetScore(p);
00782     \textcolor{keywordflow}{if} (!zslValueGteMin(score,range))
00783         \textcolor{keywordflow}{return} 0;
00784 
00785     p = ziplistIndex(zl,1); \textcolor{comment}{/* First score. */}
00786     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(p != NULL);
00787     score = zzlGetScore(p);
00788     \textcolor{keywordflow}{if} (!zslValueLteMax(score,range))
00789         \textcolor{keywordflow}{return} 0;
00790 
00791     \textcolor{keywordflow}{return} 1;
00792 \}
00793 
00794 \textcolor{comment}{/* Find pointer to the first element contained in the specified range.}
00795 \textcolor{comment}{ * Returns NULL when no element is contained in the range. */}
00796 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zzlFirstInRange(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, zrangespec *range) \{
00797     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr = ziplistIndex(zl,0), *sptr;
00798     \textcolor{keywordtype}{double} score;
00799 
00800     \textcolor{comment}{/* If everything is out of range, return early. */}
00801     \textcolor{keywordflow}{if} (!zzlIsInRange(zl,range)) \textcolor{keywordflow}{return} NULL;
00802 
00803     \textcolor{keywordflow}{while} (eptr != NULL) \{
00804         sptr = ziplistNext(zl,eptr);
00805         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(sptr != NULL);
00806 
00807         score = zzlGetScore(sptr);
00808         \textcolor{keywordflow}{if} (zslValueGteMin(score,range)) \{
00809             \textcolor{comment}{/* Check if score <= max. */}
00810             \textcolor{keywordflow}{if} (zslValueLteMax(score,range))
00811                 \textcolor{keywordflow}{return} eptr;
00812             \textcolor{keywordflow}{return} NULL;
00813         \}
00814 
00815         \textcolor{comment}{/* Move to next element. */}
00816         eptr = ziplistNext(zl,sptr);
00817     \}
00818 
00819     \textcolor{keywordflow}{return} NULL;
00820 \}
00821 
00822 \textcolor{comment}{/* Find pointer to the last element contained in the specified range.}
00823 \textcolor{comment}{ * Returns NULL when no element is contained in the range. */}
00824 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zzlLastInRange(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, zrangespec *range) \{
00825     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr = ziplistIndex(zl,-2), *sptr;
00826     \textcolor{keywordtype}{double} score;
00827 
00828     \textcolor{comment}{/* If everything is out of range, return early. */}
00829     \textcolor{keywordflow}{if} (!zzlIsInRange(zl,range)) \textcolor{keywordflow}{return} NULL;
00830 
00831     \textcolor{keywordflow}{while} (eptr != NULL) \{
00832         sptr = ziplistNext(zl,eptr);
00833         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(sptr != NULL);
00834 
00835         score = zzlGetScore(sptr);
00836         \textcolor{keywordflow}{if} (zslValueLteMax(score,range)) \{
00837             \textcolor{comment}{/* Check if score >= min. */}
00838             \textcolor{keywordflow}{if} (zslValueGteMin(score,range))
00839                 \textcolor{keywordflow}{return} eptr;
00840             \textcolor{keywordflow}{return} NULL;
00841         \}
00842 
00843         \textcolor{comment}{/* Move to previous element by moving to the score of previous element.}
00844 \textcolor{comment}{         * When this returns NULL, we know there also is no element. */}
00845         sptr = ziplistPrev(zl,eptr);
00846         \textcolor{keywordflow}{if} (sptr != NULL)
00847             \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}((eptr = ziplistPrev(zl,sptr)) != NULL);
00848         \textcolor{keywordflow}{else}
00849             eptr = NULL;
00850     \}
00851 
00852     \textcolor{keywordflow}{return} NULL;
00853 \}
00854 
00855 \textcolor{keywordtype}{int} zzlLexValueGteMin(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, zlexrangespec *spec) \{
00856     sds value = ziplistGetObject(p);
00857     \textcolor{keywordtype}{int} res = zslLexValueGteMin(value,spec);
00858     sdsfree(value);
00859     \textcolor{keywordflow}{return} res;
00860 \}
00861 
00862 \textcolor{keywordtype}{int} zzlLexValueLteMax(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, zlexrangespec *spec) \{
00863     sds value = ziplistGetObject(p);
00864     \textcolor{keywordtype}{int} res = zslLexValueLteMax(value,spec);
00865     sdsfree(value);
00866     \textcolor{keywordflow}{return} res;
00867 \}
00868 
00869 \textcolor{comment}{/* Returns if there is a part of the zset is in range. Should only be used}
00870 \textcolor{comment}{ * internally by zzlFirstInRange and zzlLastInRange. */}
00871 \textcolor{keywordtype}{int} zzlIsInLexRange(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, zlexrangespec *range) \{
00872     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p;
00873 
00874     \textcolor{comment}{/* Test for ranges that will always be empty. */}
00875     \textcolor{keywordflow}{if} (sdscmplex(range->min,range->max) > 1 ||
00876             (sdscmp(range->min,range->max) == 0 &&
00877             (range->minex || range->maxex)))
00878         \textcolor{keywordflow}{return} 0;
00879 
00880     p = ziplistIndex(zl,-2); \textcolor{comment}{/* Last element. */}
00881     \textcolor{keywordflow}{if} (p == NULL) \textcolor{keywordflow}{return} 0;
00882     \textcolor{keywordflow}{if} (!zzlLexValueGteMin(p,range))
00883         \textcolor{keywordflow}{return} 0;
00884 
00885     p = ziplistIndex(zl,0); \textcolor{comment}{/* First element. */}
00886     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(p != NULL);
00887     \textcolor{keywordflow}{if} (!zzlLexValueLteMax(p,range))
00888         \textcolor{keywordflow}{return} 0;
00889 
00890     \textcolor{keywordflow}{return} 1;
00891 \}
00892 
00893 \textcolor{comment}{/* Find pointer to the first element contained in the specified lex range.}
00894 \textcolor{comment}{ * Returns NULL when no element is contained in the range. */}
00895 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zzlFirstInLexRange(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, zlexrangespec *range) \{
00896     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr = ziplistIndex(zl,0), *sptr;
00897 
00898     \textcolor{comment}{/* If everything is out of range, return early. */}
00899     \textcolor{keywordflow}{if} (!zzlIsInLexRange(zl,range)) \textcolor{keywordflow}{return} NULL;
00900 
00901     \textcolor{keywordflow}{while} (eptr != NULL) \{
00902         \textcolor{keywordflow}{if} (zzlLexValueGteMin(eptr,range)) \{
00903             \textcolor{comment}{/* Check if score <= max. */}
00904             \textcolor{keywordflow}{if} (zzlLexValueLteMax(eptr,range))
00905                 \textcolor{keywordflow}{return} eptr;
00906             \textcolor{keywordflow}{return} NULL;
00907         \}
00908 
00909         \textcolor{comment}{/* Move to next element. */}
00910         sptr = ziplistNext(zl,eptr); \textcolor{comment}{/* This element score. Skip it. */}
00911         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(sptr != NULL);
00912         eptr = ziplistNext(zl,sptr); \textcolor{comment}{/* Next element. */}
00913     \}
00914 
00915     \textcolor{keywordflow}{return} NULL;
00916 \}
00917 
00918 \textcolor{comment}{/* Find pointer to the last element contained in the specified lex range.}
00919 \textcolor{comment}{ * Returns NULL when no element is contained in the range. */}
00920 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zzlLastInLexRange(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, zlexrangespec *range) \{
00921     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr = ziplistIndex(zl,-2), *sptr;
00922 
00923     \textcolor{comment}{/* If everything is out of range, return early. */}
00924     \textcolor{keywordflow}{if} (!zzlIsInLexRange(zl,range)) \textcolor{keywordflow}{return} NULL;
00925 
00926     \textcolor{keywordflow}{while} (eptr != NULL) \{
00927         \textcolor{keywordflow}{if} (zzlLexValueLteMax(eptr,range)) \{
00928             \textcolor{comment}{/* Check if score >= min. */}
00929             \textcolor{keywordflow}{if} (zzlLexValueGteMin(eptr,range))
00930                 \textcolor{keywordflow}{return} eptr;
00931             \textcolor{keywordflow}{return} NULL;
00932         \}
00933 
00934         \textcolor{comment}{/* Move to previous element by moving to the score of previous element.}
00935 \textcolor{comment}{         * When this returns NULL, we know there also is no element. */}
00936         sptr = ziplistPrev(zl,eptr);
00937         \textcolor{keywordflow}{if} (sptr != NULL)
00938             \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}((eptr = ziplistPrev(zl,sptr)) != NULL);
00939         \textcolor{keywordflow}{else}
00940             eptr = NULL;
00941     \}
00942 
00943     \textcolor{keywordflow}{return} NULL;
00944 \}
00945 
00946 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zzlFind(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, sds ele, \textcolor{keywordtype}{double} *score) \{
00947     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr = ziplistIndex(zl,0), *sptr;
00948 
00949     \textcolor{keywordflow}{while} (eptr != NULL) \{
00950         sptr = ziplistNext(zl,eptr);
00951         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(sptr != NULL);
00952 
00953         \textcolor{keywordflow}{if} (ziplistCompare(eptr,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)ele,sdslen(ele))) \{
00954             \textcolor{comment}{/* Matching element, pull out score. */}
00955             \textcolor{keywordflow}{if} (score != NULL) *score = zzlGetScore(sptr);
00956             \textcolor{keywordflow}{return} eptr;
00957         \}
00958 
00959         \textcolor{comment}{/* Move to next element. */}
00960         eptr = ziplistNext(zl,sptr);
00961     \}
00962     \textcolor{keywordflow}{return} NULL;
00963 \}
00964 
00965 \textcolor{comment}{/* Delete (element,score) pair from ziplist. Use local copy of eptr because we}
00966 \textcolor{comment}{ * don't want to modify the one given as argument. */}
00967 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zzlDelete(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr) \{
00968     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p = eptr;
00969 
00970     \textcolor{comment}{/* TODO: add function to ziplist API to delete N elements from offset. */}
00971     zl = ziplistDelete(zl,&p);
00972     zl = ziplistDelete(zl,&p);
00973     \textcolor{keywordflow}{return} zl;
00974 \}
00975 
00976 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zzlInsertAt(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr, sds ele, \textcolor{keywordtype}{double} score) \{
00977     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *sptr;
00978     \textcolor{keywordtype}{char} scorebuf[128];
00979     \textcolor{keywordtype}{int} scorelen;
00980     size\_t offset;
00981 
00982     scorelen = d2string(scorebuf,\textcolor{keyword}{sizeof}(scorebuf),score);
00983     \textcolor{keywordflow}{if} (eptr == NULL) \{
00984         zl = ziplistPush(zl,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)ele,sdslen(ele),\hyperlink{ziplist_8h_a25d058a2c2c0db0f131f84d23ede6ba2}{ZIPLIST\_TAIL});
00985         zl = ziplistPush(zl,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)scorebuf,scorelen,\hyperlink{ziplist_8h_a25d058a2c2c0db0f131f84d23ede6ba2}{ZIPLIST\_TAIL});
00986     \} \textcolor{keywordflow}{else} \{
00987         \textcolor{comment}{/* Keep offset relative to zl, as it might be re-allocated. */}
00988         offset = eptr-zl;
00989         zl = ziplistInsert(zl,eptr,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)ele,sdslen(ele));
00990         eptr = zl+offset;
00991 
00992         \textcolor{comment}{/* Insert score after the element. */}
00993         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}((sptr = ziplistNext(zl,eptr)) != NULL);
00994         zl = ziplistInsert(zl,sptr,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)scorebuf,scorelen);
00995     \}
00996     \textcolor{keywordflow}{return} zl;
00997 \}
00998 
00999 \textcolor{comment}{/* Insert (element,score) pair in ziplist. This function assumes the element is}
01000 \textcolor{comment}{ * not yet present in the list. */}
01001 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zzlInsert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, sds ele, \textcolor{keywordtype}{double} score) \{
01002     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr = ziplistIndex(zl,0), *sptr;
01003     \textcolor{keywordtype}{double} s;
01004 
01005     \textcolor{keywordflow}{while} (eptr != NULL) \{
01006         sptr = ziplistNext(zl,eptr);
01007         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(sptr != NULL);
01008         s = zzlGetScore(sptr);
01009 
01010         \textcolor{keywordflow}{if} (s > score) \{
01011             \textcolor{comment}{/* First element with score larger than score for element to be}
01012 \textcolor{comment}{             * inserted. This means we should take its spot in the list to}
01013 \textcolor{comment}{             * maintain ordering. */}
01014             zl = zzlInsertAt(zl,eptr,ele,score);
01015             \textcolor{keywordflow}{break};
01016         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (s == score) \{
01017             \textcolor{comment}{/* Ensure lexicographical ordering for elements. */}
01018             \textcolor{keywordflow}{if} (zzlCompareElements(eptr,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)ele,sdslen(ele)) > 0) \{
01019                 zl = zzlInsertAt(zl,eptr,ele,score);
01020                 \textcolor{keywordflow}{break};
01021             \}
01022         \}
01023 
01024         \textcolor{comment}{/* Move to next element. */}
01025         eptr = ziplistNext(zl,sptr);
01026     \}
01027 
01028     \textcolor{comment}{/* Push on tail of list when it was not yet inserted. */}
01029     \textcolor{keywordflow}{if} (eptr == NULL)
01030         zl = zzlInsertAt(zl,NULL,ele,score);
01031     \textcolor{keywordflow}{return} zl;
01032 \}
01033 
01034 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zzlDeleteRangeByScore(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, zrangespec *range, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *deleted) \{
01035     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr, *sptr;
01036     \textcolor{keywordtype}{double} score;
01037     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} num = 0;
01038 
01039     \textcolor{keywordflow}{if} (deleted != NULL) *deleted = 0;
01040 
01041     eptr = zzlFirstInRange(zl,range);
01042     \textcolor{keywordflow}{if} (eptr == NULL) \textcolor{keywordflow}{return} zl;
01043 
01044     \textcolor{comment}{/* When the tail of the ziplist is deleted, eptr will point to the sentinel}
01045 \textcolor{comment}{     * byte and ziplistNext will return NULL. */}
01046     \textcolor{keywordflow}{while} ((sptr = ziplistNext(zl,eptr)) != NULL) \{
01047         score = zzlGetScore(sptr);
01048         \textcolor{keywordflow}{if} (zslValueLteMax(score,range)) \{
01049             \textcolor{comment}{/* Delete both the element and the score. */}
01050             zl = ziplistDelete(zl,&eptr);
01051             zl = ziplistDelete(zl,&eptr);
01052             num++;
01053         \} \textcolor{keywordflow}{else} \{
01054             \textcolor{comment}{/* No longer in range. */}
01055             \textcolor{keywordflow}{break};
01056         \}
01057     \}
01058 
01059     \textcolor{keywordflow}{if} (deleted != NULL) *deleted = num;
01060     \textcolor{keywordflow}{return} zl;
01061 \}
01062 
01063 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zzlDeleteRangeByLex(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, zlexrangespec *range, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *deleted) \{
01064     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr, *sptr;
01065     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} num = 0;
01066 
01067     \textcolor{keywordflow}{if} (deleted != NULL) *deleted = 0;
01068 
01069     eptr = zzlFirstInLexRange(zl,range);
01070     \textcolor{keywordflow}{if} (eptr == NULL) \textcolor{keywordflow}{return} zl;
01071 
01072     \textcolor{comment}{/* When the tail of the ziplist is deleted, eptr will point to the sentinel}
01073 \textcolor{comment}{     * byte and ziplistNext will return NULL. */}
01074     \textcolor{keywordflow}{while} ((sptr = ziplistNext(zl,eptr)) != NULL) \{
01075         \textcolor{keywordflow}{if} (zzlLexValueLteMax(eptr,range)) \{
01076             \textcolor{comment}{/* Delete both the element and the score. */}
01077             zl = ziplistDelete(zl,&eptr);
01078             zl = ziplistDelete(zl,&eptr);
01079             num++;
01080         \} \textcolor{keywordflow}{else} \{
01081             \textcolor{comment}{/* No longer in range. */}
01082             \textcolor{keywordflow}{break};
01083         \}
01084     \}
01085 
01086     \textcolor{keywordflow}{if} (deleted != NULL) *deleted = num;
01087     \textcolor{keywordflow}{return} zl;
01088 \}
01089 
01090 \textcolor{comment}{/* Delete all the elements with rank between start and end from the skiplist.}
01091 \textcolor{comment}{ * Start and end are inclusive. Note that start and end need to be 1-based */}
01092 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zzlDeleteRangeByRank(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} start, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} end, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{
      long} *deleted) \{
01093     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} num = (end-start)+1;
01094     \textcolor{keywordflow}{if} (deleted) *deleted = num;
01095     zl = ziplistDeleteRange(zl,2*(start-1),2*num);
01096     \textcolor{keywordflow}{return} zl;
01097 \}
01098 
01099 \textcolor{comment}{/*-----------------------------------------------------------------------------}
01100 \textcolor{comment}{ * Common sorted set API}
01101 \textcolor{comment}{ *----------------------------------------------------------------------------*/}
01102 
01103 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} zsetLength(\textcolor{keyword}{const} robj *zobj) \{
01104     \textcolor{keywordtype}{int} length = -1;
01105     \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
01106         length = zzlLength(zobj->ptr);
01107     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
01108         length = ((\textcolor{keyword}{const} zset*)zobj->ptr)->zsl->length;
01109     \} \textcolor{keywordflow}{else} \{
01110         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted set encoding"});
01111     \}
01112     \textcolor{keywordflow}{return} length;
01113 \}
01114 
01115 \textcolor{keywordtype}{void} zsetConvert(robj *zobj, \textcolor{keywordtype}{int} encoding) \{
01116     zset *zs;
01117     zskiplistNode *node, *next;
01118     sds ele;
01119     \textcolor{keywordtype}{double} score;
01120 
01121     \textcolor{keywordflow}{if} (zobj->encoding == encoding) \textcolor{keywordflow}{return};
01122     \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
01123         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl = zobj->ptr;
01124         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr, *sptr;
01125         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr;
01126         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen;
01127         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} vlong;
01128 
01129         \textcolor{keywordflow}{if} (encoding != \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST})
01130             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown target encoding"});
01131 
01132         zs = zmalloc(\textcolor{keyword}{sizeof}(*zs));
01133         zs->dict = dictCreate(&zsetDictType,NULL);
01134         zs->zsl = zslCreate();
01135 
01136         eptr = ziplistIndex(zl,0);
01137         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(NULL,zobj,eptr != NULL);
01138         sptr = ziplistNext(zl,eptr);
01139         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(NULL,zobj,sptr != NULL);
01140 
01141         \textcolor{keywordflow}{while} (eptr != NULL) \{
01142             score = zzlGetScore(sptr);
01143             \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(NULL,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
01144             \textcolor{keywordflow}{if} (vstr == NULL)
01145                 ele = sdsfromlonglong(vlong);
01146             \textcolor{keywordflow}{else}
01147                 ele = sdsnewlen((\textcolor{keywordtype}{char}*)vstr,vlen);
01148 
01149             node = zslInsert(zs->zsl,score,ele);
01150             \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(dictAdd(zs->dict,ele,&node->score) == 
      \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK});
01151             zzlNext(zl,&eptr,&sptr);
01152         \}
01153 
01154         zfree(zobj->ptr);
01155         zobj->ptr = zs;
01156         zobj->encoding = \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST};
01157     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
01158         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl = ziplistNew();
01159 
01160         \textcolor{keywordflow}{if} (encoding != \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST})
01161             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown target encoding"});
01162 
01163         \textcolor{comment}{/* Approach similar to zslFree(), since we want to free the skiplist at}
01164 \textcolor{comment}{         * the same time as creating the ziplist. */}
01165         zs = zobj->ptr;
01166         dictRelease(zs->dict);
01167         node = zs->zsl->header->level[0].forward;
01168         zfree(zs->zsl->header);
01169         zfree(zs->zsl);
01170 
01171         \textcolor{keywordflow}{while} (node) \{
01172             zl = zzlInsertAt(zl,NULL,node->ele,node->score);
01173             next = node->level[0].forward;
01174             zslFreeNode(node);
01175             node = next;
01176         \}
01177 
01178         zfree(zs);
01179         zobj->ptr = zl;
01180         zobj->encoding = \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST};
01181     \} \textcolor{keywordflow}{else} \{
01182         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted set encoding"});
01183     \}
01184 \}
01185 
01186 \textcolor{comment}{/* Convert the sorted set object into a ziplist if it is not already a ziplist}
01187 \textcolor{comment}{ * and if the number of elements and the maximum element size is within the}
01188 \textcolor{comment}{ * expected ranges. */}
01189 \textcolor{keywordtype}{void} zsetConvertToZiplistIfNeeded(robj *zobj, size\_t maxelelen) \{
01190     \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \textcolor{keywordflow}{return};
01191     zset *zset = zobj->ptr;
01192 
01193     \textcolor{keywordflow}{if} (zset->zsl->length <= server.zset\_max\_ziplist\_entries &&
01194         maxelelen <= server.zset\_max\_ziplist\_value)
01195             zsetConvert(zobj,\hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST});
01196 \}
01197 
01198 \textcolor{comment}{/* Return (by reference) the score of the specified member of the sorted set}
01199 \textcolor{comment}{ * storing it into *score. If the element does not exist C\_ERR is returned}
01200 \textcolor{comment}{ * otherwise C\_OK is returned and *score is correctly populated.}
01201 \textcolor{comment}{ * If 'zobj' or 'member' is NULL, C\_ERR is returned. */}
01202 \textcolor{keywordtype}{int} zsetScore(robj *zobj, sds member, \textcolor{keywordtype}{double} *score) \{
01203     \textcolor{keywordflow}{if} (!zobj || !member) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01204 
01205     \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
01206         \textcolor{keywordflow}{if} (zzlFind(zobj->ptr, member, score) == NULL) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01207     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
01208         zset *zs = zobj->ptr;
01209         dictEntry *de = dictFind(zs->dict, member);
01210         \textcolor{keywordflow}{if} (de == NULL) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01211         *score = *(\textcolor{keywordtype}{double}*)\hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
01212     \} \textcolor{keywordflow}{else} \{
01213         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted set encoding"});
01214     \}
01215     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01216 \}
01217 
01218 \textcolor{comment}{/* Add a new element or update the score of an existing element in a sorted}
01219 \textcolor{comment}{ * set, regardless of its encoding.}
01220 \textcolor{comment}{ *}
01221 \textcolor{comment}{ * The set of flags change the command behavior. They are passed with an integer}
01222 \textcolor{comment}{ * pointer since the function will clear the flags and populate them with}
01223 \textcolor{comment}{ * other flags to indicate different conditions.}
01224 \textcolor{comment}{ *}
01225 \textcolor{comment}{ * The input flags are the following:}
01226 \textcolor{comment}{ *}
01227 \textcolor{comment}{ * ZADD\_INCR: Increment the current element score by 'score' instead of updating}
01228 \textcolor{comment}{ *            the current element score. If the element does not exist, we}
01229 \textcolor{comment}{ *            assume 0 as previous score.}
01230 \textcolor{comment}{ * ZADD\_NX:   Perform the operation only if the element does not exist.}
01231 \textcolor{comment}{ * ZADD\_XX:   Perform the operation only if the element already exist.}
01232 \textcolor{comment}{ *}
01233 \textcolor{comment}{ * When ZADD\_INCR is used, the new score of the element is stored in}
01234 \textcolor{comment}{ * '*newscore' if 'newscore' is not NULL.}
01235 \textcolor{comment}{ *}
01236 \textcolor{comment}{ * The returned flags are the following:}
01237 \textcolor{comment}{ *}
01238 \textcolor{comment}{ * ZADD\_NAN:     The resulting score is not a number.}
01239 \textcolor{comment}{ * ZADD\_ADDED:   The element was added (not present before the call).}
01240 \textcolor{comment}{ * ZADD\_UPDATED: The element score was updated.}
01241 \textcolor{comment}{ * ZADD\_NOP:     No operation was performed because of NX or XX.}
01242 \textcolor{comment}{ *}
01243 \textcolor{comment}{ * Return value:}
01244 \textcolor{comment}{ *}
01245 \textcolor{comment}{ * The function returns 1 on success, and sets the appropriate flags}
01246 \textcolor{comment}{ * ADDED or UPDATED to signal what happened during the operation (note that}
01247 \textcolor{comment}{ * none could be set if we re-added an element using the same score it used}
01248 \textcolor{comment}{ * to have, or in the case a zero increment is used).}
01249 \textcolor{comment}{ *}
01250 \textcolor{comment}{ * The function returns 0 on erorr, currently only when the increment}
01251 \textcolor{comment}{ * produces a NAN condition, or when the 'score' value is NAN since the}
01252 \textcolor{comment}{ * start.}
01253 \textcolor{comment}{ *}
01254 \textcolor{comment}{ * The commad as a side effect of adding a new element may convert the sorted}
01255 \textcolor{comment}{ * set internal encoding from ziplist to hashtable+skiplist.}
01256 \textcolor{comment}{ *}
01257 \textcolor{comment}{ * Memory managemnet of 'ele':}
01258 \textcolor{comment}{ *}
01259 \textcolor{comment}{ * The function does not take ownership of the 'ele' SDS string, but copies}
01260 \textcolor{comment}{ * it if needed. */}
01261 \textcolor{keywordtype}{int} zsetAdd(robj *zobj, \textcolor{keywordtype}{double} score, sds ele, \textcolor{keywordtype}{int} *flags, \textcolor{keywordtype}{double} *newscore) \{
01262     \textcolor{comment}{/* Turn options into simple to check vars. */}
01263     \textcolor{keywordtype}{int} incr = (*flags & \hyperlink{server_8h_aa31f5564c57b55123a4e2d6a5eb599cf}{ZADD\_INCR}) != 0;
01264     \textcolor{keywordtype}{int} nx = (*flags & \hyperlink{server_8h_a708539c0c5926d4c12c4bb2bb45513b2}{ZADD\_NX}) != 0;
01265     \textcolor{keywordtype}{int} xx = (*flags & \hyperlink{server_8h_a4bc45df3143a1110ca9b8a67d25f47eb}{ZADD\_XX}) != 0;
01266     *flags = 0; \textcolor{comment}{/* We'll return our response flags. */}
01267     \textcolor{keywordtype}{double} curscore;
01268 
01269     \textcolor{comment}{/* NaN as input is an error regardless of all the other parameters. */}
01270     \textcolor{keywordflow}{if} (isnan(score)) \{
01271         *flags = \hyperlink{server_8h_ae46720414ddb69ab95bbade04b15194c}{ZADD\_NAN};
01272         \textcolor{keywordflow}{return} 0;
01273     \}
01274 
01275     \textcolor{comment}{/* Update the sorted set according to its encoding. */}
01276     \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
01277         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr;
01278 
01279         \textcolor{keywordflow}{if} ((eptr = zzlFind(zobj->ptr,ele,&curscore)) != NULL) \{
01280             \textcolor{comment}{/* NX? Return, same element already exists. */}
01281             \textcolor{keywordflow}{if} (nx) \{
01282                 *flags |= \hyperlink{server_8h_afd0096ac4bedddb9b0b7f27396839c06}{ZADD\_NOP};
01283                 \textcolor{keywordflow}{return} 1;
01284             \}
01285 
01286             \textcolor{comment}{/* Prepare the score for the increment if needed. */}
01287             \textcolor{keywordflow}{if} (incr) \{
01288                 score += curscore;
01289                 \textcolor{keywordflow}{if} (isnan(score)) \{
01290                     *flags |= \hyperlink{server_8h_ae46720414ddb69ab95bbade04b15194c}{ZADD\_NAN};
01291                     \textcolor{keywordflow}{return} 0;
01292                 \}
01293                 \textcolor{keywordflow}{if} (newscore) *newscore = score;
01294             \}
01295 
01296             \textcolor{comment}{/* Remove and re-insert when score changed. */}
01297             \textcolor{keywordflow}{if} (score != curscore) \{
01298                 zobj->ptr = zzlDelete(zobj->ptr,eptr);
01299                 zobj->ptr = zzlInsert(zobj->ptr,ele,score);
01300                 *flags |= \hyperlink{server_8h_aabb6bb7a2a2e73ab9fcda97cf704761b}{ZADD\_UPDATED};
01301             \}
01302             \textcolor{keywordflow}{return} 1;
01303         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!xx) \{
01304             \textcolor{comment}{/* Optimize: check if the element is too large or the list}
01305 \textcolor{comment}{             * becomes too long *before* executing zzlInsert. */}
01306             zobj->ptr = zzlInsert(zobj->ptr,ele,score);
01307             \textcolor{keywordflow}{if} (zzlLength(zobj->ptr) > server.zset\_max\_ziplist\_entries)
01308                 zsetConvert(zobj,\hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST});
01309             \textcolor{keywordflow}{if} (sdslen(ele) > server.zset\_max\_ziplist\_value)
01310                 zsetConvert(zobj,\hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST});
01311             \textcolor{keywordflow}{if} (newscore) *newscore = score;
01312             *flags |= \hyperlink{server_8h_a2c0f3e2c3a5c73496b732648c69eda18}{ZADD\_ADDED};
01313             \textcolor{keywordflow}{return} 1;
01314         \} \textcolor{keywordflow}{else} \{
01315             *flags |= \hyperlink{server_8h_afd0096ac4bedddb9b0b7f27396839c06}{ZADD\_NOP};
01316             \textcolor{keywordflow}{return} 1;
01317         \}
01318     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
01319         zset *zs = zobj->ptr;
01320         zskiplistNode *znode;
01321         dictEntry *de;
01322 
01323         de = dictFind(zs->dict,ele);
01324         \textcolor{keywordflow}{if} (de != NULL) \{
01325             \textcolor{comment}{/* NX? Return, same element already exists. */}
01326             \textcolor{keywordflow}{if} (nx) \{
01327                 *flags |= \hyperlink{server_8h_afd0096ac4bedddb9b0b7f27396839c06}{ZADD\_NOP};
01328                 \textcolor{keywordflow}{return} 1;
01329             \}
01330             curscore = *(\textcolor{keywordtype}{double}*)\hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
01331 
01332             \textcolor{comment}{/* Prepare the score for the increment if needed. */}
01333             \textcolor{keywordflow}{if} (incr) \{
01334                 score += curscore;
01335                 \textcolor{keywordflow}{if} (isnan(score)) \{
01336                     *flags |= \hyperlink{server_8h_ae46720414ddb69ab95bbade04b15194c}{ZADD\_NAN};
01337                     \textcolor{keywordflow}{return} 0;
01338                 \}
01339                 \textcolor{keywordflow}{if} (newscore) *newscore = score;
01340             \}
01341 
01342             \textcolor{comment}{/* Remove and re-insert when score changes. */}
01343             \textcolor{keywordflow}{if} (score != curscore) \{
01344                 zskiplistNode *node;
01345                 \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(zslDelete(zs->zsl,curscore,ele,&node));
01346                 znode = zslInsert(zs->zsl,score,node->ele);
01347                 \textcolor{comment}{/* We reused the node->ele SDS string, free the node now}
01348 \textcolor{comment}{                 * since zslInsert created a new one. */}
01349                 node->ele = NULL;
01350                 zslFreeNode(node);
01351                 \textcolor{comment}{/* Note that we did not removed the original element from}
01352 \textcolor{comment}{                 * the hash table representing the sorted set, so we just}
01353 \textcolor{comment}{                 * update the score. */}
01354                 \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de) = &znode->score; \textcolor{comment}{/* Update score ptr. */}
01355                 *flags |= \hyperlink{server_8h_aabb6bb7a2a2e73ab9fcda97cf704761b}{ZADD\_UPDATED};
01356             \}
01357             \textcolor{keywordflow}{return} 1;
01358         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!xx) \{
01359             ele = sdsdup(ele);
01360             znode = zslInsert(zs->zsl,score,ele);
01361             \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(dictAdd(zs->dict,ele,&znode->score) == 
      \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK});
01362             *flags |= \hyperlink{server_8h_a2c0f3e2c3a5c73496b732648c69eda18}{ZADD\_ADDED};
01363             \textcolor{keywordflow}{if} (newscore) *newscore = score;
01364             \textcolor{keywordflow}{return} 1;
01365         \} \textcolor{keywordflow}{else} \{
01366             *flags |= \hyperlink{server_8h_afd0096ac4bedddb9b0b7f27396839c06}{ZADD\_NOP};
01367             \textcolor{keywordflow}{return} 1;
01368         \}
01369     \} \textcolor{keywordflow}{else} \{
01370         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted set encoding"});
01371     \}
01372     \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* Never reached. */}
01373 \}
01374 
01375 \textcolor{comment}{/* Delete the element 'ele' from the sorted set, returning 1 if the element}
01376 \textcolor{comment}{ * existed and was deleted, 0 otherwise (the element was not there). */}
01377 \textcolor{keywordtype}{int} zsetDel(robj *zobj, sds ele) \{
01378     \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
01379         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr;
01380 
01381         \textcolor{keywordflow}{if} ((eptr = zzlFind(zobj->ptr,ele,NULL)) != NULL) \{
01382             zobj->ptr = zzlDelete(zobj->ptr,eptr);
01383             \textcolor{keywordflow}{return} 1;
01384         \}
01385     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
01386         zset *zs = zobj->ptr;
01387         dictEntry *de;
01388         \textcolor{keywordtype}{double} score;
01389 
01390         de = dictUnlink(zs->dict,ele);
01391         \textcolor{keywordflow}{if} (de != NULL) \{
01392             \textcolor{comment}{/* Get the score in order to delete from the skiplist later. */}
01393             score = *(\textcolor{keywordtype}{double}*)\hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
01394 
01395             \textcolor{comment}{/* Delete from the hash table and later from the skiplist.}
01396 \textcolor{comment}{             * Note that the order is important: deleting from the skiplist}
01397 \textcolor{comment}{             * actually releases the SDS string representing the element,}
01398 \textcolor{comment}{             * which is shared between the skiplist and the hash table, so}
01399 \textcolor{comment}{             * we need to delete from the skiplist as the final step. */}
01400             dictFreeUnlinkedEntry(zs->dict,de);
01401 
01402             \textcolor{comment}{/* Delete from skiplist. */}
01403             \textcolor{keywordtype}{int} retval = zslDelete(zs->zsl,score,ele,NULL);
01404             \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(retval);
01405 
01406             \textcolor{keywordflow}{if} (htNeedsResize(zs->dict)) dictResize(zs->dict);
01407             \textcolor{keywordflow}{return} 1;
01408         \}
01409     \} \textcolor{keywordflow}{else} \{
01410         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted set encoding"});
01411     \}
01412     \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* No such element found. */}
01413 \}
01414 
01415 \textcolor{comment}{/* Given a sorted set object returns the 0-based rank of the object or}
01416 \textcolor{comment}{ * -1 if the object does not exist.}
01417 \textcolor{comment}{ *}
01418 \textcolor{comment}{ * For rank we mean the position of the element in the sorted collection}
01419 \textcolor{comment}{ * of elements. So the first element has rank 0, the second rank 1, and so}
01420 \textcolor{comment}{ * forth up to length-1 elements.}
01421 \textcolor{comment}{ *}
01422 \textcolor{comment}{ * If 'reverse' is false, the rank is returned considering as first element}
01423 \textcolor{comment}{ * the one with the lowest score. Otherwise if 'reverse' is non-zero}
01424 \textcolor{comment}{ * the rank is computed considering as element with rank 0 the one with}
01425 \textcolor{comment}{ * the highest score. */}
01426 \textcolor{keywordtype}{long} zsetRank(robj *zobj, sds ele, \textcolor{keywordtype}{int} reverse) \{
01427     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} llen;
01428     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} rank;
01429 
01430     llen = zsetLength(zobj);
01431 
01432     \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
01433         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl = zobj->ptr;
01434         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr, *sptr;
01435 
01436         eptr = ziplistIndex(zl,0);
01437         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(eptr != NULL);
01438         sptr = ziplistNext(zl,eptr);
01439         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(sptr != NULL);
01440 
01441         rank = 1;
01442         \textcolor{keywordflow}{while}(eptr != NULL) \{
01443             \textcolor{keywordflow}{if} (ziplistCompare(eptr,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)ele,sdslen(ele)))
01444                 \textcolor{keywordflow}{break};
01445             rank++;
01446             zzlNext(zl,&eptr,&sptr);
01447         \}
01448 
01449         \textcolor{keywordflow}{if} (eptr != NULL) \{
01450             \textcolor{keywordflow}{if} (reverse)
01451                 \textcolor{keywordflow}{return} llen-rank;
01452             \textcolor{keywordflow}{else}
01453                 \textcolor{keywordflow}{return} rank-1;
01454         \} \textcolor{keywordflow}{else} \{
01455             \textcolor{keywordflow}{return} -1;
01456         \}
01457     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
01458         zset *zs = zobj->ptr;
01459         zskiplist *zsl = zs->zsl;
01460         dictEntry *de;
01461         \textcolor{keywordtype}{double} score;
01462 
01463         de = dictFind(zs->dict,ele);
01464         \textcolor{keywordflow}{if} (de != NULL) \{
01465             score = *(\textcolor{keywordtype}{double}*)\hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
01466             rank = zslGetRank(zsl,score,ele);
01467             \textcolor{comment}{/* Existing elements always have a rank. */}
01468             \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(rank != 0);
01469             \textcolor{keywordflow}{if} (reverse)
01470                 \textcolor{keywordflow}{return} llen-rank;
01471             \textcolor{keywordflow}{else}
01472                 \textcolor{keywordflow}{return} rank-1;
01473         \} \textcolor{keywordflow}{else} \{
01474             \textcolor{keywordflow}{return} -1;
01475         \}
01476     \} \textcolor{keywordflow}{else} \{
01477         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted set encoding"});
01478     \}
01479 \}
01480 
01481 \textcolor{comment}{/*-----------------------------------------------------------------------------}
01482 \textcolor{comment}{ * Sorted set commands}
01483 \textcolor{comment}{ *----------------------------------------------------------------------------*/}
01484 
01485 \textcolor{comment}{/* This generic command implements both ZADD and ZINCRBY. */}
01486 \textcolor{keywordtype}{void} zaddGenericCommand(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} flags) \{
01487     \textcolor{keyword}{static} \textcolor{keywordtype}{char} *nanerr = \textcolor{stringliteral}{"resulting score is not a number (NaN)"};
01488     robj *key = c->argv[1];
01489     robj *zobj;
01490     sds ele;
01491     \textcolor{keywordtype}{double} score = 0, *scores = NULL;
01492     \textcolor{keywordtype}{int} j, elements;
01493     \textcolor{keywordtype}{int} scoreidx = 0;
01494     \textcolor{comment}{/* The following vars are used in order to track what the command actually}
01495 \textcolor{comment}{     * did during the execution, to reply to the client and to trigger the}
01496 \textcolor{comment}{     * notification of keyspace change. */}
01497     \textcolor{keywordtype}{int} added = 0;      \textcolor{comment}{/* Number of new elements added. */}
01498     \textcolor{keywordtype}{int} updated = 0;    \textcolor{comment}{/* Number of elements with updated score. */}
01499     \textcolor{keywordtype}{int} processed = 0;  \textcolor{comment}{/* Number of elements processed, may remain zero with}
01500 \textcolor{comment}{                           options like XX. */}
01501 
01502     \textcolor{comment}{/* Parse options. At the end 'scoreidx' is set to the argument position}
01503 \textcolor{comment}{     * of the score of the first score-element pair. */}
01504     scoreidx = 2;
01505     \textcolor{keywordflow}{while}(scoreidx < c->argc) \{
01506         \textcolor{keywordtype}{char} *opt = c->argv[scoreidx]->ptr;
01507         \textcolor{keywordflow}{if} (!strcasecmp(opt,\textcolor{stringliteral}{"nx"})) flags |= \hyperlink{server_8h_a708539c0c5926d4c12c4bb2bb45513b2}{ZADD\_NX};
01508         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(opt,\textcolor{stringliteral}{"xx"})) flags |= \hyperlink{server_8h_a4bc45df3143a1110ca9b8a67d25f47eb}{ZADD\_XX};
01509         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(opt,\textcolor{stringliteral}{"ch"})) flags |= \hyperlink{server_8h_ac1b2fe32c997eff75e263e6689e15d2e}{ZADD\_CH};
01510         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(opt,\textcolor{stringliteral}{"incr"})) flags |= \hyperlink{server_8h_aa31f5564c57b55123a4e2d6a5eb599cf}{ZADD\_INCR};
01511         \textcolor{keywordflow}{else} \textcolor{keywordflow}{break};
01512         scoreidx++;
01513     \}
01514 
01515     \textcolor{comment}{/* Turn options into simple to check vars. */}
01516     \textcolor{keywordtype}{int} incr = (flags & \hyperlink{server_8h_aa31f5564c57b55123a4e2d6a5eb599cf}{ZADD\_INCR}) != 0;
01517     \textcolor{keywordtype}{int} nx = (flags & \hyperlink{server_8h_a708539c0c5926d4c12c4bb2bb45513b2}{ZADD\_NX}) != 0;
01518     \textcolor{keywordtype}{int} xx = (flags & \hyperlink{server_8h_a4bc45df3143a1110ca9b8a67d25f47eb}{ZADD\_XX}) != 0;
01519     \textcolor{keywordtype}{int} ch = (flags & \hyperlink{server_8h_ac1b2fe32c997eff75e263e6689e15d2e}{ZADD\_CH}) != 0;
01520 
01521     \textcolor{comment}{/* After the options, we expect to have an even number of args, since}
01522 \textcolor{comment}{     * we expect any number of score-element pairs. */}
01523     elements = c->argc-scoreidx;
01524     \textcolor{keywordflow}{if} (elements % 2 || !elements) \{
01525         addReply(c,shared.syntaxerr);
01526         \textcolor{keywordflow}{return};
01527     \}
01528     elements /= 2; \textcolor{comment}{/* Now this holds the number of score-element pairs. */}
01529 
01530     \textcolor{comment}{/* Check for incompatible options. */}
01531     \textcolor{keywordflow}{if} (nx && xx) \{
01532         addReplyError(c,
01533             \textcolor{stringliteral}{"XX and NX options at the same time are not compatible"});
01534         \textcolor{keywordflow}{return};
01535     \}
01536 
01537     \textcolor{keywordflow}{if} (incr && elements > 1) \{
01538         addReplyError(c,
01539             \textcolor{stringliteral}{"INCR option supports a single increment-element pair"});
01540         \textcolor{keywordflow}{return};
01541     \}
01542 
01543     \textcolor{comment}{/* Start parsing all the scores, we need to emit any syntax error}
01544 \textcolor{comment}{     * before executing additions to the sorted set, as the command should}
01545 \textcolor{comment}{     * either execute fully or nothing at all. */}
01546     scores = zmalloc(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{double})*elements);
01547     \textcolor{keywordflow}{for} (j = 0; j < elements; j++) \{
01548         \textcolor{keywordflow}{if} (getDoubleFromObjectOrReply(c,c->argv[scoreidx+j*2],&scores[j],NULL)
01549             != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \textcolor{keywordflow}{goto} cleanup;
01550     \}
01551 
01552     \textcolor{comment}{/* Lookup the key and create the sorted set if does not exist. */}
01553     zobj = lookupKeyWrite(c->db,key);
01554     \textcolor{keywordflow}{if} (zobj == NULL) \{
01555         \textcolor{keywordflow}{if} (xx) \textcolor{keywordflow}{goto} reply\_to\_client; \textcolor{comment}{/* No key + XX option: nothing to do. */}
01556         \textcolor{keywordflow}{if} (server.zset\_max\_ziplist\_entries == 0 ||
01557             server.zset\_max\_ziplist\_value < sdslen(c->argv[scoreidx+1]->ptr))
01558         \{
01559             zobj = createZsetObject();
01560         \} \textcolor{keywordflow}{else} \{
01561             zobj = createZsetZiplistObject();
01562         \}
01563         dbAdd(c->db,key,zobj);
01564     \} \textcolor{keywordflow}{else} \{
01565         \textcolor{keywordflow}{if} (zobj->type != \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}) \{
01566             addReply(c,shared.wrongtypeerr);
01567             \textcolor{keywordflow}{goto} cleanup;
01568         \}
01569     \}
01570 
01571     \textcolor{keywordflow}{for} (j = 0; j < elements; j++) \{
01572         \textcolor{keywordtype}{double} newscore;
01573         score = scores[j];
01574         \textcolor{keywordtype}{int} retflags = flags;
01575 
01576         ele = c->argv[scoreidx+1+j*2]->ptr;
01577         \textcolor{keywordtype}{int} retval = zsetAdd(zobj, score, ele, &retflags, &newscore);
01578         \textcolor{keywordflow}{if} (retval == 0) \{
01579             addReplyError(c,nanerr);
01580             \textcolor{keywordflow}{goto} cleanup;
01581         \}
01582         \textcolor{keywordflow}{if} (retflags & \hyperlink{server_8h_a2c0f3e2c3a5c73496b732648c69eda18}{ZADD\_ADDED}) added++;
01583         \textcolor{keywordflow}{if} (retflags & \hyperlink{server_8h_aabb6bb7a2a2e73ab9fcda97cf704761b}{ZADD\_UPDATED}) updated++;
01584         \textcolor{keywordflow}{if} (!(retflags & \hyperlink{server_8h_afd0096ac4bedddb9b0b7f27396839c06}{ZADD\_NOP})) processed++;
01585         score = newscore;
01586     \}
01587     server.dirty += (added+updated);
01588 
01589 reply\_to\_client:
01590     \textcolor{keywordflow}{if} (incr) \{ \textcolor{comment}{/* ZINCRBY or INCR option. */}
01591         \textcolor{keywordflow}{if} (processed)
01592             addReplyDouble(c,score);
01593         \textcolor{keywordflow}{else}
01594             addReply(c,shared.nullbulk);
01595     \} \textcolor{keywordflow}{else} \{ \textcolor{comment}{/* ZADD. */}
01596         addReplyLongLong(c,ch ? added+updated : added);
01597     \}
01598 
01599 cleanup:
01600     zfree(scores);
01601     \textcolor{keywordflow}{if} (added || updated) \{
01602         signalModifiedKey(c->db,key);
01603         notifyKeyspaceEvent(\hyperlink{server_8h_ab8516a5a3ff1b9eb5f1cb303abef0d2f}{NOTIFY\_ZSET},
01604             incr ? \textcolor{stringliteral}{"zincr"} : \textcolor{stringliteral}{"zadd"}, key, c->db->id);
01605     \}
01606 \}
01607 
01608 \textcolor{keywordtype}{void} zaddCommand(\hyperlink{structclient}{client} *c) \{
01609     zaddGenericCommand(c,\hyperlink{server_8h_aa8b724e5b88e5d650fb872e66ca52995}{ZADD\_NONE});
01610 \}
01611 
01612 \textcolor{keywordtype}{void} zincrbyCommand(\hyperlink{structclient}{client} *c) \{
01613     zaddGenericCommand(c,\hyperlink{server_8h_aa31f5564c57b55123a4e2d6a5eb599cf}{ZADD\_INCR});
01614 \}
01615 
01616 \textcolor{keywordtype}{void} zremCommand(\hyperlink{structclient}{client} *c) \{
01617     robj *key = c->argv[1];
01618     robj *zobj;
01619     \textcolor{keywordtype}{int} deleted = 0, keyremoved = 0, j;
01620 
01621     \textcolor{keywordflow}{if} ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
01622         checkType(c,zobj,\hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET})) \textcolor{keywordflow}{return};
01623 
01624     \textcolor{keywordflow}{for} (j = 2; j < c->argc; j++) \{
01625         \textcolor{keywordflow}{if} (zsetDel(zobj,c->argv[j]->ptr)) deleted++;
01626         \textcolor{keywordflow}{if} (zsetLength(zobj) == 0) \{
01627             dbDelete(c->db,key);
01628             keyremoved = 1;
01629             \textcolor{keywordflow}{break};
01630         \}
01631     \}
01632 
01633     \textcolor{keywordflow}{if} (deleted) \{
01634         notifyKeyspaceEvent(\hyperlink{server_8h_ab8516a5a3ff1b9eb5f1cb303abef0d2f}{NOTIFY\_ZSET},\textcolor{stringliteral}{"zrem"},key,c->db->id);
01635         \textcolor{keywordflow}{if} (keyremoved)
01636             notifyKeyspaceEvent(\hyperlink{server_8h_a9fa53dd1068e62365f3964ad3479eec2}{NOTIFY\_GENERIC},\textcolor{stringliteral}{"del"},key,c->db->id);
01637         signalModifiedKey(c->db,key);
01638         server.dirty += deleted;
01639     \}
01640     addReplyLongLong(c,deleted);
01641 \}
01642 
01643 \textcolor{comment}{/* Implements ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZREMRANGEBYLEX commands. */}
01644 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZRANGE\_RANK} 0
01645 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZRANGE\_SCORE} 1
01646 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZRANGE\_LEX} 2
01647 \textcolor{keywordtype}{void} zremrangeGenericCommand(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} rangetype) \{
01648     robj *key = c->argv[1];
01649     robj *zobj;
01650     \textcolor{keywordtype}{int} keyremoved = 0;
01651     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} deleted = 0;
01652     zrangespec range;
01653     zlexrangespec lexrange;
01654     \textcolor{keywordtype}{long} start, end, llen;
01655 
01656     \textcolor{comment}{/* Step 1: Parse the range. */}
01657     \textcolor{keywordflow}{if} (rangetype == \hyperlink{t__zset_8c_a5efcb596b1e5f49647431b38c2c5dde3}{ZRANGE\_RANK}) \{
01658         \textcolor{keywordflow}{if} ((getLongFromObjectOrReply(c,c->argv[2],&start,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) ||
01659             (getLongFromObjectOrReply(c,c->argv[3],&end,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}))
01660             \textcolor{keywordflow}{return};
01661     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rangetype == \hyperlink{t__zset_8c_a0ca38ddc10a38a3b5f6b50e2b25fc4ce}{ZRANGE\_SCORE}) \{
01662         \textcolor{keywordflow}{if} (zslParseRange(c->argv[2],c->argv[3],&range) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
01663             addReplyError(c,\textcolor{stringliteral}{"min or max is not a float"});
01664             \textcolor{keywordflow}{return};
01665         \}
01666     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rangetype == \hyperlink{t__zset_8c_a74c64b6c3895c27dc16c15a3c4c590af}{ZRANGE\_LEX}) \{
01667         \textcolor{keywordflow}{if} (zslParseLexRange(c->argv[2],c->argv[3],&lexrange) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
01668             addReplyError(c,\textcolor{stringliteral}{"min or max not valid string range item"});
01669             \textcolor{keywordflow}{return};
01670         \}
01671     \}
01672 
01673     \textcolor{comment}{/* Step 2: Lookup & range sanity checks if needed. */}
01674     \textcolor{keywordflow}{if} ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
01675         checkType(c,zobj,\hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET})) \textcolor{keywordflow}{goto} cleanup;
01676 
01677     \textcolor{keywordflow}{if} (rangetype == \hyperlink{t__zset_8c_a5efcb596b1e5f49647431b38c2c5dde3}{ZRANGE\_RANK}) \{
01678         \textcolor{comment}{/* Sanitize indexes. */}
01679         llen = zsetLength(zobj);
01680         \textcolor{keywordflow}{if} (start < 0) start = llen+start;
01681         \textcolor{keywordflow}{if} (end < 0) end = llen+end;
01682         \textcolor{keywordflow}{if} (start < 0) start = 0;
01683 
01684         \textcolor{comment}{/* Invariant: start >= 0, so this test will be true when end < 0.}
01685 \textcolor{comment}{         * The range is empty when start > end or start >= length. */}
01686         \textcolor{keywordflow}{if} (start > end || start >= llen) \{
01687             addReply(c,shared.czero);
01688             \textcolor{keywordflow}{goto} cleanup;
01689         \}
01690         \textcolor{keywordflow}{if} (end >= llen) end = llen-1;
01691     \}
01692 
01693     \textcolor{comment}{/* Step 3: Perform the range deletion operation. */}
01694     \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
01695         \textcolor{keywordflow}{switch}(rangetype) \{
01696         \textcolor{keywordflow}{case} \hyperlink{t__zset_8c_a5efcb596b1e5f49647431b38c2c5dde3}{ZRANGE\_RANK}:
01697             zobj->ptr = zzlDeleteRangeByRank(zobj->ptr,start+1,end+1,&deleted);
01698             \textcolor{keywordflow}{break};
01699         \textcolor{keywordflow}{case} \hyperlink{t__zset_8c_a0ca38ddc10a38a3b5f6b50e2b25fc4ce}{ZRANGE\_SCORE}:
01700             zobj->ptr = zzlDeleteRangeByScore(zobj->ptr,&range,&deleted);
01701             \textcolor{keywordflow}{break};
01702         \textcolor{keywordflow}{case} \hyperlink{t__zset_8c_a74c64b6c3895c27dc16c15a3c4c590af}{ZRANGE\_LEX}:
01703             zobj->ptr = zzlDeleteRangeByLex(zobj->ptr,&lexrange,&deleted);
01704             \textcolor{keywordflow}{break};
01705         \}
01706         \textcolor{keywordflow}{if} (zzlLength(zobj->ptr) == 0) \{
01707             dbDelete(c->db,key);
01708             keyremoved = 1;
01709         \}
01710     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
01711         zset *zs = zobj->ptr;
01712         \textcolor{keywordflow}{switch}(rangetype) \{
01713         \textcolor{keywordflow}{case} \hyperlink{t__zset_8c_a5efcb596b1e5f49647431b38c2c5dde3}{ZRANGE\_RANK}:
01714             deleted = zslDeleteRangeByRank(zs->zsl,start+1,end+1,zs->dict);
01715             \textcolor{keywordflow}{break};
01716         \textcolor{keywordflow}{case} \hyperlink{t__zset_8c_a0ca38ddc10a38a3b5f6b50e2b25fc4ce}{ZRANGE\_SCORE}:
01717             deleted = zslDeleteRangeByScore(zs->zsl,&range,zs->dict);
01718             \textcolor{keywordflow}{break};
01719         \textcolor{keywordflow}{case} \hyperlink{t__zset_8c_a74c64b6c3895c27dc16c15a3c4c590af}{ZRANGE\_LEX}:
01720             deleted = zslDeleteRangeByLex(zs->zsl,&lexrange,zs->dict);
01721             \textcolor{keywordflow}{break};
01722         \}
01723         \textcolor{keywordflow}{if} (htNeedsResize(zs->dict)) dictResize(zs->dict);
01724         \textcolor{keywordflow}{if} (\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(zs->dict) == 0) \{
01725             dbDelete(c->db,key);
01726             keyremoved = 1;
01727         \}
01728     \} \textcolor{keywordflow}{else} \{
01729         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted set encoding"});
01730     \}
01731 
01732     \textcolor{comment}{/* Step 4: Notifications and reply. */}
01733     \textcolor{keywordflow}{if} (deleted) \{
01734         \textcolor{keywordtype}{char} *event[3] = \{\textcolor{stringliteral}{"zremrangebyrank"},\textcolor{stringliteral}{"zremrangebyscore"},\textcolor{stringliteral}{"zremrangebylex"}\};
01735         signalModifiedKey(c->db,key);
01736         notifyKeyspaceEvent(\hyperlink{server_8h_ab8516a5a3ff1b9eb5f1cb303abef0d2f}{NOTIFY\_ZSET},event[rangetype],key,c->db->id);
01737         \textcolor{keywordflow}{if} (keyremoved)
01738             notifyKeyspaceEvent(\hyperlink{server_8h_a9fa53dd1068e62365f3964ad3479eec2}{NOTIFY\_GENERIC},\textcolor{stringliteral}{"del"},key,c->db->id);
01739     \}
01740     server.dirty += deleted;
01741     addReplyLongLong(c,deleted);
01742 
01743 cleanup:
01744     \textcolor{keywordflow}{if} (rangetype == \hyperlink{t__zset_8c_a74c64b6c3895c27dc16c15a3c4c590af}{ZRANGE\_LEX}) zslFreeLexRange(&lexrange);
01745 \}
01746 
01747 \textcolor{keywordtype}{void} zremrangebyrankCommand(\hyperlink{structclient}{client} *c) \{
01748     zremrangeGenericCommand(c,\hyperlink{t__zset_8c_a5efcb596b1e5f49647431b38c2c5dde3}{ZRANGE\_RANK});
01749 \}
01750 
01751 \textcolor{keywordtype}{void} zremrangebyscoreCommand(\hyperlink{structclient}{client} *c) \{
01752     zremrangeGenericCommand(c,\hyperlink{t__zset_8c_a0ca38ddc10a38a3b5f6b50e2b25fc4ce}{ZRANGE\_SCORE});
01753 \}
01754 
01755 \textcolor{keywordtype}{void} zremrangebylexCommand(\hyperlink{structclient}{client} *c) \{
01756     zremrangeGenericCommand(c,\hyperlink{t__zset_8c_a74c64b6c3895c27dc16c15a3c4c590af}{ZRANGE\_LEX});
01757 \}
01758 
\Hypertarget{t__zset_8c_source_l01759}\hyperlink{structzsetopsrc}{01759} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \{
01760     robj *subject;
01761     \textcolor{keywordtype}{int} type; \textcolor{comment}{/* Set, sorted set */}
01762     \textcolor{keywordtype}{int} encoding;
01763     \textcolor{keywordtype}{double} weight;
01764 
\Hypertarget{t__zset_8c_source_l01765}\hyperlink{unionzsetopsrc_8iter}{01765}     \textcolor{keyword}{union} \{
01766         \textcolor{comment}{/* Set iterators. */}
\Hypertarget{t__zset_8c_source_l01767}\hyperlink{unionzsetopsrc_1_1__iterset_8iter_8set}{01767}         \textcolor{keyword}{union} \_iterset \{
\Hypertarget{t__zset_8c_source_l01768}\hyperlink{structzsetopsrc_1_1__iterset_8iter_8set_8is}{01768}             \textcolor{keyword}{struct} \{
01769                 intset *is;
01770                 \textcolor{keywordtype}{int} ii;
01771             \} is;
\Hypertarget{t__zset_8c_source_l01772}\hyperlink{structzsetopsrc_1_1__iterset_8iter_8set_8ht}{01772}             \textcolor{keyword}{struct} \{
01773                 dict *dict;
01774                 dictIterator *di;
01775                 dictEntry *de;
01776             \} ht;
01777         \} set;
01778 
01779         \textcolor{comment}{/* Sorted set iterators. */}
\Hypertarget{t__zset_8c_source_l01780}\hyperlink{unionzsetopsrc_1_1__iterzset_8iter_8zset}{01780}         \textcolor{keyword}{union} \_iterzset \{
\Hypertarget{t__zset_8c_source_l01781}\hyperlink{structzsetopsrc_1_1__iterzset_8iter_8zset_8zl}{01781}             \textcolor{keyword}{struct} \{
01782                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl;
01783                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr, *sptr;
01784             \} zl;
\Hypertarget{t__zset_8c_source_l01785}\hyperlink{structzsetopsrc_1_1__iterzset_8iter_8zset_8sl}{01785}             \textcolor{keyword}{struct} \{
01786                 zset *zs;
01787                 zskiplistNode *node;
01788             \} sl;
01789         \} zset;
01790     \} iter;
01791 \} zsetopsrc;
01792 
01793 
01794 \textcolor{comment}{/* Use dirty flags for pointers that need to be cleaned up in the next}
01795 \textcolor{comment}{ * iteration over the zsetopval. The dirty flag for the long long value is}
01796 \textcolor{comment}{ * special, since long long values don't need cleanup. Instead, it means that}
01797 \textcolor{comment}{ * we already checked that "ell" holds a long long, or tried to convert another}
01798 \textcolor{comment}{ * representation into a long long value. When this was successful,}
01799 \textcolor{comment}{ * OPVAL\_VALID\_LL is set as well. */}
01800 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OPVAL\_DIRTY\_SDS} 1
01801 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OPVAL\_DIRTY\_LL} 2
01802 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OPVAL\_VALID\_LL} 4
01803 
01804 \textcolor{comment}{/* Store value retrieved from the iterator. */}
\Hypertarget{t__zset_8c_source_l01805}\hyperlink{structzsetopval}{01805} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \{
01806     \textcolor{keywordtype}{int} flags;
01807     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \_buf[32]; \textcolor{comment}{/* Private buffer. */}
01808     sds ele;
01809     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *estr;
01810     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} elen;
01811     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ell;
01812     \textcolor{keywordtype}{double} score;
01813 \} zsetopval;
01814 
01815 \textcolor{keyword}{typedef} \textcolor{keyword}{union} \_iterset iterset;
01816 \textcolor{keyword}{typedef} \textcolor{keyword}{union} \_iterzset iterzset;
01817 
01818 \textcolor{keywordtype}{void} zuiInitIterator(zsetopsrc *op) \{
01819     \textcolor{keywordflow}{if} (op->subject == NULL)
01820         \textcolor{keywordflow}{return};
01821 
01822     \textcolor{keywordflow}{if} (op->type == \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET}) \{
01823         iterset *it = &op->iter.set;
01824         \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
01825             it->is.is = op->subject->ptr;
01826             it->is.ii = 0;
01827         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
01828             it->ht.dict = op->subject->ptr;
01829             it->ht.di = dictGetIterator(op->subject->ptr);
01830             it->ht.de = dictNext(it->ht.di);
01831         \} \textcolor{keywordflow}{else} \{
01832             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown set encoding"});
01833         \}
01834     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op->type == \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}) \{
01835         iterzset *it = &op->iter.zset;
01836         \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
01837             it->zl.zl = op->subject->ptr;
01838             it->zl.eptr = ziplistIndex(it->zl.zl,0);
01839             \textcolor{keywordflow}{if} (it->zl.eptr != NULL) \{
01840                 it->zl.sptr = ziplistNext(it->zl.zl,it->zl.eptr);
01841                 \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(it->zl.sptr != NULL);
01842             \}
01843         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
01844             it->sl.zs = op->subject->ptr;
01845             it->sl.node = it->sl.zs->zsl->header->level[0].forward;
01846         \} \textcolor{keywordflow}{else} \{
01847             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted set encoding"});
01848         \}
01849     \} \textcolor{keywordflow}{else} \{
01850         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unsupported type"});
01851     \}
01852 \}
01853 
01854 \textcolor{keywordtype}{void} zuiClearIterator(zsetopsrc *op) \{
01855     \textcolor{keywordflow}{if} (op->subject == NULL)
01856         \textcolor{keywordflow}{return};
01857 
01858     \textcolor{keywordflow}{if} (op->type == \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET}) \{
01859         iterset *it = &op->iter.set;
01860         \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
01861             \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(it); \textcolor{comment}{/* skip */}
01862         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
01863             dictReleaseIterator(it->ht.di);
01864         \} \textcolor{keywordflow}{else} \{
01865             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown set encoding"});
01866         \}
01867     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op->type == \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}) \{
01868         iterzset *it = &op->iter.zset;
01869         \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
01870             \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(it); \textcolor{comment}{/* skip */}
01871         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
01872             \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(it); \textcolor{comment}{/* skip */}
01873         \} \textcolor{keywordflow}{else} \{
01874             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted set encoding"});
01875         \}
01876     \} \textcolor{keywordflow}{else} \{
01877         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unsupported type"});
01878     \}
01879 \}
01880 
01881 \textcolor{keywordtype}{int} zuiLength(zsetopsrc *op) \{
01882     \textcolor{keywordflow}{if} (op->subject == NULL)
01883         \textcolor{keywordflow}{return} 0;
01884 
01885     \textcolor{keywordflow}{if} (op->type == \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET}) \{
01886         \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
01887             \textcolor{keywordflow}{return} intsetLen(op->subject->ptr);
01888         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
01889             dict *ht = op->subject->ptr;
01890             \textcolor{keywordflow}{return} \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(ht);
01891         \} \textcolor{keywordflow}{else} \{
01892             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown set encoding"});
01893         \}
01894     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op->type == \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}) \{
01895         \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
01896             \textcolor{keywordflow}{return} zzlLength(op->subject->ptr);
01897         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
01898             zset *zs = op->subject->ptr;
01899             \textcolor{keywordflow}{return} zs->zsl->length;
01900         \} \textcolor{keywordflow}{else} \{
01901             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted set encoding"});
01902         \}
01903     \} \textcolor{keywordflow}{else} \{
01904         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unsupported type"});
01905     \}
01906 \}
01907 
01908 \textcolor{comment}{/* Check if the current value is valid. If so, store it in the passed structure}
01909 \textcolor{comment}{ * and move to the next element. If not valid, this means we have reached the}
01910 \textcolor{comment}{ * end of the structure and can abort. */}
01911 \textcolor{keywordtype}{int} zuiNext(zsetopsrc *op, zsetopval *val) \{
01912     \textcolor{keywordflow}{if} (op->subject == NULL)
01913         \textcolor{keywordflow}{return} 0;
01914 
01915     \textcolor{keywordflow}{if} (val->flags & \hyperlink{t__zset_8c_acbe2b593dce5dd6c6d7219e6be208e5f}{OPVAL\_DIRTY\_SDS})
01916         sdsfree(val->ele);
01917 
01918     memset(val,0,\textcolor{keyword}{sizeof}(zsetopval));
01919 
01920     \textcolor{keywordflow}{if} (op->type == \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET}) \{
01921         iterset *it = &op->iter.set;
01922         \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
01923             int64\_t ell;
01924 
01925             \textcolor{keywordflow}{if} (!intsetGet(it->is.is,it->is.ii,&ell))
01926                 \textcolor{keywordflow}{return} 0;
01927             val->ell = ell;
01928             val->score = 1.0;
01929 
01930             \textcolor{comment}{/* Move to next element. */}
01931             it->is.ii++;
01932         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
01933             \textcolor{keywordflow}{if} (it->ht.de == NULL)
01934                 \textcolor{keywordflow}{return} 0;
01935             val->ele = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(it->ht.de);
01936             val->score = 1.0;
01937 
01938             \textcolor{comment}{/* Move to next element. */}
01939             it->ht.de = dictNext(it->ht.di);
01940         \} \textcolor{keywordflow}{else} \{
01941             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown set encoding"});
01942         \}
01943     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op->type == \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}) \{
01944         iterzset *it = &op->iter.zset;
01945         \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
01946             \textcolor{comment}{/* No need to check both, but better be explicit. */}
01947             \textcolor{keywordflow}{if} (it->zl.eptr == NULL || it->zl.sptr == NULL)
01948                 \textcolor{keywordflow}{return} 0;
01949             \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(ziplistGet(it->zl.eptr,&val->estr,&val->elen,&val->ell));
01950             val->score = zzlGetScore(it->zl.sptr);
01951 
01952             \textcolor{comment}{/* Move to next element. */}
01953             zzlNext(it->zl.zl,&it->zl.eptr,&it->zl.sptr);
01954         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
01955             \textcolor{keywordflow}{if} (it->sl.node == NULL)
01956                 \textcolor{keywordflow}{return} 0;
01957             val->ele = it->sl.node->ele;
01958             val->score = it->sl.node->score;
01959 
01960             \textcolor{comment}{/* Move to next element. */}
01961             it->sl.node = it->sl.node->level[0].forward;
01962         \} \textcolor{keywordflow}{else} \{
01963             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted set encoding"});
01964         \}
01965     \} \textcolor{keywordflow}{else} \{
01966         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unsupported type"});
01967     \}
01968     \textcolor{keywordflow}{return} 1;
01969 \}
01970 
01971 \textcolor{keywordtype}{int} zuiLongLongFromValue(zsetopval *val) \{
01972     \textcolor{keywordflow}{if} (!(val->flags & \hyperlink{t__zset_8c_a9999cca84f897ad3930ec05f5fbd4c6a}{OPVAL\_DIRTY\_LL})) \{
01973         val->flags |= \hyperlink{t__zset_8c_a9999cca84f897ad3930ec05f5fbd4c6a}{OPVAL\_DIRTY\_LL};
01974 
01975         \textcolor{keywordflow}{if} (val->ele != NULL) \{
01976             \textcolor{keywordflow}{if} (string2ll(val->ele,sdslen(val->ele),&val->ell))
01977                 val->flags |= \hyperlink{t__zset_8c_ad167719b3971be74b94f0233de011e67}{OPVAL\_VALID\_LL};
01978         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (val->estr != NULL) \{
01979             \textcolor{keywordflow}{if} (string2ll((\textcolor{keywordtype}{char}*)val->estr,val->elen,&val->ell))
01980                 val->flags |= \hyperlink{t__zset_8c_ad167719b3971be74b94f0233de011e67}{OPVAL\_VALID\_LL};
01981         \} \textcolor{keywordflow}{else} \{
01982             \textcolor{comment}{/* The long long was already set, flag as valid. */}
01983             val->flags |= \hyperlink{t__zset_8c_ad167719b3971be74b94f0233de011e67}{OPVAL\_VALID\_LL};
01984         \}
01985     \}
01986     \textcolor{keywordflow}{return} val->flags & \hyperlink{t__zset_8c_ad167719b3971be74b94f0233de011e67}{OPVAL\_VALID\_LL};
01987 \}
01988 
01989 sds zuiSdsFromValue(zsetopval *val) \{
01990     \textcolor{keywordflow}{if} (val->ele == NULL) \{
01991         \textcolor{keywordflow}{if} (val->estr != NULL) \{
01992             val->ele = sdsnewlen((\textcolor{keywordtype}{char}*)val->estr,val->elen);
01993         \} \textcolor{keywordflow}{else} \{
01994             val->ele = sdsfromlonglong(val->ell);
01995         \}
01996         val->flags |= \hyperlink{t__zset_8c_acbe2b593dce5dd6c6d7219e6be208e5f}{OPVAL\_DIRTY\_SDS};
01997     \}
01998     \textcolor{keywordflow}{return} val->ele;
01999 \}
02000 
02001 \textcolor{comment}{/* This is different from zuiSdsFromValue since returns a new SDS string}
02002 \textcolor{comment}{ * which is up to the caller to free. */}
02003 sds zuiNewSdsFromValue(zsetopval *val) \{
02004     \textcolor{keywordflow}{if} (val->flags & \hyperlink{t__zset_8c_acbe2b593dce5dd6c6d7219e6be208e5f}{OPVAL\_DIRTY\_SDS}) \{
02005         \textcolor{comment}{/* We have already one to return! */}
02006         sds ele = val->ele;
02007         val->flags &= ~\hyperlink{t__zset_8c_acbe2b593dce5dd6c6d7219e6be208e5f}{OPVAL\_DIRTY\_SDS};
02008         val->ele = NULL;
02009         \textcolor{keywordflow}{return} ele;
02010     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (val->ele) \{
02011         \textcolor{keywordflow}{return} sdsdup(val->ele);
02012     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (val->estr) \{
02013         \textcolor{keywordflow}{return} sdsnewlen((\textcolor{keywordtype}{char}*)val->estr,val->elen);
02014     \} \textcolor{keywordflow}{else} \{
02015         \textcolor{keywordflow}{return} sdsfromlonglong(val->ell);
02016     \}
02017 \}
02018 
02019 \textcolor{keywordtype}{int} zuiBufferFromValue(zsetopval *val) \{
02020     \textcolor{keywordflow}{if} (val->estr == NULL) \{
02021         \textcolor{keywordflow}{if} (val->ele != NULL) \{
02022             val->elen = sdslen(val->ele);
02023             val->estr = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)val->ele;
02024         \} \textcolor{keywordflow}{else} \{
02025             val->elen = ll2string((\textcolor{keywordtype}{char}*)val->\_buf,\textcolor{keyword}{sizeof}(val->\_buf),val->ell);
02026             val->estr = val->\_buf;
02027         \}
02028     \}
02029     \textcolor{keywordflow}{return} 1;
02030 \}
02031 
02032 \textcolor{comment}{/* Find value pointed to by val in the source pointer to by op. When found,}
02033 \textcolor{comment}{ * return 1 and store its score in target. Return 0 otherwise. */}
02034 \textcolor{keywordtype}{int} zuiFind(zsetopsrc *op, zsetopval *val, \textcolor{keywordtype}{double} *score) \{
02035     \textcolor{keywordflow}{if} (op->subject == NULL)
02036         \textcolor{keywordflow}{return} 0;
02037 
02038     \textcolor{keywordflow}{if} (op->type == \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET}) \{
02039         \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
02040             \textcolor{keywordflow}{if} (zuiLongLongFromValue(val) &&
02041                 intsetFind(op->subject->ptr,val->ell))
02042             \{
02043                 *score = 1.0;
02044                 \textcolor{keywordflow}{return} 1;
02045             \} \textcolor{keywordflow}{else} \{
02046                 \textcolor{keywordflow}{return} 0;
02047             \}
02048         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
02049             dict *ht = op->subject->ptr;
02050             zuiSdsFromValue(val);
02051             \textcolor{keywordflow}{if} (dictFind(ht,val->ele) != NULL) \{
02052                 *score = 1.0;
02053                 \textcolor{keywordflow}{return} 1;
02054             \} \textcolor{keywordflow}{else} \{
02055                 \textcolor{keywordflow}{return} 0;
02056             \}
02057         \} \textcolor{keywordflow}{else} \{
02058             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown set encoding"});
02059         \}
02060     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op->type == \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}) \{
02061         zuiSdsFromValue(val);
02062 
02063         \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
02064             \textcolor{keywordflow}{if} (zzlFind(op->subject->ptr,val->ele,score) != NULL) \{
02065                 \textcolor{comment}{/* Score is already set by zzlFind. */}
02066                 \textcolor{keywordflow}{return} 1;
02067             \} \textcolor{keywordflow}{else} \{
02068                 \textcolor{keywordflow}{return} 0;
02069             \}
02070         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
02071             zset *zs = op->subject->ptr;
02072             dictEntry *de;
02073             \textcolor{keywordflow}{if} ((de = dictFind(zs->dict,val->ele)) != NULL) \{
02074                 *score = *(\textcolor{keywordtype}{double}*)\hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
02075                 \textcolor{keywordflow}{return} 1;
02076             \} \textcolor{keywordflow}{else} \{
02077                 \textcolor{keywordflow}{return} 0;
02078             \}
02079         \} \textcolor{keywordflow}{else} \{
02080             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted set encoding"});
02081         \}
02082     \} \textcolor{keywordflow}{else} \{
02083         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unsupported type"});
02084     \}
02085 \}
02086 
02087 \textcolor{keywordtype}{int} zuiCompareByCardinality(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *s1, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *s2) \{
02088     \textcolor{keywordflow}{return} zuiLength((zsetopsrc*)s1) - zuiLength((zsetopsrc*)s2);
02089 \}
02090 
02091 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDIS\_AGGR\_SUM} 1
02092 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDIS\_AGGR\_MIN} 2
02093 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDIS\_AGGR\_MAX} 3
02094 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{zunionInterDictValue}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_e}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_e}\textcolor{preprocessor}{)} \textcolor{preprocessor}{==} NULL \textcolor{preprocessor}{?} 1.0 \textcolor{preprocessor}{:} \textcolor{preprocessor}{*}\textcolor{preprocessor}{(}\textcolor{keywordtype}{double}\textcolor{preprocessor}{*}\textcolor{preprocessor}{)}
      \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_e}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
02095 
02096 \textcolor{keyword}{inline} \textcolor{keyword}{static} \textcolor{keywordtype}{void} zunionInterAggregate(\textcolor{keywordtype}{double} *target, \textcolor{keywordtype}{double} val, \textcolor{keywordtype}{int} aggregate) \{
02097     \textcolor{keywordflow}{if} (aggregate == \hyperlink{t__zset_8c_a68af64a03a67d45bee92a8713f640ce8}{REDIS\_AGGR\_SUM}) \{
02098         *target = *target + val;
02099         \textcolor{comment}{/* The result of adding two doubles is NaN when one variable}
02100 \textcolor{comment}{         * is +inf and the other is -inf. When these numbers are added,}
02101 \textcolor{comment}{         * we maintain the convention of the result being 0.0. */}
02102         \textcolor{keywordflow}{if} (isnan(*target)) *target = 0.0;
02103     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (aggregate == \hyperlink{t__zset_8c_a2da62788a46c712881bbcf613a98b3a9}{REDIS\_AGGR\_MIN}) \{
02104         *target = val < *target ? val : *target;
02105     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (aggregate == \hyperlink{t__zset_8c_a53a2a589750e7720bfc8feb9c1c4ec51}{REDIS\_AGGR\_MAX}) \{
02106         *target = val > *target ? val : *target;
02107     \} \textcolor{keywordflow}{else} \{
02108         \textcolor{comment}{/* safety net */}
02109         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown ZUNION/INTER aggregate type"});
02110     \}
02111 \}
02112 
02113 uint64\_t dictSdsHash(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *key);
02114 \textcolor{keywordtype}{int} dictSdsKeyCompare(\textcolor{keywordtype}{void} *privdata, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key1, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key2);
02115 
02116 dictType setAccumulatorDictType = \{
02117     dictSdsHash,               \textcolor{comment}{/* hash function */}
02118     NULL,                      \textcolor{comment}{/* key dup */}
02119     NULL,                      \textcolor{comment}{/* val dup */}
02120     dictSdsKeyCompare,         \textcolor{comment}{/* key compare */}
02121     NULL,                      \textcolor{comment}{/* key destructor */}
02122     NULL                       \textcolor{comment}{/* val destructor */}
02123 \};
02124 
02125 \textcolor{keywordtype}{void} zunionInterGenericCommand(\hyperlink{structclient}{client} *c, robj *dstkey, \textcolor{keywordtype}{int} op) \{
02126     \textcolor{keywordtype}{int} i, j;
02127     \textcolor{keywordtype}{long} setnum;
02128     \textcolor{keywordtype}{int} aggregate = \hyperlink{t__zset_8c_a68af64a03a67d45bee92a8713f640ce8}{REDIS\_AGGR\_SUM};
02129     zsetopsrc *src;
02130     zsetopval zval;
02131     sds tmp;
02132     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} maxelelen = 0;
02133     robj *dstobj;
02134     zset *dstzset;
02135     zskiplistNode *znode;
02136     \textcolor{keywordtype}{int} touched = 0;
02137 
02138     \textcolor{comment}{/* expect setnum input keys to be given */}
02139     \textcolor{keywordflow}{if} ((getLongFromObjectOrReply(c, c->argv[2], &setnum, NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}))
02140         \textcolor{keywordflow}{return};
02141 
02142     \textcolor{keywordflow}{if} (setnum < 1) \{
02143         addReplyError(c,
02144             \textcolor{stringliteral}{"at least 1 input key is needed for ZUNIONSTORE/ZINTERSTORE"});
02145         \textcolor{keywordflow}{return};
02146     \}
02147 
02148     \textcolor{comment}{/* test if the expected number of keys would overflow */}
02149     \textcolor{keywordflow}{if} (setnum > c->argc-3) \{
02150         addReply(c,shared.syntaxerr);
02151         \textcolor{keywordflow}{return};
02152     \}
02153 
02154     \textcolor{comment}{/* read keys to be used for input */}
02155     src = zcalloc(\textcolor{keyword}{sizeof}(zsetopsrc) * setnum);
02156     \textcolor{keywordflow}{for} (i = 0, j = 3; i < setnum; i++, j++) \{
02157         robj *obj = lookupKeyWrite(c->db,c->argv[j]);
02158         \textcolor{keywordflow}{if} (obj != NULL) \{
02159             \textcolor{keywordflow}{if} (obj->type != \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET} && obj->type != \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET}) \{
02160                 zfree(src);
02161                 addReply(c,shared.wrongtypeerr);
02162                 \textcolor{keywordflow}{return};
02163             \}
02164 
02165             src[i].subject = obj;
02166             src[i].type = obj->type;
02167             src[i].encoding = obj->encoding;
02168         \} \textcolor{keywordflow}{else} \{
02169             src[i].subject = NULL;
02170         \}
02171 
02172         \textcolor{comment}{/* Default all weights to 1. */}
02173         src[i].weight = 1.0;
02174     \}
02175 
02176     \textcolor{comment}{/* parse optional extra arguments */}
02177     \textcolor{keywordflow}{if} (j < c->argc) \{
02178         \textcolor{keywordtype}{int} remaining = c->argc - j;
02179 
02180         \textcolor{keywordflow}{while} (remaining) \{
02181             \textcolor{keywordflow}{if} (remaining >= (setnum + 1) &&
02182                 !strcasecmp(c->argv[j]->ptr,\textcolor{stringliteral}{"weights"}))
02183             \{
02184                 j++; remaining--;
02185                 \textcolor{keywordflow}{for} (i = 0; i < setnum; i++, j++, remaining--) \{
02186                     \textcolor{keywordflow}{if} (getDoubleFromObjectOrReply(c,c->argv[j],&src[i].weight,
02187                             \textcolor{stringliteral}{"weight value is not a float"}) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
02188                     \{
02189                         zfree(src);
02190                         \textcolor{keywordflow}{return};
02191                     \}
02192                 \}
02193             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (remaining >= 2 &&
02194                        !strcasecmp(c->argv[j]->ptr,\textcolor{stringliteral}{"aggregate"}))
02195             \{
02196                 j++; remaining--;
02197                 \textcolor{keywordflow}{if} (!strcasecmp(c->argv[j]->ptr,\textcolor{stringliteral}{"sum"})) \{
02198                     aggregate = \hyperlink{t__zset_8c_a68af64a03a67d45bee92a8713f640ce8}{REDIS\_AGGR\_SUM};
02199                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[j]->ptr,\textcolor{stringliteral}{"min"})) \{
02200                     aggregate = \hyperlink{t__zset_8c_a2da62788a46c712881bbcf613a98b3a9}{REDIS\_AGGR\_MIN};
02201                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[j]->ptr,\textcolor{stringliteral}{"max"})) \{
02202                     aggregate = \hyperlink{t__zset_8c_a53a2a589750e7720bfc8feb9c1c4ec51}{REDIS\_AGGR\_MAX};
02203                 \} \textcolor{keywordflow}{else} \{
02204                     zfree(src);
02205                     addReply(c,shared.syntaxerr);
02206                     \textcolor{keywordflow}{return};
02207                 \}
02208                 j++; remaining--;
02209             \} \textcolor{keywordflow}{else} \{
02210                 zfree(src);
02211                 addReply(c,shared.syntaxerr);
02212                 \textcolor{keywordflow}{return};
02213             \}
02214         \}
02215     \}
02216 
02217     \textcolor{comment}{/* sort sets from the smallest to largest, this will improve our}
02218 \textcolor{comment}{     * algorithm's performance */}
02219     qsort(src,setnum,\textcolor{keyword}{sizeof}(zsetopsrc),zuiCompareByCardinality);
02220 
02221     dstobj = createZsetObject();
02222     dstzset = dstobj->ptr;
02223     memset(&zval, 0, \textcolor{keyword}{sizeof}(zval));
02224 
02225     \textcolor{keywordflow}{if} (op == \hyperlink{server_8h_af089a3b4de4c69fa5d3c7f5ae0d94008}{SET\_OP\_INTER}) \{
02226         \textcolor{comment}{/* Skip everything if the smallest input is empty. */}
02227         \textcolor{keywordflow}{if} (zuiLength(&src[0]) > 0) \{
02228             \textcolor{comment}{/* Precondition: as src[0] is non-empty and the inputs are ordered}
02229 \textcolor{comment}{             * by size, all src[i > 0] are non-empty too. */}
02230             zuiInitIterator(&src[0]);
02231             \textcolor{keywordflow}{while} (zuiNext(&src[0],&zval)) \{
02232                 \textcolor{keywordtype}{double} score, value;
02233 
02234                 score = src[0].weight * zval.score;
02235                 \textcolor{keywordflow}{if} (isnan(score)) score = 0;
02236 
02237                 \textcolor{keywordflow}{for} (j = 1; j < setnum; j++) \{
02238                     \textcolor{comment}{/* It is not safe to access the zset we are}
02239 \textcolor{comment}{                     * iterating, so explicitly check for equal object. */}
02240                     \textcolor{keywordflow}{if} (src[j].subject == src[0].subject) \{
02241                         value = zval.score*src[j].weight;
02242                         zunionInterAggregate(&score,value,aggregate);
02243                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (zuiFind(&src[j],&zval,&value)) \{
02244                         value *= src[j].weight;
02245                         zunionInterAggregate(&score,value,aggregate);
02246                     \} \textcolor{keywordflow}{else} \{
02247                         \textcolor{keywordflow}{break};
02248                     \}
02249                 \}
02250 
02251                 \textcolor{comment}{/* Only continue when present in every input. */}
02252                 \textcolor{keywordflow}{if} (j == setnum) \{
02253                     tmp = zuiNewSdsFromValue(&zval);
02254                     znode = zslInsert(dstzset->zsl,score,tmp);
02255                     dictAdd(dstzset->dict,tmp,&znode->score);
02256                     \textcolor{keywordflow}{if} (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);
02257                 \}
02258             \}
02259             zuiClearIterator(&src[0]);
02260         \}
02261     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op == \hyperlink{server_8h_af00a414b6d78bff8b325eb9cf82c3edb}{SET\_OP\_UNION}) \{
02262         dict *accumulator = dictCreate(&setAccumulatorDictType,NULL);
02263         dictIterator *di;
02264         dictEntry *de, *existing;
02265         \textcolor{keywordtype}{double} score;
02266 
02267         \textcolor{keywordflow}{if} (setnum) \{
02268             \textcolor{comment}{/* Our union is at least as large as the largest set.}
02269 \textcolor{comment}{             * Resize the dictionary ASAP to avoid useless rehashing. */}
02270             dictExpand(accumulator,zuiLength(&src[setnum-1]));
02271         \}
02272 
02273         \textcolor{comment}{/* Step 1: Create a dictionary of elements -> aggregated-scores}
02274 \textcolor{comment}{         * by iterating one sorted set after the other. */}
02275         \textcolor{keywordflow}{for} (i = 0; i < setnum; i++) \{
02276             \textcolor{keywordflow}{if} (zuiLength(&src[i]) == 0) \textcolor{keywordflow}{continue};
02277 
02278             zuiInitIterator(&src[i]);
02279             \textcolor{keywordflow}{while} (zuiNext(&src[i],&zval)) \{
02280                 \textcolor{comment}{/* Initialize value */}
02281                 score = src[i].weight * zval.score;
02282                 \textcolor{keywordflow}{if} (isnan(score)) score = 0;
02283 
02284                 \textcolor{comment}{/* Search for this element in the accumulating dictionary. */}
02285                 de = dictAddRaw(accumulator,zuiSdsFromValue(&zval),&existing);
02286                 \textcolor{comment}{/* If we don't have it, we need to create a new entry. */}
02287                 \textcolor{keywordflow}{if} (!existing) \{
02288                     tmp = zuiNewSdsFromValue(&zval);
02289                     \textcolor{comment}{/* Remember the longest single element encountered,}
02290 \textcolor{comment}{                     * to understand if it's possible to convert to ziplist}
02291 \textcolor{comment}{                     * at the end. */}
02292                      \textcolor{keywordflow}{if} (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);
02293                     \textcolor{comment}{/* Update the element with its initial score. */}
02294                     \hyperlink{dict_8h_a827e5dcfd37bba408fa8bdb111b0594e}{dictSetKey}(accumulator, de, tmp);
02295                     \hyperlink{dict_8h_aa0f8d86bdc0085ffb0d6345d9b92159d}{dictSetDoubleVal}(de,score);
02296                 \} \textcolor{keywordflow}{else} \{
02297                     \textcolor{comment}{/* Update the score with the score of the new instance}
02298 \textcolor{comment}{                     * of the element found in the current sorted set.}
02299 \textcolor{comment}{                     *}
02300 \textcolor{comment}{                     * Here we access directly the dictEntry double}
02301 \textcolor{comment}{                     * value inside the union as it is a big speedup}
02302 \textcolor{comment}{                     * compared to using the getDouble/setDouble API. */}
02303                     zunionInterAggregate(&existing->v.d,score,aggregate);
02304                 \}
02305             \}
02306             zuiClearIterator(&src[i]);
02307         \}
02308 
02309         \textcolor{comment}{/* Step 2: convert the dictionary into the final sorted set. */}
02310         di = dictGetIterator(accumulator);
02311 
02312         \textcolor{comment}{/* We now are aware of the final size of the resulting sorted set,}
02313 \textcolor{comment}{         * let's resize the dictionary embedded inside the sorted set to the}
02314 \textcolor{comment}{         * right size, in order to save rehashing time. */}
02315         dictExpand(dstzset->dict,\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(accumulator));
02316 
02317         \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
02318             sds ele = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
02319             score = \hyperlink{dict_8h_a4e673a942df4ba0fc35665c26c9d226c}{dictGetDoubleVal}(de);
02320             znode = zslInsert(dstzset->zsl,score,ele);
02321             dictAdd(dstzset->dict,ele,&znode->score);
02322         \}
02323         dictReleaseIterator(di);
02324         dictRelease(accumulator);
02325     \} \textcolor{keywordflow}{else} \{
02326         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown operator"});
02327     \}
02328 
02329     \textcolor{keywordflow}{if} (dbDelete(c->db,dstkey))
02330         touched = 1;
02331     \textcolor{keywordflow}{if} (dstzset->zsl->length) \{
02332         zsetConvertToZiplistIfNeeded(dstobj,maxelelen);
02333         dbAdd(c->db,dstkey,dstobj);
02334         addReplyLongLong(c,zsetLength(dstobj));
02335         signalModifiedKey(c->db,dstkey);
02336         notifyKeyspaceEvent(\hyperlink{server_8h_ab8516a5a3ff1b9eb5f1cb303abef0d2f}{NOTIFY\_ZSET},
02337             (op == \hyperlink{server_8h_af00a414b6d78bff8b325eb9cf82c3edb}{SET\_OP\_UNION}) ? \textcolor{stringliteral}{"zunionstore"} : \textcolor{stringliteral}{"zinterstore"},
02338             dstkey,c->db->id);
02339         server.dirty++;
02340     \} \textcolor{keywordflow}{else} \{
02341         decrRefCount(dstobj);
02342         addReply(c,shared.czero);
02343         \textcolor{keywordflow}{if} (touched) \{
02344             signalModifiedKey(c->db,dstkey);
02345             notifyKeyspaceEvent(\hyperlink{server_8h_a9fa53dd1068e62365f3964ad3479eec2}{NOTIFY\_GENERIC},\textcolor{stringliteral}{"del"},dstkey,c->db->id);
02346             server.dirty++;
02347         \}
02348     \}
02349     zfree(src);
02350 \}
02351 
02352 \textcolor{keywordtype}{void} zunionstoreCommand(\hyperlink{structclient}{client} *c) \{
02353     zunionInterGenericCommand(c,c->argv[1], \hyperlink{server_8h_af00a414b6d78bff8b325eb9cf82c3edb}{SET\_OP\_UNION});
02354 \}
02355 
02356 \textcolor{keywordtype}{void} zinterstoreCommand(\hyperlink{structclient}{client} *c) \{
02357     zunionInterGenericCommand(c,c->argv[1], \hyperlink{server_8h_af089a3b4de4c69fa5d3c7f5ae0d94008}{SET\_OP\_INTER});
02358 \}
02359 
02360 \textcolor{keywordtype}{void} zrangeGenericCommand(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} reverse) \{
02361     robj *key = c->argv[1];
02362     robj *zobj;
02363     \textcolor{keywordtype}{int} withscores = 0;
02364     \textcolor{keywordtype}{long} start;
02365     \textcolor{keywordtype}{long} end;
02366     \textcolor{keywordtype}{int} llen;
02367     \textcolor{keywordtype}{int} rangelen;
02368 
02369     \textcolor{keywordflow}{if} ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) ||
02370         (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})) \textcolor{keywordflow}{return};
02371 
02372     \textcolor{keywordflow}{if} (c->argc == 5 && !strcasecmp(c->argv[4]->ptr,\textcolor{stringliteral}{"withscores"})) \{
02373         withscores = 1;
02374     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->argc >= 5) \{
02375         addReply(c,shared.syntaxerr);
02376         \textcolor{keywordflow}{return};
02377     \}
02378 
02379     \textcolor{keywordflow}{if} ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL
02380          || checkType(c,zobj,\hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET})) \textcolor{keywordflow}{return};
02381 
02382     \textcolor{comment}{/* Sanitize indexes. */}
02383     llen = zsetLength(zobj);
02384     \textcolor{keywordflow}{if} (start < 0) start = llen+start;
02385     \textcolor{keywordflow}{if} (end < 0) end = llen+end;
02386     \textcolor{keywordflow}{if} (start < 0) start = 0;
02387 
02388     \textcolor{comment}{/* Invariant: start >= 0, so this test will be true when end < 0.}
02389 \textcolor{comment}{     * The range is empty when start > end or start >= length. */}
02390     \textcolor{keywordflow}{if} (start > end || start >= llen) \{
02391         addReply(c,shared.emptymultibulk);
02392         \textcolor{keywordflow}{return};
02393     \}
02394     \textcolor{keywordflow}{if} (end >= llen) end = llen-1;
02395     rangelen = (end-start)+1;
02396 
02397     \textcolor{comment}{/* Return the result in form of a multi-bulk reply */}
02398     addReplyMultiBulkLen(c, withscores ? (rangelen*2) : rangelen);
02399 
02400     \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
02401         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl = zobj->ptr;
02402         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr, *sptr;
02403         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr;
02404         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen;
02405         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} vlong;
02406 
02407         \textcolor{keywordflow}{if} (reverse)
02408             eptr = ziplistIndex(zl,-2-(2*start));
02409         \textcolor{keywordflow}{else}
02410             eptr = ziplistIndex(zl,2*start);
02411 
02412         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,zobj,eptr != NULL);
02413         sptr = ziplistNext(zl,eptr);
02414 
02415         \textcolor{keywordflow}{while} (rangelen--) \{
02416             \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,zobj,eptr != NULL && sptr != NULL);
02417             \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
02418             \textcolor{keywordflow}{if} (vstr == NULL)
02419                 addReplyBulkLongLong(c,vlong);
02420             \textcolor{keywordflow}{else}
02421                 addReplyBulkCBuffer(c,vstr,vlen);
02422 
02423             \textcolor{keywordflow}{if} (withscores)
02424                 addReplyDouble(c,zzlGetScore(sptr));
02425 
02426             \textcolor{keywordflow}{if} (reverse)
02427                 zzlPrev(zl,&eptr,&sptr);
02428             \textcolor{keywordflow}{else}
02429                 zzlNext(zl,&eptr,&sptr);
02430         \}
02431 
02432     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
02433         zset *zs = zobj->ptr;
02434         zskiplist *zsl = zs->zsl;
02435         zskiplistNode *ln;
02436         sds ele;
02437 
02438         \textcolor{comment}{/* Check if starting point is trivial, before doing log(N) lookup. */}
02439         \textcolor{keywordflow}{if} (reverse) \{
02440             ln = zsl->tail;
02441             \textcolor{keywordflow}{if} (start > 0)
02442                 ln = zslGetElementByRank(zsl,llen-start);
02443         \} \textcolor{keywordflow}{else} \{
02444             ln = zsl->header->level[0].forward;
02445             \textcolor{keywordflow}{if} (start > 0)
02446                 ln = zslGetElementByRank(zsl,start+1);
02447         \}
02448 
02449         \textcolor{keywordflow}{while}(rangelen--) \{
02450             \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,zobj,ln != NULL);
02451             ele = ln->ele;
02452             addReplyBulkCBuffer(c,ele,sdslen(ele));
02453             \textcolor{keywordflow}{if} (withscores)
02454                 addReplyDouble(c,ln->score);
02455             ln = reverse ? ln->backward : ln->level[0].forward;
02456         \}
02457     \} \textcolor{keywordflow}{else} \{
02458         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted set encoding"});
02459     \}
02460 \}
02461 
02462 \textcolor{keywordtype}{void} zrangeCommand(\hyperlink{structclient}{client} *c) \{
02463     zrangeGenericCommand(c,0);
02464 \}
02465 
02466 \textcolor{keywordtype}{void} zrevrangeCommand(\hyperlink{structclient}{client} *c) \{
02467     zrangeGenericCommand(c,1);
02468 \}
02469 
02470 \textcolor{comment}{/* This command implements ZRANGEBYSCORE, ZREVRANGEBYSCORE. */}
02471 \textcolor{keywordtype}{void} genericZrangebyscoreCommand(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} reverse) \{
02472     zrangespec range;
02473     robj *key = c->argv[1];
02474     robj *zobj;
02475     \textcolor{keywordtype}{long} offset = 0, limit = -1;
02476     \textcolor{keywordtype}{int} withscores = 0;
02477     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} rangelen = 0;
02478     \textcolor{keywordtype}{void} *replylen = NULL;
02479     \textcolor{keywordtype}{int} minidx, maxidx;
02480 
02481     \textcolor{comment}{/* Parse the range arguments. */}
02482     \textcolor{keywordflow}{if} (reverse) \{
02483         \textcolor{comment}{/* Range is given as [max,min] */}
02484         maxidx = 2; minidx = 3;
02485     \} \textcolor{keywordflow}{else} \{
02486         \textcolor{comment}{/* Range is given as [min,max] */}
02487         minidx = 2; maxidx = 3;
02488     \}
02489 
02490     \textcolor{keywordflow}{if} (zslParseRange(c->argv[minidx],c->argv[maxidx],&range) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
02491         addReplyError(c,\textcolor{stringliteral}{"min or max is not a float"});
02492         \textcolor{keywordflow}{return};
02493     \}
02494 
02495     \textcolor{comment}{/* Parse optional extra arguments. Note that ZCOUNT will exactly have}
02496 \textcolor{comment}{     * 4 arguments, so we'll never enter the following code path. */}
02497     \textcolor{keywordflow}{if} (c->argc > 4) \{
02498         \textcolor{keywordtype}{int} remaining = c->argc - 4;
02499         \textcolor{keywordtype}{int} pos = 4;
02500 
02501         \textcolor{keywordflow}{while} (remaining) \{
02502             \textcolor{keywordflow}{if} (remaining >= 1 && !strcasecmp(c->argv[pos]->ptr,\textcolor{stringliteral}{"withscores"})) \{
02503                 pos++; remaining--;
02504                 withscores = 1;
02505             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (remaining >= 3 && !strcasecmp(c->argv[pos]->ptr,\textcolor{stringliteral}{"limit"})) \{
02506                 \textcolor{keywordflow}{if} ((getLongFromObjectOrReply(c, c->argv[pos+1], &offset, NULL)
02507                         != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) ||
02508                     (getLongFromObjectOrReply(c, c->argv[pos+2], &limit, NULL)
02509                         != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}))
02510                 \{
02511                     \textcolor{keywordflow}{return};
02512                 \}
02513                 pos += 3; remaining -= 3;
02514             \} \textcolor{keywordflow}{else} \{
02515                 addReply(c,shared.syntaxerr);
02516                 \textcolor{keywordflow}{return};
02517             \}
02518         \}
02519     \}
02520 
02521     \textcolor{comment}{/* Ok, lookup the key and get the range */}
02522     \textcolor{keywordflow}{if} ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL ||
02523         checkType(c,zobj,\hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET})) \textcolor{keywordflow}{return};
02524 
02525     \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
02526         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl = zobj->ptr;
02527         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr, *sptr;
02528         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr;
02529         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen;
02530         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} vlong;
02531         \textcolor{keywordtype}{double} score;
02532 
02533         \textcolor{comment}{/* If reversed, get the last node in range as starting point. */}
02534         \textcolor{keywordflow}{if} (reverse) \{
02535             eptr = zzlLastInRange(zl,&range);
02536         \} \textcolor{keywordflow}{else} \{
02537             eptr = zzlFirstInRange(zl,&range);
02538         \}
02539 
02540         \textcolor{comment}{/* No "first" element in the specified interval. */}
02541         \textcolor{keywordflow}{if} (eptr == NULL) \{
02542             addReply(c, shared.emptymultibulk);
02543             \textcolor{keywordflow}{return};
02544         \}
02545 
02546         \textcolor{comment}{/* Get score pointer for the first element. */}
02547         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,zobj,eptr != NULL);
02548         sptr = ziplistNext(zl,eptr);
02549 
02550         \textcolor{comment}{/* We don't know in advance how many matching elements there are in the}
02551 \textcolor{comment}{         * list, so we push this object that will represent the multi-bulk}
02552 \textcolor{comment}{         * length in the output buffer, and will "fix" it later */}
02553         replylen = addDeferredMultiBulkLength(c);
02554 
02555         \textcolor{comment}{/* If there is an offset, just traverse the number of elements without}
02556 \textcolor{comment}{         * checking the score because that is done in the next loop. */}
02557         \textcolor{keywordflow}{while} (eptr && offset--) \{
02558             \textcolor{keywordflow}{if} (reverse) \{
02559                 zzlPrev(zl,&eptr,&sptr);
02560             \} \textcolor{keywordflow}{else} \{
02561                 zzlNext(zl,&eptr,&sptr);
02562             \}
02563         \}
02564 
02565         \textcolor{keywordflow}{while} (eptr && limit--) \{
02566             score = zzlGetScore(sptr);
02567 
02568             \textcolor{comment}{/* Abort when the node is no longer in range. */}
02569             \textcolor{keywordflow}{if} (reverse) \{
02570                 \textcolor{keywordflow}{if} (!zslValueGteMin(score,&range)) \textcolor{keywordflow}{break};
02571             \} \textcolor{keywordflow}{else} \{
02572                 \textcolor{keywordflow}{if} (!zslValueLteMax(score,&range)) \textcolor{keywordflow}{break};
02573             \}
02574 
02575             \textcolor{comment}{/* We know the element exists, so ziplistGet should always succeed */}
02576             \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
02577 
02578             rangelen++;
02579             \textcolor{keywordflow}{if} (vstr == NULL) \{
02580                 addReplyBulkLongLong(c,vlong);
02581             \} \textcolor{keywordflow}{else} \{
02582                 addReplyBulkCBuffer(c,vstr,vlen);
02583             \}
02584 
02585             \textcolor{keywordflow}{if} (withscores) \{
02586                 addReplyDouble(c,score);
02587             \}
02588 
02589             \textcolor{comment}{/* Move to next node */}
02590             \textcolor{keywordflow}{if} (reverse) \{
02591                 zzlPrev(zl,&eptr,&sptr);
02592             \} \textcolor{keywordflow}{else} \{
02593                 zzlNext(zl,&eptr,&sptr);
02594             \}
02595         \}
02596     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
02597         zset *zs = zobj->ptr;
02598         zskiplist *zsl = zs->zsl;
02599         zskiplistNode *ln;
02600 
02601         \textcolor{comment}{/* If reversed, get the last node in range as starting point. */}
02602         \textcolor{keywordflow}{if} (reverse) \{
02603             ln = zslLastInRange(zsl,&range);
02604         \} \textcolor{keywordflow}{else} \{
02605             ln = zslFirstInRange(zsl,&range);
02606         \}
02607 
02608         \textcolor{comment}{/* No "first" element in the specified interval. */}
02609         \textcolor{keywordflow}{if} (ln == NULL) \{
02610             addReply(c, shared.emptymultibulk);
02611             \textcolor{keywordflow}{return};
02612         \}
02613 
02614         \textcolor{comment}{/* We don't know in advance how many matching elements there are in the}
02615 \textcolor{comment}{         * list, so we push this object that will represent the multi-bulk}
02616 \textcolor{comment}{         * length in the output buffer, and will "fix" it later */}
02617         replylen = addDeferredMultiBulkLength(c);
02618 
02619         \textcolor{comment}{/* If there is an offset, just traverse the number of elements without}
02620 \textcolor{comment}{         * checking the score because that is done in the next loop. */}
02621         \textcolor{keywordflow}{while} (ln && offset--) \{
02622             \textcolor{keywordflow}{if} (reverse) \{
02623                 ln = ln->backward;
02624             \} \textcolor{keywordflow}{else} \{
02625                 ln = ln->level[0].forward;
02626             \}
02627         \}
02628 
02629         \textcolor{keywordflow}{while} (ln && limit--) \{
02630             \textcolor{comment}{/* Abort when the node is no longer in range. */}
02631             \textcolor{keywordflow}{if} (reverse) \{
02632                 \textcolor{keywordflow}{if} (!zslValueGteMin(ln->score,&range)) \textcolor{keywordflow}{break};
02633             \} \textcolor{keywordflow}{else} \{
02634                 \textcolor{keywordflow}{if} (!zslValueLteMax(ln->score,&range)) \textcolor{keywordflow}{break};
02635             \}
02636 
02637             rangelen++;
02638             addReplyBulkCBuffer(c,ln->ele,sdslen(ln->ele));
02639 
02640             \textcolor{keywordflow}{if} (withscores) \{
02641                 addReplyDouble(c,ln->score);
02642             \}
02643 
02644             \textcolor{comment}{/* Move to next node */}
02645             \textcolor{keywordflow}{if} (reverse) \{
02646                 ln = ln->backward;
02647             \} \textcolor{keywordflow}{else} \{
02648                 ln = ln->level[0].forward;
02649             \}
02650         \}
02651     \} \textcolor{keywordflow}{else} \{
02652         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted set encoding"});
02653     \}
02654 
02655     \textcolor{keywordflow}{if} (withscores) \{
02656         rangelen *= 2;
02657     \}
02658 
02659     setDeferredMultiBulkLength(c, replylen, rangelen);
02660 \}
02661 
02662 \textcolor{keywordtype}{void} zrangebyscoreCommand(\hyperlink{structclient}{client} *c) \{
02663     genericZrangebyscoreCommand(c,0);
02664 \}
02665 
02666 \textcolor{keywordtype}{void} zrevrangebyscoreCommand(\hyperlink{structclient}{client} *c) \{
02667     genericZrangebyscoreCommand(c,1);
02668 \}
02669 
02670 \textcolor{keywordtype}{void} zcountCommand(\hyperlink{structclient}{client} *c) \{
02671     robj *key = c->argv[1];
02672     robj *zobj;
02673     zrangespec range;
02674     \textcolor{keywordtype}{int} count = 0;
02675 
02676     \textcolor{comment}{/* Parse the range arguments */}
02677     \textcolor{keywordflow}{if} (zslParseRange(c->argv[2],c->argv[3],&range) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
02678         addReplyError(c,\textcolor{stringliteral}{"min or max is not a float"});
02679         \textcolor{keywordflow}{return};
02680     \}
02681 
02682     \textcolor{comment}{/* Lookup the sorted set */}
02683     \textcolor{keywordflow}{if} ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||
02684         checkType(c, zobj, \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET})) \textcolor{keywordflow}{return};
02685 
02686     \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
02687         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl = zobj->ptr;
02688         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr, *sptr;
02689         \textcolor{keywordtype}{double} score;
02690 
02691         \textcolor{comment}{/* Use the first element in range as the starting point */}
02692         eptr = zzlFirstInRange(zl,&range);
02693 
02694         \textcolor{comment}{/* No "first" element */}
02695         \textcolor{keywordflow}{if} (eptr == NULL) \{
02696             addReply(c, shared.czero);
02697             \textcolor{keywordflow}{return};
02698         \}
02699 
02700         \textcolor{comment}{/* First element is in range */}
02701         sptr = ziplistNext(zl,eptr);
02702         score = zzlGetScore(sptr);
02703         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,zobj,zslValueLteMax(score,&range));
02704 
02705         \textcolor{comment}{/* Iterate over elements in range */}
02706         \textcolor{keywordflow}{while} (eptr) \{
02707             score = zzlGetScore(sptr);
02708 
02709             \textcolor{comment}{/* Abort when the node is no longer in range. */}
02710             \textcolor{keywordflow}{if} (!zslValueLteMax(score,&range)) \{
02711                 \textcolor{keywordflow}{break};
02712             \} \textcolor{keywordflow}{else} \{
02713                 count++;
02714                 zzlNext(zl,&eptr,&sptr);
02715             \}
02716         \}
02717     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
02718         zset *zs = zobj->ptr;
02719         zskiplist *zsl = zs->zsl;
02720         zskiplistNode *zn;
02721         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} rank;
02722 
02723         \textcolor{comment}{/* Find first element in range */}
02724         zn = zslFirstInRange(zsl, &range);
02725 
02726         \textcolor{comment}{/* Use rank of first element, if any, to determine preliminary count */}
02727         \textcolor{keywordflow}{if} (zn != NULL) \{
02728             rank = zslGetRank(zsl, zn->score, zn->ele);
02729             count = (zsl->length - (rank - 1));
02730 
02731             \textcolor{comment}{/* Find last element in range */}
02732             zn = zslLastInRange(zsl, &range);
02733 
02734             \textcolor{comment}{/* Use rank of last element, if any, to determine the actual count */}
02735             \textcolor{keywordflow}{if} (zn != NULL) \{
02736                 rank = zslGetRank(zsl, zn->score, zn->ele);
02737                 count -= (zsl->length - rank);
02738             \}
02739         \}
02740     \} \textcolor{keywordflow}{else} \{
02741         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted set encoding"});
02742     \}
02743 
02744     addReplyLongLong(c, count);
02745 \}
02746 
02747 \textcolor{keywordtype}{void} zlexcountCommand(\hyperlink{structclient}{client} *c) \{
02748     robj *key = c->argv[1];
02749     robj *zobj;
02750     zlexrangespec range;
02751     \textcolor{keywordtype}{int} count = 0;
02752 
02753     \textcolor{comment}{/* Parse the range arguments */}
02754     \textcolor{keywordflow}{if} (zslParseLexRange(c->argv[2],c->argv[3],&range) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
02755         addReplyError(c,\textcolor{stringliteral}{"min or max not valid string range item"});
02756         \textcolor{keywordflow}{return};
02757     \}
02758 
02759     \textcolor{comment}{/* Lookup the sorted set */}
02760     \textcolor{keywordflow}{if} ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||
02761         checkType(c, zobj, \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}))
02762     \{
02763         zslFreeLexRange(&range);
02764         \textcolor{keywordflow}{return};
02765     \}
02766 
02767     \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
02768         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl = zobj->ptr;
02769         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr, *sptr;
02770 
02771         \textcolor{comment}{/* Use the first element in range as the starting point */}
02772         eptr = zzlFirstInLexRange(zl,&range);
02773 
02774         \textcolor{comment}{/* No "first" element */}
02775         \textcolor{keywordflow}{if} (eptr == NULL) \{
02776             zslFreeLexRange(&range);
02777             addReply(c, shared.czero);
02778             \textcolor{keywordflow}{return};
02779         \}
02780 
02781         \textcolor{comment}{/* First element is in range */}
02782         sptr = ziplistNext(zl,eptr);
02783         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,zobj,zzlLexValueLteMax(eptr,&range));
02784 
02785         \textcolor{comment}{/* Iterate over elements in range */}
02786         \textcolor{keywordflow}{while} (eptr) \{
02787             \textcolor{comment}{/* Abort when the node is no longer in range. */}
02788             \textcolor{keywordflow}{if} (!zzlLexValueLteMax(eptr,&range)) \{
02789                 \textcolor{keywordflow}{break};
02790             \} \textcolor{keywordflow}{else} \{
02791                 count++;
02792                 zzlNext(zl,&eptr,&sptr);
02793             \}
02794         \}
02795     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
02796         zset *zs = zobj->ptr;
02797         zskiplist *zsl = zs->zsl;
02798         zskiplistNode *zn;
02799         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} rank;
02800 
02801         \textcolor{comment}{/* Find first element in range */}
02802         zn = zslFirstInLexRange(zsl, &range);
02803 
02804         \textcolor{comment}{/* Use rank of first element, if any, to determine preliminary count */}
02805         \textcolor{keywordflow}{if} (zn != NULL) \{
02806             rank = zslGetRank(zsl, zn->score, zn->ele);
02807             count = (zsl->length - (rank - 1));
02808 
02809             \textcolor{comment}{/* Find last element in range */}
02810             zn = zslLastInLexRange(zsl, &range);
02811 
02812             \textcolor{comment}{/* Use rank of last element, if any, to determine the actual count */}
02813             \textcolor{keywordflow}{if} (zn != NULL) \{
02814                 rank = zslGetRank(zsl, zn->score, zn->ele);
02815                 count -= (zsl->length - rank);
02816             \}
02817         \}
02818     \} \textcolor{keywordflow}{else} \{
02819         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted set encoding"});
02820     \}
02821 
02822     zslFreeLexRange(&range);
02823     addReplyLongLong(c, count);
02824 \}
02825 
02826 \textcolor{comment}{/* This command implements ZRANGEBYLEX, ZREVRANGEBYLEX. */}
02827 \textcolor{keywordtype}{void} genericZrangebylexCommand(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} reverse) \{
02828     zlexrangespec range;
02829     robj *key = c->argv[1];
02830     robj *zobj;
02831     \textcolor{keywordtype}{long} offset = 0, limit = -1;
02832     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} rangelen = 0;
02833     \textcolor{keywordtype}{void} *replylen = NULL;
02834     \textcolor{keywordtype}{int} minidx, maxidx;
02835 
02836     \textcolor{comment}{/* Parse the range arguments. */}
02837     \textcolor{keywordflow}{if} (reverse) \{
02838         \textcolor{comment}{/* Range is given as [max,min] */}
02839         maxidx = 2; minidx = 3;
02840     \} \textcolor{keywordflow}{else} \{
02841         \textcolor{comment}{/* Range is given as [min,max] */}
02842         minidx = 2; maxidx = 3;
02843     \}
02844 
02845     \textcolor{keywordflow}{if} (zslParseLexRange(c->argv[minidx],c->argv[maxidx],&range) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
02846         addReplyError(c,\textcolor{stringliteral}{"min or max not valid string range item"});
02847         \textcolor{keywordflow}{return};
02848     \}
02849 
02850     \textcolor{comment}{/* Parse optional extra arguments. Note that ZCOUNT will exactly have}
02851 \textcolor{comment}{     * 4 arguments, so we'll never enter the following code path. */}
02852     \textcolor{keywordflow}{if} (c->argc > 4) \{
02853         \textcolor{keywordtype}{int} remaining = c->argc - 4;
02854         \textcolor{keywordtype}{int} pos = 4;
02855 
02856         \textcolor{keywordflow}{while} (remaining) \{
02857             \textcolor{keywordflow}{if} (remaining >= 3 && !strcasecmp(c->argv[pos]->ptr,\textcolor{stringliteral}{"limit"})) \{
02858                 \textcolor{keywordflow}{if} ((getLongFromObjectOrReply(c, c->argv[pos+1], &offset, NULL) != 
      \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) ||
02859                     (getLongFromObjectOrReply(c, c->argv[pos+2], &limit, NULL) != 
      \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})) \textcolor{keywordflow}{return};
02860                 pos += 3; remaining -= 3;
02861             \} \textcolor{keywordflow}{else} \{
02862                 zslFreeLexRange(&range);
02863                 addReply(c,shared.syntaxerr);
02864                 \textcolor{keywordflow}{return};
02865             \}
02866         \}
02867     \}
02868 
02869     \textcolor{comment}{/* Ok, lookup the key and get the range */}
02870     \textcolor{keywordflow}{if} ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL ||
02871         checkType(c,zobj,\hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}))
02872     \{
02873         zslFreeLexRange(&range);
02874         \textcolor{keywordflow}{return};
02875     \}
02876 
02877     \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
02878         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl = zobj->ptr;
02879         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr, *sptr;
02880         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr;
02881         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen;
02882         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} vlong;
02883 
02884         \textcolor{comment}{/* If reversed, get the last node in range as starting point. */}
02885         \textcolor{keywordflow}{if} (reverse) \{
02886             eptr = zzlLastInLexRange(zl,&range);
02887         \} \textcolor{keywordflow}{else} \{
02888             eptr = zzlFirstInLexRange(zl,&range);
02889         \}
02890 
02891         \textcolor{comment}{/* No "first" element in the specified interval. */}
02892         \textcolor{keywordflow}{if} (eptr == NULL) \{
02893             addReply(c, shared.emptymultibulk);
02894             zslFreeLexRange(&range);
02895             \textcolor{keywordflow}{return};
02896         \}
02897 
02898         \textcolor{comment}{/* Get score pointer for the first element. */}
02899         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,zobj,eptr != NULL);
02900         sptr = ziplistNext(zl,eptr);
02901 
02902         \textcolor{comment}{/* We don't know in advance how many matching elements there are in the}
02903 \textcolor{comment}{         * list, so we push this object that will represent the multi-bulk}
02904 \textcolor{comment}{         * length in the output buffer, and will "fix" it later */}
02905         replylen = addDeferredMultiBulkLength(c);
02906 
02907         \textcolor{comment}{/* If there is an offset, just traverse the number of elements without}
02908 \textcolor{comment}{         * checking the score because that is done in the next loop. */}
02909         \textcolor{keywordflow}{while} (eptr && offset--) \{
02910             \textcolor{keywordflow}{if} (reverse) \{
02911                 zzlPrev(zl,&eptr,&sptr);
02912             \} \textcolor{keywordflow}{else} \{
02913                 zzlNext(zl,&eptr,&sptr);
02914             \}
02915         \}
02916 
02917         \textcolor{keywordflow}{while} (eptr && limit--) \{
02918             \textcolor{comment}{/* Abort when the node is no longer in range. */}
02919             \textcolor{keywordflow}{if} (reverse) \{
02920                 \textcolor{keywordflow}{if} (!zzlLexValueGteMin(eptr,&range)) \textcolor{keywordflow}{break};
02921             \} \textcolor{keywordflow}{else} \{
02922                 \textcolor{keywordflow}{if} (!zzlLexValueLteMax(eptr,&range)) \textcolor{keywordflow}{break};
02923             \}
02924 
02925             \textcolor{comment}{/* We know the element exists, so ziplistGet should always}
02926 \textcolor{comment}{             * succeed. */}
02927             \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
02928 
02929             rangelen++;
02930             \textcolor{keywordflow}{if} (vstr == NULL) \{
02931                 addReplyBulkLongLong(c,vlong);
02932             \} \textcolor{keywordflow}{else} \{
02933                 addReplyBulkCBuffer(c,vstr,vlen);
02934             \}
02935 
02936             \textcolor{comment}{/* Move to next node */}
02937             \textcolor{keywordflow}{if} (reverse) \{
02938                 zzlPrev(zl,&eptr,&sptr);
02939             \} \textcolor{keywordflow}{else} \{
02940                 zzlNext(zl,&eptr,&sptr);
02941             \}
02942         \}
02943     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (zobj->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
02944         zset *zs = zobj->ptr;
02945         zskiplist *zsl = zs->zsl;
02946         zskiplistNode *ln;
02947 
02948         \textcolor{comment}{/* If reversed, get the last node in range as starting point. */}
02949         \textcolor{keywordflow}{if} (reverse) \{
02950             ln = zslLastInLexRange(zsl,&range);
02951         \} \textcolor{keywordflow}{else} \{
02952             ln = zslFirstInLexRange(zsl,&range);
02953         \}
02954 
02955         \textcolor{comment}{/* No "first" element in the specified interval. */}
02956         \textcolor{keywordflow}{if} (ln == NULL) \{
02957             addReply(c, shared.emptymultibulk);
02958             zslFreeLexRange(&range);
02959             \textcolor{keywordflow}{return};
02960         \}
02961 
02962         \textcolor{comment}{/* We don't know in advance how many matching elements there are in the}
02963 \textcolor{comment}{         * list, so we push this object that will represent the multi-bulk}
02964 \textcolor{comment}{         * length in the output buffer, and will "fix" it later */}
02965         replylen = addDeferredMultiBulkLength(c);
02966 
02967         \textcolor{comment}{/* If there is an offset, just traverse the number of elements without}
02968 \textcolor{comment}{         * checking the score because that is done in the next loop. */}
02969         \textcolor{keywordflow}{while} (ln && offset--) \{
02970             \textcolor{keywordflow}{if} (reverse) \{
02971                 ln = ln->backward;
02972             \} \textcolor{keywordflow}{else} \{
02973                 ln = ln->level[0].forward;
02974             \}
02975         \}
02976 
02977         \textcolor{keywordflow}{while} (ln && limit--) \{
02978             \textcolor{comment}{/* Abort when the node is no longer in range. */}
02979             \textcolor{keywordflow}{if} (reverse) \{
02980                 \textcolor{keywordflow}{if} (!zslLexValueGteMin(ln->ele,&range)) \textcolor{keywordflow}{break};
02981             \} \textcolor{keywordflow}{else} \{
02982                 \textcolor{keywordflow}{if} (!zslLexValueLteMax(ln->ele,&range)) \textcolor{keywordflow}{break};
02983             \}
02984 
02985             rangelen++;
02986             addReplyBulkCBuffer(c,ln->ele,sdslen(ln->ele));
02987 
02988             \textcolor{comment}{/* Move to next node */}
02989             \textcolor{keywordflow}{if} (reverse) \{
02990                 ln = ln->backward;
02991             \} \textcolor{keywordflow}{else} \{
02992                 ln = ln->level[0].forward;
02993             \}
02994         \}
02995     \} \textcolor{keywordflow}{else} \{
02996         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted set encoding"});
02997     \}
02998 
02999     zslFreeLexRange(&range);
03000     setDeferredMultiBulkLength(c, replylen, rangelen);
03001 \}
03002 
03003 \textcolor{keywordtype}{void} zrangebylexCommand(\hyperlink{structclient}{client} *c) \{
03004     genericZrangebylexCommand(c,0);
03005 \}
03006 
03007 \textcolor{keywordtype}{void} zrevrangebylexCommand(\hyperlink{structclient}{client} *c) \{
03008     genericZrangebylexCommand(c,1);
03009 \}
03010 
03011 \textcolor{keywordtype}{void} zcardCommand(\hyperlink{structclient}{client} *c) \{
03012     robj *key = c->argv[1];
03013     robj *zobj;
03014 
03015     \textcolor{keywordflow}{if} ((zobj = lookupKeyReadOrReply(c,key,shared.czero)) == NULL ||
03016         checkType(c,zobj,\hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET})) \textcolor{keywordflow}{return};
03017 
03018     addReplyLongLong(c,zsetLength(zobj));
03019 \}
03020 
03021 \textcolor{keywordtype}{void} zscoreCommand(\hyperlink{structclient}{client} *c) \{
03022     robj *key = c->argv[1];
03023     robj *zobj;
03024     \textcolor{keywordtype}{double} score;
03025 
03026     \textcolor{keywordflow}{if} ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||
03027         checkType(c,zobj,\hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET})) \textcolor{keywordflow}{return};
03028 
03029     \textcolor{keywordflow}{if} (zsetScore(zobj,c->argv[2]->ptr,&score) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
03030         addReply(c,shared.nullbulk);
03031     \} \textcolor{keywordflow}{else} \{
03032         addReplyDouble(c,score);
03033     \}
03034 \}
03035 
03036 \textcolor{keywordtype}{void} zrankGenericCommand(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} reverse) \{
03037     robj *key = c->argv[1];
03038     robj *ele = c->argv[2];
03039     robj *zobj;
03040     \textcolor{keywordtype}{long} rank;
03041 
03042     \textcolor{keywordflow}{if} ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||
03043         checkType(c,zobj,\hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET})) \textcolor{keywordflow}{return};
03044 
03045     \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,ele,\hyperlink{server_8h_afcfb5bd97af52d1dbce331745cae030c}{sdsEncodedObject}(ele));
03046     rank = zsetRank(zobj,ele->ptr,reverse);
03047     \textcolor{keywordflow}{if} (rank >= 0) \{
03048         addReplyLongLong(c,rank);
03049     \} \textcolor{keywordflow}{else} \{
03050         addReply(c,shared.nullbulk);
03051     \}
03052 \}
03053 
03054 \textcolor{keywordtype}{void} zrankCommand(\hyperlink{structclient}{client} *c) \{
03055     zrankGenericCommand(c, 0);
03056 \}
03057 
03058 \textcolor{keywordtype}{void} zrevrankCommand(\hyperlink{structclient}{client} *c) \{
03059     zrankGenericCommand(c, 1);
03060 \}
03061 
03062 \textcolor{keywordtype}{void} zscanCommand(\hyperlink{structclient}{client} *c) \{
03063     robj *o;
03064     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} cursor;
03065 
03066     \textcolor{keywordflow}{if} (parseScanCursorOrReply(c,c->argv[2],&cursor) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \textcolor{keywordflow}{return};
03067     \textcolor{keywordflow}{if} ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
03068         checkType(c,o,\hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET})) \textcolor{keywordflow}{return};
03069     scanGenericCommand(c,o,cursor);
03070 \}
\end{DoxyCode}
