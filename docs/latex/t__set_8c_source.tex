\hypertarget{t__set_8c_source}{}\section{t\+\_\+set.\+c}
\label{t__set_8c_source}\index{src/t\+\_\+set.\+c@{src/t\+\_\+set.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>}
00003 \textcolor{comment}{ * All rights reserved.}
00004 \textcolor{comment}{ *}
00005 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00006 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00007 \textcolor{comment}{ *}
00008 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00009 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00010 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00011 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00012 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00013 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00014 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00015 \textcolor{comment}{ *     specific prior written permission.}
00016 \textcolor{comment}{ *}
00017 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00018 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00019 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00020 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00021 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00022 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00023 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00024 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00025 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00026 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00027 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00028 \textcolor{comment}{ */}
00029 
00030 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{server_8h}{"server.h"}
00031 
00032 \textcolor{comment}{/*-----------------------------------------------------------------------------}
00033 \textcolor{comment}{ * Set Commands}
00034 \textcolor{comment}{ *----------------------------------------------------------------------------*/}
00035 
00036 \textcolor{keywordtype}{void} sunionDiffGenericCommand(\hyperlink{structclient}{client} *c, robj **setkeys, \textcolor{keywordtype}{int} setnum,
00037                               robj *dstkey, \textcolor{keywordtype}{int} op);
00038 
00039 \textcolor{comment}{/* Factory method to return a set that *can* hold "value". When the object has}
00040 \textcolor{comment}{ * an integer-encodable value, an intset will be returned. Otherwise a regular}
00041 \textcolor{comment}{ * hash table. */}
00042 robj *setTypeCreate(sds value) \{
00043     \textcolor{keywordflow}{if} (isSdsRepresentableAsLongLong(value,NULL) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
00044         \textcolor{keywordflow}{return} createIntsetObject();
00045     \textcolor{keywordflow}{return} createSetObject();
00046 \}
00047 
00048 \textcolor{comment}{/* Add the specified value into a set.}
00049 \textcolor{comment}{ *}
00050 \textcolor{comment}{ * If the value was already member of the set, nothing is done and 0 is}
00051 \textcolor{comment}{ * returned, otherwise the new element is added and 1 is returned. */}
00052 \textcolor{keywordtype}{int} setTypeAdd(robj *subject, sds value) \{
00053     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} llval;
00054     \textcolor{keywordflow}{if} (subject->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00055         dict *ht = subject->ptr;
00056         dictEntry *de = dictAddRaw(ht,value,NULL);
00057         \textcolor{keywordflow}{if} (de) \{
00058             \hyperlink{dict_8h_a827e5dcfd37bba408fa8bdb111b0594e}{dictSetKey}(ht,de,sdsdup(value));
00059             \hyperlink{dict_8h_a95cae6581aca3a7a4c5e226e565294c9}{dictSetVal}(ht,de,NULL);
00060             \textcolor{keywordflow}{return} 1;
00061         \}
00062     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (subject->encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
00063         \textcolor{keywordflow}{if} (isSdsRepresentableAsLongLong(value,&llval) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
00064             uint8\_t success = 0;
00065             subject->ptr = intsetAdd(subject->ptr,llval,&success);
00066             \textcolor{keywordflow}{if} (success) \{
00067                 \textcolor{comment}{/* Convert to regular set when the intset contains}
00068 \textcolor{comment}{                 * too many entries. */}
00069                 \textcolor{keywordflow}{if} (intsetLen(subject->ptr) > server.set\_max\_intset\_entries)
00070                     setTypeConvert(subject,\hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT});
00071                 \textcolor{keywordflow}{return} 1;
00072             \}
00073         \} \textcolor{keywordflow}{else} \{
00074             \textcolor{comment}{/* Failed to get integer from object, convert to regular set. */}
00075             setTypeConvert(subject,\hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT});
00076 
00077             \textcolor{comment}{/* The set *was* an intset and this value is not integer}
00078 \textcolor{comment}{             * encodable, so dictAdd should always work. */}
00079             \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(dictAdd(subject->ptr,sdsdup(value),NULL) == 
      \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK});
00080             \textcolor{keywordflow}{return} 1;
00081         \}
00082     \} \textcolor{keywordflow}{else} \{
00083         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown set encoding"});
00084     \}
00085     \textcolor{keywordflow}{return} 0;
00086 \}
00087 
00088 \textcolor{keywordtype}{int} setTypeRemove(robj *setobj, sds value) \{
00089     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} llval;
00090     \textcolor{keywordflow}{if} (setobj->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00091         \textcolor{keywordflow}{if} (dictDelete(setobj->ptr,value) == \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK}) \{
00092             \textcolor{keywordflow}{if} (htNeedsResize(setobj->ptr)) dictResize(setobj->ptr);
00093             \textcolor{keywordflow}{return} 1;
00094         \}
00095     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (setobj->encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
00096         \textcolor{keywordflow}{if} (isSdsRepresentableAsLongLong(value,&llval) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
00097             \textcolor{keywordtype}{int} success;
00098             setobj->ptr = intsetRemove(setobj->ptr,llval,&success);
00099             \textcolor{keywordflow}{if} (success) \textcolor{keywordflow}{return} 1;
00100         \}
00101     \} \textcolor{keywordflow}{else} \{
00102         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown set encoding"});
00103     \}
00104     \textcolor{keywordflow}{return} 0;
00105 \}
00106 
00107 \textcolor{keywordtype}{int} setTypeIsMember(robj *subject, sds value) \{
00108     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} llval;
00109     \textcolor{keywordflow}{if} (subject->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00110         \textcolor{keywordflow}{return} dictFind((dict*)subject->ptr,value) != NULL;
00111     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (subject->encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
00112         \textcolor{keywordflow}{if} (isSdsRepresentableAsLongLong(value,&llval) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
00113             \textcolor{keywordflow}{return} intsetFind((intset*)subject->ptr,llval);
00114         \}
00115     \} \textcolor{keywordflow}{else} \{
00116         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown set encoding"});
00117     \}
00118     \textcolor{keywordflow}{return} 0;
00119 \}
00120 
00121 setTypeIterator *setTypeInitIterator(robj *subject) \{
00122     setTypeIterator *si = zmalloc(\textcolor{keyword}{sizeof}(setTypeIterator));
00123     si->subject = subject;
00124     si->encoding = subject->encoding;
00125     \textcolor{keywordflow}{if} (si->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00126         si->di = dictGetIterator(subject->ptr);
00127     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (si->encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
00128         si->ii = 0;
00129     \} \textcolor{keywordflow}{else} \{
00130         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown set encoding"});
00131     \}
00132     \textcolor{keywordflow}{return} si;
00133 \}
00134 
00135 \textcolor{keywordtype}{void} setTypeReleaseIterator(setTypeIterator *si) \{
00136     \textcolor{keywordflow}{if} (si->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT})
00137         dictReleaseIterator(si->di);
00138     zfree(si);
00139 \}
00140 
00141 \textcolor{comment}{/* Move to the next entry in the set. Returns the object at the current}
00142 \textcolor{comment}{ * position.}
00143 \textcolor{comment}{ *}
00144 \textcolor{comment}{ * Since set elements can be internally be stored as SDS strings or}
00145 \textcolor{comment}{ * simple arrays of integers, setTypeNext returns the encoding of the}
00146 \textcolor{comment}{ * set object you are iterating, and will populate the appropriate pointer}
00147 \textcolor{comment}{ * (sdsele) or (llele) accordingly.}
00148 \textcolor{comment}{ *}
00149 \textcolor{comment}{ * Note that both the sdsele and llele pointers should be passed and cannot}
00150 \textcolor{comment}{ * be NULL since the function will try to defensively populate the non}
00151 \textcolor{comment}{ * used field with values which are easy to trap if misused.}
00152 \textcolor{comment}{ *}
00153 \textcolor{comment}{ * When there are no longer elements -1 is returned. */}
00154 \textcolor{keywordtype}{int} setTypeNext(setTypeIterator *si, sds *sdsele, int64\_t *llele) \{
00155     \textcolor{keywordflow}{if} (si->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00156         dictEntry *de = dictNext(si->di);
00157         \textcolor{keywordflow}{if} (de == NULL) \textcolor{keywordflow}{return} -1;
00158         *sdsele = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
00159         *llele = -123456789; \textcolor{comment}{/* Not needed. Defensive. */}
00160     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (si->encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
00161         \textcolor{keywordflow}{if} (!intsetGet(si->subject->ptr,si->ii++,llele))
00162             \textcolor{keywordflow}{return} -1;
00163         *sdsele = NULL; \textcolor{comment}{/* Not needed. Defensive. */}
00164     \} \textcolor{keywordflow}{else} \{
00165         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Wrong set encoding in setTypeNext"});
00166     \}
00167     \textcolor{keywordflow}{return} si->encoding;
00168 \}
00169 
00170 \textcolor{comment}{/* The not copy on write friendly version but easy to use version}
00171 \textcolor{comment}{ * of setTypeNext() is setTypeNextObject(), returning new SDS}
00172 \textcolor{comment}{ * strings. So if you don't retain a pointer to this object you should call}
00173 \textcolor{comment}{ * sdsfree() against it.}
00174 \textcolor{comment}{ *}
00175 \textcolor{comment}{ * This function is the way to go for write operations where COW is not}
00176 \textcolor{comment}{ * an issue. */}
00177 sds setTypeNextObject(setTypeIterator *si) \{
00178     int64\_t intele;
00179     sds sdsele;
00180     \textcolor{keywordtype}{int} encoding;
00181 
00182     encoding = setTypeNext(si,&sdsele,&intele);
00183     \textcolor{keywordflow}{switch}(encoding) \{
00184         \textcolor{keywordflow}{case} -1:    \textcolor{keywordflow}{return} NULL;
00185         \textcolor{keywordflow}{case} \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}:
00186             \textcolor{keywordflow}{return} sdsfromlonglong(intele);
00187         \textcolor{keywordflow}{case} \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}:
00188             \textcolor{keywordflow}{return} sdsdup(sdsele);
00189         \textcolor{keywordflow}{default}:
00190             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unsupported encoding"});
00191     \}
00192     \textcolor{keywordflow}{return} NULL; \textcolor{comment}{/* just to suppress warnings */}
00193 \}
00194 
00195 \textcolor{comment}{/* Return random element from a non empty set.}
00196 \textcolor{comment}{ * The returned element can be a int64\_t value if the set is encoded}
00197 \textcolor{comment}{ * as an "intset" blob of integers, or an SDS string if the set}
00198 \textcolor{comment}{ * is a regular set.}
00199 \textcolor{comment}{ *}
00200 \textcolor{comment}{ * The caller provides both pointers to be populated with the right}
00201 \textcolor{comment}{ * object. The return value of the function is the object->encoding}
00202 \textcolor{comment}{ * field of the object and is used by the caller to check if the}
00203 \textcolor{comment}{ * int64\_t pointer or the redis object pointer was populated.}
00204 \textcolor{comment}{ *}
00205 \textcolor{comment}{ * Note that both the sdsele and llele pointers should be passed and cannot}
00206 \textcolor{comment}{ * be NULL since the function will try to defensively populate the non}
00207 \textcolor{comment}{ * used field with values which are easy to trap if misused. */}
00208 \textcolor{keywordtype}{int} setTypeRandomElement(robj *setobj, sds *sdsele, int64\_t *llele) \{
00209     \textcolor{keywordflow}{if} (setobj->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00210         dictEntry *de = dictGetRandomKey(setobj->ptr);
00211         *sdsele = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
00212         *llele = -123456789; \textcolor{comment}{/* Not needed. Defensive. */}
00213     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (setobj->encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
00214         *llele = intsetRandom(setobj->ptr);
00215         *sdsele = NULL; \textcolor{comment}{/* Not needed. Defensive. */}
00216     \} \textcolor{keywordflow}{else} \{
00217         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown set encoding"});
00218     \}
00219     \textcolor{keywordflow}{return} setobj->encoding;
00220 \}
00221 
00222 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} setTypeSize(\textcolor{keyword}{const} robj *subject) \{
00223     \textcolor{keywordflow}{if} (subject->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00224         \textcolor{keywordflow}{return} \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}((\textcolor{keyword}{const} dict*)subject->ptr);
00225     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (subject->encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
00226         \textcolor{keywordflow}{return} intsetLen((\textcolor{keyword}{const} intset*)subject->ptr);
00227     \} \textcolor{keywordflow}{else} \{
00228         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown set encoding"});
00229     \}
00230 \}
00231 
00232 \textcolor{comment}{/* Convert the set to specified encoding. The resulting dict (when converting}
00233 \textcolor{comment}{ * to a hash table) is presized to hold the number of elements in the original}
00234 \textcolor{comment}{ * set. */}
00235 \textcolor{keywordtype}{void} setTypeConvert(robj *setobj, \textcolor{keywordtype}{int} enc) \{
00236     setTypeIterator *si;
00237     \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(NULL,setobj,setobj->type == 
      \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET} &&
00238                              setobj->encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET});
00239 
00240     \textcolor{keywordflow}{if} (enc == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00241         int64\_t intele;
00242         dict *d = dictCreate(&setDictType,NULL);
00243         sds element;
00244 
00245         \textcolor{comment}{/* Presize the dict to avoid rehashing */}
00246         dictExpand(d,intsetLen(setobj->ptr));
00247 
00248         \textcolor{comment}{/* To add the elements we extract integers and create redis objects */}
00249         si = setTypeInitIterator(setobj);
00250         \textcolor{keywordflow}{while} (setTypeNext(si,&element,&intele) != -1) \{
00251             element = sdsfromlonglong(intele);
00252             \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(dictAdd(d,element,NULL) == \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK});
00253         \}
00254         setTypeReleaseIterator(si);
00255 
00256         setobj->encoding = \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT};
00257         zfree(setobj->ptr);
00258         setobj->ptr = d;
00259     \} \textcolor{keywordflow}{else} \{
00260         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unsupported set conversion"});
00261     \}
00262 \}
00263 
00264 \textcolor{keywordtype}{void} saddCommand(\hyperlink{structclient}{client} *c) \{
00265     robj *set;
00266     \textcolor{keywordtype}{int} j, added = 0;
00267 
00268     set = lookupKeyWrite(c->db,c->argv[1]);
00269     \textcolor{keywordflow}{if} (set == NULL) \{
00270         set = setTypeCreate(c->argv[2]->ptr);
00271         dbAdd(c->db,c->argv[1],set);
00272     \} \textcolor{keywordflow}{else} \{
00273         \textcolor{keywordflow}{if} (set->type != \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET}) \{
00274             addReply(c,shared.wrongtypeerr);
00275             \textcolor{keywordflow}{return};
00276         \}
00277     \}
00278 
00279     \textcolor{keywordflow}{for} (j = 2; j < c->argc; j++) \{
00280         \textcolor{keywordflow}{if} (setTypeAdd(set,c->argv[j]->ptr)) added++;
00281     \}
00282     \textcolor{keywordflow}{if} (added) \{
00283         signalModifiedKey(c->db,c->argv[1]);
00284         notifyKeyspaceEvent(\hyperlink{server_8h_a625aec945b2152a46979b1b21f2af274}{NOTIFY\_SET},\textcolor{stringliteral}{"sadd"},c->argv[1],c->db->id);
00285     \}
00286     server.dirty += added;
00287     addReplyLongLong(c,added);
00288 \}
00289 
00290 \textcolor{keywordtype}{void} sremCommand(\hyperlink{structclient}{client} *c) \{
00291     robj *set;
00292     \textcolor{keywordtype}{int} j, deleted = 0, keyremoved = 0;
00293 
00294     \textcolor{keywordflow}{if} ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
00295         checkType(c,set,\hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET})) \textcolor{keywordflow}{return};
00296 
00297     \textcolor{keywordflow}{for} (j = 2; j < c->argc; j++) \{
00298         \textcolor{keywordflow}{if} (setTypeRemove(set,c->argv[j]->ptr)) \{
00299             deleted++;
00300             \textcolor{keywordflow}{if} (setTypeSize(set) == 0) \{
00301                 dbDelete(c->db,c->argv[1]);
00302                 keyremoved = 1;
00303                 \textcolor{keywordflow}{break};
00304             \}
00305         \}
00306     \}
00307     \textcolor{keywordflow}{if} (deleted) \{
00308         signalModifiedKey(c->db,c->argv[1]);
00309         notifyKeyspaceEvent(\hyperlink{server_8h_a625aec945b2152a46979b1b21f2af274}{NOTIFY\_SET},\textcolor{stringliteral}{"srem"},c->argv[1],c->db->id);
00310         \textcolor{keywordflow}{if} (keyremoved)
00311             notifyKeyspaceEvent(\hyperlink{server_8h_a9fa53dd1068e62365f3964ad3479eec2}{NOTIFY\_GENERIC},\textcolor{stringliteral}{"del"},c->argv[1],
00312                                 c->db->id);
00313         server.dirty += deleted;
00314     \}
00315     addReplyLongLong(c,deleted);
00316 \}
00317 
00318 \textcolor{keywordtype}{void} smoveCommand(\hyperlink{structclient}{client} *c) \{
00319     robj *srcset, *dstset, *ele;
00320     srcset = lookupKeyWrite(c->db,c->argv[1]);
00321     dstset = lookupKeyWrite(c->db,c->argv[2]);
00322     ele = c->argv[3];
00323 
00324     \textcolor{comment}{/* If the source key does not exist return 0 */}
00325     \textcolor{keywordflow}{if} (srcset == NULL) \{
00326         addReply(c,shared.czero);
00327         \textcolor{keywordflow}{return};
00328     \}
00329 
00330     \textcolor{comment}{/* If the source key has the wrong type, or the destination key}
00331 \textcolor{comment}{     * is set and has the wrong type, return with an error. */}
00332     \textcolor{keywordflow}{if} (checkType(c,srcset,\hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET}) ||
00333         (dstset && checkType(c,dstset,\hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET}))) \textcolor{keywordflow}{return};
00334 
00335     \textcolor{comment}{/* If srcset and dstset are equal, SMOVE is a no-op */}
00336     \textcolor{keywordflow}{if} (srcset == dstset) \{
00337         addReply(c,setTypeIsMember(srcset,ele->ptr) ?
00338             shared.cone : shared.czero);
00339         \textcolor{keywordflow}{return};
00340     \}
00341 
00342     \textcolor{comment}{/* If the element cannot be removed from the src set, return 0. */}
00343     \textcolor{keywordflow}{if} (!setTypeRemove(srcset,ele->ptr)) \{
00344         addReply(c,shared.czero);
00345         \textcolor{keywordflow}{return};
00346     \}
00347     notifyKeyspaceEvent(\hyperlink{server_8h_a625aec945b2152a46979b1b21f2af274}{NOTIFY\_SET},\textcolor{stringliteral}{"srem"},c->argv[1],c->db->id);
00348 
00349     \textcolor{comment}{/* Remove the src set from the database when empty */}
00350     \textcolor{keywordflow}{if} (setTypeSize(srcset) == 0) \{
00351         dbDelete(c->db,c->argv[1]);
00352         notifyKeyspaceEvent(\hyperlink{server_8h_a9fa53dd1068e62365f3964ad3479eec2}{NOTIFY\_GENERIC},\textcolor{stringliteral}{"del"},c->argv[1],c->db->id);
00353     \}
00354 
00355     \textcolor{comment}{/* Create the destination set when it doesn't exist */}
00356     \textcolor{keywordflow}{if} (!dstset) \{
00357         dstset = setTypeCreate(ele->ptr);
00358         dbAdd(c->db,c->argv[2],dstset);
00359     \}
00360 
00361     signalModifiedKey(c->db,c->argv[1]);
00362     signalModifiedKey(c->db,c->argv[2]);
00363     server.dirty++;
00364 
00365     \textcolor{comment}{/* An extra key has changed when ele was successfully added to dstset */}
00366     \textcolor{keywordflow}{if} (setTypeAdd(dstset,ele->ptr)) \{
00367         server.dirty++;
00368         notifyKeyspaceEvent(\hyperlink{server_8h_a625aec945b2152a46979b1b21f2af274}{NOTIFY\_SET},\textcolor{stringliteral}{"sadd"},c->argv[2],c->db->id);
00369     \}
00370     addReply(c,shared.cone);
00371 \}
00372 
00373 \textcolor{keywordtype}{void} sismemberCommand(\hyperlink{structclient}{client} *c) \{
00374     robj *set;
00375 
00376     \textcolor{keywordflow}{if} ((set = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
00377         checkType(c,set,\hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET})) \textcolor{keywordflow}{return};
00378 
00379     \textcolor{keywordflow}{if} (setTypeIsMember(set,c->argv[2]->ptr))
00380         addReply(c,shared.cone);
00381     \textcolor{keywordflow}{else}
00382         addReply(c,shared.czero);
00383 \}
00384 
00385 \textcolor{keywordtype}{void} scardCommand(\hyperlink{structclient}{client} *c) \{
00386     robj *o;
00387 
00388     \textcolor{keywordflow}{if} ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
00389         checkType(c,o,\hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET})) \textcolor{keywordflow}{return};
00390 
00391     addReplyLongLong(c,setTypeSize(o));
00392 \}
00393 
00394 \textcolor{comment}{/* Handle the "SPOP key <count>" variant. The normal version of the}
00395 \textcolor{comment}{ * command is handled by the spopCommand() function itself. */}
00396 
00397 \textcolor{comment}{/* How many times bigger should be the set compared to the remaining size}
00398 \textcolor{comment}{ * for us to use the "create new set" strategy? Read later in the}
00399 \textcolor{comment}{ * implementation for more info. */}
00400 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SPOP\_MOVE\_STRATEGY\_MUL} 5
00401 
00402 \textcolor{keywordtype}{void} spopWithCountCommand(\hyperlink{structclient}{client} *c) \{
00403     \textcolor{keywordtype}{long} l;
00404     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} count, size;
00405     robj *set;
00406 
00407     \textcolor{comment}{/* Get the count argument */}
00408     \textcolor{keywordflow}{if} (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \textcolor{keywordflow}{return};
00409     \textcolor{keywordflow}{if} (l >= 0) \{
00410         count = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}) l;
00411     \} \textcolor{keywordflow}{else} \{
00412         addReply(c,shared.outofrangeerr);
00413         \textcolor{keywordflow}{return};
00414     \}
00415 
00416     \textcolor{comment}{/* Make sure a key with the name inputted exists, and that it's type is}
00417 \textcolor{comment}{     * indeed a set. Otherwise, return nil */}
00418     \textcolor{keywordflow}{if} ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk))
00419         == NULL || checkType(c,set,\hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET})) \textcolor{keywordflow}{return};
00420 
00421     \textcolor{comment}{/* If count is zero, serve an empty multibulk ASAP to avoid special}
00422 \textcolor{comment}{     * cases later. */}
00423     \textcolor{keywordflow}{if} (count == 0) \{
00424         addReply(c,shared.emptymultibulk);
00425         \textcolor{keywordflow}{return};
00426     \}
00427 
00428     size = setTypeSize(set);
00429 
00430     \textcolor{comment}{/* Generate an SPOP keyspace notification */}
00431     notifyKeyspaceEvent(\hyperlink{server_8h_a625aec945b2152a46979b1b21f2af274}{NOTIFY\_SET},\textcolor{stringliteral}{"spop"},c->argv[1],c->db->id);
00432     server.dirty += count;
00433 
00434     \textcolor{comment}{/* CASE 1:}
00435 \textcolor{comment}{     * The number of requested elements is greater than or equal to}
00436 \textcolor{comment}{     * the number of elements inside the set: simply return the whole set. */}
00437     \textcolor{keywordflow}{if} (count >= size) \{
00438         \textcolor{comment}{/* We just return the entire set */}
00439         sunionDiffGenericCommand(c,c->argv+1,1,NULL,\hyperlink{server_8h_af00a414b6d78bff8b325eb9cf82c3edb}{SET\_OP\_UNION});
00440 
00441         \textcolor{comment}{/* Delete the set as it is now empty */}
00442         dbDelete(c->db,c->argv[1]);
00443         notifyKeyspaceEvent(\hyperlink{server_8h_a9fa53dd1068e62365f3964ad3479eec2}{NOTIFY\_GENERIC},\textcolor{stringliteral}{"del"},c->argv[1],c->db->id);
00444 
00445         \textcolor{comment}{/* Propagate this command as an DEL operation */}
00446         rewriteClientCommandVector(c,2,shared.del,c->argv[1]);
00447         signalModifiedKey(c->db,c->argv[1]);
00448         server.dirty++;
00449         \textcolor{keywordflow}{return};
00450     \}
00451 
00452     \textcolor{comment}{/* Case 2 and 3 require to replicate SPOP as a set of SREM commands.}
00453 \textcolor{comment}{     * Prepare our replication argument vector. Also send the array length}
00454 \textcolor{comment}{     * which is common to both the code paths. */}
00455     robj *propargv[3];
00456     propargv[0] = createStringObject(\textcolor{stringliteral}{"SREM"},4);
00457     propargv[1] = c->argv[1];
00458     addReplyMultiBulkLen(c,count);
00459 
00460     \textcolor{comment}{/* Common iteration vars. */}
00461     sds sdsele;
00462     robj *objele;
00463     \textcolor{keywordtype}{int} encoding;
00464     int64\_t llele;
00465     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} remaining = size-count; \textcolor{comment}{/* Elements left after SPOP. */}
00466 
00467     \textcolor{comment}{/* If we are here, the number of requested elements is less than the}
00468 \textcolor{comment}{     * number of elements inside the set. Also we are sure that count < size.}
00469 \textcolor{comment}{     * Use two different strategies.}
00470 \textcolor{comment}{     *}
00471 \textcolor{comment}{     * CASE 2: The number of elements to return is small compared to the}
00472 \textcolor{comment}{     * set size. We can just extract random elements and return them to}
00473 \textcolor{comment}{     * the set. */}
00474     \textcolor{keywordflow}{if} (remaining*\hyperlink{t__set_8c_a335afb64760239e89abc51603161dd51}{SPOP\_MOVE\_STRATEGY\_MUL} > count) \{
00475         \textcolor{keywordflow}{while}(count--) \{
00476             \textcolor{comment}{/* Emit and remove. */}
00477             encoding = setTypeRandomElement(set,&sdsele,&llele);
00478             \textcolor{keywordflow}{if} (encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
00479                 addReplyBulkLongLong(c,llele);
00480                 objele = createStringObjectFromLongLong(llele);
00481                 set->ptr = intsetRemove(set->ptr,llele,NULL);
00482             \} \textcolor{keywordflow}{else} \{
00483                 addReplyBulkCBuffer(c,sdsele,sdslen(sdsele));
00484                 objele = createStringObject(sdsele,sdslen(sdsele));
00485                 setTypeRemove(set,sdsele);
00486             \}
00487 
00488             \textcolor{comment}{/* Replicate/AOF this command as an SREM operation */}
00489             propargv[2] = objele;
00490             alsoPropagate(server.sremCommand,c->db->id,propargv,3,
00491                 \hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF}|\hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL});
00492             decrRefCount(objele);
00493         \}
00494     \} \textcolor{keywordflow}{else} \{
00495     \textcolor{comment}{/* CASE 3: The number of elements to return is very big, approaching}
00496 \textcolor{comment}{     * the size of the set itself. After some time extracting random elements}
00497 \textcolor{comment}{     * from such a set becomes computationally expensive, so we use}
00498 \textcolor{comment}{     * a different strategy, we extract random elements that we don't}
00499 \textcolor{comment}{     * want to return (the elements that will remain part of the set),}
00500 \textcolor{comment}{     * creating a new set as we do this (that will be stored as the original}
00501 \textcolor{comment}{     * set). Then we return the elements left in the original set and}
00502 \textcolor{comment}{     * release it. */}
00503         robj *newset = NULL;
00504 
00505         \textcolor{comment}{/* Create a new set with just the remaining elements. */}
00506         \textcolor{keywordflow}{while}(remaining--) \{
00507             encoding = setTypeRandomElement(set,&sdsele,&llele);
00508             \textcolor{keywordflow}{if} (encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
00509                 sdsele = sdsfromlonglong(llele);
00510             \} \textcolor{keywordflow}{else} \{
00511                 sdsele = sdsdup(sdsele);
00512             \}
00513             \textcolor{keywordflow}{if} (!newset) newset = setTypeCreate(sdsele);
00514             setTypeAdd(newset,sdsele);
00515             setTypeRemove(set,sdsele);
00516             sdsfree(sdsele);
00517         \}
00518 
00519         \textcolor{comment}{/* Assign the new set as the key value. */}
00520         incrRefCount(set); \textcolor{comment}{/* Protect the old set value. */}
00521         dbOverwrite(c->db,c->argv[1],newset);
00522 
00523         \textcolor{comment}{/* Tranfer the old set to the client and release it. */}
00524         setTypeIterator *si;
00525         si = setTypeInitIterator(set);
00526         \textcolor{keywordflow}{while}((encoding = setTypeNext(si,&sdsele,&llele)) != -1) \{
00527             \textcolor{keywordflow}{if} (encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
00528                 addReplyBulkLongLong(c,llele);
00529                 objele = createStringObjectFromLongLong(llele);
00530             \} \textcolor{keywordflow}{else} \{
00531                 addReplyBulkCBuffer(c,sdsele,sdslen(sdsele));
00532                 objele = createStringObject(sdsele,sdslen(sdsele));
00533             \}
00534 
00535             \textcolor{comment}{/* Replicate/AOF this command as an SREM operation */}
00536             propargv[2] = objele;
00537             alsoPropagate(server.sremCommand,c->db->id,propargv,3,
00538                 \hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF}|\hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL});
00539             decrRefCount(objele);
00540         \}
00541         setTypeReleaseIterator(si);
00542         decrRefCount(set);
00543     \}
00544 
00545     \textcolor{comment}{/* Don't propagate the command itself even if we incremented the}
00546 \textcolor{comment}{     * dirty counter. We don't want to propagate an SPOP command since}
00547 \textcolor{comment}{     * we propagated the command as a set of SREMs operations using}
00548 \textcolor{comment}{     * the alsoPropagate() API. */}
00549     decrRefCount(propargv[0]);
00550     preventCommandPropagation(c);
00551     signalModifiedKey(c->db,c->argv[1]);
00552     server.dirty++;
00553 \}
00554 
00555 \textcolor{keywordtype}{void} spopCommand(\hyperlink{structclient}{client} *c) \{
00556     robj *set, *ele, *aux;
00557     sds sdsele;
00558     int64\_t llele;
00559     \textcolor{keywordtype}{int} encoding;
00560 
00561     \textcolor{keywordflow}{if} (c->argc == 3) \{
00562         spopWithCountCommand(c);
00563         \textcolor{keywordflow}{return};
00564     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->argc > 3) \{
00565         addReply(c,shared.syntaxerr);
00566         \textcolor{keywordflow}{return};
00567     \}
00568 
00569     \textcolor{comment}{/* Make sure a key with the name inputted exists, and that it's type is}
00570 \textcolor{comment}{     * indeed a set */}
00571     \textcolor{keywordflow}{if} ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
00572         checkType(c,set,\hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET})) \textcolor{keywordflow}{return};
00573 
00574     \textcolor{comment}{/* Get a random element from the set */}
00575     encoding = setTypeRandomElement(set,&sdsele,&llele);
00576 
00577     \textcolor{comment}{/* Remove the element from the set */}
00578     \textcolor{keywordflow}{if} (encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
00579         ele = createStringObjectFromLongLong(llele);
00580         set->ptr = intsetRemove(set->ptr,llele,NULL);
00581     \} \textcolor{keywordflow}{else} \{
00582         ele = createStringObject(sdsele,sdslen(sdsele));
00583         setTypeRemove(set,ele->ptr);
00584     \}
00585 
00586     notifyKeyspaceEvent(\hyperlink{server_8h_a625aec945b2152a46979b1b21f2af274}{NOTIFY\_SET},\textcolor{stringliteral}{"spop"},c->argv[1],c->db->id);
00587 
00588     \textcolor{comment}{/* Replicate/AOF this command as an SREM operation */}
00589     aux = createStringObject(\textcolor{stringliteral}{"SREM"},4);
00590     rewriteClientCommandVector(c,3,aux,c->argv[1],ele);
00591     decrRefCount(aux);
00592 
00593     \textcolor{comment}{/* Add the element to the reply */}
00594     addReplyBulk(c,ele);
00595     decrRefCount(ele);
00596 
00597     \textcolor{comment}{/* Delete the set if it's empty */}
00598     \textcolor{keywordflow}{if} (setTypeSize(set) == 0) \{
00599         dbDelete(c->db,c->argv[1]);
00600         notifyKeyspaceEvent(\hyperlink{server_8h_a9fa53dd1068e62365f3964ad3479eec2}{NOTIFY\_GENERIC},\textcolor{stringliteral}{"del"},c->argv[1],c->db->id);
00601     \}
00602 
00603     \textcolor{comment}{/* Set has been modified */}
00604     signalModifiedKey(c->db,c->argv[1]);
00605     server.dirty++;
00606 \}
00607 
00608 \textcolor{comment}{/* handle the "SRANDMEMBER key <count>" variant. The normal version of the}
00609 \textcolor{comment}{ * command is handled by the srandmemberCommand() function itself. */}
00610 
00611 \textcolor{comment}{/* How many times bigger should be the set compared to the requested size}
00612 \textcolor{comment}{ * for us to don't use the "remove elements" strategy? Read later in the}
00613 \textcolor{comment}{ * implementation for more info. */}
00614 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SRANDMEMBER\_SUB\_STRATEGY\_MUL} 3
00615 
00616 \textcolor{keywordtype}{void} srandmemberWithCountCommand(\hyperlink{structclient}{client} *c) \{
00617     \textcolor{keywordtype}{long} l;
00618     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} count, size;
00619     \textcolor{keywordtype}{int} uniq = 1;
00620     robj *set;
00621     sds ele;
00622     int64\_t llele;
00623     \textcolor{keywordtype}{int} encoding;
00624 
00625     dict *d;
00626 
00627     \textcolor{keywordflow}{if} (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \textcolor{keywordflow}{return};
00628     \textcolor{keywordflow}{if} (l >= 0) \{
00629         count = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}) l;
00630     \} \textcolor{keywordflow}{else} \{
00631         \textcolor{comment}{/* A negative count means: return the same elements multiple times}
00632 \textcolor{comment}{         * (i.e. don't remove the extracted element after every extraction). */}
00633         count = -l;
00634         uniq = 0;
00635     \}
00636 
00637     \textcolor{keywordflow}{if} ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk))
00638         == NULL || checkType(c,set,\hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET})) \textcolor{keywordflow}{return};
00639     size = setTypeSize(set);
00640 
00641     \textcolor{comment}{/* If count is zero, serve it ASAP to avoid special cases later. */}
00642     \textcolor{keywordflow}{if} (count == 0) \{
00643         addReply(c,shared.emptymultibulk);
00644         \textcolor{keywordflow}{return};
00645     \}
00646 
00647     \textcolor{comment}{/* CASE 1: The count was negative, so the extraction method is just:}
00648 \textcolor{comment}{     * "return N random elements" sampling the whole set every time.}
00649 \textcolor{comment}{     * This case is trivial and can be served without auxiliary data}
00650 \textcolor{comment}{     * structures. */}
00651     \textcolor{keywordflow}{if} (!uniq) \{
00652         addReplyMultiBulkLen(c,count);
00653         \textcolor{keywordflow}{while}(count--) \{
00654             encoding = setTypeRandomElement(set,&ele,&llele);
00655             \textcolor{keywordflow}{if} (encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
00656                 addReplyBulkLongLong(c,llele);
00657             \} \textcolor{keywordflow}{else} \{
00658                 addReplyBulkCBuffer(c,ele,sdslen(ele));
00659             \}
00660         \}
00661         \textcolor{keywordflow}{return};
00662     \}
00663 
00664     \textcolor{comment}{/* CASE 2:}
00665 \textcolor{comment}{     * The number of requested elements is greater than the number of}
00666 \textcolor{comment}{     * elements inside the set: simply return the whole set. */}
00667     \textcolor{keywordflow}{if} (count >= size) \{
00668         sunionDiffGenericCommand(c,c->argv+1,1,NULL,\hyperlink{server_8h_af00a414b6d78bff8b325eb9cf82c3edb}{SET\_OP\_UNION});
00669         \textcolor{keywordflow}{return};
00670     \}
00671 
00672     \textcolor{comment}{/* For CASE 3 and CASE 4 we need an auxiliary dictionary. */}
00673     d = dictCreate(&objectKeyPointerValueDictType,NULL);
00674 
00675     \textcolor{comment}{/* CASE 3:}
00676 \textcolor{comment}{     * The number of elements inside the set is not greater than}
00677 \textcolor{comment}{     * SRANDMEMBER\_SUB\_STRATEGY\_MUL times the number of requested elements.}
00678 \textcolor{comment}{     * In this case we create a set from scratch with all the elements, and}
00679 \textcolor{comment}{     * subtract random elements to reach the requested number of elements.}
00680 \textcolor{comment}{     *}
00681 \textcolor{comment}{     * This is done because if the number of requsted elements is just}
00682 \textcolor{comment}{     * a bit less than the number of elements in the set, the natural approach}
00683 \textcolor{comment}{     * used into CASE 3 is highly inefficient. */}
00684     \textcolor{keywordflow}{if} (count*\hyperlink{t__set_8c_a9edf8cf2fd1e44f7347fd8a19ba92257}{SRANDMEMBER\_SUB\_STRATEGY\_MUL} > size) \{
00685         setTypeIterator *si;
00686 
00687         \textcolor{comment}{/* Add all the elements into the temporary dictionary. */}
00688         si = setTypeInitIterator(set);
00689         \textcolor{keywordflow}{while}((encoding = setTypeNext(si,&ele,&llele)) != -1) \{
00690             \textcolor{keywordtype}{int} retval = \hyperlink{dict_8h_a6ce31f31f044b1570d335e8fa0c388c6}{DICT\_ERR};
00691 
00692             \textcolor{keywordflow}{if} (encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
00693                 retval = dictAdd(d,createStringObjectFromLongLong(llele),NULL);
00694             \} \textcolor{keywordflow}{else} \{
00695                 retval = dictAdd(d,createStringObject(ele,sdslen(ele)),NULL);
00696             \}
00697             \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(retval == \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK});
00698         \}
00699         setTypeReleaseIterator(si);
00700         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(d) == size);
00701 
00702         \textcolor{comment}{/* Remove random elements to reach the right count. */}
00703         \textcolor{keywordflow}{while}(size > count) \{
00704             dictEntry *de;
00705 
00706             de = dictGetRandomKey(d);
00707             dictDelete(d,\hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de));
00708             size--;
00709         \}
00710     \}
00711 
00712     \textcolor{comment}{/* CASE 4: We have a big set compared to the requested number of elements.}
00713 \textcolor{comment}{     * In this case we can simply get random elements from the set and add}
00714 \textcolor{comment}{     * to the temporary set, trying to eventually get enough unique elements}
00715 \textcolor{comment}{     * to reach the specified count. */}
00716     \textcolor{keywordflow}{else} \{
00717         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} added = 0;
00718         robj *objele;
00719 
00720         \textcolor{keywordflow}{while}(added < count) \{
00721             encoding = setTypeRandomElement(set,&ele,&llele);
00722             \textcolor{keywordflow}{if} (encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
00723                 objele = createStringObjectFromLongLong(llele);
00724             \} \textcolor{keywordflow}{else} \{
00725                 objele = createStringObject(ele,sdslen(ele));
00726             \}
00727             \textcolor{comment}{/* Try to add the object to the dictionary. If it already exists}
00728 \textcolor{comment}{             * free it, otherwise increment the number of objects we have}
00729 \textcolor{comment}{             * in the result dictionary. */}
00730             \textcolor{keywordflow}{if} (dictAdd(d,objele,NULL) == \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK})
00731                 added++;
00732             \textcolor{keywordflow}{else}
00733                 decrRefCount(objele);
00734         \}
00735     \}
00736 
00737     \textcolor{comment}{/* CASE 3 & 4: send the result to the user. */}
00738     \{
00739         dictIterator *di;
00740         dictEntry *de;
00741 
00742         addReplyMultiBulkLen(c,count);
00743         di = dictGetIterator(d);
00744         \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL)
00745             addReplyBulk(c,\hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de));
00746         dictReleaseIterator(di);
00747         dictRelease(d);
00748     \}
00749 \}
00750 
00751 \textcolor{keywordtype}{void} srandmemberCommand(\hyperlink{structclient}{client} *c) \{
00752     robj *set;
00753     sds ele;
00754     int64\_t llele;
00755     \textcolor{keywordtype}{int} encoding;
00756 
00757     \textcolor{keywordflow}{if} (c->argc == 3) \{
00758         srandmemberWithCountCommand(c);
00759         \textcolor{keywordflow}{return};
00760     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->argc > 3) \{
00761         addReply(c,shared.syntaxerr);
00762         \textcolor{keywordflow}{return};
00763     \}
00764 
00765     \textcolor{keywordflow}{if} ((set = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
00766         checkType(c,set,\hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET})) \textcolor{keywordflow}{return};
00767 
00768     encoding = setTypeRandomElement(set,&ele,&llele);
00769     \textcolor{keywordflow}{if} (encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
00770         addReplyBulkLongLong(c,llele);
00771     \} \textcolor{keywordflow}{else} \{
00772         addReplyBulkCBuffer(c,ele,sdslen(ele));
00773     \}
00774 \}
00775 
00776 \textcolor{keywordtype}{int} qsortCompareSetsByCardinality(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *s1, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *s2) \{
00777     \textcolor{keywordflow}{if} (setTypeSize(*(robj**)s1) > setTypeSize(*(robj**)s2)) \textcolor{keywordflow}{return} 1;
00778     \textcolor{keywordflow}{if} (setTypeSize(*(robj**)s1) < setTypeSize(*(robj**)s2)) \textcolor{keywordflow}{return} -1;
00779     \textcolor{keywordflow}{return} 0;
00780 \}
00781 
00782 \textcolor{comment}{/* This is used by SDIFF and in this case we can receive NULL that should}
00783 \textcolor{comment}{ * be handled as empty sets. */}
00784 \textcolor{keywordtype}{int} qsortCompareSetsByRevCardinality(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *s1, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *s2) \{
00785     robj *o1 = *(robj**)s1, *o2 = *(robj**)s2;
00786     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} first = o1 ? setTypeSize(o1) : 0;
00787     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} second = o2 ? setTypeSize(o2) : 0;
00788 
00789     \textcolor{keywordflow}{if} (first < second) \textcolor{keywordflow}{return} 1;
00790     \textcolor{keywordflow}{if} (first > second) \textcolor{keywordflow}{return} -1;
00791     \textcolor{keywordflow}{return} 0;
00792 \}
00793 
00794 \textcolor{keywordtype}{void} sinterGenericCommand(\hyperlink{structclient}{client} *c, robj **setkeys,
00795                           \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} setnum, robj *dstkey) \{
00796     robj **sets = zmalloc(\textcolor{keyword}{sizeof}(robj*)*setnum);
00797     setTypeIterator *si;
00798     robj *dstset = NULL;
00799     sds elesds;
00800     int64\_t intobj;
00801     \textcolor{keywordtype}{void} *replylen = NULL;
00802     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} j, cardinality = 0;
00803     \textcolor{keywordtype}{int} encoding;
00804 
00805     \textcolor{keywordflow}{for} (j = 0; j < setnum; j++) \{
00806         robj *setobj = dstkey ?
00807             lookupKeyWrite(c->db,setkeys[j]) :
00808             lookupKeyRead(c->db,setkeys[j]);
00809         \textcolor{keywordflow}{if} (!setobj) \{
00810             zfree(sets);
00811             \textcolor{keywordflow}{if} (dstkey) \{
00812                 \textcolor{keywordflow}{if} (dbDelete(c->db,dstkey)) \{
00813                     signalModifiedKey(c->db,dstkey);
00814                     server.dirty++;
00815                 \}
00816                 addReply(c,shared.czero);
00817             \} \textcolor{keywordflow}{else} \{
00818                 addReply(c,shared.emptymultibulk);
00819             \}
00820             \textcolor{keywordflow}{return};
00821         \}
00822         \textcolor{keywordflow}{if} (checkType(c,setobj,\hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET})) \{
00823             zfree(sets);
00824             \textcolor{keywordflow}{return};
00825         \}
00826         sets[j] = setobj;
00827     \}
00828     \textcolor{comment}{/* Sort sets from the smallest to largest, this will improve our}
00829 \textcolor{comment}{     * algorithm's performance */}
00830     qsort(sets,setnum,\textcolor{keyword}{sizeof}(robj*),qsortCompareSetsByCardinality);
00831 
00832     \textcolor{comment}{/* The first thing we should output is the total number of elements...}
00833 \textcolor{comment}{     * since this is a multi-bulk write, but at this stage we don't know}
00834 \textcolor{comment}{     * the intersection set size, so we use a trick, append an empty object}
00835 \textcolor{comment}{     * to the output list and save the pointer to later modify it with the}
00836 \textcolor{comment}{     * right length */}
00837     \textcolor{keywordflow}{if} (!dstkey) \{
00838         replylen = addDeferredMultiBulkLength(c);
00839     \} \textcolor{keywordflow}{else} \{
00840         \textcolor{comment}{/* If we have a target key where to store the resulting set}
00841 \textcolor{comment}{         * create this key with an empty set inside */}
00842         dstset = createIntsetObject();
00843     \}
00844 
00845     \textcolor{comment}{/* Iterate all the elements of the first (smallest) set, and test}
00846 \textcolor{comment}{     * the element against all the other sets, if at least one set does}
00847 \textcolor{comment}{     * not include the element it is discarded */}
00848     si = setTypeInitIterator(sets[0]);
00849     \textcolor{keywordflow}{while}((encoding = setTypeNext(si,&elesds,&intobj)) != -1) \{
00850         \textcolor{keywordflow}{for} (j = 1; j < setnum; j++) \{
00851             \textcolor{keywordflow}{if} (sets[j] == sets[0]) \textcolor{keywordflow}{continue};
00852             \textcolor{keywordflow}{if} (encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
00853                 \textcolor{comment}{/* intset with intset is simple... and fast */}
00854                 \textcolor{keywordflow}{if} (sets[j]->encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET} &&
00855                     !intsetFind((intset*)sets[j]->ptr,intobj))
00856                 \{
00857                     \textcolor{keywordflow}{break};
00858                 \textcolor{comment}{/* in order to compare an integer with an object we}
00859 \textcolor{comment}{                 * have to use the generic function, creating an object}
00860 \textcolor{comment}{                 * for this */}
00861                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (sets[j]->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00862                     elesds = sdsfromlonglong(intobj);
00863                     \textcolor{keywordflow}{if} (!setTypeIsMember(sets[j],elesds)) \{
00864                         sdsfree(elesds);
00865                         \textcolor{keywordflow}{break};
00866                     \}
00867                     sdsfree(elesds);
00868                 \}
00869             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00870                 \textcolor{keywordflow}{if} (!setTypeIsMember(sets[j],elesds)) \{
00871                     \textcolor{keywordflow}{break};
00872                 \}
00873             \}
00874         \}
00875 
00876         \textcolor{comment}{/* Only take action when all sets contain the member */}
00877         \textcolor{keywordflow}{if} (j == setnum) \{
00878             \textcolor{keywordflow}{if} (!dstkey) \{
00879                 \textcolor{keywordflow}{if} (encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT})
00880                     addReplyBulkCBuffer(c,elesds,sdslen(elesds));
00881                 \textcolor{keywordflow}{else}
00882                     addReplyBulkLongLong(c,intobj);
00883                 cardinality++;
00884             \} \textcolor{keywordflow}{else} \{
00885                 \textcolor{keywordflow}{if} (encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
00886                     elesds = sdsfromlonglong(intobj);
00887                     setTypeAdd(dstset,elesds);
00888                     sdsfree(elesds);
00889                 \} \textcolor{keywordflow}{else} \{
00890                     setTypeAdd(dstset,elesds);
00891                 \}
00892             \}
00893         \}
00894     \}
00895     setTypeReleaseIterator(si);
00896 
00897     \textcolor{keywordflow}{if} (dstkey) \{
00898         \textcolor{comment}{/* Store the resulting set into the target, if the intersection}
00899 \textcolor{comment}{         * is not an empty set. */}
00900         \textcolor{keywordtype}{int} deleted = dbDelete(c->db,dstkey);
00901         \textcolor{keywordflow}{if} (setTypeSize(dstset) > 0) \{
00902             dbAdd(c->db,dstkey,dstset);
00903             addReplyLongLong(c,setTypeSize(dstset));
00904             notifyKeyspaceEvent(\hyperlink{server_8h_a625aec945b2152a46979b1b21f2af274}{NOTIFY\_SET},\textcolor{stringliteral}{"sinterstore"},
00905                 dstkey,c->db->id);
00906         \} \textcolor{keywordflow}{else} \{
00907             decrRefCount(dstset);
00908             addReply(c,shared.czero);
00909             \textcolor{keywordflow}{if} (deleted)
00910                 notifyKeyspaceEvent(\hyperlink{server_8h_a9fa53dd1068e62365f3964ad3479eec2}{NOTIFY\_GENERIC},\textcolor{stringliteral}{"del"},
00911                     dstkey,c->db->id);
00912         \}
00913         signalModifiedKey(c->db,dstkey);
00914         server.dirty++;
00915     \} \textcolor{keywordflow}{else} \{
00916         setDeferredMultiBulkLength(c,replylen,cardinality);
00917     \}
00918     zfree(sets);
00919 \}
00920 
00921 \textcolor{keywordtype}{void} sinterCommand(\hyperlink{structclient}{client} *c) \{
00922     sinterGenericCommand(c,c->argv+1,c->argc-1,NULL);
00923 \}
00924 
00925 \textcolor{keywordtype}{void} sinterstoreCommand(\hyperlink{structclient}{client} *c) \{
00926     sinterGenericCommand(c,c->argv+2,c->argc-2,c->argv[1]);
00927 \}
00928 
00929 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SET\_OP\_UNION} 0
00930 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SET\_OP\_DIFF} 1
00931 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SET\_OP\_INTER} 2
00932 
00933 \textcolor{keywordtype}{void} sunionDiffGenericCommand(\hyperlink{structclient}{client} *c, robj **setkeys, \textcolor{keywordtype}{int} setnum,
00934                               robj *dstkey, \textcolor{keywordtype}{int} op) \{
00935     robj **sets = zmalloc(\textcolor{keyword}{sizeof}(robj*)*setnum);
00936     setTypeIterator *si;
00937     robj *dstset = NULL;
00938     sds ele;
00939     \textcolor{keywordtype}{int} j, cardinality = 0;
00940     \textcolor{keywordtype}{int} diff\_algo = 1;
00941 
00942     \textcolor{keywordflow}{for} (j = 0; j < setnum; j++) \{
00943         robj *setobj = dstkey ?
00944             lookupKeyWrite(c->db,setkeys[j]) :
00945             lookupKeyRead(c->db,setkeys[j]);
00946         \textcolor{keywordflow}{if} (!setobj) \{
00947             sets[j] = NULL;
00948             \textcolor{keywordflow}{continue};
00949         \}
00950         \textcolor{keywordflow}{if} (checkType(c,setobj,\hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET})) \{
00951             zfree(sets);
00952             \textcolor{keywordflow}{return};
00953         \}
00954         sets[j] = setobj;
00955     \}
00956 
00957     \textcolor{comment}{/* Select what DIFF algorithm to use.}
00958 \textcolor{comment}{     *}
00959 \textcolor{comment}{     * Algorithm 1 is O(N*M) where N is the size of the element first set}
00960 \textcolor{comment}{     * and M the total number of sets.}
00961 \textcolor{comment}{     *}
00962 \textcolor{comment}{     * Algorithm 2 is O(N) where N is the total number of elements in all}
00963 \textcolor{comment}{     * the sets.}
00964 \textcolor{comment}{     *}
00965 \textcolor{comment}{     * We compute what is the best bet with the current input here. */}
00966     \textcolor{keywordflow}{if} (op == \hyperlink{server_8h_ad22703ffec4b7bf6cd262099917dc6a1}{SET\_OP\_DIFF} && sets[0]) \{
00967         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} algo\_one\_work = 0, algo\_two\_work = 0;
00968 
00969         \textcolor{keywordflow}{for} (j = 0; j < setnum; j++) \{
00970             \textcolor{keywordflow}{if} (sets[j] == NULL) \textcolor{keywordflow}{continue};
00971 
00972             algo\_one\_work += setTypeSize(sets[0]);
00973             algo\_two\_work += setTypeSize(sets[j]);
00974         \}
00975 
00976         \textcolor{comment}{/* Algorithm 1 has better constant times and performs less operations}
00977 \textcolor{comment}{         * if there are elements in common. Give it some advantage. */}
00978         algo\_one\_work /= 2;
00979         diff\_algo = (algo\_one\_work <= algo\_two\_work) ? 1 : 2;
00980 
00981         \textcolor{keywordflow}{if} (diff\_algo == 1 && setnum > 1) \{
00982             \textcolor{comment}{/* With algorithm 1 it is better to order the sets to subtract}
00983 \textcolor{comment}{             * by decreasing size, so that we are more likely to find}
00984 \textcolor{comment}{             * duplicated elements ASAP. */}
00985             qsort(sets+1,setnum-1,\textcolor{keyword}{sizeof}(robj*),
00986                 qsortCompareSetsByRevCardinality);
00987         \}
00988     \}
00989 
00990     \textcolor{comment}{/* We need a temp set object to store our union. If the dstkey}
00991 \textcolor{comment}{     * is not NULL (that is, we are inside an SUNIONSTORE operation) then}
00992 \textcolor{comment}{     * this set object will be the resulting object to set into the target key*/}
00993     dstset = createIntsetObject();
00994 
00995     \textcolor{keywordflow}{if} (op == \hyperlink{server_8h_af00a414b6d78bff8b325eb9cf82c3edb}{SET\_OP\_UNION}) \{
00996         \textcolor{comment}{/* Union is trivial, just add every element of every set to the}
00997 \textcolor{comment}{         * temporary set. */}
00998         \textcolor{keywordflow}{for} (j = 0; j < setnum; j++) \{
00999             \textcolor{keywordflow}{if} (!sets[j]) \textcolor{keywordflow}{continue}; \textcolor{comment}{/* non existing keys are like empty sets */}
01000 
01001             si = setTypeInitIterator(sets[j]);
01002             \textcolor{keywordflow}{while}((ele = setTypeNextObject(si)) != NULL) \{
01003                 \textcolor{keywordflow}{if} (setTypeAdd(dstset,ele)) cardinality++;
01004                 sdsfree(ele);
01005             \}
01006             setTypeReleaseIterator(si);
01007         \}
01008     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op == \hyperlink{server_8h_ad22703ffec4b7bf6cd262099917dc6a1}{SET\_OP\_DIFF} && sets[0] && diff\_algo == 1) \{
01009         \textcolor{comment}{/* DIFF Algorithm 1:}
01010 \textcolor{comment}{         *}
01011 \textcolor{comment}{         * We perform the diff by iterating all the elements of the first set,}
01012 \textcolor{comment}{         * and only adding it to the target set if the element does not exist}
01013 \textcolor{comment}{         * into all the other sets.}
01014 \textcolor{comment}{         *}
01015 \textcolor{comment}{         * This way we perform at max N*M operations, where N is the size of}
01016 \textcolor{comment}{         * the first set, and M the number of sets. */}
01017         si = setTypeInitIterator(sets[0]);
01018         \textcolor{keywordflow}{while}((ele = setTypeNextObject(si)) != NULL) \{
01019             \textcolor{keywordflow}{for} (j = 1; j < setnum; j++) \{
01020                 \textcolor{keywordflow}{if} (!sets[j]) \textcolor{keywordflow}{continue}; \textcolor{comment}{/* no key is an empty set. */}
01021                 \textcolor{keywordflow}{if} (sets[j] == sets[0]) \textcolor{keywordflow}{break}; \textcolor{comment}{/* same set! */}
01022                 \textcolor{keywordflow}{if} (setTypeIsMember(sets[j],ele)) \textcolor{keywordflow}{break};
01023             \}
01024             \textcolor{keywordflow}{if} (j == setnum) \{
01025                 \textcolor{comment}{/* There is no other set with this element. Add it. */}
01026                 setTypeAdd(dstset,ele);
01027                 cardinality++;
01028             \}
01029             sdsfree(ele);
01030         \}
01031         setTypeReleaseIterator(si);
01032     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op == \hyperlink{server_8h_ad22703ffec4b7bf6cd262099917dc6a1}{SET\_OP\_DIFF} && sets[0] && diff\_algo == 2) \{
01033         \textcolor{comment}{/* DIFF Algorithm 2:}
01034 \textcolor{comment}{         *}
01035 \textcolor{comment}{         * Add all the elements of the first set to the auxiliary set.}
01036 \textcolor{comment}{         * Then remove all the elements of all the next sets from it.}
01037 \textcolor{comment}{         *}
01038 \textcolor{comment}{         * This is O(N) where N is the sum of all the elements in every}
01039 \textcolor{comment}{         * set. */}
01040         \textcolor{keywordflow}{for} (j = 0; j < setnum; j++) \{
01041             \textcolor{keywordflow}{if} (!sets[j]) \textcolor{keywordflow}{continue}; \textcolor{comment}{/* non existing keys are like empty sets */}
01042 
01043             si = setTypeInitIterator(sets[j]);
01044             \textcolor{keywordflow}{while}((ele = setTypeNextObject(si)) != NULL) \{
01045                 \textcolor{keywordflow}{if} (j == 0) \{
01046                     \textcolor{keywordflow}{if} (setTypeAdd(dstset,ele)) cardinality++;
01047                 \} \textcolor{keywordflow}{else} \{
01048                     \textcolor{keywordflow}{if} (setTypeRemove(dstset,ele)) cardinality--;
01049                 \}
01050                 sdsfree(ele);
01051             \}
01052             setTypeReleaseIterator(si);
01053 
01054             \textcolor{comment}{/* Exit if result set is empty as any additional removal}
01055 \textcolor{comment}{             * of elements will have no effect. */}
01056             \textcolor{keywordflow}{if} (cardinality == 0) \textcolor{keywordflow}{break};
01057         \}
01058     \}
01059 
01060     \textcolor{comment}{/* Output the content of the resulting set, if not in STORE mode */}
01061     \textcolor{keywordflow}{if} (!dstkey) \{
01062         addReplyMultiBulkLen(c,cardinality);
01063         si = setTypeInitIterator(dstset);
01064         \textcolor{keywordflow}{while}((ele = setTypeNextObject(si)) != NULL) \{
01065             addReplyBulkCBuffer(c,ele,sdslen(ele));
01066             sdsfree(ele);
01067         \}
01068         setTypeReleaseIterator(si);
01069         decrRefCount(dstset);
01070     \} \textcolor{keywordflow}{else} \{
01071         \textcolor{comment}{/* If we have a target key where to store the resulting set}
01072 \textcolor{comment}{         * create this key with the result set inside */}
01073         \textcolor{keywordtype}{int} deleted = dbDelete(c->db,dstkey);
01074         \textcolor{keywordflow}{if} (setTypeSize(dstset) > 0) \{
01075             dbAdd(c->db,dstkey,dstset);
01076             addReplyLongLong(c,setTypeSize(dstset));
01077             notifyKeyspaceEvent(\hyperlink{server_8h_a625aec945b2152a46979b1b21f2af274}{NOTIFY\_SET},
01078                 op == \hyperlink{server_8h_af00a414b6d78bff8b325eb9cf82c3edb}{SET\_OP\_UNION} ? \textcolor{stringliteral}{"sunionstore"} : \textcolor{stringliteral}{"sdiffstore"},
01079                 dstkey,c->db->id);
01080         \} \textcolor{keywordflow}{else} \{
01081             decrRefCount(dstset);
01082             addReply(c,shared.czero);
01083             \textcolor{keywordflow}{if} (deleted)
01084                 notifyKeyspaceEvent(\hyperlink{server_8h_a9fa53dd1068e62365f3964ad3479eec2}{NOTIFY\_GENERIC},\textcolor{stringliteral}{"del"},
01085                     dstkey,c->db->id);
01086         \}
01087         signalModifiedKey(c->db,dstkey);
01088         server.dirty++;
01089     \}
01090     zfree(sets);
01091 \}
01092 
01093 \textcolor{keywordtype}{void} sunionCommand(\hyperlink{structclient}{client} *c) \{
01094     sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,\hyperlink{server_8h_af00a414b6d78bff8b325eb9cf82c3edb}{SET\_OP\_UNION});
01095 \}
01096 
01097 \textcolor{keywordtype}{void} sunionstoreCommand(\hyperlink{structclient}{client} *c) \{
01098     sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],\hyperlink{server_8h_af00a414b6d78bff8b325eb9cf82c3edb}{SET\_OP\_UNION});
01099 \}
01100 
01101 \textcolor{keywordtype}{void} sdiffCommand(\hyperlink{structclient}{client} *c) \{
01102     sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,\hyperlink{server_8h_ad22703ffec4b7bf6cd262099917dc6a1}{SET\_OP\_DIFF});
01103 \}
01104 
01105 \textcolor{keywordtype}{void} sdiffstoreCommand(\hyperlink{structclient}{client} *c) \{
01106     sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],\hyperlink{server_8h_ad22703ffec4b7bf6cd262099917dc6a1}{SET\_OP\_DIFF});
01107 \}
01108 
01109 \textcolor{keywordtype}{void} sscanCommand(\hyperlink{structclient}{client} *c) \{
01110     robj *set;
01111     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} cursor;
01112 
01113     \textcolor{keywordflow}{if} (parseScanCursorOrReply(c,c->argv[2],&cursor) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \textcolor{keywordflow}{return};
01114     \textcolor{keywordflow}{if} ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
01115         checkType(c,set,\hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET})) \textcolor{keywordflow}{return};
01116     scanGenericCommand(c,set,cursor);
01117 \}
\end{DoxyCode}
