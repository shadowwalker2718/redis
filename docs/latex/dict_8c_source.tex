\hypertarget{dict_8c_source}{}\section{dict.\+c}
\label{dict_8c_source}\index{src/dict.\+c@{src/dict.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* Hash Tables Implementation.}
00002 \textcolor{comment}{ *}
00003 \textcolor{comment}{ * This file implements in memory hash tables with insert/del/replace/find/}
00004 \textcolor{comment}{ * get-random-element operations. Hash tables will auto resize if needed}
00005 \textcolor{comment}{ * tables of power of two in size are used, collisions are handled by}
00006 \textcolor{comment}{ * chaining. See the source code for more information... :)}
00007 \textcolor{comment}{ *}
00008 \textcolor{comment}{ * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>}
00009 \textcolor{comment}{ * All rights reserved.}
00010 \textcolor{comment}{ *}
00011 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00012 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00013 \textcolor{comment}{ *}
00014 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00015 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00016 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00017 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00018 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00019 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00020 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00021 \textcolor{comment}{ *     specific prior written permission.}
00022 \textcolor{comment}{ *}
00023 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00024 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00025 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00026 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00027 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00028 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00029 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00030 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00031 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00032 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00033 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00034 \textcolor{comment}{ */}
00035 
00036 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{fmacros_8h}{"fmacros.h"}
00037 
00038 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdio}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00039 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdlib}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00040 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdint}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00041 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{string}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00042 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdarg}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00043 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{limits}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00044 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{time}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00045 
00046 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{dict_8h}{"dict.h"}
00047 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{zmalloc_8h}{"zmalloc.h"}
00048 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifndef} \textcolor{preprocessor}{DICT\_BENCHMARK\_MAIN}
00049 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{redisassert_8h}{"redisassert.h"}
00050 \textcolor{preprocessor}{#}\textcolor{preprocessor}{else}
00051 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{assert}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00052 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
00053 
00054 \textcolor{comment}{/* Using dictEnableResize() / dictDisableResize() we make possible to}
00055 \textcolor{comment}{ * enable/disable resizing of the hash table as needed. This is very important}
00056 \textcolor{comment}{ * for Redis, as we use copy-on-write and don't want to move too much memory}
00057 \textcolor{comment}{ * around when there is a child performing saving operations.}
00058 \textcolor{comment}{ *}
00059 \textcolor{comment}{ * Note that even when dict\_can\_resize is set to 0, not all resizes are}
00060 \textcolor{comment}{ * prevented: a hash table is still allowed to grow if the ratio between}
00061 \textcolor{comment}{ * the number of elements and the buckets > dict\_force\_resize\_ratio. */}
00062 \textcolor{keyword}{static} \textcolor{keywordtype}{int} dict\_can\_resize = 1;
00063 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dict\_force\_resize\_ratio = 5;
00064 
00065 \textcolor{comment}{/* -------------------------- private prototypes ---------------------------- */}
00066 
00067 \textcolor{keyword}{static} \textcolor{keywordtype}{int} \_dictExpandIfNeeded(dict *ht);
00068 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \_dictNextPower(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} size);
00069 \textcolor{keyword}{static} \textcolor{keywordtype}{long} \_dictKeyIndex(dict *ht, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key, uint64\_t hash, dictEntry **existing);
00070 \textcolor{keyword}{static} \textcolor{keywordtype}{int} \_dictInit(dict *ht, dictType *type, \textcolor{keywordtype}{void} *privDataPtr);
00071 
00072 \textcolor{comment}{/* -------------------------- hash functions -------------------------------- */}
00073 
00074 \textcolor{keyword}{static} uint8\_t dict\_hash\_function\_seed[16];
00075 
00076 \textcolor{keywordtype}{void} dictSetHashFunctionSeed(uint8\_t *seed) \{
00077     memcpy(dict\_hash\_function\_seed,seed,\textcolor{keyword}{sizeof}(dict\_hash\_function\_seed));
00078 \}
00079 
00080 uint8\_t *dictGetHashFunctionSeed(\textcolor{keywordtype}{void}) \{
00081     \textcolor{keywordflow}{return} dict\_hash\_function\_seed;
00082 \}
00083 
00084 \textcolor{comment}{/* The default hashing function uses SipHash implementation}
00085 \textcolor{comment}{ * in siphash.c. */}
00086 
00087 uint64\_t siphash(\textcolor{keyword}{const} uint8\_t *in, \textcolor{keyword}{const} size\_t inlen, \textcolor{keyword}{const} uint8\_t *k);
00088 uint64\_t siphash\_nocase(\textcolor{keyword}{const} uint8\_t *in, \textcolor{keyword}{const} size\_t inlen, \textcolor{keyword}{const} uint8\_t *k);
00089 
00090 uint64\_t dictGenHashFunction(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *key, \textcolor{keywordtype}{int} len) \{
00091     \textcolor{keywordflow}{return} siphash(key,len,dict\_hash\_function\_seed);
00092 \}
00093 
00094 uint64\_t dictGenCaseHashFunction(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buf, \textcolor{keywordtype}{int} len) \{
00095     \textcolor{keywordflow}{return} siphash\_nocase(buf,len,dict\_hash\_function\_seed);
00096 \}
00097 
00098 \textcolor{comment}{/* ----------------------------- API implementation ------------------------- */}
00099 
00100 \textcolor{comment}{/* Reset a hash table already initialized with ht\_init().}
00101 \textcolor{comment}{ * NOTE: This function should only be called by ht\_destroy(). */}
00102 \textcolor{keyword}{static} \textcolor{keywordtype}{void} \_dictReset(dictht *ht)
00103 \{
00104     ht->table = NULL;
00105     ht->size = 0;
00106     ht->sizemask = 0;
00107     ht->used = 0;
00108 \}
00109 
00110 \textcolor{comment}{/* Create a new hash table */}
00111 dict *dictCreate(dictType *type,
00112         \textcolor{keywordtype}{void} *privDataPtr)
00113 \{
00114     dict *d = zmalloc(\textcolor{keyword}{sizeof}(*d));
00115 
00116     \_dictInit(d,type,privDataPtr);
00117     \textcolor{keywordflow}{return} d;
00118 \}
00119 
00120 \textcolor{comment}{/* Initialize the hash table */}
00121 \textcolor{keywordtype}{int} \_dictInit(dict *d, dictType *type,
00122         \textcolor{keywordtype}{void} *privDataPtr)
00123 \{
00124     \_dictReset(&d->ht[0]);
00125     \_dictReset(&d->ht[1]);
00126     d->type = type;
00127     d->privdata = privDataPtr;
00128     d->rehashidx = -1;
00129     d->iterators = 0;
00130     \textcolor{keywordflow}{return} \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK};
00131 \}
00132 
00133 \textcolor{comment}{/* Resize the table to the minimal size that contains all the elements,}
00134 \textcolor{comment}{ * but with the invariant of a USED/BUCKETS ratio near to <= 1 */}
00135 \textcolor{keywordtype}{int} dictResize(dict *d)
00136 \{
00137     \textcolor{keywordtype}{int} minimal;
00138 
00139     \textcolor{keywordflow}{if} (!dict\_can\_resize || \hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(d)) \textcolor{keywordflow}{return} 
      \hyperlink{dict_8h_a6ce31f31f044b1570d335e8fa0c388c6}{DICT\_ERR};
00140     minimal = d->ht[0].used;
00141     \textcolor{keywordflow}{if} (minimal < \hyperlink{dict_8h_aff97c19d1616cf2c697573ee3f515692}{DICT\_HT\_INITIAL\_SIZE})
00142         minimal = \hyperlink{dict_8h_aff97c19d1616cf2c697573ee3f515692}{DICT\_HT\_INITIAL\_SIZE};
00143     \textcolor{keywordflow}{return} dictExpand(d, minimal);
00144 \}
00145 
00146 \textcolor{comment}{/* Expand or create the hash table */}
00147 \textcolor{keywordtype}{int} dictExpand(dict *d, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} size)
00148 \{
00149     dictht n; \textcolor{comment}{/* the new hash table */}
00150     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} realsize = \_dictNextPower(size);
00151 
00152     \textcolor{comment}{/* the size is invalid if it is smaller than the number of}
00153 \textcolor{comment}{     * elements already inside the hash table */}
00154     \textcolor{keywordflow}{if} (\hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(d) || d->ht[0].used > size)
00155         \textcolor{keywordflow}{return} \hyperlink{dict_8h_a6ce31f31f044b1570d335e8fa0c388c6}{DICT\_ERR};
00156 
00157     \textcolor{comment}{/* Rehashing to the same table size is not useful. */}
00158     \textcolor{keywordflow}{if} (realsize == d->ht[0].size) \textcolor{keywordflow}{return} \hyperlink{dict_8h_a6ce31f31f044b1570d335e8fa0c388c6}{DICT\_ERR};
00159 
00160     \textcolor{comment}{/* Allocate the new hash table and initialize all pointers to NULL */}
00161     n.size = realsize;
00162     n.sizemask = realsize-1;
00163     n.table = zcalloc(realsize*\textcolor{keyword}{sizeof}(dictEntry*));
00164     n.used = 0;
00165 
00166     \textcolor{comment}{/* Is this the first initialization? If so it's not really a rehashing}
00167 \textcolor{comment}{     * we just set the first hash table so that it can accept keys. */}
00168     \textcolor{keywordflow}{if} (d->ht[0].table == NULL) \{
00169         d->ht[0] = n;
00170         \textcolor{keywordflow}{return} \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK};
00171     \}
00172 
00173     \textcolor{comment}{/* Prepare a second hash table for incremental rehashing */}
00174     d->ht[1] = n;
00175     d->rehashidx = 0;
00176     \textcolor{keywordflow}{return} \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK};
00177 \}
00178 
00179 \textcolor{comment}{/* Performs N steps of incremental rehashing. Returns 1 if there are still}
00180 \textcolor{comment}{ * keys to move from the old to the new hash table, otherwise 0 is returned.}
00181 \textcolor{comment}{ *}
00182 \textcolor{comment}{ * Note that a rehashing step consists in moving a bucket (that may have more}
00183 \textcolor{comment}{ * than one key as we use chaining) from the old to the new hash table, however}
00184 \textcolor{comment}{ * since part of the hash table may be composed of empty spaces, it is not}
00185 \textcolor{comment}{ * guaranteed that this function will rehash even a single bucket, since it}
00186 \textcolor{comment}{ * will visit at max N*10 empty buckets in total, otherwise the amount of}
00187 \textcolor{comment}{ * work it does would be unbound and the function may block for a long time. */}
00188 \textcolor{keywordtype}{int} dictRehash(dict *d, \textcolor{keywordtype}{int} n) \{
00189     \textcolor{keywordtype}{int} empty\_visits = n*10; \textcolor{comment}{/* Max number of empty buckets to visit. */}
00190     \textcolor{keywordflow}{if} (!\hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(d)) \textcolor{keywordflow}{return} 0;
00191 
00192     \textcolor{keywordflow}{while}(n-- && d->ht[0].used != 0) \{
00193         dictEntry *de, *nextde;
00194 
00195         \textcolor{comment}{/* Note that rehashidx can't overflow as we are sure there are more}
00196 \textcolor{comment}{         * elements because ht[0].used != 0 */}
00197         \hyperlink{redisassert_8h_a993abaa2c168852c1592879472938781}{assert}(d->ht[0].size > (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})d->rehashidx);
00198         \textcolor{keywordflow}{while}(d->ht[0].table[d->rehashidx] == NULL) \{
00199             d->rehashidx++;
00200             \textcolor{keywordflow}{if} (--empty\_visits == 0) \textcolor{keywordflow}{return} 1;
00201         \}
00202         de = d->ht[0].table[d->rehashidx];
00203         \textcolor{comment}{/* Move all the keys in this bucket from the old to the new hash HT */}
00204         \textcolor{keywordflow}{while}(de) \{
00205             uint64\_t h;
00206 
00207             nextde = de->next;
00208             \textcolor{comment}{/* Get the index in the new hash table */}
00209             h = \hyperlink{dict_8h_a15a270e95a4eea30557df137e9747a95}{dictHashKey}(d, de->key) & d->ht[1].sizemask;
00210             de->next = d->ht[1].table[h];
00211             d->ht[1].table[h] = de;
00212             d->ht[0].used--;
00213             d->ht[1].used++;
00214             de = nextde;
00215         \}
00216         d->ht[0].table[d->rehashidx] = NULL;
00217         d->rehashidx++;
00218     \}
00219 
00220     \textcolor{comment}{/* Check if we already rehashed the whole table... */}
00221     \textcolor{keywordflow}{if} (d->ht[0].used == 0) \{
00222         zfree(d->ht[0].table);
00223         d->ht[0] = d->ht[1];
00224         \_dictReset(&d->ht[1]);
00225         d->rehashidx = -1;
00226         \textcolor{keywordflow}{return} 0;
00227     \}
00228 
00229     \textcolor{comment}{/* More to rehash... */}
00230     \textcolor{keywordflow}{return} 1;
00231 \}
00232 
00233 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} timeInMilliseconds(\textcolor{keywordtype}{void}) \{
00234     \textcolor{keyword}{struct} timeval tv;
00235 
00236     gettimeofday(&tv,NULL);
00237     \textcolor{keywordflow}{return} (((\textcolor{keywordtype}{long} \textcolor{keywordtype}{long})tv.tv\_sec)*1000)+(tv.tv\_usec/1000);
00238 \}
00239 
00240 \textcolor{comment}{/* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */}
00241 \textcolor{keywordtype}{int} dictRehashMilliseconds(dict *d, \textcolor{keywordtype}{int} ms) \{
00242     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} start = timeInMilliseconds();
00243     \textcolor{keywordtype}{int} rehashes = 0;
00244 
00245     \textcolor{keywordflow}{while}(dictRehash(d,100)) \{
00246         rehashes += 100;
00247         \textcolor{keywordflow}{if} (timeInMilliseconds()-start > ms) \textcolor{keywordflow}{break};
00248     \}
00249     \textcolor{keywordflow}{return} rehashes;
00250 \}
00251 
00252 \textcolor{comment}{/* This function performs just a step of rehashing, and only if there are}
00253 \textcolor{comment}{ * no safe iterators bound to our hash table. When we have iterators in the}
00254 \textcolor{comment}{ * middle of a rehashing we can't mess with the two hash tables otherwise}
00255 \textcolor{comment}{ * some element can be missed or duplicated.}
00256 \textcolor{comment}{ *}
00257 \textcolor{comment}{ * This function is called by common lookup or update operations in the}
00258 \textcolor{comment}{ * dictionary so that the hash table automatically migrates from H1 to H2}
00259 \textcolor{comment}{ * while it is actively used. */}
00260 \textcolor{keyword}{static} \textcolor{keywordtype}{void} \_dictRehashStep(dict *d) \{
00261     \textcolor{keywordflow}{if} (d->iterators == 0) dictRehash(d,1);
00262 \}
00263 
00264 \textcolor{comment}{/* Add an element to the target hash table */}
00265 \textcolor{keywordtype}{int} dictAdd(dict *d, \textcolor{keywordtype}{void} *key, \textcolor{keywordtype}{void} *val)
00266 \{
00267     dictEntry *entry = dictAddRaw(d,key,NULL);
00268 
00269     \textcolor{keywordflow}{if} (!entry) \textcolor{keywordflow}{return} \hyperlink{dict_8h_a6ce31f31f044b1570d335e8fa0c388c6}{DICT\_ERR};
00270     \hyperlink{dict_8h_a95cae6581aca3a7a4c5e226e565294c9}{dictSetVal}(d, entry, val);
00271     \textcolor{keywordflow}{return} \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK};
00272 \}
00273 
00274 \textcolor{comment}{/* Low level add or find:}
00275 \textcolor{comment}{ * This function adds the entry but instead of setting a value returns the}
00276 \textcolor{comment}{ * dictEntry structure to the user, that will make sure to fill the value}
00277 \textcolor{comment}{ * field as he wishes.}
00278 \textcolor{comment}{ *}
00279 \textcolor{comment}{ * This function is also directly exposed to the user API to be called}
00280 \textcolor{comment}{ * mainly in order to store non-pointers inside the hash value, example:}
00281 \textcolor{comment}{ *}
00282 \textcolor{comment}{ * entry = dictAddRaw(dict,mykey,NULL);}
00283 \textcolor{comment}{ * if (entry != NULL) dictSetSignedIntegerVal(entry,1000);}
00284 \textcolor{comment}{ *}
00285 \textcolor{comment}{ * Return values:}
00286 \textcolor{comment}{ *}
00287 \textcolor{comment}{ * If key already exists NULL is returned, and "*existing" is populated}
00288 \textcolor{comment}{ * with the existing entry if existing is not NULL.}
00289 \textcolor{comment}{ *}
00290 \textcolor{comment}{ * If key was added, the hash entry is returned to be manipulated by the caller.}
00291 \textcolor{comment}{ */}
00292 dictEntry *dictAddRaw(dict *d, \textcolor{keywordtype}{void} *key, dictEntry **existing)
00293 \{
00294     \textcolor{keywordtype}{long} index;
00295     dictEntry *entry;
00296     dictht *ht;
00297 
00298     \textcolor{keywordflow}{if} (\hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(d)) \_dictRehashStep(d);
00299 
00300     \textcolor{comment}{/* Get the index of the new element, or -1 if}
00301 \textcolor{comment}{     * the element already exists. */}
00302     \textcolor{keywordflow}{if} ((index = \_dictKeyIndex(d, key, \hyperlink{dict_8h_a15a270e95a4eea30557df137e9747a95}{dictHashKey}(d,key), existing)) == -1)
00303         \textcolor{keywordflow}{return} NULL;
00304 
00305     \textcolor{comment}{/* Allocate the memory and store the new entry.}
00306 \textcolor{comment}{     * Insert the element in top, with the assumption that in a database}
00307 \textcolor{comment}{     * system it is more likely that recently added entries are accessed}
00308 \textcolor{comment}{     * more frequently. */}
00309     ht = \hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(d) ? &d->ht[1] : &d->ht[0];
00310     entry = zmalloc(\textcolor{keyword}{sizeof}(*entry));
00311     entry->next = ht->table[index];
00312     ht->table[index] = entry;
00313     ht->used++;
00314 
00315     \textcolor{comment}{/* Set the hash entry fields. */}
00316     \hyperlink{dict_8h_a827e5dcfd37bba408fa8bdb111b0594e}{dictSetKey}(d, entry, key);
00317     \textcolor{keywordflow}{return} entry;
00318 \}
00319 
00320 \textcolor{comment}{/* Add or Overwrite:}
00321 \textcolor{comment}{ * Add an element, discarding the old value if the key already exists.}
00322 \textcolor{comment}{ * Return 1 if the key was added from scratch, 0 if there was already an}
00323 \textcolor{comment}{ * element with such key and dictReplace() just performed a value update}
00324 \textcolor{comment}{ * operation. */}
00325 \textcolor{keywordtype}{int} dictReplace(dict *d, \textcolor{keywordtype}{void} *key, \textcolor{keywordtype}{void} *val)
00326 \{
00327     dictEntry *entry, *existing, auxentry;
00328 
00329     \textcolor{comment}{/* Try to add the element. If the key}
00330 \textcolor{comment}{     * does not exists dictAdd will suceed. */}
00331     entry = dictAddRaw(d,key,&existing);
00332     \textcolor{keywordflow}{if} (entry) \{
00333         \hyperlink{dict_8h_a95cae6581aca3a7a4c5e226e565294c9}{dictSetVal}(d, entry, val);
00334         \textcolor{keywordflow}{return} 1;
00335     \}
00336 
00337     \textcolor{comment}{/* Set the new value and free the old one. Note that it is important}
00338 \textcolor{comment}{     * to do that in this order, as the value may just be exactly the same}
00339 \textcolor{comment}{     * as the previous one. In this context, think to reference counting,}
00340 \textcolor{comment}{     * you want to increment (set), and then decrement (free), and not the}
00341 \textcolor{comment}{     * reverse. */}
00342     auxentry = *existing;
00343     \hyperlink{dict_8h_a95cae6581aca3a7a4c5e226e565294c9}{dictSetVal}(d, existing, val);
00344     \hyperlink{dict_8h_a4a90ee4c2d8391f2d6f9c65ccf4ba037}{dictFreeVal}(d, &auxentry);
00345     \textcolor{keywordflow}{return} 0;
00346 \}
00347 
00348 \textcolor{comment}{/* Add or Find:}
00349 \textcolor{comment}{ * dictAddOrFind() is simply a version of dictAddRaw() that always}
00350 \textcolor{comment}{ * returns the hash entry of the specified key, even if the key already}
00351 \textcolor{comment}{ * exists and can't be added (in that case the entry of the already}
00352 \textcolor{comment}{ * existing key is returned.)}
00353 \textcolor{comment}{ *}
00354 \textcolor{comment}{ * See dictAddRaw() for more information. */}
00355 dictEntry *dictAddOrFind(dict *d, \textcolor{keywordtype}{void} *key) \{
00356     dictEntry *entry, *existing;
00357     entry = dictAddRaw(d,key,&existing);
00358     \textcolor{keywordflow}{return} entry ? entry : existing;
00359 \}
00360 
00361 \textcolor{comment}{/* Search and remove an element. This is an helper function for}
00362 \textcolor{comment}{ * dictDelete() and dictUnlink(), please check the top comment}
00363 \textcolor{comment}{ * of those functions. */}
00364 \textcolor{keyword}{static} dictEntry *dictGenericDelete(dict *d, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key, \textcolor{keywordtype}{int} nofree) \{
00365     uint64\_t h, idx;
00366     dictEntry *he, *prevHe;
00367     \textcolor{keywordtype}{int} table;
00368 
00369     \textcolor{keywordflow}{if} (d->ht[0].used == 0 && d->ht[1].used == 0) \textcolor{keywordflow}{return} NULL;
00370 
00371     \textcolor{keywordflow}{if} (\hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(d)) \_dictRehashStep(d);
00372     h = \hyperlink{dict_8h_a15a270e95a4eea30557df137e9747a95}{dictHashKey}(d, key);
00373 
00374     \textcolor{keywordflow}{for} (table = 0; table <= 1; table++) \{
00375         idx = h & d->ht[table].sizemask;
00376         he = d->ht[table].table[idx];
00377         prevHe = NULL;
00378         \textcolor{keywordflow}{while}(he) \{
00379             \textcolor{keywordflow}{if} (key==he->key || \hyperlink{dict_8h_ab373389c580b8441ab28082cb7643762}{dictCompareKeys}(d, key, he->key)) \{
00380                 \textcolor{comment}{/* Unlink the element from the list */}
00381                 \textcolor{keywordflow}{if} (prevHe)
00382                     prevHe->next = he->next;
00383                 \textcolor{keywordflow}{else}
00384                     d->ht[table].table[idx] = he->next;
00385                 \textcolor{keywordflow}{if} (!nofree) \{
00386                     \hyperlink{dict_8h_a29fe9bb2bf0eac2c86a613536afe73ca}{dictFreeKey}(d, he);
00387                     \hyperlink{dict_8h_a4a90ee4c2d8391f2d6f9c65ccf4ba037}{dictFreeVal}(d, he);
00388                     zfree(he);
00389                 \}
00390                 d->ht[table].used--;
00391                 \textcolor{keywordflow}{return} he;
00392             \}
00393             prevHe = he;
00394             he = he->next;
00395         \}
00396         \textcolor{keywordflow}{if} (!\hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(d)) \textcolor{keywordflow}{break};
00397     \}
00398     \textcolor{keywordflow}{return} NULL; \textcolor{comment}{/* not found */}
00399 \}
00400 
00401 \textcolor{comment}{/* Remove an element, returning DICT\_OK on success or DICT\_ERR if the}
00402 \textcolor{comment}{ * element was not found. */}
00403 \textcolor{keywordtype}{int} dictDelete(dict *ht, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key) \{
00404     \textcolor{keywordflow}{return} dictGenericDelete(ht,key,0) ? \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK} : \hyperlink{dict_8h_a6ce31f31f044b1570d335e8fa0c388c6}{DICT\_ERR};
00405 \}
00406 
00407 \textcolor{comment}{/* Remove an element from the table, but without actually releasing}
00408 \textcolor{comment}{ * the key, value and dictionary entry. The dictionary entry is returned}
00409 \textcolor{comment}{ * if the element was found (and unlinked from the table), and the user}
00410 \textcolor{comment}{ * should later call `dictFreeUnlinkedEntry()` with it in order to release it.}
00411 \textcolor{comment}{ * Otherwise if the key is not found, NULL is returned.}
00412 \textcolor{comment}{ *}
00413 \textcolor{comment}{ * This function is useful when we want to remove something from the hash}
00414 \textcolor{comment}{ * table but want to use its value before actually deleting the entry.}
00415 \textcolor{comment}{ * Without this function the pattern would require two lookups:}
00416 \textcolor{comment}{ *}
00417 \textcolor{comment}{ *  entry = dictFind(...);}
00418 \textcolor{comment}{ *  // Do something with entry}
00419 \textcolor{comment}{ *  dictDelete(dictionary,entry);}
00420 \textcolor{comment}{ *}
00421 \textcolor{comment}{ * Thanks to this function it is possible to avoid this, and use}
00422 \textcolor{comment}{ * instead:}
00423 \textcolor{comment}{ *}
00424 \textcolor{comment}{ * entry = dictUnlink(dictionary,entry);}
00425 \textcolor{comment}{ * // Do something with entry}
00426 \textcolor{comment}{ * dictFreeUnlinkedEntry(entry); // <- This does not need to lookup again.}
00427 \textcolor{comment}{ */}
00428 dictEntry *dictUnlink(dict *ht, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key) \{
00429     \textcolor{keywordflow}{return} dictGenericDelete(ht,key,1);
00430 \}
00431 
00432 \textcolor{comment}{/* You need to call this function to really free the entry after a call}
00433 \textcolor{comment}{ * to dictUnlink(). It's safe to call this function with 'he' = NULL. */}
00434 \textcolor{keywordtype}{void} dictFreeUnlinkedEntry(dict *d, dictEntry *he) \{
00435     \textcolor{keywordflow}{if} (he == NULL) \textcolor{keywordflow}{return};
00436     \hyperlink{dict_8h_a29fe9bb2bf0eac2c86a613536afe73ca}{dictFreeKey}(d, he);
00437     \hyperlink{dict_8h_a4a90ee4c2d8391f2d6f9c65ccf4ba037}{dictFreeVal}(d, he);
00438     zfree(he);
00439 \}
00440 
00441 \textcolor{comment}{/* Destroy an entire dictionary */}
00442 \textcolor{keywordtype}{int} \_dictClear(dict *d, dictht *ht, \textcolor{keywordtype}{void}(callback)(\textcolor{keywordtype}{void} *)) \{
00443     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} i;
00444 
00445     \textcolor{comment}{/* Free all the elements */}
00446     \textcolor{keywordflow}{for} (i = 0; i < ht->size && ht->used > 0; i++) \{
00447         dictEntry *he, *nextHe;
00448 
00449         \textcolor{keywordflow}{if} (callback && (i & 65535) == 0) callback(d->privdata);
00450 
00451         \textcolor{keywordflow}{if} ((he = ht->table[i]) == NULL) \textcolor{keywordflow}{continue};
00452         \textcolor{keywordflow}{while}(he) \{
00453             nextHe = he->next;
00454             \hyperlink{dict_8h_a29fe9bb2bf0eac2c86a613536afe73ca}{dictFreeKey}(d, he);
00455             \hyperlink{dict_8h_a4a90ee4c2d8391f2d6f9c65ccf4ba037}{dictFreeVal}(d, he);
00456             zfree(he);
00457             ht->used--;
00458             he = nextHe;
00459         \}
00460     \}
00461     \textcolor{comment}{/* Free the table and the allocated cache structure */}
00462     zfree(ht->table);
00463     \textcolor{comment}{/* Re-initialize the table */}
00464     \_dictReset(ht);
00465     \textcolor{keywordflow}{return} \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK}; \textcolor{comment}{/* never fails */}
00466 \}
00467 
00468 \textcolor{comment}{/* Clear & Release the hash table */}
00469 \textcolor{keywordtype}{void} dictRelease(dict *d)
00470 \{
00471     \_dictClear(d,&d->ht[0],NULL);
00472     \_dictClear(d,&d->ht[1],NULL);
00473     zfree(d);
00474 \}
00475 
00476 dictEntry *dictFind(dict *d, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key)
00477 \{
00478     dictEntry *he;
00479     uint64\_t h, idx, table;
00480 
00481     \textcolor{keywordflow}{if} (d->ht[0].used + d->ht[1].used == 0) \textcolor{keywordflow}{return} NULL; \textcolor{comment}{/* dict is empty */}
00482     \textcolor{keywordflow}{if} (\hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(d)) \_dictRehashStep(d);
00483     h = \hyperlink{dict_8h_a15a270e95a4eea30557df137e9747a95}{dictHashKey}(d, key);
00484     \textcolor{keywordflow}{for} (table = 0; table <= 1; table++) \{
00485         idx = h & d->ht[table].sizemask;
00486         he = d->ht[table].table[idx];
00487         \textcolor{keywordflow}{while}(he) \{
00488             \textcolor{keywordflow}{if} (key==he->key || \hyperlink{dict_8h_ab373389c580b8441ab28082cb7643762}{dictCompareKeys}(d, key, he->key))
00489                 \textcolor{keywordflow}{return} he;
00490             he = he->next;
00491         \}
00492         \textcolor{keywordflow}{if} (!\hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(d)) \textcolor{keywordflow}{return} NULL;
00493     \}
00494     \textcolor{keywordflow}{return} NULL;
00495 \}
00496 
00497 \textcolor{keywordtype}{void} *dictFetchValue(dict *d, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key) \{
00498     dictEntry *he;
00499 
00500     he = dictFind(d,key);
00501     \textcolor{keywordflow}{return} he ? \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(he) : NULL;
00502 \}
00503 
00504 \textcolor{comment}{/* A fingerprint is a 64 bit number that represents the state of the dictionary}
00505 \textcolor{comment}{ * at a given time, it's just a few dict properties xored together.}
00506 \textcolor{comment}{ * When an unsafe iterator is initialized, we get the dict fingerprint, and check}
00507 \textcolor{comment}{ * the fingerprint again when the iterator is released.}
00508 \textcolor{comment}{ * If the two fingerprints are different it means that the user of the iterator}
00509 \textcolor{comment}{ * performed forbidden operations against the dictionary while iterating. */}
00510 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} dictFingerprint(dict *d) \{
00511     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} integers[6], hash = 0;
00512     \textcolor{keywordtype}{int} j;
00513 
00514     integers[0] = (\textcolor{keywordtype}{long}) d->ht[0].table;
00515     integers[1] = d->ht[0].size;
00516     integers[2] = d->ht[0].used;
00517     integers[3] = (\textcolor{keywordtype}{long}) d->ht[1].table;
00518     integers[4] = d->ht[1].size;
00519     integers[5] = d->ht[1].used;
00520 
00521     \textcolor{comment}{/* We hash N integers by summing every successive integer with the integer}
00522 \textcolor{comment}{     * hashing of the previous sum. Basically:}
00523 \textcolor{comment}{     *}
00524 \textcolor{comment}{     * Result = hash(hash(hash(int1)+int2)+int3) ...}
00525 \textcolor{comment}{     *}
00526 \textcolor{comment}{     * This way the same set of integers in a different order will (likely) hash}
00527 \textcolor{comment}{     * to a different number. */}
00528     \textcolor{keywordflow}{for} (j = 0; j < 6; j++) \{
00529         hash += integers[j];
00530         \textcolor{comment}{/* For the hashing step we use Tomas Wang's 64 bit integer hash. */}
00531         hash = (~hash) + (hash << 21); \textcolor{comment}{// hash = (hash << 21) - hash - 1;}
00532         hash = hash ^ (hash >> 24);
00533         hash = (hash + (hash << 3)) + (hash << 8); \textcolor{comment}{// hash * 265}
00534         hash = hash ^ (hash >> 14);
00535         hash = (hash + (hash << 2)) + (hash << 4); \textcolor{comment}{// hash * 21}
00536         hash = hash ^ (hash >> 28);
00537         hash = hash + (hash << 31);
00538     \}
00539     \textcolor{keywordflow}{return} hash;
00540 \}
00541 
00542 dictIterator *dictGetIterator(dict *d)
00543 \{
00544     dictIterator *iter = zmalloc(\textcolor{keyword}{sizeof}(*iter));
00545 
00546     iter->d = d;
00547     iter->table = 0;
00548     iter->index = -1;
00549     iter->safe = 0;
00550     iter->entry = NULL;
00551     iter->nextEntry = NULL;
00552     \textcolor{keywordflow}{return} iter;
00553 \}
00554 
00555 dictIterator *dictGetSafeIterator(dict *d) \{
00556     dictIterator *i = dictGetIterator(d);
00557 
00558     i->safe = 1;
00559     \textcolor{keywordflow}{return} i;
00560 \}
00561 
00562 dictEntry *dictNext(dictIterator *iter)
00563 \{
00564     \textcolor{keywordflow}{while} (1) \{
00565         \textcolor{keywordflow}{if} (iter->entry == NULL) \{
00566             dictht *ht = &iter->d->ht[iter->table];
00567             \textcolor{keywordflow}{if} (iter->index == -1 && iter->table == 0) \{
00568                 \textcolor{keywordflow}{if} (iter->safe)
00569                     iter->d->iterators++;
00570                 \textcolor{keywordflow}{else}
00571                     iter->fingerprint = dictFingerprint(iter->d);
00572             \}
00573             iter->index++;
00574             \textcolor{keywordflow}{if} (iter->index >= (\textcolor{keywordtype}{long}) ht->size) \{
00575                 \textcolor{keywordflow}{if} (\hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(iter->d) && iter->table == 0) \{
00576                     iter->table++;
00577                     iter->index = 0;
00578                     ht = &iter->d->ht[1];
00579                 \} \textcolor{keywordflow}{else} \{
00580                     \textcolor{keywordflow}{break};
00581                 \}
00582             \}
00583             iter->entry = ht->table[iter->index];
00584         \} \textcolor{keywordflow}{else} \{
00585             iter->entry = iter->nextEntry;
00586         \}
00587         \textcolor{keywordflow}{if} (iter->entry) \{
00588             \textcolor{comment}{/* We need to save the 'next' here, the iterator user}
00589 \textcolor{comment}{             * may delete the entry we are returning. */}
00590             iter->nextEntry = iter->entry->next;
00591             \textcolor{keywordflow}{return} iter->entry;
00592         \}
00593     \}
00594     \textcolor{keywordflow}{return} NULL;
00595 \}
00596 
00597 \textcolor{keywordtype}{void} dictReleaseIterator(dictIterator *iter)
00598 \{
00599     \textcolor{keywordflow}{if} (!(iter->index == -1 && iter->table == 0)) \{
00600         \textcolor{keywordflow}{if} (iter->safe)
00601             iter->d->iterators--;
00602         \textcolor{keywordflow}{else}
00603             \hyperlink{redisassert_8h_a993abaa2c168852c1592879472938781}{assert}(iter->fingerprint == dictFingerprint(iter->d));
00604     \}
00605     zfree(iter);
00606 \}
00607 
00608 \textcolor{comment}{/* Return a random entry from the hash table. Useful to}
00609 \textcolor{comment}{ * implement randomized algorithms */}
00610 dictEntry *dictGetRandomKey(dict *d)
00611 \{
00612     dictEntry *he, *orighe;
00613     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} h;
00614     \textcolor{keywordtype}{int} listlen, listele;
00615 
00616     \textcolor{keywordflow}{if} (\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(d) == 0) \textcolor{keywordflow}{return} NULL;
00617     \textcolor{keywordflow}{if} (\hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(d)) \_dictRehashStep(d);
00618     \textcolor{keywordflow}{if} (\hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(d)) \{
00619         \textcolor{keywordflow}{do} \{
00620             \textcolor{comment}{/* We are sure there are no elements in indexes from 0}
00621 \textcolor{comment}{             * to rehashidx-1 */}
00622             h = d->rehashidx + (random() % (d->ht[0].size +
00623                                             d->ht[1].size -
00624                                             d->rehashidx));
00625             he = (h >= d->ht[0].size) ? d->ht[1].table[h - d->ht[0].size] :
00626                                       d->ht[0].table[h];
00627         \} \textcolor{keywordflow}{while}(he == NULL);
00628     \} \textcolor{keywordflow}{else} \{
00629         \textcolor{keywordflow}{do} \{
00630             h = random() & d->ht[0].sizemask;
00631             he = d->ht[0].table[h];
00632         \} \textcolor{keywordflow}{while}(he == NULL);
00633     \}
00634 
00635     \textcolor{comment}{/* Now we found a non empty bucket, but it is a linked}
00636 \textcolor{comment}{     * list and we need to get a random element from the list.}
00637 \textcolor{comment}{     * The only sane way to do so is counting the elements and}
00638 \textcolor{comment}{     * select a random index. */}
00639     listlen = 0;
00640     orighe = he;
00641     \textcolor{keywordflow}{while}(he) \{
00642         he = he->next;
00643         listlen++;
00644     \}
00645     listele = random() % listlen;
00646     he = orighe;
00647     \textcolor{keywordflow}{while}(listele--) he = he->next;
00648     \textcolor{keywordflow}{return} he;
00649 \}
00650 
00651 \textcolor{comment}{/* This function samples the dictionary to return a few keys from random}
00652 \textcolor{comment}{ * locations.}
00653 \textcolor{comment}{ *}
00654 \textcolor{comment}{ * It does not guarantee to return all the keys specified in 'count', nor}
00655 \textcolor{comment}{ * it does guarantee to return non-duplicated elements, however it will make}
00656 \textcolor{comment}{ * some effort to do both things.}
00657 \textcolor{comment}{ *}
00658 \textcolor{comment}{ * Returned pointers to hash table entries are stored into 'des' that}
00659 \textcolor{comment}{ * points to an array of dictEntry pointers. The array must have room for}
00660 \textcolor{comment}{ * at least 'count' elements, that is the argument we pass to the function}
00661 \textcolor{comment}{ * to tell how many random elements we need.}
00662 \textcolor{comment}{ *}
00663 \textcolor{comment}{ * The function returns the number of items stored into 'des', that may}
00664 \textcolor{comment}{ * be less than 'count' if the hash table has less than 'count' elements}
00665 \textcolor{comment}{ * inside, or if not enough elements were found in a reasonable amount of}
00666 \textcolor{comment}{ * steps.}
00667 \textcolor{comment}{ *}
00668 \textcolor{comment}{ * Note that this function is not suitable when you need a good distribution}
00669 \textcolor{comment}{ * of the returned items, but only when you need to "sample" a given number}
00670 \textcolor{comment}{ * of continuous elements to run some kind of algorithm or to produce}
00671 \textcolor{comment}{ * statistics. However the function is much faster than dictGetRandomKey()}
00672 \textcolor{comment}{ * at producing N elements. */}
00673 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} dictGetSomeKeys(dict *d, dictEntry **des, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} count) \{
00674     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} j; \textcolor{comment}{/* internal hash table id, 0 or 1. */}
00675     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} tables; \textcolor{comment}{/* 1 or 2 tables? */}
00676     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} stored = 0, maxsizemask;
00677     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} maxsteps;
00678 
00679     \textcolor{keywordflow}{if} (\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(d) < count) count = \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(d);
00680     maxsteps = count*10;
00681 
00682     \textcolor{comment}{/* Try to do a rehashing work proportional to 'count'. */}
00683     \textcolor{keywordflow}{for} (j = 0; j < count; j++) \{
00684         \textcolor{keywordflow}{if} (\hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(d))
00685             \_dictRehashStep(d);
00686         \textcolor{keywordflow}{else}
00687             \textcolor{keywordflow}{break};
00688     \}
00689 
00690     tables = \hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(d) ? 2 : 1;
00691     maxsizemask = d->ht[0].sizemask;
00692     \textcolor{keywordflow}{if} (tables > 1 && maxsizemask < d->ht[1].sizemask)
00693         maxsizemask = d->ht[1].sizemask;
00694 
00695     \textcolor{comment}{/* Pick a random point inside the larger table. */}
00696     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} i = random() & maxsizemask;
00697     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} emptylen = 0; \textcolor{comment}{/* Continuous empty entries so far. */}
00698     \textcolor{keywordflow}{while}(stored < count && maxsteps--) \{
00699         \textcolor{keywordflow}{for} (j = 0; j < tables; j++) \{
00700             \textcolor{comment}{/* Invariant of the dict.c rehashing: up to the indexes already}
00701 \textcolor{comment}{             * visited in ht[0] during the rehashing, there are no populated}
00702 \textcolor{comment}{             * buckets, so we can skip ht[0] for indexes between 0 and idx-1. */}
00703             \textcolor{keywordflow}{if} (tables == 2 && j == 0 && i < (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}) d->rehashidx) \{
00704                 \textcolor{comment}{/* Moreover, if we are currently out of range in the second}
00705 \textcolor{comment}{                 * table, there will be no elements in both tables up to}
00706 \textcolor{comment}{                 * the current rehashing index, so we jump if possible.}
00707 \textcolor{comment}{                 * (this happens when going from big to small table). */}
00708                 \textcolor{keywordflow}{if} (i >= d->ht[1].size) i = d->rehashidx;
00709                 \textcolor{keywordflow}{continue};
00710             \}
00711             \textcolor{keywordflow}{if} (i >= d->ht[j].size) \textcolor{keywordflow}{continue}; \textcolor{comment}{/* Out of range for this table. */}
00712             dictEntry *he = d->ht[j].table[i];
00713 
00714             \textcolor{comment}{/* Count contiguous empty buckets, and jump to other}
00715 \textcolor{comment}{             * locations if they reach 'count' (with a minimum of 5). */}
00716             \textcolor{keywordflow}{if} (he == NULL) \{
00717                 emptylen++;
00718                 \textcolor{keywordflow}{if} (emptylen >= 5 && emptylen > count) \{
00719                     i = random() & maxsizemask;
00720                     emptylen = 0;
00721                 \}
00722             \} \textcolor{keywordflow}{else} \{
00723                 emptylen = 0;
00724                 \textcolor{keywordflow}{while} (he) \{
00725                     \textcolor{comment}{/* Collect all the elements of the buckets found non}
00726 \textcolor{comment}{                     * empty while iterating. */}
00727                     *des = he;
00728                     des++;
00729                     he = he->next;
00730                     stored++;
00731                     \textcolor{keywordflow}{if} (stored == count) \textcolor{keywordflow}{return} stored;
00732                 \}
00733             \}
00734         \}
00735         i = (i+1) & maxsizemask;
00736     \}
00737     \textcolor{keywordflow}{return} stored;
00738 \}
00739 
00740 \textcolor{comment}{/* Function to reverse bits. Algorithm from:}
00741 \textcolor{comment}{ * http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel */}
00742 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} rev(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} v) \{
00743     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} s = 8 * \textcolor{keyword}{sizeof}(v); \textcolor{comment}{// bit size; must be power of 2}
00744     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} mask = ~0;
00745     \textcolor{keywordflow}{while} ((s >>= 1) > 0) \{
00746         mask ^= (mask << s);
00747         v = ((v >> s) & mask) | ((v << s) & ~mask);
00748     \}
00749     \textcolor{keywordflow}{return} v;
00750 \}
00751 
00752 \textcolor{comment}{/* dictScan() is used to iterate over the elements of a dictionary.}
00753 \textcolor{comment}{ *}
00754 \textcolor{comment}{ * Iterating works the following way:}
00755 \textcolor{comment}{ *}
00756 \textcolor{comment}{ * 1) Initially you call the function using a cursor (v) value of 0.}
00757 \textcolor{comment}{ * 2) The function performs one step of the iteration, and returns the}
00758 \textcolor{comment}{ *    new cursor value you must use in the next call.}
00759 \textcolor{comment}{ * 3) When the returned cursor is 0, the iteration is complete.}
00760 \textcolor{comment}{ *}
00761 \textcolor{comment}{ * The function guarantees all elements present in the}
00762 \textcolor{comment}{ * dictionary get returned between the start and end of the iteration.}
00763 \textcolor{comment}{ * However it is possible some elements get returned multiple times.}
00764 \textcolor{comment}{ *}
00765 \textcolor{comment}{ * For every element returned, the callback argument 'fn' is}
00766 \textcolor{comment}{ * called with 'privdata' as first argument and the dictionary entry}
00767 \textcolor{comment}{ * 'de' as second argument.}
00768 \textcolor{comment}{ *}
00769 \textcolor{comment}{ * HOW IT WORKS.}
00770 \textcolor{comment}{ *}
00771 \textcolor{comment}{ * The iteration algorithm was designed by Pieter Noordhuis.}
00772 \textcolor{comment}{ * The main idea is to increment a cursor starting from the higher order}
00773 \textcolor{comment}{ * bits. That is, instead of incrementing the cursor normally, the bits}
00774 \textcolor{comment}{ * of the cursor are reversed, then the cursor is incremented, and finally}
00775 \textcolor{comment}{ * the bits are reversed again.}
00776 \textcolor{comment}{ *}
00777 \textcolor{comment}{ * This strategy is needed because the hash table may be resized between}
00778 \textcolor{comment}{ * iteration calls.}
00779 \textcolor{comment}{ *}
00780 \textcolor{comment}{ * dict.c hash tables are always power of two in size, and they}
00781 \textcolor{comment}{ * use chaining, so the position of an element in a given table is given}
00782 \textcolor{comment}{ * by computing the bitwise AND between Hash(key) and SIZE-1}
00783 \textcolor{comment}{ * (where SIZE-1 is always the mask that is equivalent to taking the rest}
00784 \textcolor{comment}{ *  of the division between the Hash of the key and SIZE).}
00785 \textcolor{comment}{ *}
00786 \textcolor{comment}{ * For example if the current hash table size is 16, the mask is}
00787 \textcolor{comment}{ * (in binary) 1111. The position of a key in the hash table will always be}
00788 \textcolor{comment}{ * the last four bits of the hash output, and so forth.}
00789 \textcolor{comment}{ *}
00790 \textcolor{comment}{ * WHAT HAPPENS IF THE TABLE CHANGES IN SIZE?}
00791 \textcolor{comment}{ *}
00792 \textcolor{comment}{ * If the hash table grows, elements can go anywhere in one multiple of}
00793 \textcolor{comment}{ * the old bucket: for example let's say we already iterated with}
00794 \textcolor{comment}{ * a 4 bit cursor 1100 (the mask is 1111 because hash table size = 16).}
00795 \textcolor{comment}{ *}
00796 \textcolor{comment}{ * If the hash table will be resized to 64 elements, then the new mask will}
00797 \textcolor{comment}{ * be 111111. The new buckets you obtain by substituting in ??1100}
00798 \textcolor{comment}{ * with either 0 or 1 can be targeted only by keys we already visited}
00799 \textcolor{comment}{ * when scanning the bucket 1100 in the smaller hash table.}
00800 \textcolor{comment}{ *}
00801 \textcolor{comment}{ * By iterating the higher bits first, because of the inverted counter, the}
00802 \textcolor{comment}{ * cursor does not need to restart if the table size gets bigger. It will}
00803 \textcolor{comment}{ * continue iterating using cursors without '1100' at the end, and also}
00804 \textcolor{comment}{ * without any other combination of the final 4 bits already explored.}
00805 \textcolor{comment}{ *}
00806 \textcolor{comment}{ * Similarly when the table size shrinks over time, for example going from}
00807 \textcolor{comment}{ * 16 to 8, if a combination of the lower three bits (the mask for size 8}
00808 \textcolor{comment}{ * is 111) were already completely explored, it would not be visited again}
00809 \textcolor{comment}{ * because we are sure we tried, for example, both 0111 and 1111 (all the}
00810 \textcolor{comment}{ * variations of the higher bit) so we don't need to test it again.}
00811 \textcolor{comment}{ *}
00812 \textcolor{comment}{ * WAIT... YOU HAVE *TWO* TABLES DURING REHASHING!}
00813 \textcolor{comment}{ *}
00814 \textcolor{comment}{ * Yes, this is true, but we always iterate the smaller table first, then}
00815 \textcolor{comment}{ * we test all the expansions of the current cursor into the larger}
00816 \textcolor{comment}{ * table. For example if the current cursor is 101 and we also have a}
00817 \textcolor{comment}{ * larger table of size 16, we also test (0)101 and (1)101 inside the larger}
00818 \textcolor{comment}{ * table. This reduces the problem back to having only one table, where}
00819 \textcolor{comment}{ * the larger one, if it exists, is just an expansion of the smaller one.}
00820 \textcolor{comment}{ *}
00821 \textcolor{comment}{ * LIMITATIONS}
00822 \textcolor{comment}{ *}
00823 \textcolor{comment}{ * This iterator is completely stateless, and this is a huge advantage,}
00824 \textcolor{comment}{ * including no additional memory used.}
00825 \textcolor{comment}{ *}
00826 \textcolor{comment}{ * The disadvantages resulting from this design are:}
00827 \textcolor{comment}{ *}
00828 \textcolor{comment}{ * 1) It is possible we return elements more than once. However this is usually}
00829 \textcolor{comment}{ *    easy to deal with in the application level.}
00830 \textcolor{comment}{ * 2) The iterator must return multiple elements per call, as it needs to always}
00831 \textcolor{comment}{ *    return all the keys chained in a given bucket, and all the expansions, so}
00832 \textcolor{comment}{ *    we are sure we don't miss keys moving during rehashing.}
00833 \textcolor{comment}{ * 3) The reverse cursor is somewhat hard to understand at first, but this}
00834 \textcolor{comment}{ *    comment is supposed to help.}
00835 \textcolor{comment}{ */}
00836 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dictScan(dict *d,
00837                        \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} v,
00838                        dictScanFunction *fn,
00839                        dictScanBucketFunction* bucketfn,
00840                        \textcolor{keywordtype}{void} *privdata)
00841 \{
00842     dictht *t0, *t1;
00843     \textcolor{keyword}{const} dictEntry *de, *next;
00844     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} m0, m1;
00845 
00846     \textcolor{keywordflow}{if} (\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(d) == 0) \textcolor{keywordflow}{return} 0;
00847 
00848     \textcolor{keywordflow}{if} (!\hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(d)) \{
00849         t0 = &(d->ht[0]);
00850         m0 = t0->sizemask;
00851 
00852         \textcolor{comment}{/* Emit entries at cursor */}
00853         \textcolor{keywordflow}{if} (bucketfn) bucketfn(privdata, &t0->table[v & m0]);
00854         de = t0->table[v & m0];
00855         \textcolor{keywordflow}{while} (de) \{
00856             next = de->next;
00857             fn(privdata, de);
00858             de = next;
00859         \}
00860 
00861     \} \textcolor{keywordflow}{else} \{
00862         t0 = &d->ht[0];
00863         t1 = &d->ht[1];
00864 
00865         \textcolor{comment}{/* Make sure t0 is the smaller and t1 is the bigger table */}
00866         \textcolor{keywordflow}{if} (t0->size > t1->size) \{
00867             t0 = &d->ht[1];
00868             t1 = &d->ht[0];
00869         \}
00870 
00871         m0 = t0->sizemask;
00872         m1 = t1->sizemask;
00873 
00874         \textcolor{comment}{/* Emit entries at cursor */}
00875         \textcolor{keywordflow}{if} (bucketfn) bucketfn(privdata, &t0->table[v & m0]);
00876         de = t0->table[v & m0];
00877         \textcolor{keywordflow}{while} (de) \{
00878             next = de->next;
00879             fn(privdata, de);
00880             de = next;
00881         \}
00882 
00883         \textcolor{comment}{/* Iterate over indices in larger table that are the expansion}
00884 \textcolor{comment}{         * of the index pointed to by the cursor in the smaller table */}
00885         \textcolor{keywordflow}{do} \{
00886             \textcolor{comment}{/* Emit entries at cursor */}
00887             \textcolor{keywordflow}{if} (bucketfn) bucketfn(privdata, &t1->table[v & m1]);
00888             de = t1->table[v & m1];
00889             \textcolor{keywordflow}{while} (de) \{
00890                 next = de->next;
00891                 fn(privdata, de);
00892                 de = next;
00893             \}
00894 
00895             \textcolor{comment}{/* Increment bits not covered by the smaller mask */}
00896             v = (((v | m0) + 1) & ~m0) | (v & m0);
00897 
00898             \textcolor{comment}{/* Continue while bits covered by mask difference is non-zero */}
00899         \} \textcolor{keywordflow}{while} (v & (m0 ^ m1));
00900     \}
00901 
00902     \textcolor{comment}{/* Set unmasked bits so incrementing the reversed cursor}
00903 \textcolor{comment}{     * operates on the masked bits of the smaller table */}
00904     v |= ~m0;
00905 
00906     \textcolor{comment}{/* Increment the reverse cursor */}
00907     v = rev(v);
00908     v++;
00909     v = rev(v);
00910 
00911     \textcolor{keywordflow}{return} v;
00912 \}
00913 
00914 \textcolor{comment}{/* ------------------------- private functions ------------------------------ */}
00915 
00916 \textcolor{comment}{/* Expand the hash table if needed */}
00917 \textcolor{keyword}{static} \textcolor{keywordtype}{int} \_dictExpandIfNeeded(dict *d)
00918 \{
00919     \textcolor{comment}{/* Incremental rehashing already in progress. Return. */}
00920     \textcolor{keywordflow}{if} (\hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(d)) \textcolor{keywordflow}{return} \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK};
00921 
00922     \textcolor{comment}{/* If the hash table is empty expand it to the initial size. */}
00923     \textcolor{keywordflow}{if} (d->ht[0].size == 0) \textcolor{keywordflow}{return} dictExpand(d, \hyperlink{dict_8h_aff97c19d1616cf2c697573ee3f515692}{DICT\_HT\_INITIAL\_SIZE});
00924 
00925     \textcolor{comment}{/* If we reached the 1:1 ratio, and we are allowed to resize the hash}
00926 \textcolor{comment}{     * table (global setting) or we should avoid it but the ratio between}
00927 \textcolor{comment}{     * elements/buckets is over the "safe" threshold, we resize doubling}
00928 \textcolor{comment}{     * the number of buckets. */}
00929     \textcolor{keywordflow}{if} (d->ht[0].used >= d->ht[0].size &&
00930         (dict\_can\_resize ||
00931          d->ht[0].used/d->ht[0].size > dict\_force\_resize\_ratio))
00932     \{
00933         \textcolor{keywordflow}{return} dictExpand(d, d->ht[0].used*2);
00934     \}
00935     \textcolor{keywordflow}{return} \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK};
00936 \}
00937 
00938 \textcolor{comment}{/* Our hash table capability is a power of two */}
00939 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \_dictNextPower(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} size)
00940 \{
00941     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} i = \hyperlink{dict_8h_aff97c19d1616cf2c697573ee3f515692}{DICT\_HT\_INITIAL\_SIZE};
00942 
00943     \textcolor{keywordflow}{if} (size >= LONG\_MAX) \textcolor{keywordflow}{return} LONG\_MAX + 1LU;
00944     \textcolor{keywordflow}{while}(1) \{
00945         \textcolor{keywordflow}{if} (i >= size)
00946             \textcolor{keywordflow}{return} i;
00947         i *= 2;
00948     \}
00949 \}
00950 
00951 \textcolor{comment}{/* Returns the index of a free slot that can be populated with}
00952 \textcolor{comment}{ * a hash entry for the given 'key'.}
00953 \textcolor{comment}{ * If the key already exists, -1 is returned}
00954 \textcolor{comment}{ * and the optional output parameter may be filled.}
00955 \textcolor{comment}{ *}
00956 \textcolor{comment}{ * Note that if we are in the process of rehashing the hash table, the}
00957 \textcolor{comment}{ * index is always returned in the context of the second (new) hash table. */}
00958 \textcolor{keyword}{static} \textcolor{keywordtype}{long} \_dictKeyIndex(dict *d, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key, uint64\_t hash, dictEntry **existing)
00959 \{
00960     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} idx, table;
00961     dictEntry *he;
00962     \textcolor{keywordflow}{if} (existing) *existing = NULL;
00963 
00964     \textcolor{comment}{/* Expand the hash table if needed */}
00965     \textcolor{keywordflow}{if} (\_dictExpandIfNeeded(d) == \hyperlink{dict_8h_a6ce31f31f044b1570d335e8fa0c388c6}{DICT\_ERR})
00966         \textcolor{keywordflow}{return} -1;
00967     \textcolor{keywordflow}{for} (table = 0; table <= 1; table++) \{
00968         idx = hash & d->ht[table].sizemask;
00969         \textcolor{comment}{/* Search if this slot does not already contain the given key */}
00970         he = d->ht[table].table[idx];
00971         \textcolor{keywordflow}{while}(he) \{
00972             \textcolor{keywordflow}{if} (key==he->key || \hyperlink{dict_8h_ab373389c580b8441ab28082cb7643762}{dictCompareKeys}(d, key, he->key)) \{
00973                 \textcolor{keywordflow}{if} (existing) *existing = he;
00974                 \textcolor{keywordflow}{return} -1;
00975             \}
00976             he = he->next;
00977         \}
00978         \textcolor{keywordflow}{if} (!\hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(d)) \textcolor{keywordflow}{break};
00979     \}
00980     \textcolor{keywordflow}{return} idx;
00981 \}
00982 
00983 \textcolor{keywordtype}{void} dictEmpty(dict *d, \textcolor{keywordtype}{void}(callback)(\textcolor{keywordtype}{void}*)) \{
00984     \_dictClear(d,&d->ht[0],callback);
00985     \_dictClear(d,&d->ht[1],callback);
00986     d->rehashidx = -1;
00987     d->iterators = 0;
00988 \}
00989 
00990 \textcolor{keywordtype}{void} dictEnableResize(\textcolor{keywordtype}{void}) \{
00991     dict\_can\_resize = 1;
00992 \}
00993 
00994 \textcolor{keywordtype}{void} dictDisableResize(\textcolor{keywordtype}{void}) \{
00995     dict\_can\_resize = 0;
00996 \}
00997 
00998 uint64\_t dictGetHash(dict *d, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key) \{
00999     \textcolor{keywordflow}{return} \hyperlink{dict_8h_a15a270e95a4eea30557df137e9747a95}{dictHashKey}(d, key);
01000 \}
01001 
01002 \textcolor{comment}{/* Finds the dictEntry reference by using pointer and pre-calculated hash.}
01003 \textcolor{comment}{ * oldkey is a dead pointer and should not be accessed.}
01004 \textcolor{comment}{ * the hash value should be provided using dictGetHash.}
01005 \textcolor{comment}{ * no string / key comparison is performed.}
01006 \textcolor{comment}{ * return value is the reference to the dictEntry if found, or NULL if not found. */}
01007 dictEntry **dictFindEntryRefByPtrAndHash(dict *d, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *oldptr, uint64\_t hash) \{
01008     dictEntry *he, **heref;
01009     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} idx, table;
01010 
01011     \textcolor{keywordflow}{if} (d->ht[0].used + d->ht[1].used == 0) \textcolor{keywordflow}{return} NULL; \textcolor{comment}{/* dict is empty */}
01012     \textcolor{keywordflow}{for} (table = 0; table <= 1; table++) \{
01013         idx = hash & d->ht[table].sizemask;
01014         heref = &d->ht[table].table[idx];
01015         he = *heref;
01016         \textcolor{keywordflow}{while}(he) \{
01017             \textcolor{keywordflow}{if} (oldptr==he->key)
01018                 \textcolor{keywordflow}{return} heref;
01019             heref = &he->next;
01020             he = *heref;
01021         \}
01022         \textcolor{keywordflow}{if} (!\hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(d)) \textcolor{keywordflow}{return} NULL;
01023     \}
01024     \textcolor{keywordflow}{return} NULL;
01025 \}
01026 
01027 \textcolor{comment}{/* ------------------------------- Debugging ---------------------------------*/}
01028 
01029 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{DICT\_STATS\_VECTLEN} 50
01030 size\_t \_dictGetStatsHt(\textcolor{keywordtype}{char} *buf, size\_t bufsize, dictht *ht, \textcolor{keywordtype}{int} tableid) \{
01031     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} i, slots = 0, chainlen, maxchainlen = 0;
01032     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} totchainlen = 0;
01033     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} clvector[\hyperlink{dict_8c_a6c5f3134060f1ca17b2371b4271bbe64}{DICT\_STATS\_VECTLEN}];
01034     size\_t l = 0;
01035 
01036     \textcolor{keywordflow}{if} (ht->used == 0) \{
01037         \textcolor{keywordflow}{return} snprintf(buf,bufsize,
01038             \textcolor{stringliteral}{"No stats available for empty dictionaries\(\backslash\)n"});
01039     \}
01040 
01041     \textcolor{comment}{/* Compute stats. */}
01042     \textcolor{keywordflow}{for} (i = 0; i < \hyperlink{dict_8c_a6c5f3134060f1ca17b2371b4271bbe64}{DICT\_STATS\_VECTLEN}; i++) clvector[i] = 0;
01043     \textcolor{keywordflow}{for} (i = 0; i < ht->size; i++) \{
01044         dictEntry *he;
01045 
01046         \textcolor{keywordflow}{if} (ht->table[i] == NULL) \{
01047             clvector[0]++;
01048             \textcolor{keywordflow}{continue};
01049         \}
01050         slots++;
01051         \textcolor{comment}{/* For each hash entry on this slot... */}
01052         chainlen = 0;
01053         he = ht->table[i];
01054         \textcolor{keywordflow}{while}(he) \{
01055             chainlen++;
01056             he = he->next;
01057         \}
01058         clvector[(chainlen < \hyperlink{dict_8c_a6c5f3134060f1ca17b2371b4271bbe64}{DICT\_STATS\_VECTLEN}) ? chainlen : (
      \hyperlink{dict_8c_a6c5f3134060f1ca17b2371b4271bbe64}{DICT\_STATS\_VECTLEN}-1)]++;
01059         \textcolor{keywordflow}{if} (chainlen > maxchainlen) maxchainlen = chainlen;
01060         totchainlen += chainlen;
01061     \}
01062 
01063     \textcolor{comment}{/* Generate human readable stats. */}
01064     l += snprintf(buf+l,bufsize-l,
01065         \textcolor{stringliteral}{"Hash table %d stats (%s):\(\backslash\)n"}
01066         \textcolor{stringliteral}{" table size: %ld\(\backslash\)n"}
01067         \textcolor{stringliteral}{" number of elements: %ld\(\backslash\)n"}
01068         \textcolor{stringliteral}{" different slots: %ld\(\backslash\)n"}
01069         \textcolor{stringliteral}{" max chain length: %ld\(\backslash\)n"}
01070         \textcolor{stringliteral}{" avg chain length (counted): %.02f\(\backslash\)n"}
01071         \textcolor{stringliteral}{" avg chain length (computed): %.02f\(\backslash\)n"}
01072         \textcolor{stringliteral}{" Chain length distribution:\(\backslash\)n"},
01073         tableid, (tableid == 0) ? \textcolor{stringliteral}{"main hash table"} : \textcolor{stringliteral}{"rehashing target"},
01074         ht->size, ht->used, slots, maxchainlen,
01075         (\textcolor{keywordtype}{float})totchainlen/slots, (\textcolor{keywordtype}{float})ht->used/slots);
01076 
01077     \textcolor{keywordflow}{for} (i = 0; i < \hyperlink{dict_8c_a6c5f3134060f1ca17b2371b4271bbe64}{DICT\_STATS\_VECTLEN}-1; i++) \{
01078         \textcolor{keywordflow}{if} (clvector[i] == 0) \textcolor{keywordflow}{continue};
01079         \textcolor{keywordflow}{if} (l >= bufsize) \textcolor{keywordflow}{break};
01080         l += snprintf(buf+l,bufsize-l,
01081             \textcolor{stringliteral}{"   %s%ld: %ld (%.02f%%)\(\backslash\)n"},
01082             (i == \hyperlink{dict_8c_a6c5f3134060f1ca17b2371b4271bbe64}{DICT\_STATS\_VECTLEN}-1)?\textcolor{stringliteral}{">= "}:\textcolor{stringliteral}{""},
01083             i, clvector[i], ((\textcolor{keywordtype}{float})clvector[i]/ht->size)*100);
01084     \}
01085 
01086     \textcolor{comment}{/* Unlike snprintf(), teturn the number of characters actually written. */}
01087     \textcolor{keywordflow}{if} (bufsize) buf[bufsize-1] = \textcolor{stringliteral}{'\(\backslash\)0'};
01088     \textcolor{keywordflow}{return} strlen(buf);
01089 \}
01090 
01091 \textcolor{keywordtype}{void} dictGetStats(\textcolor{keywordtype}{char} *buf, size\_t bufsize, dict *d) \{
01092     size\_t l;
01093     \textcolor{keywordtype}{char} *orig\_buf = buf;
01094     size\_t orig\_bufsize = bufsize;
01095 
01096     l = \_dictGetStatsHt(buf,bufsize,&d->ht[0],0);
01097     buf += l;
01098     bufsize -= l;
01099     \textcolor{keywordflow}{if} (\hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(d) && bufsize > 0) \{
01100         \_dictGetStatsHt(buf,bufsize,&d->ht[1],1);
01101     \}
01102     \textcolor{comment}{/* Make sure there is a NULL term at the end. */}
01103     \textcolor{keywordflow}{if} (orig\_bufsize) orig\_buf[orig\_bufsize-1] = \textcolor{stringliteral}{'\(\backslash\)0'};
01104 \}
01105 
01106 \textcolor{comment}{/* ------------------------------- Benchmark ---------------------------------*/}
01107 
01108 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \textcolor{preprocessor}{DICT\_BENCHMARK\_MAIN}
01109 
01110 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{stringliteral}{"sds.h"}
01111 
01112 uint64\_t hashCallback(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *key) \{
01113     \textcolor{keywordflow}{return} dictGenHashFunction((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)key, sdslen((\textcolor{keywordtype}{char}*)key));
01114 \}
01115 
01116 \textcolor{keywordtype}{int} compareCallback(\textcolor{keywordtype}{void} *privdata, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key1, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key2) \{
01117     \textcolor{keywordtype}{int} l1,l2;
01118     DICT\_NOTUSED(privdata);
01119 
01120     l1 = sdslen((sds)key1);
01121     l2 = sdslen((sds)key2);
01122     \textcolor{keywordflow}{if} (l1 != l2) \textcolor{keywordflow}{return} 0;
01123     \textcolor{keywordflow}{return} memcmp(key1, key2, l1) == 0;
01124 \}
01125 
01126 \textcolor{keywordtype}{void} freeCallback(\textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{void} *val) \{
01127     DICT\_NOTUSED(privdata);
01128 
01129     sdsfree(val);
01130 \}
01131 
01132 dictType BenchmarkDictType = \{
01133     hashCallback,
01134     NULL,
01135     NULL,
01136     compareCallback,
01137     freeCallback,
01138     NULL
01139 \};
01140 
01141 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{start\_benchmark}\textcolor{preprocessor}{(}\textcolor{preprocessor}{)} \textcolor{preprocessor}{start} \textcolor{preprocessor}{=} \textcolor{preprocessor}{timeInMilliseconds}\textcolor{preprocessor}{(}\textcolor{preprocessor}{)}
01142 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{end\_benchmark}\textcolor{preprocessor}{(}\textcolor{preprocessor}{msg}\textcolor{preprocessor}{)} \textcolor{preprocessor}{do} \textcolor{preprocessor}{\{}
01143     \textcolor{preprocessor}{elapsed} \textcolor{preprocessor}{=} \textcolor{preprocessor}{timeInMilliseconds}\textcolor{preprocessor}{(}\textcolor{preprocessor}{)}\textcolor{preprocessor}{-}\textcolor{preprocessor}{start}\textcolor{preprocessor}{;}
01144     \textcolor{preprocessor}{printf}\textcolor{preprocessor}{(}\textcolor{preprocessor}{msg} \textcolor{stringliteral}{": %ld items in %lld ms\(\backslash\)n"}\textcolor{preprocessor}{,} \textcolor{preprocessor}{count}\textcolor{preprocessor}{,} \textcolor{preprocessor}{elapsed}\textcolor{preprocessor}{)}\textcolor{preprocessor}{;} \textcolor{preprocessor}{\(\backslash\)}
01145 \textcolor{preprocessor}{\}}\textcolor{preprocessor}{while}\textcolor{preprocessor}{(}0\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
01146 
01147 \textcolor{comment}{/* dict-benchmark [count] */}
01148 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
01149     \textcolor{keywordtype}{long} j;
01150     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} start, elapsed;
01151     dict *dict = dictCreate(&BenchmarkDictType,NULL);
01152     \textcolor{keywordtype}{long} count = 0;
01153 
01154     \textcolor{keywordflow}{if} (argc == 2) \{
01155         count = strtol(argv[1],NULL,10);
01156     \} \textcolor{keywordflow}{else} \{
01157         count = 5000000;
01158     \}
01159 
01160     start\_benchmark();
01161     \textcolor{keywordflow}{for} (j = 0; j < count; j++) \{
01162         \textcolor{keywordtype}{int} retval = dictAdd(dict,sdsfromlonglong(j),(\textcolor{keywordtype}{void}*)j);
01163         assert(retval == DICT\_OK);
01164     \}
01165     end\_benchmark(\textcolor{stringliteral}{"Inserting"});
01166     assert((\textcolor{keywordtype}{long})dictSize(dict) == count);
01167 
01168     \textcolor{comment}{/* Wait for rehashing. */}
01169     \textcolor{keywordflow}{while} (dictIsRehashing(dict)) \{
01170         dictRehashMilliseconds(dict,100);
01171     \}
01172 
01173     start\_benchmark();
01174     \textcolor{keywordflow}{for} (j = 0; j < count; j++) \{
01175         sds key = sdsfromlonglong(j);
01176         dictEntry *de = dictFind(dict,key);
01177         assert(de != NULL);
01178         sdsfree(key);
01179     \}
01180     end\_benchmark(\textcolor{stringliteral}{"Linear access of existing elements"});
01181 
01182     start\_benchmark();
01183     \textcolor{keywordflow}{for} (j = 0; j < count; j++) \{
01184         sds key = sdsfromlonglong(j);
01185         dictEntry *de = dictFind(dict,key);
01186         assert(de != NULL);
01187         sdsfree(key);
01188     \}
01189     end\_benchmark(\textcolor{stringliteral}{"Linear access of existing elements (2nd round)"});
01190 
01191     start\_benchmark();
01192     \textcolor{keywordflow}{for} (j = 0; j < count; j++) \{
01193         sds key = sdsfromlonglong(rand() % count);
01194         dictEntry *de = dictFind(dict,key);
01195         assert(de != NULL);
01196         sdsfree(key);
01197     \}
01198     end\_benchmark(\textcolor{stringliteral}{"Random access of existing elements"});
01199 
01200     start\_benchmark();
01201     \textcolor{keywordflow}{for} (j = 0; j < count; j++) \{
01202         sds key = sdsfromlonglong(rand() % count);
01203         key[0] = \textcolor{stringliteral}{'X'};
01204         dictEntry *de = dictFind(dict,key);
01205         assert(de == NULL);
01206         sdsfree(key);
01207     \}
01208     end\_benchmark(\textcolor{stringliteral}{"Accessing missing"});
01209 
01210     start\_benchmark();
01211     \textcolor{keywordflow}{for} (j = 0; j < count; j++) \{
01212         sds key = sdsfromlonglong(j);
01213         \textcolor{keywordtype}{int} retval = dictDelete(dict,key);
01214         assert(retval == DICT\_OK);
01215         key[0] += 17; \textcolor{comment}{/* Change first number to letter. */}
01216         retval = dictAdd(dict,key,(\textcolor{keywordtype}{void}*)j);
01217         assert(retval == DICT\_OK);
01218     \}
01219     end\_benchmark(\textcolor{stringliteral}{"Removing and adding"});
01220 \}
01221 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
\end{DoxyCode}
