\hypertarget{syncio_8c_source}{}\section{syncio.\+c}
\label{syncio_8c_source}\index{src/syncio.\+c@{src/syncio.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* Synchronous socket and file I/O operations useful across the core.}
00002 \textcolor{comment}{ *}
00003 \textcolor{comment}{ * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>}
00004 \textcolor{comment}{ * All rights reserved.}
00005 \textcolor{comment}{ *}
00006 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00007 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00008 \textcolor{comment}{ *}
00009 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00010 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00011 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00012 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00013 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00014 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00015 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00016 \textcolor{comment}{ *     specific prior written permission.}
00017 \textcolor{comment}{ *}
00018 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00019 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00020 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00021 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00022 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00023 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00024 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00025 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00026 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00027 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00028 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00029 \textcolor{comment}{ */}
00030 
00031 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{server_8h}{"server.h"}
00032 
00033 \textcolor{comment}{/* ----------------- Blocking sockets I/O with timeouts --------------------- */}
00034 
00035 \textcolor{comment}{/* Redis performs most of the I/O in a nonblocking way, with the exception}
00036 \textcolor{comment}{ * of the SYNC command where the slave does it in a blocking way, and}
00037 \textcolor{comment}{ * the MIGRATE command that must be blocking in order to be atomic from the}
00038 \textcolor{comment}{ * point of view of the two instances (one migrating the key and one receiving}
00039 \textcolor{comment}{ * the key). This is why need the following blocking I/O functions.}
00040 \textcolor{comment}{ *}
00041 \textcolor{comment}{ * All the functions take the timeout in milliseconds. */}
00042 
00043 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SYNCIO\_\_RESOLUTION} 10 \textcolor{comment}{/* Resolution in milliseconds */}
00044 
00045 \textcolor{comment}{/* Write the specified payload to 'fd'. If writing the whole payload will be}
00046 \textcolor{comment}{ * done within 'timeout' milliseconds the operation succeeds and 'size' is}
00047 \textcolor{comment}{ * returned. Otherwise the operation fails, -1 is returned, and an unspecified}
00048 \textcolor{comment}{ * partial write could be performed against the file descriptor. */}
00049 ssize\_t syncWrite(\textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{char} *ptr, ssize\_t size, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} timeout) \{
00050     ssize\_t nwritten, ret = size;
00051     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} start = mstime();
00052     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} remaining = timeout;
00053 
00054     \textcolor{keywordflow}{while}(1) \{
00055         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} wait = (remaining > \hyperlink{syncio_8c_abba2f131af11e3cf265355831c9bcbb2}{SYNCIO\_\_RESOLUTION}) ?
00056                           remaining : \hyperlink{syncio_8c_abba2f131af11e3cf265355831c9bcbb2}{SYNCIO\_\_RESOLUTION};
00057         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} elapsed;
00058 
00059         \textcolor{comment}{/* Optimistically try to write before checking if the file descriptor}
00060 \textcolor{comment}{         * is actually writable. At worst we get EAGAIN. */}
00061         nwritten = write(fd,ptr,size);
00062         \textcolor{keywordflow}{if} (nwritten == -1) \{
00063             \textcolor{keywordflow}{if} (errno != EAGAIN) \textcolor{keywordflow}{return} -1;
00064         \} \textcolor{keywordflow}{else} \{
00065             ptr += nwritten;
00066             size -= nwritten;
00067         \}
00068         \textcolor{keywordflow}{if} (size == 0) \textcolor{keywordflow}{return} ret;
00069 
00070         \textcolor{comment}{/* Wait */}
00071         aeWait(fd,\hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE},wait);
00072         elapsed = mstime() - start;
00073         \textcolor{keywordflow}{if} (elapsed >= timeout) \{
00074             errno = ETIMEDOUT;
00075             \textcolor{keywordflow}{return} -1;
00076         \}
00077         remaining = timeout - elapsed;
00078     \}
00079 \}
00080 
00081 \textcolor{comment}{/* Read the specified amount of bytes from 'fd'. If all the bytes are read}
00082 \textcolor{comment}{ * within 'timeout' milliseconds the operation succeed and 'size' is returned.}
00083 \textcolor{comment}{ * Otherwise the operation fails, -1 is returned, and an unspecified amount of}
00084 \textcolor{comment}{ * data could be read from the file descriptor. */}
00085 ssize\_t syncRead(\textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{char} *ptr, ssize\_t size, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} timeout) \{
00086     ssize\_t nread, totread = 0;
00087     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} start = mstime();
00088     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} remaining = timeout;
00089 
00090     \textcolor{keywordflow}{if} (size == 0) \textcolor{keywordflow}{return} 0;
00091     \textcolor{keywordflow}{while}(1) \{
00092         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} wait = (remaining > \hyperlink{syncio_8c_abba2f131af11e3cf265355831c9bcbb2}{SYNCIO\_\_RESOLUTION}) ?
00093                           remaining : \hyperlink{syncio_8c_abba2f131af11e3cf265355831c9bcbb2}{SYNCIO\_\_RESOLUTION};
00094         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} elapsed;
00095 
00096         \textcolor{comment}{/* Optimistically try to read before checking if the file descriptor}
00097 \textcolor{comment}{         * is actually readable. At worst we get EAGAIN. */}
00098         nread = read(fd,ptr,size);
00099         \textcolor{keywordflow}{if} (nread == 0) \textcolor{keywordflow}{return} -1; \textcolor{comment}{/* short read. */}
00100         \textcolor{keywordflow}{if} (nread == -1) \{
00101             \textcolor{keywordflow}{if} (errno != EAGAIN) \textcolor{keywordflow}{return} -1;
00102         \} \textcolor{keywordflow}{else} \{
00103             ptr += nread;
00104             size -= nread;
00105             totread += nread;
00106         \}
00107         \textcolor{keywordflow}{if} (size == 0) \textcolor{keywordflow}{return} totread;
00108 
00109         \textcolor{comment}{/* Wait */}
00110         aeWait(fd,\hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE},wait);
00111         elapsed = mstime() - start;
00112         \textcolor{keywordflow}{if} (elapsed >= timeout) \{
00113             errno = ETIMEDOUT;
00114             \textcolor{keywordflow}{return} -1;
00115         \}
00116         remaining = timeout - elapsed;
00117     \}
00118 \}
00119 
00120 \textcolor{comment}{/* Read a line making sure that every char will not require more than 'timeout'}
00121 \textcolor{comment}{ * milliseconds to be read.}
00122 \textcolor{comment}{ *}
00123 \textcolor{comment}{ * On success the number of bytes read is returned, otherwise -1.}
00124 \textcolor{comment}{ * On success the string is always correctly terminated with a 0 byte. */}
00125 ssize\_t syncReadLine(\textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{char} *ptr, ssize\_t size, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} timeout) \{
00126     ssize\_t nread = 0;
00127 
00128     size--;
00129     \textcolor{keywordflow}{while}(size) \{
00130         \textcolor{keywordtype}{char} c;
00131 
00132         \textcolor{keywordflow}{if} (syncRead(fd,&c,1,timeout) == -1) \textcolor{keywordflow}{return} -1;
00133         \textcolor{keywordflow}{if} (c == \textcolor{stringliteral}{'\(\backslash\)n'}) \{
00134             *ptr = \textcolor{stringliteral}{'\(\backslash\)0'};
00135             \textcolor{keywordflow}{if} (nread && *(ptr-1) == \textcolor{stringliteral}{'\(\backslash\)r'}) *(ptr-1) = \textcolor{stringliteral}{'\(\backslash\)0'};
00136             \textcolor{keywordflow}{return} nread;
00137         \} \textcolor{keywordflow}{else} \{
00138             *ptr++ = c;
00139             *ptr = \textcolor{stringliteral}{'\(\backslash\)0'};
00140             nread++;
00141         \}
00142         size--;
00143     \}
00144     \textcolor{keywordflow}{return} nread;
00145 \}
\end{DoxyCode}
