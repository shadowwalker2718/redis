\hypertarget{replication_8c_source}{}\section{replication.\+c}
\label{replication_8c_source}\index{src/replication.\+c@{src/replication.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* Asynchronous replication implementation.}
00002 \textcolor{comment}{ *}
00003 \textcolor{comment}{ * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>}
00004 \textcolor{comment}{ * All rights reserved.}
00005 \textcolor{comment}{ *}
00006 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00007 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00008 \textcolor{comment}{ *}
00009 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00010 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00011 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00012 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00013 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00014 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00015 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00016 \textcolor{comment}{ *     specific prior written permission.}
00017 \textcolor{comment}{ *}
00018 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00019 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00020 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00021 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00022 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00023 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00024 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00025 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00026 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00027 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00028 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00029 \textcolor{comment}{ */}
00030 
00031 
00032 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{server_8h}{"server.h"}
00033 
00034 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{time}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00035 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{unistd}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00036 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{fcntl}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00037 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{socket}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00038 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{stat}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00039 
00040 \textcolor{keywordtype}{void} replicationDiscardCachedMaster(\textcolor{keywordtype}{void});
00041 \textcolor{keywordtype}{void} replicationResurrectCachedMaster(\textcolor{keywordtype}{int} newfd);
00042 \textcolor{keywordtype}{void} replicationSendAck(\textcolor{keywordtype}{void});
00043 \textcolor{keywordtype}{void} putSlaveOnline(\hyperlink{structclient}{client} *slave);
00044 \textcolor{keywordtype}{int} cancelReplicationHandshake(\textcolor{keywordtype}{void});
00045 
00046 \textcolor{comment}{/* --------------------------- Utility functions ---------------------------- */}
00047 
00048 \textcolor{comment}{/* Return the pointer to a string representing the slave ip:listening\_port}
00049 \textcolor{comment}{ * pair. Mostly useful for logging, since we want to log a slave using its}
00050 \textcolor{comment}{ * IP address and its listening port which is more clear for the user, for}
00051 \textcolor{comment}{ * example: "Closing connection with slave 10.1.2.3:6380". */}
00052 \textcolor{keywordtype}{char} *replicationGetSlaveName(\hyperlink{structclient}{client} *c) \{
00053     \textcolor{keyword}{static} \textcolor{keywordtype}{char} buf[\hyperlink{server_8h_a39a30f77e23c1994e70b6c9bc892dee9}{NET\_PEER\_ID\_LEN}];
00054     \textcolor{keywordtype}{char} ip[\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN}];
00055 
00056     ip[0] = \textcolor{stringliteral}{'\(\backslash\)0'};
00057     buf[0] = \textcolor{stringliteral}{'\(\backslash\)0'};
00058     \textcolor{keywordflow}{if} (c->slave\_ip[0] != \textcolor{stringliteral}{'\(\backslash\)0'} ||
00059         anetPeerToString(c->fd,ip,\textcolor{keyword}{sizeof}(ip),NULL) != -1)
00060     \{
00061         \textcolor{comment}{/* Note that the 'ip' buffer is always larger than 'c->slave\_ip' */}
00062         \textcolor{keywordflow}{if} (c->slave\_ip[0] != \textcolor{stringliteral}{'\(\backslash\)0'}) memcpy(ip,c->slave\_ip,\textcolor{keyword}{sizeof}(c->slave\_ip));
00063 
00064         \textcolor{keywordflow}{if} (c->slave\_listening\_port)
00065             anetFormatAddr(buf,\textcolor{keyword}{sizeof}(buf),ip,c->slave\_listening\_port);
00066         \textcolor{keywordflow}{else}
00067             snprintf(buf,\textcolor{keyword}{sizeof}(buf),\textcolor{stringliteral}{"%s:<unknown-slave-port>"},ip);
00068     \} \textcolor{keywordflow}{else} \{
00069         snprintf(buf,\textcolor{keyword}{sizeof}(buf),\textcolor{stringliteral}{"client id #%llu"},
00070             (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) c->id);
00071     \}
00072     \textcolor{keywordflow}{return} buf;
00073 \}
00074 
00075 \textcolor{comment}{/* ---------------------------------- MASTER -------------------------------- */}
00076 
00077 \textcolor{keywordtype}{void} createReplicationBacklog(\textcolor{keywordtype}{void}) \{
00078     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(server.repl\_backlog == NULL);
00079     server.repl\_backlog = zmalloc(server.repl\_backlog\_size);
00080     server.repl\_backlog\_histlen = 0;
00081     server.repl\_backlog\_idx = 0;
00082 
00083     \textcolor{comment}{/* We don't have any data inside our buffer, but virtually the first}
00084 \textcolor{comment}{     * byte we have is the next byte that will be generated for the}
00085 \textcolor{comment}{     * replication stream. */}
00086     server.repl\_backlog\_off = server.master\_repl\_offset+1;
00087 \}
00088 
00089 \textcolor{comment}{/* This function is called when the user modifies the replication backlog}
00090 \textcolor{comment}{ * size at runtime. It is up to the function to both update the}
00091 \textcolor{comment}{ * server.repl\_backlog\_size and to resize the buffer and setup it so that}
00092 \textcolor{comment}{ * it contains the same data as the previous one (possibly less data, but}
00093 \textcolor{comment}{ * the most recent bytes, or the same data and more free space in case the}
00094 \textcolor{comment}{ * buffer is enlarged). */}
00095 \textcolor{keywordtype}{void} resizeReplicationBacklog(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} newsize) \{
00096     \textcolor{keywordflow}{if} (newsize < \hyperlink{server_8h_a72c70207aaa211eadddba3f42e73a3b5}{CONFIG\_REPL\_BACKLOG\_MIN\_SIZE})
00097         newsize = \hyperlink{server_8h_a72c70207aaa211eadddba3f42e73a3b5}{CONFIG\_REPL\_BACKLOG\_MIN\_SIZE};
00098     \textcolor{keywordflow}{if} (server.repl\_backlog\_size == newsize) \textcolor{keywordflow}{return};
00099 
00100     server.repl\_backlog\_size = newsize;
00101     \textcolor{keywordflow}{if} (server.repl\_backlog != NULL) \{
00102         \textcolor{comment}{/* What we actually do is to flush the old buffer and realloc a new}
00103 \textcolor{comment}{         * empty one. It will refill with new data incrementally.}
00104 \textcolor{comment}{         * The reason is that copying a few gigabytes adds latency and even}
00105 \textcolor{comment}{         * worse often we need to alloc additional space before freeing the}
00106 \textcolor{comment}{         * old buffer. */}
00107         zfree(server.repl\_backlog);
00108         server.repl\_backlog = zmalloc(server.repl\_backlog\_size);
00109         server.repl\_backlog\_histlen = 0;
00110         server.repl\_backlog\_idx = 0;
00111         \textcolor{comment}{/* Next byte we have is... the next since the buffer is empty. */}
00112         server.repl\_backlog\_off = server.master\_repl\_offset+1;
00113     \}
00114 \}
00115 
00116 \textcolor{keywordtype}{void} freeReplicationBacklog(\textcolor{keywordtype}{void}) \{
00117     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.slaves) == 0);
00118     zfree(server.repl\_backlog);
00119     server.repl\_backlog = NULL;
00120 \}
00121 
00122 \textcolor{comment}{/* Add data to the replication backlog.}
00123 \textcolor{comment}{ * This function also increments the global replication offset stored at}
00124 \textcolor{comment}{ * server.master\_repl\_offset, because there is no case where we want to feed}
00125 \textcolor{comment}{ * the backlog without incrementing the offset. */}
00126 \textcolor{keywordtype}{void} feedReplicationBacklog(\textcolor{keywordtype}{void} *ptr, size\_t len) \{
00127     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p = ptr;
00128 
00129     server.master\_repl\_offset += len;
00130 
00131     \textcolor{comment}{/* This is a circular buffer, so write as much data we can at every}
00132 \textcolor{comment}{     * iteration and rewind the "idx" index if we reach the limit. */}
00133     \textcolor{keywordflow}{while}(len) \{
00134         size\_t thislen = server.repl\_backlog\_size - server.repl\_backlog\_idx;
00135         \textcolor{keywordflow}{if} (thislen > len) thislen = len;
00136         memcpy(server.repl\_backlog+server.repl\_backlog\_idx,p,thislen);
00137         server.repl\_backlog\_idx += thislen;
00138         \textcolor{keywordflow}{if} (server.repl\_backlog\_idx == server.repl\_backlog\_size)
00139             server.repl\_backlog\_idx = 0;
00140         len -= thislen;
00141         p += thislen;
00142         server.repl\_backlog\_histlen += thislen;
00143     \}
00144     \textcolor{keywordflow}{if} (server.repl\_backlog\_histlen > server.repl\_backlog\_size)
00145         server.repl\_backlog\_histlen = server.repl\_backlog\_size;
00146     \textcolor{comment}{/* Set the offset of the first byte we have in the backlog. */}
00147     server.repl\_backlog\_off = server.master\_repl\_offset -
00148                               server.repl\_backlog\_histlen + 1;
00149 \}
00150 
00151 \textcolor{comment}{/* Wrapper for feedReplicationBacklog() that takes Redis string objects}
00152 \textcolor{comment}{ * as input. */}
00153 \textcolor{keywordtype}{void} feedReplicationBacklogWithObject(robj *o) \{
00154     \textcolor{keywordtype}{char} llstr[\hyperlink{server_8h_a39ec35278876f65fc1ef70b049856ca3}{LONG\_STR\_SIZE}];
00155     \textcolor{keywordtype}{void} *p;
00156     size\_t len;
00157 
00158     \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_ae934cf008a0be0ef009c92c2d006a816}{OBJ\_ENCODING\_INT}) \{
00159         len = ll2string(llstr,\textcolor{keyword}{sizeof}(llstr),(\textcolor{keywordtype}{long})o->ptr);
00160         p = llstr;
00161     \} \textcolor{keywordflow}{else} \{
00162         len = sdslen(o->ptr);
00163         p = o->ptr;
00164     \}
00165     feedReplicationBacklog(p,len);
00166 \}
00167 
00168 \textcolor{comment}{/* Propagate write commands to slaves, and populate the replication backlog}
00169 \textcolor{comment}{ * as well. This function is used if the instance is a master: we use}
00170 \textcolor{comment}{ * the commands received by our clients in order to create the replication}
00171 \textcolor{comment}{ * stream. Instead if the instance is a slave and has sub-slaves attached,}
00172 \textcolor{comment}{ * we use replicationFeedSlavesFromMaster() */}
00173 \textcolor{keywordtype}{void} replicationFeedSlaves(list *slaves, \textcolor{keywordtype}{int} dictid, robj **argv, \textcolor{keywordtype}{int} argc) \{
00174     listNode *ln;
00175     listIter li;
00176     \textcolor{keywordtype}{int} j, len;
00177     \textcolor{keywordtype}{char} llstr[\hyperlink{server_8h_a39ec35278876f65fc1ef70b049856ca3}{LONG\_STR\_SIZE}];
00178 
00179     \textcolor{comment}{/* If the instance is not a top level master, return ASAP: we'll just proxy}
00180 \textcolor{comment}{     * the stream of data we receive from our master instead, in order to}
00181 \textcolor{comment}{     * propagate *identical* replication stream. In this way this slave can}
00182 \textcolor{comment}{     * advertise the same replication ID as the master (since it shares the}
00183 \textcolor{comment}{     * master replication history and has the same backlog and offsets). */}
00184     \textcolor{keywordflow}{if} (server.masterhost != NULL) \textcolor{keywordflow}{return};
00185 
00186     \textcolor{comment}{/* If there aren't slaves, and there is no backlog buffer to populate,}
00187 \textcolor{comment}{     * we can return ASAP. */}
00188     \textcolor{keywordflow}{if} (server.repl\_backlog == NULL && \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(slaves) == 0) \textcolor{keywordflow}{return};
00189 
00190     \textcolor{comment}{/* We can't have slaves attached and no backlog. */}
00191     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(!(\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(slaves) != 0 && server.repl\_backlog == NULL));
00192 
00193     \textcolor{comment}{/* Send SELECT command to every slave if needed. */}
00194     \textcolor{keywordflow}{if} (server.slaveseldb != dictid) \{
00195         robj *selectcmd;
00196 
00197         \textcolor{comment}{/* For a few DBs we have pre-computed SELECT command. */}
00198         \textcolor{keywordflow}{if} (dictid >= 0 && dictid < \hyperlink{server_8h_a950a6acbe9809f9e3dc541e8175b7b44}{PROTO\_SHARED\_SELECT\_CMDS}) \{
00199             selectcmd = shared.select[dictid];
00200         \} \textcolor{keywordflow}{else} \{
00201             \textcolor{keywordtype}{int} dictid\_len;
00202 
00203             dictid\_len = ll2string(llstr,\textcolor{keyword}{sizeof}(llstr),dictid);
00204             selectcmd = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},
00205                 sdscatprintf(sdsempty(),
00206                 \textcolor{stringliteral}{"*2\(\backslash\)r\(\backslash\)n$6\(\backslash\)r\(\backslash\)nSELECT\(\backslash\)r\(\backslash\)n$%d\(\backslash\)r\(\backslash\)n%s\(\backslash\)r\(\backslash\)n"},
00207                 dictid\_len, llstr));
00208         \}
00209 
00210         \textcolor{comment}{/* Add the SELECT command into the backlog. */}
00211         \textcolor{keywordflow}{if} (server.repl\_backlog) feedReplicationBacklogWithObject(selectcmd);
00212 
00213         \textcolor{comment}{/* Send it to slaves. */}
00214         listRewind(slaves,&li);
00215         \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
00216             \hyperlink{structclient}{client} *slave = ln->value;
00217             \textcolor{keywordflow}{if} (slave->replstate == \hyperlink{server_8h_a170ee2dd8cfefaf0d112edcc3152f8d7}{SLAVE\_STATE\_WAIT\_BGSAVE\_START}) \textcolor{keywordflow}{
      continue};
00218             addReply(slave,selectcmd);
00219         \}
00220 
00221         \textcolor{keywordflow}{if} (dictid < 0 || dictid >= \hyperlink{server_8h_a950a6acbe9809f9e3dc541e8175b7b44}{PROTO\_SHARED\_SELECT\_CMDS})
00222             decrRefCount(selectcmd);
00223     \}
00224     server.slaveseldb = dictid;
00225 
00226     \textcolor{comment}{/* Write the command to the replication backlog if any. */}
00227     \textcolor{keywordflow}{if} (server.repl\_backlog) \{
00228         \textcolor{keywordtype}{char} aux[\hyperlink{server_8h_a39ec35278876f65fc1ef70b049856ca3}{LONG\_STR\_SIZE}+3];
00229 
00230         \textcolor{comment}{/* Add the multi bulk reply length. */}
00231         aux[0] = \textcolor{stringliteral}{'*'};
00232         len = ll2string(aux+1,\textcolor{keyword}{sizeof}(aux)-1,argc);
00233         aux[len+1] = \textcolor{stringliteral}{'\(\backslash\)r'};
00234         aux[len+2] = \textcolor{stringliteral}{'\(\backslash\)n'};
00235         feedReplicationBacklog(aux,len+3);
00236 
00237         \textcolor{keywordflow}{for} (j = 0; j < argc; j++) \{
00238             \textcolor{keywordtype}{long} objlen = stringObjectLen(argv[j]);
00239 
00240             \textcolor{comment}{/* We need to feed the buffer with the object as a bulk reply}
00241 \textcolor{comment}{             * not just as a plain string, so create the $..CRLF payload len}
00242 \textcolor{comment}{             * and add the final CRLF */}
00243             aux[0] = \textcolor{stringliteral}{'$'};
00244             len = ll2string(aux+1,\textcolor{keyword}{sizeof}(aux)-1,objlen);
00245             aux[len+1] = \textcolor{stringliteral}{'\(\backslash\)r'};
00246             aux[len+2] = \textcolor{stringliteral}{'\(\backslash\)n'};
00247             feedReplicationBacklog(aux,len+3);
00248             feedReplicationBacklogWithObject(argv[j]);
00249             feedReplicationBacklog(aux+len+1,2);
00250         \}
00251     \}
00252 
00253     \textcolor{comment}{/* Write the command to every slave. */}
00254     listRewind(slaves,&li);
00255     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
00256         \hyperlink{structclient}{client} *slave = ln->value;
00257 
00258         \textcolor{comment}{/* Don't feed slaves that are still waiting for BGSAVE to start */}
00259         \textcolor{keywordflow}{if} (slave->replstate == \hyperlink{server_8h_a170ee2dd8cfefaf0d112edcc3152f8d7}{SLAVE\_STATE\_WAIT\_BGSAVE\_START}) \textcolor{keywordflow}{continue};
00260 
00261         \textcolor{comment}{/* Feed slaves that are waiting for the initial SYNC (so these commands}
00262 \textcolor{comment}{         * are queued in the output buffer until the initial SYNC completes),}
00263 \textcolor{comment}{         * or are already in sync with the master. */}
00264 
00265         \textcolor{comment}{/* Add the multi bulk length. */}
00266         addReplyMultiBulkLen(slave,argc);
00267 
00268         \textcolor{comment}{/* Finally any additional argument that was not stored inside the}
00269 \textcolor{comment}{         * static buffer if any (from j to argc). */}
00270         \textcolor{keywordflow}{for} (j = 0; j < argc; j++)
00271             addReplyBulk(slave,argv[j]);
00272     \}
00273 \}
00274 
00275 \textcolor{comment}{/* This function is used in order to proxy what we receive from our master}
00276 \textcolor{comment}{ * to our sub-slaves. */}
00277 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{ctype}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00278 \textcolor{keywordtype}{void} replicationFeedSlavesFromMasterStream(list *slaves, \textcolor{keywordtype}{char} *buf, size\_t buflen) \{
00279     listNode *ln;
00280     listIter li;
00281 
00282     \textcolor{comment}{/* Debugging: this is handy to see the stream sent from master}
00283 \textcolor{comment}{     * to slaves. Disabled with if(0). */}
00284     \textcolor{keywordflow}{if} (0) \{
00285         printf(\textcolor{stringliteral}{"%zu:"},buflen);
00286         \textcolor{keywordflow}{for} (size\_t j = 0; j < buflen; j++) \{
00287             printf(\textcolor{stringliteral}{"%c"}, isprint(buf[j]) ? buf[j] : \textcolor{stringliteral}{'.'});
00288         \}
00289         printf(\textcolor{stringliteral}{"\(\backslash\)n"});
00290     \}
00291 
00292     \textcolor{keywordflow}{if} (server.repl\_backlog) feedReplicationBacklog(buf,buflen);
00293     listRewind(slaves,&li);
00294     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
00295         \hyperlink{structclient}{client} *slave = ln->value;
00296 
00297         \textcolor{comment}{/* Don't feed slaves that are still waiting for BGSAVE to start */}
00298         \textcolor{keywordflow}{if} (slave->replstate == \hyperlink{server_8h_a170ee2dd8cfefaf0d112edcc3152f8d7}{SLAVE\_STATE\_WAIT\_BGSAVE\_START}) \textcolor{keywordflow}{continue};
00299         addReplyString(slave,buf,buflen);
00300     \}
00301 \}
00302 
00303 \textcolor{keywordtype}{void} replicationFeedMonitors(\hyperlink{structclient}{client} *c, list *monitors, \textcolor{keywordtype}{int} dictid, robj **argv, \textcolor{keywordtype}{int} argc) \{
00304     listNode *ln;
00305     listIter li;
00306     \textcolor{keywordtype}{int} j;
00307     sds cmdrepr = sdsnew(\textcolor{stringliteral}{"+"});
00308     robj *cmdobj;
00309     \textcolor{keyword}{struct} timeval tv;
00310 
00311     gettimeofday(&tv,NULL);
00312     cmdrepr = sdscatprintf(cmdrepr,\textcolor{stringliteral}{"%ld.%06ld "},(\textcolor{keywordtype}{long})tv.tv\_sec,(\textcolor{keywordtype}{long})tv.tv\_usec);
00313     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_af9d0b0f45ef2c1fd29ac714a300de706}{CLIENT\_LUA}) \{
00314         cmdrepr = sdscatprintf(cmdrepr,\textcolor{stringliteral}{"[%d lua] "},dictid);
00315     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_ae19f45757ef3ffb2f3abb86cbc3b67a2}{CLIENT\_UNIX\_SOCKET}) \{
00316         cmdrepr = sdscatprintf(cmdrepr,\textcolor{stringliteral}{"[%d unix:%s] "},dictid,server.unixsocket);
00317     \} \textcolor{keywordflow}{else} \{
00318         cmdrepr = sdscatprintf(cmdrepr,\textcolor{stringliteral}{"[%d %s] "},dictid,getClientPeerId(c));
00319     \}
00320 
00321     \textcolor{keywordflow}{for} (j = 0; j < argc; j++) \{
00322         \textcolor{keywordflow}{if} (argv[j]->encoding == \hyperlink{server_8h_ae934cf008a0be0ef009c92c2d006a816}{OBJ\_ENCODING\_INT}) \{
00323             cmdrepr = sdscatprintf(cmdrepr, \textcolor{stringliteral}{"\(\backslash\)"%ld\(\backslash\)""}, (\textcolor{keywordtype}{long})argv[j]->ptr);
00324         \} \textcolor{keywordflow}{else} \{
00325             cmdrepr = sdscatrepr(cmdrepr,(\textcolor{keywordtype}{char}*)argv[j]->ptr,
00326                         sdslen(argv[j]->ptr));
00327         \}
00328         \textcolor{keywordflow}{if} (j != argc-1)
00329             cmdrepr = sdscatlen(cmdrepr,\textcolor{stringliteral}{" "},1);
00330     \}
00331     cmdrepr = sdscatlen(cmdrepr,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"},2);
00332     cmdobj = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},cmdrepr);
00333 
00334     listRewind(monitors,&li);
00335     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
00336         \hyperlink{structclient}{client} *monitor = ln->value;
00337         addReply(monitor,cmdobj);
00338     \}
00339     decrRefCount(cmdobj);
00340 \}
00341 
00342 \textcolor{comment}{/* Feed the slave 'c' with the replication backlog starting from the}
00343 \textcolor{comment}{ * specified 'offset' up to the end of the backlog. */}
00344 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} addReplyReplicationBacklog(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} offset) \{
00345     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} j, skip, len;
00346 
00347     serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG}, \textcolor{stringliteral}{"[PSYNC] Slave request offset: %lld"}, offset);
00348 
00349     \textcolor{keywordflow}{if} (server.repl\_backlog\_histlen == 0) \{
00350         serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG}, \textcolor{stringliteral}{"[PSYNC] Backlog history len is zero"});
00351         \textcolor{keywordflow}{return} 0;
00352     \}
00353 
00354     serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG}, \textcolor{stringliteral}{"[PSYNC] Backlog size: %lld"},
00355              server.repl\_backlog\_size);
00356     serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG}, \textcolor{stringliteral}{"[PSYNC] First byte: %lld"},
00357              server.repl\_backlog\_off);
00358     serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG}, \textcolor{stringliteral}{"[PSYNC] History len: %lld"},
00359              server.repl\_backlog\_histlen);
00360     serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG}, \textcolor{stringliteral}{"[PSYNC] Current index: %lld"},
00361              server.repl\_backlog\_idx);
00362 
00363     \textcolor{comment}{/* Compute the amount of bytes we need to discard. */}
00364     skip = offset - server.repl\_backlog\_off;
00365     serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG}, \textcolor{stringliteral}{"[PSYNC] Skipping: %lld"}, skip);
00366 
00367     \textcolor{comment}{/* Point j to the oldest byte, that is actually our}
00368 \textcolor{comment}{     * server.repl\_backlog\_off byte. */}
00369     j = (server.repl\_backlog\_idx +
00370         (server.repl\_backlog\_size-server.repl\_backlog\_histlen)) %
00371         server.repl\_backlog\_size;
00372     serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG}, \textcolor{stringliteral}{"[PSYNC] Index of first byte: %lld"}, j);
00373 
00374     \textcolor{comment}{/* Discard the amount of data to seek to the specified 'offset'. */}
00375     j = (j + skip) % server.repl\_backlog\_size;
00376 
00377     \textcolor{comment}{/* Feed slave with data. Since it is a circular buffer we have to}
00378 \textcolor{comment}{     * split the reply in two parts if we are cross-boundary. */}
00379     len = server.repl\_backlog\_histlen - skip;
00380     serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG}, \textcolor{stringliteral}{"[PSYNC] Reply total length: %lld"}, len);
00381     \textcolor{keywordflow}{while}(len) \{
00382         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} thislen =
00383             ((server.repl\_backlog\_size - j) < len) ?
00384             (server.repl\_backlog\_size - j) : len;
00385 
00386         serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG}, \textcolor{stringliteral}{"[PSYNC] addReply() length: %lld"}, thislen);
00387         addReplySds(c,sdsnewlen(server.repl\_backlog + j, thislen));
00388         len -= thislen;
00389         j = 0;
00390     \}
00391     \textcolor{keywordflow}{return} server.repl\_backlog\_histlen - skip;
00392 \}
00393 
00394 \textcolor{comment}{/* Return the offset to provide as reply to the PSYNC command received}
00395 \textcolor{comment}{ * from the slave. The returned value is only valid immediately after}
00396 \textcolor{comment}{ * the BGSAVE process started and before executing any other command}
00397 \textcolor{comment}{ * from clients. */}
00398 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} getPsyncInitialOffset(\textcolor{keywordtype}{void}) \{
00399     \textcolor{keywordflow}{return} server.master\_repl\_offset;
00400 \}
00401 
00402 \textcolor{comment}{/* Send a FULLRESYNC reply in the specific case of a full resynchronization,}
00403 \textcolor{comment}{ * as a side effect setup the slave for a full sync in different ways:}
00404 \textcolor{comment}{ *}
00405 \textcolor{comment}{ * 1) Remember, into the slave client structure, the replication offset}
00406 \textcolor{comment}{ *    we sent here, so that if new slaves will later attach to the same}
00407 \textcolor{comment}{ *    background RDB saving process (by duplicating this client output}
00408 \textcolor{comment}{ *    buffer), we can get the right offset from this slave.}
00409 \textcolor{comment}{ * 2) Set the replication state of the slave to WAIT\_BGSAVE\_END so that}
00410 \textcolor{comment}{ *    we start accumulating differences from this point.}
00411 \textcolor{comment}{ * 3) Force the replication stream to re-emit a SELECT statement so}
00412 \textcolor{comment}{ *    the new slave incremental differences will start selecting the}
00413 \textcolor{comment}{ *    right database number.}
00414 \textcolor{comment}{ *}
00415 \textcolor{comment}{ * Normally this function should be called immediately after a successful}
00416 \textcolor{comment}{ * BGSAVE for replication was started, or when there is one already in}
00417 \textcolor{comment}{ * progress that we attached our slave to. */}
00418 \textcolor{keywordtype}{int} replicationSetupSlaveForFullResync(\hyperlink{structclient}{client} *slave, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} offset) \{
00419     \textcolor{keywordtype}{char} buf[128];
00420     \textcolor{keywordtype}{int} buflen;
00421 
00422     slave->psync\_initial\_offset = offset;
00423     slave->replstate = \hyperlink{server_8h_a2a1b586e8f326f831f6ab466c8c3f38a}{SLAVE\_STATE\_WAIT\_BGSAVE\_END};
00424     \textcolor{comment}{/* We are going to accumulate the incremental changes for this}
00425 \textcolor{comment}{     * slave as well. Set slaveseldb to -1 in order to force to re-emit}
00426 \textcolor{comment}{     * a SELECT statement in the replication stream. */}
00427     server.slaveseldb = -1;
00428 
00429     \textcolor{comment}{/* Don't send this reply to slaves that approached us with}
00430 \textcolor{comment}{     * the old SYNC command. */}
00431     \textcolor{keywordflow}{if} (!(slave->flags & \hyperlink{server_8h_ac13d62411270bd658f6d82e711e0f912}{CLIENT\_PRE\_PSYNC})) \{
00432         buflen = snprintf(buf,\textcolor{keyword}{sizeof}(buf),\textcolor{stringliteral}{"+FULLRESYNC %s %lld\(\backslash\)r\(\backslash\)n"},
00433                           server.replid,offset);
00434         \textcolor{keywordflow}{if} (write(slave->fd,buf,buflen) != buflen) \{
00435             freeClientAsync(slave);
00436             \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00437         \}
00438     \}
00439     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00440 \}
00441 
00442 \textcolor{comment}{/* This function handles the PSYNC command from the point of view of a}
00443 \textcolor{comment}{ * master receiving a request for partial resynchronization.}
00444 \textcolor{comment}{ *}
00445 \textcolor{comment}{ * On success return C\_OK, otherwise C\_ERR is returned and we proceed}
00446 \textcolor{comment}{ * with the usual full resync. */}
00447 \textcolor{keywordtype}{int} masterTryPartialResynchronization(\hyperlink{structclient}{client} *c) \{
00448     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} psync\_offset, psync\_len;
00449     \textcolor{keywordtype}{char} *master\_replid = c->argv[1]->ptr;
00450     \textcolor{keywordtype}{char} buf[128];
00451     \textcolor{keywordtype}{int} buflen;
00452 
00453     \textcolor{comment}{/* Parse the replication offset asked by the slave. Go to full sync}
00454 \textcolor{comment}{     * on parse error: this should never happen but we try to handle}
00455 \textcolor{comment}{     * it in a robust way compared to aborting. */}
00456     \textcolor{keywordflow}{if} (getLongLongFromObjectOrReply(c,c->argv[2],&psync\_offset,NULL) !=
00457        \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \textcolor{keywordflow}{goto} need\_full\_resync;
00458 
00459     \textcolor{comment}{/* Is the replication ID of this master the same advertised by the wannabe}
00460 \textcolor{comment}{     * slave via PSYNC? If the replication ID changed this master has a}
00461 \textcolor{comment}{     * different replication history, and there is no way to continue.}
00462 \textcolor{comment}{     *}
00463 \textcolor{comment}{     * Note that there are two potentially valid replication IDs: the ID1}
00464 \textcolor{comment}{     * and the ID2. The ID2 however is only valid up to a specific offset. */}
00465     \textcolor{keywordflow}{if} (strcasecmp(master\_replid, server.replid) &&
00466         (strcasecmp(master\_replid, server.replid2) ||
00467          psync\_offset > server.second\_replid\_offset))
00468     \{
00469         \textcolor{comment}{/* Run id "?" is used by slaves that want to force a full resync. */}
00470         \textcolor{keywordflow}{if} (master\_replid[0] != \textcolor{stringliteral}{'?'}) \{
00471             \textcolor{keywordflow}{if} (strcasecmp(master\_replid, server.replid) &&
00472                 strcasecmp(master\_replid, server.replid2))
00473             \{
00474                 serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Partial resynchronization not accepted: "}
00475                     \textcolor{stringliteral}{"Replication ID mismatch (Slave asked for '%s', my "}
00476                     \textcolor{stringliteral}{"replication IDs are '%s' and '%s')"},
00477                     master\_replid, server.replid, server.replid2);
00478             \} \textcolor{keywordflow}{else} \{
00479                 serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Partial resynchronization not accepted: "}
00480                     \textcolor{stringliteral}{"Requested offset for second ID was %lld, but I can reply "}
00481                     \textcolor{stringliteral}{"up to %lld"}, psync\_offset, server.second\_replid\_offset);
00482             \}
00483         \} \textcolor{keywordflow}{else} \{
00484             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Full resync requested by slave %s"},
00485                 replicationGetSlaveName(c));
00486         \}
00487         \textcolor{keywordflow}{goto} need\_full\_resync;
00488     \}
00489 
00490     \textcolor{comment}{/* We still have the data our slave is asking for? */}
00491     \textcolor{keywordflow}{if} (!server.repl\_backlog ||
00492         psync\_offset < server.repl\_backlog\_off ||
00493         psync\_offset > (server.repl\_backlog\_off + server.repl\_backlog\_histlen))
00494     \{
00495         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
00496             \textcolor{stringliteral}{"Unable to partial resync with slave %s for lack of backlog (Slave request was: %lld)."}, 
      replicationGetSlaveName(c), psync\_offset);
00497         \textcolor{keywordflow}{if} (psync\_offset > server.master\_repl\_offset) \{
00498             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
00499                 \textcolor{stringliteral}{"Warning: slave %s tried to PSYNC with an offset that is greater than the master
       replication offset."}, replicationGetSlaveName(c));
00500         \}
00501         \textcolor{keywordflow}{goto} need\_full\_resync;
00502     \}
00503 
00504     \textcolor{comment}{/* If we reached this point, we are able to perform a partial resync:}
00505 \textcolor{comment}{     * 1) Set client state to make it a slave.}
00506 \textcolor{comment}{     * 2) Inform the client we can continue with +CONTINUE}
00507 \textcolor{comment}{     * 3) Send the backlog data (from the offset to the end) to the slave. */}
00508     c->flags |= \hyperlink{server_8h_ae9f6995948253652bc9454d79a72f4a7}{CLIENT\_SLAVE};
00509     c->replstate = \hyperlink{server_8h_ad895fdf16e5ed5275d19ddf8578b900f}{SLAVE\_STATE\_ONLINE};
00510     c->repl\_ack\_time = server.unixtime;
00511     c->repl\_put\_online\_on\_ack = 0;
00512     listAddNodeTail(server.slaves,c);
00513     \textcolor{comment}{/* We can't use the connection buffers since they are used to accumulate}
00514 \textcolor{comment}{     * new commands at this stage. But we are sure the socket send buffer is}
00515 \textcolor{comment}{     * empty so this write will never fail actually. */}
00516     \textcolor{keywordflow}{if} (c->slave\_capa & \hyperlink{server_8h_a7ae8ce840619af1c0922648a45816afe}{SLAVE\_CAPA\_PSYNC2}) \{
00517         buflen = snprintf(buf,\textcolor{keyword}{sizeof}(buf),\textcolor{stringliteral}{"+CONTINUE %s\(\backslash\)r\(\backslash\)n"}, server.replid);
00518     \} \textcolor{keywordflow}{else} \{
00519         buflen = snprintf(buf,\textcolor{keyword}{sizeof}(buf),\textcolor{stringliteral}{"+CONTINUE\(\backslash\)r\(\backslash\)n"});
00520     \}
00521     \textcolor{keywordflow}{if} (write(c->fd,buf,buflen) != buflen) \{
00522         freeClientAsync(c);
00523         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00524     \}
00525     psync\_len = addReplyReplicationBacklog(c,psync\_offset);
00526     serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
00527         \textcolor{stringliteral}{"Partial resynchronization request from %s accepted. Sending %lld bytes of backlog starting
       from offset %lld."},
00528             replicationGetSlaveName(c),
00529             psync\_len, psync\_offset);
00530     \textcolor{comment}{/* Note that we don't need to set the selected DB at server.slaveseldb}
00531 \textcolor{comment}{     * to -1 to force the master to emit SELECT, since the slave already}
00532 \textcolor{comment}{     * has this state from the previous connection with the master. */}
00533 
00534     refreshGoodSlavesCount();
00535     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}; \textcolor{comment}{/* The caller can return, no full resync needed. */}
00536 
00537 need\_full\_resync:
00538     \textcolor{comment}{/* We need a full resync for some reason... Note that we can't}
00539 \textcolor{comment}{     * reply to PSYNC right now if a full SYNC is needed. The reply}
00540 \textcolor{comment}{     * must include the master offset at the time the RDB file we transfer}
00541 \textcolor{comment}{     * is generated, so we need to delay the reply to that moment. */}
00542     \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00543 \}
00544 
00545 \textcolor{comment}{/* Start a BGSAVE for replication goals, which is, selecting the disk or}
00546 \textcolor{comment}{ * socket target depending on the configuration, and making sure that}
00547 \textcolor{comment}{ * the script cache is flushed before to start.}
00548 \textcolor{comment}{ *}
00549 \textcolor{comment}{ * The mincapa argument is the bitwise AND among all the slaves capabilities}
00550 \textcolor{comment}{ * of the slaves waiting for this BGSAVE, so represents the slave capabilities}
00551 \textcolor{comment}{ * all the slaves support. Can be tested via SLAVE\_CAPA\_* macros.}
00552 \textcolor{comment}{ *}
00553 \textcolor{comment}{ * Side effects, other than starting a BGSAVE:}
00554 \textcolor{comment}{ *}
00555 \textcolor{comment}{ * 1) Handle the slaves in WAIT\_START state, by preparing them for a full}
00556 \textcolor{comment}{ *    sync if the BGSAVE was succesfully started, or sending them an error}
00557 \textcolor{comment}{ *    and dropping them from the list of slaves.}
00558 \textcolor{comment}{ *}
00559 \textcolor{comment}{ * 2) Flush the Lua scripting script cache if the BGSAVE was actually}
00560 \textcolor{comment}{ *    started.}
00561 \textcolor{comment}{ *}
00562 \textcolor{comment}{ * Returns C\_OK on success or C\_ERR otherwise. */}
00563 \textcolor{keywordtype}{int} startBgsaveForReplication(\textcolor{keywordtype}{int} mincapa) \{
00564     \textcolor{keywordtype}{int} retval;
00565     \textcolor{keywordtype}{int} socket\_target = server.repl\_diskless\_sync && (mincapa & 
      \hyperlink{server_8h_a679170caf08eeb16170fc653c9c1dfb2}{SLAVE\_CAPA\_EOF});
00566     listIter li;
00567     listNode *ln;
00568 
00569     serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Starting BGSAVE for SYNC with target: %s"},
00570         socket\_target ? \textcolor{stringliteral}{"slaves sockets"} : \textcolor{stringliteral}{"disk"});
00571 
00572     rdbSaveInfo rsi, *rsiptr;
00573     rsiptr = rdbPopulateSaveInfo(&rsi);
00574     \textcolor{comment}{/* Only do rdbSave* when rsiptr is not NULL,}
00575 \textcolor{comment}{     * otherwise slave will miss repl-stream-db. */}
00576     \textcolor{keywordflow}{if} (rsiptr) \{
00577         \textcolor{keywordflow}{if} (socket\_target)
00578             retval = rdbSaveToSlavesSockets(rsiptr);
00579         \textcolor{keywordflow}{else}
00580             retval = rdbSaveBackground(server.rdb\_filename,rsiptr);
00581     \} \textcolor{keywordflow}{else} \{
00582         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"BGSAVE for replication: replication information not available,
       can't generate the RDB file right now. Try later."});
00583         retval = \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00584     \}
00585 
00586     \textcolor{comment}{/* If we failed to BGSAVE, remove the slaves waiting for a full}
00587 \textcolor{comment}{     * resynchorinization from the list of salves, inform them with}
00588 \textcolor{comment}{     * an error about what happened, close the connection ASAP. */}
00589     \textcolor{keywordflow}{if} (retval == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
00590         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"BGSAVE for replication failed"});
00591         listRewind(server.slaves,&li);
00592         \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
00593             \hyperlink{structclient}{client} *slave = ln->value;
00594 
00595             \textcolor{keywordflow}{if} (slave->replstate == \hyperlink{server_8h_a170ee2dd8cfefaf0d112edcc3152f8d7}{SLAVE\_STATE\_WAIT\_BGSAVE\_START}) \{
00596                 slave->flags &= ~\hyperlink{server_8h_ae9f6995948253652bc9454d79a72f4a7}{CLIENT\_SLAVE};
00597                 listDelNode(server.slaves,ln);
00598                 addReplyError(slave,
00599                     \textcolor{stringliteral}{"BGSAVE failed, replication can't continue"});
00600                 slave->flags |= \hyperlink{server_8h_a8cff2154afcc2e87ac85bdbbe2814091}{CLIENT\_CLOSE\_AFTER\_REPLY};
00601             \}
00602         \}
00603         \textcolor{keywordflow}{return} retval;
00604     \}
00605 
00606     \textcolor{comment}{/* If the target is socket, rdbSaveToSlavesSockets() already setup}
00607 \textcolor{comment}{     * the salves for a full resync. Otherwise for disk target do it now.*/}
00608     \textcolor{keywordflow}{if} (!socket\_target) \{
00609         listRewind(server.slaves,&li);
00610         \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
00611             \hyperlink{structclient}{client} *slave = ln->value;
00612 
00613             \textcolor{keywordflow}{if} (slave->replstate == \hyperlink{server_8h_a170ee2dd8cfefaf0d112edcc3152f8d7}{SLAVE\_STATE\_WAIT\_BGSAVE\_START}) \{
00614                     replicationSetupSlaveForFullResync(slave,
00615                             getPsyncInitialOffset());
00616             \}
00617         \}
00618     \}
00619 
00620     \textcolor{comment}{/* Flush the script cache, since we need that slave differences are}
00621 \textcolor{comment}{     * accumulated without requiring slaves to match our cached scripts. */}
00622     \textcolor{keywordflow}{if} (retval == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) replicationScriptCacheFlush();
00623     \textcolor{keywordflow}{return} retval;
00624 \}
00625 
00626 \textcolor{comment}{/* SYNC and PSYNC command implemenation. */}
00627 \textcolor{keywordtype}{void} syncCommand(\hyperlink{structclient}{client} *c) \{
00628     \textcolor{comment}{/* ignore SYNC if already slave or in monitor mode */}
00629     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_ae9f6995948253652bc9454d79a72f4a7}{CLIENT\_SLAVE}) \textcolor{keywordflow}{return};
00630 
00631     \textcolor{comment}{/* Refuse SYNC requests if we are a slave but the link with our master}
00632 \textcolor{comment}{     * is not ok... */}
00633     \textcolor{keywordflow}{if} (server.masterhost && server.repl\_state != \hyperlink{server_8h_aed693b3a9cdfc05cf5ab7551a8c86fbe}{REPL\_STATE\_CONNECTED}) \{
00634         addReplySds(c,sdsnew(\textcolor{stringliteral}{"-NOMASTERLINK Can't SYNC while not connected with my master\(\backslash\)r\(\backslash\)n"}));
00635         \textcolor{keywordflow}{return};
00636     \}
00637 
00638     \textcolor{comment}{/* SYNC can't be issued when the server has pending data to send to}
00639 \textcolor{comment}{     * the client about already issued commands. We need a fresh reply}
00640 \textcolor{comment}{     * buffer registering the differences between the BGSAVE and the current}
00641 \textcolor{comment}{     * dataset, so that we can copy to other slaves if needed. */}
00642     \textcolor{keywordflow}{if} (clientHasPendingReplies(c)) \{
00643         addReplyError(c,\textcolor{stringliteral}{"SYNC and PSYNC are invalid with pending output"});
00644         \textcolor{keywordflow}{return};
00645     \}
00646 
00647     serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Slave %s asks for synchronization"},
00648         replicationGetSlaveName(c));
00649 
00650     \textcolor{comment}{/* Try a partial resynchronization if this is a PSYNC command.}
00651 \textcolor{comment}{     * If it fails, we continue with usual full resynchronization, however}
00652 \textcolor{comment}{     * when this happens masterTryPartialResynchronization() already}
00653 \textcolor{comment}{     * replied with:}
00654 \textcolor{comment}{     *}
00655 \textcolor{comment}{     * +FULLRESYNC <replid> <offset>}
00656 \textcolor{comment}{     *}
00657 \textcolor{comment}{     * So the slave knows the new replid and offset to try a PSYNC later}
00658 \textcolor{comment}{     * if the connection with the master is lost. */}
00659     \textcolor{keywordflow}{if} (!strcasecmp(c->argv[0]->ptr,\textcolor{stringliteral}{"psync"})) \{
00660         \textcolor{keywordflow}{if} (masterTryPartialResynchronization(c) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
00661             server.stat\_sync\_partial\_ok++;
00662             \textcolor{keywordflow}{return}; \textcolor{comment}{/* No full resync needed, return. */}
00663         \} \textcolor{keywordflow}{else} \{
00664             \textcolor{keywordtype}{char} *master\_replid = c->argv[1]->ptr;
00665 
00666             \textcolor{comment}{/* Increment stats for failed PSYNCs, but only if the}
00667 \textcolor{comment}{             * replid is not "?", as this is used by slaves to force a full}
00668 \textcolor{comment}{             * resync on purpose when they are not albe to partially}
00669 \textcolor{comment}{             * resync. */}
00670             \textcolor{keywordflow}{if} (master\_replid[0] != \textcolor{stringliteral}{'?'}) server.stat\_sync\_partial\_err++;
00671         \}
00672     \} \textcolor{keywordflow}{else} \{
00673         \textcolor{comment}{/* If a slave uses SYNC, we are dealing with an old implementation}
00674 \textcolor{comment}{         * of the replication protocol (like redis-cli --slave). Flag the client}
00675 \textcolor{comment}{         * so that we don't expect to receive REPLCONF ACK feedbacks. */}
00676         c->flags |= \hyperlink{server_8h_ac13d62411270bd658f6d82e711e0f912}{CLIENT\_PRE\_PSYNC};
00677     \}
00678 
00679     \textcolor{comment}{/* Full resynchronization. */}
00680     server.stat\_sync\_full++;
00681 
00682     \textcolor{comment}{/* Setup the slave as one waiting for BGSAVE to start. The following code}
00683 \textcolor{comment}{     * paths will change the state if we handle the slave differently. */}
00684     c->replstate = \hyperlink{server_8h_a170ee2dd8cfefaf0d112edcc3152f8d7}{SLAVE\_STATE\_WAIT\_BGSAVE\_START};
00685     \textcolor{keywordflow}{if} (server.repl\_disable\_tcp\_nodelay)
00686         anetDisableTcpNoDelay(NULL, c->fd); \textcolor{comment}{/* Non critical if it fails. */}
00687     c->repldbfd = -1;
00688     c->flags |= \hyperlink{server_8h_ae9f6995948253652bc9454d79a72f4a7}{CLIENT\_SLAVE};
00689     listAddNodeTail(server.slaves,c);
00690 
00691     \textcolor{comment}{/* Create the replication backlog if needed. */}
00692     \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.slaves) == 1 && server.repl\_backlog == NULL) \{
00693         \textcolor{comment}{/* When we create the backlog from scratch, we always use a new}
00694 \textcolor{comment}{         * replication ID and clear the ID2, since there is no valid}
00695 \textcolor{comment}{         * past history. */}
00696         changeReplicationId();
00697         clearReplicationId2();
00698         createReplicationBacklog();
00699     \}
00700 
00701     \textcolor{comment}{/* CASE 1: BGSAVE is in progress, with disk target. */}
00702     \textcolor{keywordflow}{if} (server.rdb\_child\_pid != -1 &&
00703         server.rdb\_child\_type == \hyperlink{server_8h_a9d886e992717fa246dd7954244ff6bdf}{RDB\_CHILD\_TYPE\_DISK})
00704     \{
00705         \textcolor{comment}{/* Ok a background save is in progress. Let's check if it is a good}
00706 \textcolor{comment}{         * one for replication, i.e. if there is another slave that is}
00707 \textcolor{comment}{         * registering differences since the server forked to save. */}
00708         \hyperlink{structclient}{client} *slave;
00709         listNode *ln;
00710         listIter li;
00711 
00712         listRewind(server.slaves,&li);
00713         \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
00714             slave = ln->value;
00715             \textcolor{keywordflow}{if} (slave->replstate == \hyperlink{server_8h_a2a1b586e8f326f831f6ab466c8c3f38a}{SLAVE\_STATE\_WAIT\_BGSAVE\_END}) \textcolor{keywordflow}{break};
00716         \}
00717         \textcolor{comment}{/* To attach this slave, we check that it has at least all the}
00718 \textcolor{comment}{         * capabilities of the slave that triggered the current BGSAVE. */}
00719         \textcolor{keywordflow}{if} (ln && ((c->slave\_capa & slave->slave\_capa) == slave->slave\_capa)) \{
00720             \textcolor{comment}{/* Perfect, the server is already registering differences for}
00721 \textcolor{comment}{             * another slave. Set the right state, and copy the buffer. */}
00722             copyClientOutputBuffer(c,slave);
00723             replicationSetupSlaveForFullResync(c,slave->psync\_initial\_offset);
00724             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Waiting for end of BGSAVE for SYNC"});
00725         \} \textcolor{keywordflow}{else} \{
00726             \textcolor{comment}{/* No way, we need to wait for the next BGSAVE in order to}
00727 \textcolor{comment}{             * register differences. */}
00728             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Can't attach the slave to the current BGSAVE. Waiting for
       next BGSAVE for SYNC"});
00729         \}
00730 
00731     \textcolor{comment}{/* CASE 2: BGSAVE is in progress, with socket target. */}
00732     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.rdb\_child\_pid != -1 &&
00733                server.rdb\_child\_type == \hyperlink{server_8h_acdbf61346e1d2f54716e2ab6fe73e954}{RDB\_CHILD\_TYPE\_SOCKET})
00734     \{
00735         \textcolor{comment}{/* There is an RDB child process but it is writing directly to}
00736 \textcolor{comment}{         * children sockets. We need to wait for the next BGSAVE}
00737 \textcolor{comment}{         * in order to synchronize. */}
00738         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Current BGSAVE has socket target. Waiting for next BGSAVE for
       SYNC"});
00739 
00740     \textcolor{comment}{/* CASE 3: There is no BGSAVE is progress. */}
00741     \} \textcolor{keywordflow}{else} \{
00742         \textcolor{keywordflow}{if} (server.repl\_diskless\_sync && (c->slave\_capa & \hyperlink{server_8h_a679170caf08eeb16170fc653c9c1dfb2}{SLAVE\_CAPA\_EOF})) \{
00743             \textcolor{comment}{/* Diskless replication RDB child is created inside}
00744 \textcolor{comment}{             * replicationCron() since we want to delay its start a}
00745 \textcolor{comment}{             * few seconds to wait for more slaves to arrive. */}
00746             \textcolor{keywordflow}{if} (server.repl\_diskless\_sync\_delay)
00747                 serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Delay next BGSAVE for diskless SYNC"});
00748         \} \textcolor{keywordflow}{else} \{
00749             \textcolor{comment}{/* Target is disk (or the slave is not capable of supporting}
00750 \textcolor{comment}{             * diskless replication) and we don't have a BGSAVE in progress,}
00751 \textcolor{comment}{             * let's start one. */}
00752             \textcolor{keywordflow}{if} (server.aof\_child\_pid == -1) \{
00753                 startBgsaveForReplication(c->slave\_capa);
00754             \} \textcolor{keywordflow}{else} \{
00755                 serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
00756                     \textcolor{stringliteral}{"No BGSAVE in progress, but an AOF rewrite is active. "}
00757                     \textcolor{stringliteral}{"BGSAVE for replication delayed"});
00758             \}
00759         \}
00760     \}
00761     \textcolor{keywordflow}{return};
00762 \}
00763 
00764 \textcolor{comment}{/* REPLCONF <option> <value> <option> <value> ...}
00765 \textcolor{comment}{ * This command is used by a slave in order to configure the replication}
00766 \textcolor{comment}{ * process before starting it with the SYNC command.}
00767 \textcolor{comment}{ *}
00768 \textcolor{comment}{ * Currently the only use of this command is to communicate to the master}
00769 \textcolor{comment}{ * what is the listening port of the Slave redis instance, so that the}
00770 \textcolor{comment}{ * master can accurately list slaves and their listening ports in}
00771 \textcolor{comment}{ * the INFO output.}
00772 \textcolor{comment}{ *}
00773 \textcolor{comment}{ * In the future the same command can be used in order to configure}
00774 \textcolor{comment}{ * the replication to initiate an incremental replication instead of a}
00775 \textcolor{comment}{ * full resync. */}
00776 \textcolor{keywordtype}{void} replconfCommand(\hyperlink{structclient}{client} *c) \{
00777     \textcolor{keywordtype}{int} j;
00778 
00779     \textcolor{keywordflow}{if} ((c->argc % 2) == 0) \{
00780         \textcolor{comment}{/* Number of arguments must be odd to make sure that every}
00781 \textcolor{comment}{         * option has a corresponding value. */}
00782         addReply(c,shared.syntaxerr);
00783         \textcolor{keywordflow}{return};
00784     \}
00785 
00786     \textcolor{comment}{/* Process every option-value pair. */}
00787     \textcolor{keywordflow}{for} (j = 1; j < c->argc; j+=2) \{
00788         \textcolor{keywordflow}{if} (!strcasecmp(c->argv[j]->ptr,\textcolor{stringliteral}{"listening-port"})) \{
00789             \textcolor{keywordtype}{long} port;
00790 
00791             \textcolor{keywordflow}{if} ((getLongFromObjectOrReply(c,c->argv[j+1],
00792                     &port,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}))
00793                 \textcolor{keywordflow}{return};
00794             c->slave\_listening\_port = port;
00795         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[j]->ptr,\textcolor{stringliteral}{"ip-address"})) \{
00796             sds ip = c->argv[j+1]->ptr;
00797             \textcolor{keywordflow}{if} (sdslen(ip) < \textcolor{keyword}{sizeof}(c->slave\_ip)) \{
00798                 memcpy(c->slave\_ip,ip,sdslen(ip)+1);
00799             \} \textcolor{keywordflow}{else} \{
00800                 addReplyErrorFormat(c,\textcolor{stringliteral}{"REPLCONF ip-address provided by "}
00801                     \textcolor{stringliteral}{"slave instance is too long: %zd bytes"}, sdslen(ip));
00802                 \textcolor{keywordflow}{return};
00803             \}
00804         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[j]->ptr,\textcolor{stringliteral}{"capa"})) \{
00805             \textcolor{comment}{/* Ignore capabilities not understood by this master. */}
00806             \textcolor{keywordflow}{if} (!strcasecmp(c->argv[j+1]->ptr,\textcolor{stringliteral}{"eof"}))
00807                 c->slave\_capa |= \hyperlink{server_8h_a679170caf08eeb16170fc653c9c1dfb2}{SLAVE\_CAPA\_EOF};
00808             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[j+1]->ptr,\textcolor{stringliteral}{"psync2"}))
00809                 c->slave\_capa |= \hyperlink{server_8h_a7ae8ce840619af1c0922648a45816afe}{SLAVE\_CAPA\_PSYNC2};
00810         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[j]->ptr,\textcolor{stringliteral}{"ack"})) \{
00811             \textcolor{comment}{/* REPLCONF ACK is used by slave to inform the master the amount}
00812 \textcolor{comment}{             * of replication stream that it processed so far. It is an}
00813 \textcolor{comment}{             * internal only command that normal clients should never use. */}
00814             \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} offset;
00815 
00816             \textcolor{keywordflow}{if} (!(c->flags & \hyperlink{server_8h_ae9f6995948253652bc9454d79a72f4a7}{CLIENT\_SLAVE})) \textcolor{keywordflow}{return};
00817             \textcolor{keywordflow}{if} ((getLongLongFromObject(c->argv[j+1], &offset) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}))
00818                 \textcolor{keywordflow}{return};
00819             \textcolor{keywordflow}{if} (offset > c->repl\_ack\_off)
00820                 c->repl\_ack\_off = offset;
00821             c->repl\_ack\_time = server.unixtime;
00822             \textcolor{comment}{/* If this was a diskless replication, we need to really put}
00823 \textcolor{comment}{             * the slave online when the first ACK is received (which}
00824 \textcolor{comment}{             * confirms slave is online and ready to get more data). */}
00825             \textcolor{keywordflow}{if} (c->repl\_put\_online\_on\_ack && c->replstate == 
      \hyperlink{server_8h_ad895fdf16e5ed5275d19ddf8578b900f}{SLAVE\_STATE\_ONLINE})
00826                 putSlaveOnline(c);
00827             \textcolor{comment}{/* Note: this command does not reply anything! */}
00828             \textcolor{keywordflow}{return};
00829         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[j]->ptr,\textcolor{stringliteral}{"getack"})) \{
00830             \textcolor{comment}{/* REPLCONF GETACK is used in order to request an ACK ASAP}
00831 \textcolor{comment}{             * to the slave. */}
00832             \textcolor{keywordflow}{if} (server.masterhost && server.master) replicationSendAck();
00833             \textcolor{keywordflow}{return};
00834         \} \textcolor{keywordflow}{else} \{
00835             addReplyErrorFormat(c,\textcolor{stringliteral}{"Unrecognized REPLCONF option: %s"},
00836                 (\textcolor{keywordtype}{char}*)c->argv[j]->ptr);
00837             \textcolor{keywordflow}{return};
00838         \}
00839     \}
00840     addReply(c,shared.ok);
00841 \}
00842 
00843 \textcolor{comment}{/* This function puts a slave in the online state, and should be called just}
00844 \textcolor{comment}{ * after a slave received the RDB file for the initial synchronization, and}
00845 \textcolor{comment}{ * we are finally ready to send the incremental stream of commands.}
00846 \textcolor{comment}{ *}
00847 \textcolor{comment}{ * It does a few things:}
00848 \textcolor{comment}{ *}
00849 \textcolor{comment}{ * 1) Put the slave in ONLINE state (useless when the function is called}
00850 \textcolor{comment}{ *    because state is already ONLINE but repl\_put\_online\_on\_ack is true).}
00851 \textcolor{comment}{ * 2) Make sure the writable event is re-installed, since calling the SYNC}
00852 \textcolor{comment}{ *    command disables it, so that we can accumulate output buffer without}
00853 \textcolor{comment}{ *    sending it to the slave.}
00854 \textcolor{comment}{ * 3) Update the count of good slaves. */}
00855 \textcolor{keywordtype}{void} putSlaveOnline(\hyperlink{structclient}{client} *slave) \{
00856     slave->replstate = \hyperlink{server_8h_ad895fdf16e5ed5275d19ddf8578b900f}{SLAVE\_STATE\_ONLINE};
00857     slave->repl\_put\_online\_on\_ack = 0;
00858     slave->repl\_ack\_time = server.unixtime; \textcolor{comment}{/* Prevent false timeout. */}
00859     \textcolor{keywordflow}{if} (aeCreateFileEvent(server.el, slave->fd, \hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE},
00860         sendReplyToClient, slave) == \hyperlink{ae_8h_aa16dcf7effdf8f8df97f51b1cb51a9df}{AE\_ERR}) \{
00861         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Unable to register writable event for slave bulk transfer: %s"}
      , strerror(errno));
00862         freeClient(slave);
00863         \textcolor{keywordflow}{return};
00864     \}
00865     refreshGoodSlavesCount();
00866     serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Synchronization with slave %s succeeded"},
00867         replicationGetSlaveName(slave));
00868 \}
00869 
00870 \textcolor{keywordtype}{void} sendBulkToSlave(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask) \{
00871     \hyperlink{structclient}{client} *slave = privdata;
00872     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(el);
00873     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(mask);
00874     \textcolor{keywordtype}{char} buf[\hyperlink{server_8h_ac30919814359f46fb41e9fc497dd8e05}{PROTO\_IOBUF\_LEN}];
00875     ssize\_t nwritten, buflen;
00876 
00877     \textcolor{comment}{/* Before sending the RDB file, we send the preamble as configured by the}
00878 \textcolor{comment}{     * replication process. Currently the preamble is just the bulk count of}
00879 \textcolor{comment}{     * the file in the form "$<length>\(\backslash\)r\(\backslash\)n". */}
00880     \textcolor{keywordflow}{if} (slave->replpreamble) \{
00881         nwritten = write(fd,slave->replpreamble,sdslen(slave->replpreamble));
00882         \textcolor{keywordflow}{if} (nwritten == -1) \{
00883             serverLog(\hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE},\textcolor{stringliteral}{"Write error sending RDB preamble to slave: %s"},
00884                 strerror(errno));
00885             freeClient(slave);
00886             \textcolor{keywordflow}{return};
00887         \}
00888         server.stat\_net\_output\_bytes += nwritten;
00889         sdsrange(slave->replpreamble,nwritten,-1);
00890         \textcolor{keywordflow}{if} (sdslen(slave->replpreamble) == 0) \{
00891             sdsfree(slave->replpreamble);
00892             slave->replpreamble = NULL;
00893             \textcolor{comment}{/* fall through sending data. */}
00894         \} \textcolor{keywordflow}{else} \{
00895             \textcolor{keywordflow}{return};
00896         \}
00897     \}
00898 
00899     \textcolor{comment}{/* If the preamble was already transfered, send the RDB bulk data. */}
00900     lseek(slave->repldbfd,slave->repldboff,SEEK\_SET);
00901     buflen = read(slave->repldbfd,buf,\hyperlink{server_8h_ac30919814359f46fb41e9fc497dd8e05}{PROTO\_IOBUF\_LEN});
00902     \textcolor{keywordflow}{if} (buflen <= 0) \{
00903         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Read error sending DB to slave: %s"},
00904             (buflen == 0) ? \textcolor{stringliteral}{"premature EOF"} : strerror(errno));
00905         freeClient(slave);
00906         \textcolor{keywordflow}{return};
00907     \}
00908     \textcolor{keywordflow}{if} ((nwritten = write(fd,buf,buflen)) == -1) \{
00909         \textcolor{keywordflow}{if} (errno != EAGAIN) \{
00910             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Write error sending DB to slave: %s"},
00911                 strerror(errno));
00912             freeClient(slave);
00913         \}
00914         \textcolor{keywordflow}{return};
00915     \}
00916     slave->repldboff += nwritten;
00917     server.stat\_net\_output\_bytes += nwritten;
00918     \textcolor{keywordflow}{if} (slave->repldboff == slave->repldbsize) \{
00919         close(slave->repldbfd);
00920         slave->repldbfd = -1;
00921         aeDeleteFileEvent(server.el,slave->fd,\hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE});
00922         putSlaveOnline(slave);
00923     \}
00924 \}
00925 
00926 \textcolor{comment}{/* This function is called at the end of every background saving,}
00927 \textcolor{comment}{ * or when the replication RDB transfer strategy is modified from}
00928 \textcolor{comment}{ * disk to socket or the other way around.}
00929 \textcolor{comment}{ *}
00930 \textcolor{comment}{ * The goal of this function is to handle slaves waiting for a successful}
00931 \textcolor{comment}{ * background saving in order to perform non-blocking synchronization, and}
00932 \textcolor{comment}{ * to schedule a new BGSAVE if there are slaves that attached while a}
00933 \textcolor{comment}{ * BGSAVE was in progress, but it was not a good one for replication (no}
00934 \textcolor{comment}{ * other slave was accumulating differences).}
00935 \textcolor{comment}{ *}
00936 \textcolor{comment}{ * The argument bgsaveerr is C\_OK if the background saving succeeded}
00937 \textcolor{comment}{ * otherwise C\_ERR is passed to the function.}
00938 \textcolor{comment}{ * The 'type' argument is the type of the child that terminated}
00939 \textcolor{comment}{ * (if it had a disk or socket target). */}
00940 \textcolor{keywordtype}{void} updateSlavesWaitingBgsave(\textcolor{keywordtype}{int} bgsaveerr, \textcolor{keywordtype}{int} type) \{
00941     listNode *ln;
00942     \textcolor{keywordtype}{int} startbgsave = 0;
00943     \textcolor{keywordtype}{int} mincapa = -1;
00944     listIter li;
00945 
00946     listRewind(server.slaves,&li);
00947     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
00948         \hyperlink{structclient}{client} *slave = ln->value;
00949 
00950         \textcolor{keywordflow}{if} (slave->replstate == \hyperlink{server_8h_a170ee2dd8cfefaf0d112edcc3152f8d7}{SLAVE\_STATE\_WAIT\_BGSAVE\_START}) \{
00951             startbgsave = 1;
00952             mincapa = (mincapa == -1) ? slave->slave\_capa :
00953                                         (mincapa & slave->slave\_capa);
00954         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (slave->replstate == \hyperlink{server_8h_a2a1b586e8f326f831f6ab466c8c3f38a}{SLAVE\_STATE\_WAIT\_BGSAVE\_END}) \{
00955             \textcolor{keyword}{struct} \hyperlink{config_8h_ae18037d20ab1bc7c716ea0bcb506f7af}{redis\_stat} buf;
00956 
00957             \textcolor{comment}{/* If this was an RDB on disk save, we have to prepare to send}
00958 \textcolor{comment}{             * the RDB from disk to the slave socket. Otherwise if this was}
00959 \textcolor{comment}{             * already an RDB -> Slaves socket transfer, used in the case of}
00960 \textcolor{comment}{             * diskless replication, our work is trivial, we can just put}
00961 \textcolor{comment}{             * the slave online. */}
00962             \textcolor{keywordflow}{if} (type == \hyperlink{server_8h_acdbf61346e1d2f54716e2ab6fe73e954}{RDB\_CHILD\_TYPE\_SOCKET}) \{
00963                 serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
00964                     \textcolor{stringliteral}{"Streamed RDB transfer with slave %s succeeded (socket). Waiting for REPLCONF ACK
       from slave to enable streaming"},
00965                         replicationGetSlaveName(slave));
00966                 \textcolor{comment}{/* Note: we wait for a REPLCONF ACK message from slave in}
00967 \textcolor{comment}{                 * order to really put it online (install the write handler}
00968 \textcolor{comment}{                 * so that the accumulated data can be transfered). However}
00969 \textcolor{comment}{                 * we change the replication state ASAP, since our slave}
00970 \textcolor{comment}{                 * is technically online now. */}
00971                 slave->replstate = \hyperlink{server_8h_ad895fdf16e5ed5275d19ddf8578b900f}{SLAVE\_STATE\_ONLINE};
00972                 slave->repl\_put\_online\_on\_ack = 1;
00973                 slave->repl\_ack\_time = server.unixtime; \textcolor{comment}{/* Timeout otherwise. */}
00974             \} \textcolor{keywordflow}{else} \{
00975                 \textcolor{keywordflow}{if} (bgsaveerr != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
00976                     freeClient(slave);
00977                     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"SYNC failed. BGSAVE child returned an error"});
00978                     \textcolor{keywordflow}{continue};
00979                 \}
00980                 \textcolor{keywordflow}{if} ((slave->repldbfd = open(server.rdb\_filename,O\_RDONLY)) == -1 ||
00981                     \hyperlink{config_8h_a7fb7329d05a6b4d1b1e7a3fac44c0668}{redis\_fstat}(slave->repldbfd,&buf) == -1) \{
00982                     freeClient(slave);
00983                     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"SYNC failed. Can't open/stat DB after BGSAVE: %s"},
       strerror(errno));
00984                     \textcolor{keywordflow}{continue};
00985                 \}
00986                 slave->repldboff = 0;
00987                 slave->repldbsize = buf.st\_size;
00988                 slave->replstate = \hyperlink{server_8h_ada38427ad2d0c09875081868a53cc51f}{SLAVE\_STATE\_SEND\_BULK};
00989                 slave->replpreamble = sdscatprintf(sdsempty(),\textcolor{stringliteral}{"$%lld\(\backslash\)r\(\backslash\)n"},
00990                     (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) slave->repldbsize);
00991 
00992                 aeDeleteFileEvent(server.el,slave->fd,\hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE});
00993                 \textcolor{keywordflow}{if} (aeCreateFileEvent(server.el, slave->fd, \hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE}, sendBulkToSlave, 
      slave) == \hyperlink{ae_8h_aa16dcf7effdf8f8df97f51b1cb51a9df}{AE\_ERR}) \{
00994                     freeClient(slave);
00995                     \textcolor{keywordflow}{continue};
00996                 \}
00997             \}
00998         \}
00999     \}
01000     \textcolor{keywordflow}{if} (startbgsave) startBgsaveForReplication(mincapa);
01001 \}
01002 
01003 \textcolor{comment}{/* Change the current instance replication ID with a new, random one.}
01004 \textcolor{comment}{ * This will prevent successful PSYNCs between this master and other}
01005 \textcolor{comment}{ * slaves, so the command should be called when something happens that}
01006 \textcolor{comment}{ * alters the current story of the dataset. */}
01007 \textcolor{keywordtype}{void} changeReplicationId(\textcolor{keywordtype}{void}) \{
01008     getRandomHexChars(server.replid,\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE});
01009     server.replid[\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}] = \textcolor{stringliteral}{'\(\backslash\)0'};
01010 \}
01011 
01012 \textcolor{comment}{/* Clear (invalidate) the secondary replication ID. This happens, for}
01013 \textcolor{comment}{ * example, after a full resynchronization, when we start a new replication}
01014 \textcolor{comment}{ * history. */}
01015 \textcolor{keywordtype}{void} clearReplicationId2(\textcolor{keywordtype}{void}) \{
01016     memset(server.replid2,\textcolor{stringliteral}{'0'},\textcolor{keyword}{sizeof}(server.replid));
01017     server.replid2[\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}] = \textcolor{stringliteral}{'\(\backslash\)0'};
01018     server.second\_replid\_offset = -1;
01019 \}
01020 
01021 \textcolor{comment}{/* Use the current replication ID / offset as secondary replication}
01022 \textcolor{comment}{ * ID, and change the current one in order to start a new history.}
01023 \textcolor{comment}{ * This should be used when an instance is switched from slave to master}
01024 \textcolor{comment}{ * so that it can serve PSYNC requests performed using the master}
01025 \textcolor{comment}{ * replication ID. */}
01026 \textcolor{keywordtype}{void} shiftReplicationId(\textcolor{keywordtype}{void}) \{
01027     memcpy(server.replid2,server.replid,\textcolor{keyword}{sizeof}(server.replid));
01028     \textcolor{comment}{/* We set the second replid offset to the master offset + 1, since}
01029 \textcolor{comment}{     * the slave will ask for the first byte it has not yet received, so}
01030 \textcolor{comment}{     * we need to add one to the offset: for example if, as a slave, we are}
01031 \textcolor{comment}{     * sure we have the same history as the master for 50 bytes, after we}
01032 \textcolor{comment}{     * are turned into a master, we can accept a PSYNC request with offset}
01033 \textcolor{comment}{     * 51, since the slave asking has the same history up to the 50th}
01034 \textcolor{comment}{     * byte, and is asking for the new bytes starting at offset 51. */}
01035     server.second\_replid\_offset = server.master\_repl\_offset+1;
01036     changeReplicationId();
01037     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Setting secondary replication ID to %s, valid up to offset: %lld.
       New replication ID is %s"}, server.replid2, server.second\_replid\_offset, server.replid);
01038 \}
01039 
01040 \textcolor{comment}{/* ----------------------------------- SLAVE -------------------------------- */}
01041 
01042 \textcolor{comment}{/* Returns 1 if the given replication state is a handshake state,}
01043 \textcolor{comment}{ * 0 otherwise. */}
01044 \textcolor{keywordtype}{int} slaveIsInHandshakeState(\textcolor{keywordtype}{void}) \{
01045     \textcolor{keywordflow}{return} server.repl\_state >= \hyperlink{server_8h_a61922e0fcf35df9722d2648484d23ff2}{REPL\_STATE\_RECEIVE\_PONG} &&
01046            server.repl\_state <= \hyperlink{server_8h_a31432ee96d5825316f1d96bcbda28d58}{REPL\_STATE\_RECEIVE\_PSYNC};
01047 \}
01048 
01049 \textcolor{comment}{/* Avoid the master to detect the slave is timing out while loading the}
01050 \textcolor{comment}{ * RDB file in initial synchronization. We send a single newline character}
01051 \textcolor{comment}{ * that is valid protocol but is guaranteed to either be sent entierly or}
01052 \textcolor{comment}{ * not, since the byte is indivisible.}
01053 \textcolor{comment}{ *}
01054 \textcolor{comment}{ * The function is called in two contexts: while we flush the current}
01055 \textcolor{comment}{ * data with emptyDb(), and while we load the new data received as an}
01056 \textcolor{comment}{ * RDB file from the master. */}
01057 \textcolor{keywordtype}{void} replicationSendNewlineToMaster(\textcolor{keywordtype}{void}) \{
01058     \textcolor{keyword}{static} time\_t newline\_sent;
01059     \textcolor{keywordflow}{if} (time(NULL) != newline\_sent) \{
01060         newline\_sent = time(NULL);
01061         \textcolor{keywordflow}{if} (write(server.repl\_transfer\_s,\textcolor{stringliteral}{"\(\backslash\)n"},1) == -1) \{
01062             \textcolor{comment}{/* Pinging back in this stage is best-effort. */}
01063         \}
01064     \}
01065 \}
01066 
01067 \textcolor{comment}{/* Callback used by emptyDb() while flushing away old data to load}
01068 \textcolor{comment}{ * the new dataset received by the master. */}
01069 \textcolor{keywordtype}{void} replicationEmptyDbCallback(\textcolor{keywordtype}{void} *privdata) \{
01070     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(privdata);
01071     replicationSendNewlineToMaster();
01072 \}
01073 
01074 \textcolor{comment}{/* Once we have a link with the master and the synchroniziation was}
01075 \textcolor{comment}{ * performed, this function materializes the master client we store}
01076 \textcolor{comment}{ * at server.master, starting from the specified file descriptor. */}
01077 \textcolor{keywordtype}{void} replicationCreateMasterClient(\textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{int} dbid) \{
01078     server.master = createClient(fd);
01079     server.master->flags |= \hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER};
01080     server.master->authenticated = 1;
01081     server.master->reploff = server.master\_initial\_offset;
01082     server.master->read\_reploff = server.master->reploff;
01083     memcpy(server.master->replid, server.master\_replid,
01084         \textcolor{keyword}{sizeof}(server.master\_replid));
01085     \textcolor{comment}{/* If master offset is set to -1, this master is old and is not}
01086 \textcolor{comment}{     * PSYNC capable, so we flag it accordingly. */}
01087     \textcolor{keywordflow}{if} (server.master->reploff == -1)
01088         server.master->flags |= \hyperlink{server_8h_ac13d62411270bd658f6d82e711e0f912}{CLIENT\_PRE\_PSYNC};
01089     \textcolor{keywordflow}{if} (dbid != -1) selectDb(server.master,dbid);
01090 \}
01091 
01092 \textcolor{keywordtype}{void} restartAOF() \{
01093     \textcolor{keywordtype}{int} retry = 10;
01094     \textcolor{keywordflow}{while} (retry-- && startAppendOnly() == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
01095         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Failed enabling the AOF after successful master
       synchronization! Trying it again in one second."});
01096         sleep(1);
01097     \}
01098     \textcolor{keywordflow}{if} (!retry) \{
01099         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"FATAL: this slave instance finished the synchronization with
       its master, but the AOF can't be turned on. Exiting now."});
01100         exit(1);
01101     \}
01102 \}
01103 
01104 \textcolor{comment}{/* Asynchronously read the SYNC payload we receive from a master */}
01105 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REPL\_MAX\_WRITTEN\_BEFORE\_FSYNC} \textcolor{preprocessor}{(}1024\textcolor{preprocessor}{*}1024\textcolor{preprocessor}{*}8\textcolor{preprocessor}{)} \textcolor{comment}{/* 8 MB */}
01106 \textcolor{keywordtype}{void} readSyncBulkPayload(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask) \{
01107     \textcolor{keywordtype}{char} buf[4096];
01108     ssize\_t nread, readlen;
01109     off\_t left;
01110     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(el);
01111     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(privdata);
01112     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(mask);
01113 
01114     \textcolor{comment}{/* Static vars used to hold the EOF mark, and the last bytes received}
01115 \textcolor{comment}{     * form the server: when they match, we reached the end of the transfer. */}
01116     \textcolor{keyword}{static} \textcolor{keywordtype}{char} eofmark[\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}];
01117     \textcolor{keyword}{static} \textcolor{keywordtype}{char} lastbytes[\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}];
01118     \textcolor{keyword}{static} \textcolor{keywordtype}{int} usemark = 0;
01119 
01120     \textcolor{comment}{/* If repl\_transfer\_size == -1 we still have to read the bulk length}
01121 \textcolor{comment}{     * from the master reply. */}
01122     \textcolor{keywordflow}{if} (server.repl\_transfer\_size == -1) \{
01123         \textcolor{keywordflow}{if} (syncReadLine(fd,buf,1024,server.repl\_syncio\_timeout*1000) == -1) \{
01124             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01125                 \textcolor{stringliteral}{"I/O error reading bulk count from MASTER: %s"},
01126                 strerror(errno));
01127             \textcolor{keywordflow}{goto} error;
01128         \}
01129 
01130         \textcolor{keywordflow}{if} (buf[0] == \textcolor{stringliteral}{'-'}) \{
01131             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01132                 \textcolor{stringliteral}{"MASTER aborted replication with an error: %s"},
01133                 buf+1);
01134             \textcolor{keywordflow}{goto} error;
01135         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (buf[0] == \textcolor{stringliteral}{'\(\backslash\)0'}) \{
01136             \textcolor{comment}{/* At this stage just a newline works as a PING in order to take}
01137 \textcolor{comment}{             * the connection live. So we refresh our last interaction}
01138 \textcolor{comment}{             * timestamp. */}
01139             server.repl\_transfer\_lastio = server.unixtime;
01140             \textcolor{keywordflow}{return};
01141         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (buf[0] != \textcolor{stringliteral}{'$'}) \{
01142             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Bad protocol from MASTER, the first byte is not '$' (we
       received '%s'), are you sure the host and port are right?"}, buf);
01143             \textcolor{keywordflow}{goto} error;
01144         \}
01145 
01146         \textcolor{comment}{/* There are two possible forms for the bulk payload. One is the}
01147 \textcolor{comment}{         * usual $<count> bulk format. The other is used for diskless transfers}
01148 \textcolor{comment}{         * when the master does not know beforehand the size of the file to}
01149 \textcolor{comment}{         * transfer. In the latter case, the following format is used:}
01150 \textcolor{comment}{         *}
01151 \textcolor{comment}{         * $EOF:<40 bytes delimiter>}
01152 \textcolor{comment}{         *}
01153 \textcolor{comment}{         * At the end of the file the announced delimiter is transmitted. The}
01154 \textcolor{comment}{         * delimiter is long and random enough that the probability of a}
01155 \textcolor{comment}{         * collision with the actual file content can be ignored. */}
01156         \textcolor{keywordflow}{if} (strncmp(buf+1,\textcolor{stringliteral}{"EOF:"},4) == 0 && strlen(buf+5) >= 
      \hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}) \{
01157             usemark = 1;
01158             memcpy(eofmark,buf+5,\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE});
01159             memset(lastbytes,0,\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE});
01160             \textcolor{comment}{/* Set any repl\_transfer\_size to avoid entering this code path}
01161 \textcolor{comment}{             * at the next call. */}
01162             server.repl\_transfer\_size = 0;
01163             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01164                 \textcolor{stringliteral}{"MASTER <-> SLAVE sync: receiving streamed RDB from master"});
01165         \} \textcolor{keywordflow}{else} \{
01166             usemark = 0;
01167             server.repl\_transfer\_size = strtol(buf+1,NULL,10);
01168             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01169                 \textcolor{stringliteral}{"MASTER <-> SLAVE sync: receiving %lld bytes from master"},
01170                 (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) server.repl\_transfer\_size);
01171         \}
01172         \textcolor{keywordflow}{return};
01173     \}
01174 
01175     \textcolor{comment}{/* Read bulk data */}
01176     \textcolor{keywordflow}{if} (usemark) \{
01177         readlen = \textcolor{keyword}{sizeof}(buf);
01178     \} \textcolor{keywordflow}{else} \{
01179         left = server.repl\_transfer\_size - server.repl\_transfer\_read;
01180         readlen = (left < (\textcolor{keywordtype}{signed})\textcolor{keyword}{sizeof}(buf)) ? left : (\textcolor{keywordtype}{signed})\textcolor{keyword}{sizeof}(buf);
01181     \}
01182 
01183     nread = read(fd,buf,readlen);
01184     \textcolor{keywordflow}{if} (nread <= 0) \{
01185         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"I/O error trying to sync with MASTER: %s"},
01186             (nread == -1) ? strerror(errno) : \textcolor{stringliteral}{"connection lost"});
01187         cancelReplicationHandshake();
01188         \textcolor{keywordflow}{return};
01189     \}
01190     server.stat\_net\_input\_bytes += nread;
01191 
01192     \textcolor{comment}{/* When a mark is used, we want to detect EOF asap in order to avoid}
01193 \textcolor{comment}{     * writing the EOF mark into the file... */}
01194     \textcolor{keywordtype}{int} eof\_reached = 0;
01195 
01196     \textcolor{keywordflow}{if} (usemark) \{
01197         \textcolor{comment}{/* Update the last bytes array, and check if it matches our delimiter.*/}
01198         \textcolor{keywordflow}{if} (nread >= \hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}) \{
01199             memcpy(lastbytes,buf+nread-\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE},
      \hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE});
01200         \} \textcolor{keywordflow}{else} \{
01201             \textcolor{keywordtype}{int} rem = \hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}-nread;
01202             memmove(lastbytes,lastbytes+nread,rem);
01203             memcpy(lastbytes+rem,buf,nread);
01204         \}
01205         \textcolor{keywordflow}{if} (memcmp(lastbytes,eofmark,\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}) == 0) eof\_reached = 1;
01206     \}
01207 
01208     server.repl\_transfer\_lastio = server.unixtime;
01209     \textcolor{keywordflow}{if} (write(server.repl\_transfer\_fd,buf,nread) != nread) \{
01210         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Write error or short write writing to the DB dump file needed
       for MASTER <-> SLAVE synchronization: %s"}, strerror(errno));
01211         \textcolor{keywordflow}{goto} error;
01212     \}
01213     server.repl\_transfer\_read += nread;
01214 
01215     \textcolor{comment}{/* Delete the last 40 bytes from the file if we reached EOF. */}
01216     \textcolor{keywordflow}{if} (usemark && eof\_reached) \{
01217         \textcolor{keywordflow}{if} (ftruncate(server.repl\_transfer\_fd,
01218             server.repl\_transfer\_read - \hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}) == -1)
01219         \{
01220             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Error truncating the RDB file received from the master for
       SYNC: %s"}, strerror(errno));
01221             \textcolor{keywordflow}{goto} error;
01222         \}
01223     \}
01224 
01225     \textcolor{comment}{/* Sync data on disk from time to time, otherwise at the end of the transfer}
01226 \textcolor{comment}{     * we may suffer a big delay as the memory buffers are copied into the}
01227 \textcolor{comment}{     * actual disk. */}
01228     \textcolor{keywordflow}{if} (server.repl\_transfer\_read >=
01229         server.repl\_transfer\_last\_fsync\_off + \hyperlink{replication_8c_a9a25193630fb39ddc25ea99935beca00}{REPL\_MAX\_WRITTEN\_BEFORE\_FSYNC}
      )
01230     \{
01231         off\_t sync\_size = server.repl\_transfer\_read -
01232                           server.repl\_transfer\_last\_fsync\_off;
01233         \hyperlink{config_8h_a05dc8943201853339c308c0762f023c1}{rdb\_fsync\_range}(server.repl\_transfer\_fd,
01234             server.repl\_transfer\_last\_fsync\_off, sync\_size);
01235         server.repl\_transfer\_last\_fsync\_off += sync\_size;
01236     \}
01237 
01238     \textcolor{comment}{/* Check if the transfer is now complete */}
01239     \textcolor{keywordflow}{if} (!usemark) \{
01240         \textcolor{keywordflow}{if} (server.repl\_transfer\_read == server.repl\_transfer\_size)
01241             eof\_reached = 1;
01242     \}
01243 
01244     \textcolor{keywordflow}{if} (eof\_reached) \{
01245         \textcolor{keywordtype}{int} aof\_is\_enabled = server.aof\_state != \hyperlink{server_8h_a5226306fbcebcb6d5d02e0fef3c213c2}{AOF\_OFF};
01246 
01247         \textcolor{keywordflow}{if} (rename(server.repl\_transfer\_tmpfile,server.rdb\_filename) == -1) \{
01248             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Failed trying to rename the temp DB into dump.rdb in
       MASTER <-> SLAVE synchronization: %s"}, strerror(errno));
01249             cancelReplicationHandshake();
01250             \textcolor{keywordflow}{return};
01251         \}
01252         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE}, \textcolor{stringliteral}{"MASTER <-> SLAVE sync: Flushing old data"});
01253         \textcolor{comment}{/* We need to stop any AOFRW fork before flusing and parsing}
01254 \textcolor{comment}{         * RDB, otherwise we'll create a copy-on-write disaster. */}
01255         \textcolor{keywordflow}{if}(aof\_is\_enabled) stopAppendOnly();
01256         signalFlushedDb(-1);
01257         emptyDb(
01258             -1,
01259             server.repl\_slave\_lazy\_flush ? \hyperlink{server_8h_a83bdc5c1a2af487191bb7ca716494ee7}{EMPTYDB\_ASYNC} : 
      \hyperlink{server_8h_a83a0ecde3a9f1f6bbcae9f4b966a509b}{EMPTYDB\_NO\_FLAGS},
01260             replicationEmptyDbCallback);
01261         \textcolor{comment}{/* Before loading the DB into memory we need to delete the readable}
01262 \textcolor{comment}{         * handler, otherwise it will get called recursively since}
01263 \textcolor{comment}{         * rdbLoad() will call the event loop to process events from time to}
01264 \textcolor{comment}{         * time for non blocking loading. */}
01265         aeDeleteFileEvent(server.el,server.repl\_transfer\_s,\hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE});
01266         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE}, \textcolor{stringliteral}{"MASTER <-> SLAVE sync: Loading DB in memory"});
01267         rdbSaveInfo rsi = \hyperlink{server_8h_a694b5ed5268bee8c50cc5b38fbec99ce}{RDB\_SAVE\_INFO\_INIT};
01268         \textcolor{keywordflow}{if} (rdbLoad(server.rdb\_filename,&rsi) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
01269             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Failed trying to load the MASTER synchronization DB from
       disk"});
01270             cancelReplicationHandshake();
01271             \textcolor{comment}{/* Re-enable the AOF if we disabled it earlier, in order to restore}
01272 \textcolor{comment}{             * the original configuration. */}
01273             \textcolor{keywordflow}{if} (aof\_is\_enabled) restartAOF();
01274             \textcolor{keywordflow}{return};
01275         \}
01276         \textcolor{comment}{/* Final setup of the connected slave <- master link */}
01277         zfree(server.repl\_transfer\_tmpfile);
01278         close(server.repl\_transfer\_fd);
01279         replicationCreateMasterClient(server.repl\_transfer\_s,rsi.repl\_stream\_db);
01280         server.repl\_state = \hyperlink{server_8h_aed693b3a9cdfc05cf5ab7551a8c86fbe}{REPL\_STATE\_CONNECTED};
01281         \textcolor{comment}{/* After a full resynchroniziation we use the replication ID and}
01282 \textcolor{comment}{         * offset of the master. The secondary ID / offset are cleared since}
01283 \textcolor{comment}{         * we are starting a new history. */}
01284         memcpy(server.replid,server.master->replid,\textcolor{keyword}{sizeof}(server.replid));
01285         server.master\_repl\_offset = server.master->reploff;
01286         clearReplicationId2();
01287         \textcolor{comment}{/* Let's create the replication backlog if needed. Slaves need to}
01288 \textcolor{comment}{         * accumulate the backlog regardless of the fact they have sub-slaves}
01289 \textcolor{comment}{         * or not, in order to behave correctly if they are promoted to}
01290 \textcolor{comment}{         * masters after a failover. */}
01291         \textcolor{keywordflow}{if} (server.repl\_backlog == NULL) createReplicationBacklog();
01292 
01293         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE}, \textcolor{stringliteral}{"MASTER <-> SLAVE sync: Finished with success"});
01294         \textcolor{comment}{/* Restart the AOF subsystem now that we finished the sync. This}
01295 \textcolor{comment}{         * will trigger an AOF rewrite, and when done will start appending}
01296 \textcolor{comment}{         * to the new file. */}
01297         \textcolor{keywordflow}{if} (aof\_is\_enabled) restartAOF();
01298     \}
01299     \textcolor{keywordflow}{return};
01300 
01301 error:
01302     cancelReplicationHandshake();
01303     \textcolor{keywordflow}{return};
01304 \}
01305 
01306 \textcolor{comment}{/* Send a synchronous command to the master. Used to send AUTH and}
01307 \textcolor{comment}{ * REPLCONF commands before starting the replication with SYNC.}
01308 \textcolor{comment}{ *}
01309 \textcolor{comment}{ * The command returns an sds string representing the result of the}
01310 \textcolor{comment}{ * operation. On error the first byte is a "-".}
01311 \textcolor{comment}{ */}
01312 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SYNC\_CMD\_READ} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)}
01313 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SYNC\_CMD\_WRITE} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}1\textcolor{preprocessor}{)}
01314 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SYNC\_CMD\_FULL} \textcolor{preprocessor}{(}\hyperlink{replication_8c_a5dde0948d622fc1b0327b0d49cb3cef5}{SYNC\_CMD\_READ}\textcolor{preprocessor}{|}\hyperlink{replication_8c_aa4480c458f209657b59d476157d44aab}{SYNC\_CMD\_WRITE}\textcolor{preprocessor}{)}
01315 \textcolor{keywordtype}{char} *sendSynchronousCommand(\textcolor{keywordtype}{int} flags, \textcolor{keywordtype}{int} fd, ...) \{
01316 
01317     \textcolor{comment}{/* Create the command to send to the master, we use simple inline}
01318 \textcolor{comment}{     * protocol for simplicity as currently we only send simple strings. */}
01319     \textcolor{keywordflow}{if} (flags & \hyperlink{replication_8c_aa4480c458f209657b59d476157d44aab}{SYNC\_CMD\_WRITE}) \{
01320         \textcolor{keywordtype}{char} *arg;
01321         va\_list ap;
01322         sds cmd = sdsempty();
01323         va\_start(ap,fd);
01324 
01325         \textcolor{keywordflow}{while}(1) \{
01326             arg = va\_arg(ap, \textcolor{keywordtype}{char}*);
01327             \textcolor{keywordflow}{if} (arg == NULL) \textcolor{keywordflow}{break};
01328 
01329             \textcolor{keywordflow}{if} (sdslen(cmd) != 0) cmd = sdscatlen(cmd,\textcolor{stringliteral}{" "},1);
01330             cmd = sdscat(cmd,arg);
01331         \}
01332         cmd = sdscatlen(cmd,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"},2);
01333 
01334         \textcolor{comment}{/* Transfer command to the server. */}
01335         \textcolor{keywordflow}{if} (syncWrite(fd,cmd,sdslen(cmd),server.repl\_syncio\_timeout*1000)
01336             == -1)
01337         \{
01338             sdsfree(cmd);
01339             \textcolor{keywordflow}{return} sdscatprintf(sdsempty(),\textcolor{stringliteral}{"-Writing to master: %s"},
01340                     strerror(errno));
01341         \}
01342         sdsfree(cmd);
01343         va\_end(ap);
01344     \}
01345 
01346     \textcolor{comment}{/* Read the reply from the server. */}
01347     \textcolor{keywordflow}{if} (flags & \hyperlink{replication_8c_a5dde0948d622fc1b0327b0d49cb3cef5}{SYNC\_CMD\_READ}) \{
01348         \textcolor{keywordtype}{char} buf[256];
01349 
01350         \textcolor{keywordflow}{if} (syncReadLine(fd,buf,\textcolor{keyword}{sizeof}(buf),server.repl\_syncio\_timeout*1000)
01351             == -1)
01352         \{
01353             \textcolor{keywordflow}{return} sdscatprintf(sdsempty(),\textcolor{stringliteral}{"-Reading from master: %s"},
01354                     strerror(errno));
01355         \}
01356         server.repl\_transfer\_lastio = server.unixtime;
01357         \textcolor{keywordflow}{return} sdsnew(buf);
01358     \}
01359     \textcolor{keywordflow}{return} NULL;
01360 \}
01361 
01362 \textcolor{comment}{/* Try a partial resynchronization with the master if we are about to reconnect.}
01363 \textcolor{comment}{ * If there is no cached master structure, at least try to issue a}
01364 \textcolor{comment}{ * "PSYNC ? -1" command in order to trigger a full resync using the PSYNC}
01365 \textcolor{comment}{ * command in order to obtain the master run id and the master replication}
01366 \textcolor{comment}{ * global offset.}
01367 \textcolor{comment}{ *}
01368 \textcolor{comment}{ * This function is designed to be called from syncWithMaster(), so the}
01369 \textcolor{comment}{ * following assumptions are made:}
01370 \textcolor{comment}{ *}
01371 \textcolor{comment}{ * 1) We pass the function an already connected socket "fd".}
01372 \textcolor{comment}{ * 2) This function does not close the file descriptor "fd". However in case}
01373 \textcolor{comment}{ *    of successful partial resynchronization, the function will reuse}
01374 \textcolor{comment}{ *    'fd' as file descriptor of the server.master client structure.}
01375 \textcolor{comment}{ *}
01376 \textcolor{comment}{ * The function is split in two halves: if read\_reply is 0, the function}
01377 \textcolor{comment}{ * writes the PSYNC command on the socket, and a new function call is}
01378 \textcolor{comment}{ * needed, with read\_reply set to 1, in order to read the reply of the}
01379 \textcolor{comment}{ * command. This is useful in order to support non blocking operations, so}
01380 \textcolor{comment}{ * that we write, return into the event loop, and read when there are data.}
01381 \textcolor{comment}{ *}
01382 \textcolor{comment}{ * When read\_reply is 0 the function returns PSYNC\_WRITE\_ERR if there}
01383 \textcolor{comment}{ * was a write error, or PSYNC\_WAIT\_REPLY to signal we need another call}
01384 \textcolor{comment}{ * with read\_reply set to 1. However even when read\_reply is set to 1}
01385 \textcolor{comment}{ * the function may return PSYNC\_WAIT\_REPLY again to signal there were}
01386 \textcolor{comment}{ * insufficient data to read to complete its work. We should re-enter}
01387 \textcolor{comment}{ * into the event loop and wait in such a case.}
01388 \textcolor{comment}{ *}
01389 \textcolor{comment}{ * The function returns:}
01390 \textcolor{comment}{ *}
01391 \textcolor{comment}{ * PSYNC\_CONTINUE: If the PSYNC command succeded and we can continue.}
01392 \textcolor{comment}{ * PSYNC\_FULLRESYNC: If PSYNC is supported but a full resync is needed.}
01393 \textcolor{comment}{ *                   In this case the master run\_id and global replication}
01394 \textcolor{comment}{ *                   offset is saved.}
01395 \textcolor{comment}{ * PSYNC\_NOT\_SUPPORTED: If the server does not understand PSYNC at all and}
01396 \textcolor{comment}{ *                      the caller should fall back to SYNC.}
01397 \textcolor{comment}{ * PSYNC\_WRITE\_ERROR: There was an error writing the command to the socket.}
01398 \textcolor{comment}{ * PSYNC\_WAIT\_REPLY: Call again the function with read\_reply set to 1.}
01399 \textcolor{comment}{ * PSYNC\_TRY\_LATER: Master is currently in a transient error condition.}
01400 \textcolor{comment}{ *}
01401 \textcolor{comment}{ * Notable side effects:}
01402 \textcolor{comment}{ *}
01403 \textcolor{comment}{ * 1) As a side effect of the function call the function removes the readable}
01404 \textcolor{comment}{ *    event handler from "fd", unless the return value is PSYNC\_WAIT\_REPLY.}
01405 \textcolor{comment}{ * 2) server.master\_initial\_offset is set to the right value according}
01406 \textcolor{comment}{ *    to the master reply. This will be used to populate the 'server.master'}
01407 \textcolor{comment}{ *    structure replication offset.}
01408 \textcolor{comment}{ */}
01409 
01410 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{PSYNC\_WRITE\_ERROR} 0
01411 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{PSYNC\_WAIT\_REPLY} 1
01412 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{PSYNC\_CONTINUE} 2
01413 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{PSYNC\_FULLRESYNC} 3
01414 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{PSYNC\_NOT\_SUPPORTED} 4
01415 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{PSYNC\_TRY\_LATER} 5
01416 \textcolor{keywordtype}{int} slaveTryPartialResynchronization(\textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{int} read\_reply) \{
01417     \textcolor{keywordtype}{char} *psync\_replid;
01418     \textcolor{keywordtype}{char} psync\_offset[32];
01419     sds reply;
01420 
01421     \textcolor{comment}{/* Writing half */}
01422     \textcolor{keywordflow}{if} (!read\_reply) \{
01423         \textcolor{comment}{/* Initially set master\_initial\_offset to -1 to mark the current}
01424 \textcolor{comment}{         * master run\_id and offset as not valid. Later if we'll be able to do}
01425 \textcolor{comment}{         * a FULL resync using the PSYNC command we'll set the offset at the}
01426 \textcolor{comment}{         * right value, so that this information will be propagated to the}
01427 \textcolor{comment}{         * client structure representing the master into server.master. */}
01428         server.master\_initial\_offset = -1;
01429 
01430         \textcolor{keywordflow}{if} (server.cached\_master) \{
01431             psync\_replid = server.cached\_master->replid;
01432             snprintf(psync\_offset,\textcolor{keyword}{sizeof}(psync\_offset),\textcolor{stringliteral}{"%lld"}, server.cached\_master->reploff+1);
01433             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Trying a partial resynchronization (request %s:%s)."}, 
      psync\_replid, psync\_offset);
01434         \} \textcolor{keywordflow}{else} \{
01435             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Partial resynchronization not possible (no cached master)"});
01436             psync\_replid = \textcolor{stringliteral}{"?"};
01437             memcpy(psync\_offset,\textcolor{stringliteral}{"-1"},3);
01438         \}
01439 
01440         \textcolor{comment}{/* Issue the PSYNC command */}
01441         reply = sendSynchronousCommand(\hyperlink{replication_8c_aa4480c458f209657b59d476157d44aab}{SYNC\_CMD\_WRITE},fd,\textcolor{stringliteral}{"PSYNC"},psync\_replid,
      psync\_offset,NULL);
01442         \textcolor{keywordflow}{if} (reply != NULL) \{
01443             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Unable to send PSYNC to master: %s"},reply);
01444             sdsfree(reply);
01445             aeDeleteFileEvent(server.el,fd,\hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE});
01446             \textcolor{keywordflow}{return} \hyperlink{replication_8c_a63479df7aec0103920c029d735f6b4ba}{PSYNC\_WRITE\_ERROR};
01447         \}
01448         \textcolor{keywordflow}{return} \hyperlink{replication_8c_a4308c1e1292e0c34cf84d6e54b4869aa}{PSYNC\_WAIT\_REPLY};
01449     \}
01450 
01451     \textcolor{comment}{/* Reading half */}
01452     reply = sendSynchronousCommand(\hyperlink{replication_8c_a5dde0948d622fc1b0327b0d49cb3cef5}{SYNC\_CMD\_READ},fd,NULL);
01453     \textcolor{keywordflow}{if} (sdslen(reply) == 0) \{
01454         \textcolor{comment}{/* The master may send empty newlines after it receives PSYNC}
01455 \textcolor{comment}{         * and before to reply, just to keep the connection alive. */}
01456         sdsfree(reply);
01457         \textcolor{keywordflow}{return} \hyperlink{replication_8c_a4308c1e1292e0c34cf84d6e54b4869aa}{PSYNC\_WAIT\_REPLY};
01458     \}
01459 
01460     aeDeleteFileEvent(server.el,fd,\hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE});
01461 
01462     \textcolor{keywordflow}{if} (!strncmp(reply,\textcolor{stringliteral}{"+FULLRESYNC"},11)) \{
01463         \textcolor{keywordtype}{char} *replid = NULL, *offset = NULL;
01464 
01465         \textcolor{comment}{/* FULL RESYNC, parse the reply in order to extract the run id}
01466 \textcolor{comment}{         * and the replication offset. */}
01467         replid = strchr(reply,\textcolor{stringliteral}{' '});
01468         \textcolor{keywordflow}{if} (replid) \{
01469             replid++;
01470             offset = strchr(replid,\textcolor{stringliteral}{' '});
01471             \textcolor{keywordflow}{if} (offset) offset++;
01472         \}
01473         \textcolor{keywordflow}{if} (!replid || !offset || (offset-replid-1) != \hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}) \{
01474             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01475                 \textcolor{stringliteral}{"Master replied with wrong +FULLRESYNC syntax."});
01476             \textcolor{comment}{/* This is an unexpected condition, actually the +FULLRESYNC}
01477 \textcolor{comment}{             * reply means that the master supports PSYNC, but the reply}
01478 \textcolor{comment}{             * format seems wrong. To stay safe we blank the master}
01479 \textcolor{comment}{             * replid to make sure next PSYNCs will fail. */}
01480             memset(server.master\_replid,0,\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}+1);
01481         \} \textcolor{keywordflow}{else} \{
01482             memcpy(server.master\_replid, replid, offset-replid-1);
01483             server.master\_replid[\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}] = \textcolor{stringliteral}{'\(\backslash\)0'};
01484             server.master\_initial\_offset = strtoll(offset,NULL,10);
01485             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Full resync from master: %s:%lld"},
01486                 server.master\_replid,
01487                 server.master\_initial\_offset);
01488         \}
01489         \textcolor{comment}{/* We are going to full resync, discard the cached master structure. */}
01490         replicationDiscardCachedMaster();
01491         sdsfree(reply);
01492         \textcolor{keywordflow}{return} \hyperlink{replication_8c_a9d0b6b76f92efdd69eba7de13dae3764}{PSYNC\_FULLRESYNC};
01493     \}
01494 
01495     \textcolor{keywordflow}{if} (!strncmp(reply,\textcolor{stringliteral}{"+CONTINUE"},9)) \{
01496         \textcolor{comment}{/* Partial resync was accepted. */}
01497         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01498             \textcolor{stringliteral}{"Successful partial resynchronization with master."});
01499 
01500         \textcolor{comment}{/* Check the new replication ID advertised by the master. If it}
01501 \textcolor{comment}{         * changed, we need to set the new ID as primary ID, and set or}
01502 \textcolor{comment}{         * secondary ID as the old master ID up to the current offset, so}
01503 \textcolor{comment}{         * that our sub-slaves will be able to PSYNC with us after a}
01504 \textcolor{comment}{         * disconnection. */}
01505         \textcolor{keywordtype}{char} *start = reply+10;
01506         \textcolor{keywordtype}{char} *end = reply+9;
01507         \textcolor{keywordflow}{while}(end[0] != \textcolor{stringliteral}{'\(\backslash\)r'} && end[0] != \textcolor{stringliteral}{'\(\backslash\)n'} && end[0] != \textcolor{stringliteral}{'\(\backslash\)0'}) end++;
01508         \textcolor{keywordflow}{if} (end-start == \hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}) \{
01509             \textcolor{keywordtype}{char} \textcolor{keyword}{new}[\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}+1];
01510             memcpy(\textcolor{keyword}{new},start,\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE});
01511             \textcolor{keyword}{new}[\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}] = \textcolor{stringliteral}{'\(\backslash\)0'};
01512 
01513             \textcolor{keywordflow}{if} (strcmp(\textcolor{keyword}{new},server.cached\_master->replid)) \{
01514                 \textcolor{comment}{/* Master ID changed. */}
01515                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Master replication ID changed to %s"},\textcolor{keyword}{new});
01516 
01517                 \textcolor{comment}{/* Set the old ID as our ID2, up to the current offset+1. */}
01518                 memcpy(server.replid2,server.cached\_master->replid,
01519                     \textcolor{keyword}{sizeof}(server.replid2));
01520                 server.second\_replid\_offset = server.master\_repl\_offset+1;
01521 
01522                 \textcolor{comment}{/* Update the cached master ID and our own primary ID to the}
01523 \textcolor{comment}{                 * new one. */}
01524                 memcpy(server.replid,\textcolor{keyword}{new},\textcolor{keyword}{sizeof}(server.replid));
01525                 memcpy(server.cached\_master->replid,\textcolor{keyword}{new},\textcolor{keyword}{sizeof}(server.replid));
01526 
01527                 \textcolor{comment}{/* Disconnect all the sub-slaves: they need to be notified. */}
01528                 disconnectSlaves();
01529             \}
01530         \}
01531 
01532         \textcolor{comment}{/* Setup the replication to continue. */}
01533         sdsfree(reply);
01534         replicationResurrectCachedMaster(fd);
01535 
01536         \textcolor{comment}{/* If this instance was restarted and we read the metadata to}
01537 \textcolor{comment}{         * PSYNC from the persistence file, our replication backlog could}
01538 \textcolor{comment}{         * be still not initialized. Create it. */}
01539         \textcolor{keywordflow}{if} (server.repl\_backlog == NULL) createReplicationBacklog();
01540         \textcolor{keywordflow}{return} \hyperlink{replication_8c_a96f39718bf5cfd2859bdaea530f509b9}{PSYNC\_CONTINUE};
01541     \}
01542 
01543     \textcolor{comment}{/* If we reach this point we received either an error (since the master does}
01544 \textcolor{comment}{     * not understand PSYNC or because it is in a special state and cannot}
01545 \textcolor{comment}{     * serve our request), or an unexpected reply from the master.}
01546 \textcolor{comment}{     *}
01547 \textcolor{comment}{     * Return PSYNC\_NOT\_SUPPORTED on errors we don't understand, otherwise}
01548 \textcolor{comment}{     * return PSYNC\_TRY\_LATER if we believe this is a transient error. */}
01549 
01550     \textcolor{keywordflow}{if} (!strncmp(reply,\textcolor{stringliteral}{"-NOMASTERLINK"},13) ||
01551         !strncmp(reply,\textcolor{stringliteral}{"-LOADING"},8))
01552     \{
01553         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01554             \textcolor{stringliteral}{"Master is currently unable to PSYNC "}
01555             \textcolor{stringliteral}{"but should be in the future: %s"}, reply);
01556         sdsfree(reply);
01557         \textcolor{keywordflow}{return} \hyperlink{replication_8c_a033726631820c6ebdfb2f034a870e9da}{PSYNC\_TRY\_LATER};
01558     \}
01559 
01560     \textcolor{keywordflow}{if} (strncmp(reply,\textcolor{stringliteral}{"-ERR"},4)) \{
01561         \textcolor{comment}{/* If it's not an error, log the unexpected event. */}
01562         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01563             \textcolor{stringliteral}{"Unexpected reply to PSYNC from master: %s"}, reply);
01564     \} \textcolor{keywordflow}{else} \{
01565         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01566             \textcolor{stringliteral}{"Master does not support PSYNC or is in "}
01567             \textcolor{stringliteral}{"error state (reply: %s)"}, reply);
01568     \}
01569     sdsfree(reply);
01570     replicationDiscardCachedMaster();
01571     \textcolor{keywordflow}{return} \hyperlink{replication_8c_a9722855166099ab95f712e73ed819abf}{PSYNC\_NOT\_SUPPORTED};
01572 \}
01573 
01574 \textcolor{comment}{/* This handler fires when the non blocking connect was able to}
01575 \textcolor{comment}{ * establish a connection with the master. */}
01576 \textcolor{keywordtype}{void} syncWithMaster(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask) \{
01577     \textcolor{keywordtype}{char} tmpfile[256], *err = NULL;
01578     \textcolor{keywordtype}{int} dfd = -1, maxtries = 5;
01579     \textcolor{keywordtype}{int} sockerr = 0, psync\_result;
01580     socklen\_t errlen = \textcolor{keyword}{sizeof}(sockerr);
01581     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(el);
01582     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(privdata);
01583     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(mask);
01584 
01585     \textcolor{comment}{/* If this event fired after the user turned the instance into a master}
01586 \textcolor{comment}{     * with SLAVEOF NO ONE we must just return ASAP. */}
01587     \textcolor{keywordflow}{if} (server.repl\_state == \hyperlink{server_8h_a256b9506e551eaa7417f75f8fa9ed901}{REPL\_STATE\_NONE}) \{
01588         close(fd);
01589         \textcolor{keywordflow}{return};
01590     \}
01591 
01592     \textcolor{comment}{/* Check for errors in the socket: after a non blocking connect() we}
01593 \textcolor{comment}{     * may find that the socket is in error state. */}
01594     \textcolor{keywordflow}{if} (getsockopt(fd, SOL\_SOCKET, SO\_ERROR, &sockerr, &errlen) == -1)
01595         sockerr = errno;
01596     \textcolor{keywordflow}{if} (sockerr) \{
01597         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Error condition on socket for SYNC: %s"},
01598             strerror(sockerr));
01599         \textcolor{keywordflow}{goto} error;
01600     \}
01601 
01602     \textcolor{comment}{/* Send a PING to check the master is able to reply without errors. */}
01603     \textcolor{keywordflow}{if} (server.repl\_state == \hyperlink{server_8h_a5fd7ad86a4a65d6486d151151a59e9a5}{REPL\_STATE\_CONNECTING}) \{
01604         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Non blocking connect for SYNC fired the event."});
01605         \textcolor{comment}{/* Delete the writable event so that the readable event remains}
01606 \textcolor{comment}{         * registered and we can wait for the PONG reply. */}
01607         aeDeleteFileEvent(server.el,fd,\hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE});
01608         server.repl\_state = \hyperlink{server_8h_a61922e0fcf35df9722d2648484d23ff2}{REPL\_STATE\_RECEIVE\_PONG};
01609         \textcolor{comment}{/* Send the PING, don't check for errors at all, we have the timeout}
01610 \textcolor{comment}{         * that will take care about this. */}
01611         err = sendSynchronousCommand(\hyperlink{replication_8c_aa4480c458f209657b59d476157d44aab}{SYNC\_CMD\_WRITE},fd,\textcolor{stringliteral}{"PING"},NULL);
01612         \textcolor{keywordflow}{if} (err) \textcolor{keywordflow}{goto} write\_error;
01613         \textcolor{keywordflow}{return};
01614     \}
01615 
01616     \textcolor{comment}{/* Receive the PONG command. */}
01617     \textcolor{keywordflow}{if} (server.repl\_state == \hyperlink{server_8h_a61922e0fcf35df9722d2648484d23ff2}{REPL\_STATE\_RECEIVE\_PONG}) \{
01618         err = sendSynchronousCommand(\hyperlink{replication_8c_a5dde0948d622fc1b0327b0d49cb3cef5}{SYNC\_CMD\_READ},fd,NULL);
01619 
01620         \textcolor{comment}{/* We accept only two replies as valid, a positive +PONG reply}
01621 \textcolor{comment}{         * (we just check for "+") or an authentication error.}
01622 \textcolor{comment}{         * Note that older versions of Redis replied with "operation not}
01623 \textcolor{comment}{         * permitted" instead of using a proper error code, so we test}
01624 \textcolor{comment}{         * both. */}
01625         \textcolor{keywordflow}{if} (err[0] != \textcolor{stringliteral}{'+'} &&
01626             strncmp(err,\textcolor{stringliteral}{"-NOAUTH"},7) != 0 &&
01627             strncmp(err,\textcolor{stringliteral}{"-ERR operation not permitted"},28) != 0)
01628         \{
01629             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Error reply to PING from master: '%s'"},err);
01630             sdsfree(err);
01631             \textcolor{keywordflow}{goto} error;
01632         \} \textcolor{keywordflow}{else} \{
01633             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01634                 \textcolor{stringliteral}{"Master replied to PING, replication can continue..."});
01635         \}
01636         sdsfree(err);
01637         server.repl\_state = \hyperlink{server_8h_aec2fc2703ecb4784a64eedb760136a3f}{REPL\_STATE\_SEND\_AUTH};
01638     \}
01639 
01640     \textcolor{comment}{/* AUTH with the master if required. */}
01641     \textcolor{keywordflow}{if} (server.repl\_state == \hyperlink{server_8h_aec2fc2703ecb4784a64eedb760136a3f}{REPL\_STATE\_SEND\_AUTH}) \{
01642         \textcolor{keywordflow}{if} (server.masterauth) \{
01643             err = sendSynchronousCommand(\hyperlink{replication_8c_aa4480c458f209657b59d476157d44aab}{SYNC\_CMD\_WRITE},fd,\textcolor{stringliteral}{"AUTH"},server.masterauth,NULL
      );
01644             \textcolor{keywordflow}{if} (err) \textcolor{keywordflow}{goto} write\_error;
01645             server.repl\_state = \hyperlink{server_8h_a927236ee88a2420450021c4ab3d0e0d3}{REPL\_STATE\_RECEIVE\_AUTH};
01646             \textcolor{keywordflow}{return};
01647         \} \textcolor{keywordflow}{else} \{
01648             server.repl\_state = \hyperlink{server_8h_a85992c63bed9483320b32c54c110ed80}{REPL\_STATE\_SEND\_PORT};
01649         \}
01650     \}
01651 
01652     \textcolor{comment}{/* Receive AUTH reply. */}
01653     \textcolor{keywordflow}{if} (server.repl\_state == \hyperlink{server_8h_a927236ee88a2420450021c4ab3d0e0d3}{REPL\_STATE\_RECEIVE\_AUTH}) \{
01654         err = sendSynchronousCommand(\hyperlink{replication_8c_a5dde0948d622fc1b0327b0d49cb3cef5}{SYNC\_CMD\_READ},fd,NULL);
01655         \textcolor{keywordflow}{if} (err[0] == \textcolor{stringliteral}{'-'}) \{
01656             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Unable to AUTH to MASTER: %s"},err);
01657             sdsfree(err);
01658             \textcolor{keywordflow}{goto} error;
01659         \}
01660         sdsfree(err);
01661         server.repl\_state = \hyperlink{server_8h_a85992c63bed9483320b32c54c110ed80}{REPL\_STATE\_SEND\_PORT};
01662     \}
01663 
01664     \textcolor{comment}{/* Set the slave port, so that Master's INFO command can list the}
01665 \textcolor{comment}{     * slave listening port correctly. */}
01666     \textcolor{keywordflow}{if} (server.repl\_state == \hyperlink{server_8h_a85992c63bed9483320b32c54c110ed80}{REPL\_STATE\_SEND\_PORT}) \{
01667         sds port = sdsfromlonglong(server.slave\_announce\_port ?
01668             server.slave\_announce\_port : server.port);
01669         err = sendSynchronousCommand(\hyperlink{replication_8c_aa4480c458f209657b59d476157d44aab}{SYNC\_CMD\_WRITE},fd,\textcolor{stringliteral}{"REPLCONF"},
01670                 \textcolor{stringliteral}{"listening-port"},port, NULL);
01671         sdsfree(port);
01672         \textcolor{keywordflow}{if} (err) \textcolor{keywordflow}{goto} write\_error;
01673         sdsfree(err);
01674         server.repl\_state = \hyperlink{server_8h_abdf6b7d97826598c4c9176141b712c2c}{REPL\_STATE\_RECEIVE\_PORT};
01675         \textcolor{keywordflow}{return};
01676     \}
01677 
01678     \textcolor{comment}{/* Receive REPLCONF listening-port reply. */}
01679     \textcolor{keywordflow}{if} (server.repl\_state == \hyperlink{server_8h_abdf6b7d97826598c4c9176141b712c2c}{REPL\_STATE\_RECEIVE\_PORT}) \{
01680         err = sendSynchronousCommand(\hyperlink{replication_8c_a5dde0948d622fc1b0327b0d49cb3cef5}{SYNC\_CMD\_READ},fd,NULL);
01681         \textcolor{comment}{/* Ignore the error if any, not all the Redis versions support}
01682 \textcolor{comment}{         * REPLCONF listening-port. */}
01683         \textcolor{keywordflow}{if} (err[0] == \textcolor{stringliteral}{'-'}) \{
01684             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"(Non critical) Master does not understand "}
01685                                 \textcolor{stringliteral}{"REPLCONF listening-port: %s"}, err);
01686         \}
01687         sdsfree(err);
01688         server.repl\_state = \hyperlink{server_8h_a76e12a8d873ec0cfb646bcf60ea3a8b9}{REPL\_STATE\_SEND\_IP};
01689     \}
01690 
01691     \textcolor{comment}{/* Skip REPLCONF ip-address if there is no slave-announce-ip option set. */}
01692     \textcolor{keywordflow}{if} (server.repl\_state == \hyperlink{server_8h_a76e12a8d873ec0cfb646bcf60ea3a8b9}{REPL\_STATE\_SEND\_IP} &&
01693         server.slave\_announce\_ip == NULL)
01694     \{
01695             server.repl\_state = \hyperlink{server_8h_a9933a133c5a09bdaa0a35a8152826ea3}{REPL\_STATE\_SEND\_CAPA};
01696     \}
01697 
01698     \textcolor{comment}{/* Set the slave ip, so that Master's INFO command can list the}
01699 \textcolor{comment}{     * slave IP address port correctly in case of port forwarding or NAT. */}
01700     \textcolor{keywordflow}{if} (server.repl\_state == \hyperlink{server_8h_a76e12a8d873ec0cfb646bcf60ea3a8b9}{REPL\_STATE\_SEND\_IP}) \{
01701         err = sendSynchronousCommand(\hyperlink{replication_8c_aa4480c458f209657b59d476157d44aab}{SYNC\_CMD\_WRITE},fd,\textcolor{stringliteral}{"REPLCONF"},
01702                 \textcolor{stringliteral}{"ip-address"},server.slave\_announce\_ip, NULL);
01703         \textcolor{keywordflow}{if} (err) \textcolor{keywordflow}{goto} write\_error;
01704         sdsfree(err);
01705         server.repl\_state = \hyperlink{server_8h_a41b2bc439b62dfa5cc310aa95cca90da}{REPL\_STATE\_RECEIVE\_IP};
01706         \textcolor{keywordflow}{return};
01707     \}
01708 
01709     \textcolor{comment}{/* Receive REPLCONF ip-address reply. */}
01710     \textcolor{keywordflow}{if} (server.repl\_state == \hyperlink{server_8h_a41b2bc439b62dfa5cc310aa95cca90da}{REPL\_STATE\_RECEIVE\_IP}) \{
01711         err = sendSynchronousCommand(\hyperlink{replication_8c_a5dde0948d622fc1b0327b0d49cb3cef5}{SYNC\_CMD\_READ},fd,NULL);
01712         \textcolor{comment}{/* Ignore the error if any, not all the Redis versions support}
01713 \textcolor{comment}{         * REPLCONF listening-port. */}
01714         \textcolor{keywordflow}{if} (err[0] == \textcolor{stringliteral}{'-'}) \{
01715             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"(Non critical) Master does not understand "}
01716                                 \textcolor{stringliteral}{"REPLCONF ip-address: %s"}, err);
01717         \}
01718         sdsfree(err);
01719         server.repl\_state = \hyperlink{server_8h_a9933a133c5a09bdaa0a35a8152826ea3}{REPL\_STATE\_SEND\_CAPA};
01720     \}
01721 
01722     \textcolor{comment}{/* Inform the master of our (slave) capabilities.}
01723 \textcolor{comment}{     *}
01724 \textcolor{comment}{     * EOF: supports EOF-style RDB transfer for diskless replication.}
01725 \textcolor{comment}{     * PSYNC2: supports PSYNC v2, so understands +CONTINUE <new repl ID>.}
01726 \textcolor{comment}{     *}
01727 \textcolor{comment}{     * The master will ignore capabilities it does not understand. */}
01728     \textcolor{keywordflow}{if} (server.repl\_state == \hyperlink{server_8h_a9933a133c5a09bdaa0a35a8152826ea3}{REPL\_STATE\_SEND\_CAPA}) \{
01729         err = sendSynchronousCommand(\hyperlink{replication_8c_aa4480c458f209657b59d476157d44aab}{SYNC\_CMD\_WRITE},fd,\textcolor{stringliteral}{"REPLCONF"},
01730                 \textcolor{stringliteral}{"capa"},\textcolor{stringliteral}{"eof"},\textcolor{stringliteral}{"capa"},\textcolor{stringliteral}{"psync2"},NULL);
01731         \textcolor{keywordflow}{if} (err) \textcolor{keywordflow}{goto} write\_error;
01732         sdsfree(err);
01733         server.repl\_state = \hyperlink{server_8h_a9dd64738880c47dd6c12b7b90d73ad98}{REPL\_STATE\_RECEIVE\_CAPA};
01734         \textcolor{keywordflow}{return};
01735     \}
01736 
01737     \textcolor{comment}{/* Receive CAPA reply. */}
01738     \textcolor{keywordflow}{if} (server.repl\_state == \hyperlink{server_8h_a9dd64738880c47dd6c12b7b90d73ad98}{REPL\_STATE\_RECEIVE\_CAPA}) \{
01739         err = sendSynchronousCommand(\hyperlink{replication_8c_a5dde0948d622fc1b0327b0d49cb3cef5}{SYNC\_CMD\_READ},fd,NULL);
01740         \textcolor{comment}{/* Ignore the error if any, not all the Redis versions support}
01741 \textcolor{comment}{         * REPLCONF capa. */}
01742         \textcolor{keywordflow}{if} (err[0] == \textcolor{stringliteral}{'-'}) \{
01743             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"(Non critical) Master does not understand "}
01744                                   \textcolor{stringliteral}{"REPLCONF capa: %s"}, err);
01745         \}
01746         sdsfree(err);
01747         server.repl\_state = \hyperlink{server_8h_aa9951dea877e8e4f04d910ecf88f92fd}{REPL\_STATE\_SEND\_PSYNC};
01748     \}
01749 
01750     \textcolor{comment}{/* Try a partial resynchonization. If we don't have a cached master}
01751 \textcolor{comment}{     * slaveTryPartialResynchronization() will at least try to use PSYNC}
01752 \textcolor{comment}{     * to start a full resynchronization so that we get the master run id}
01753 \textcolor{comment}{     * and the global offset, to try a partial resync at the next}
01754 \textcolor{comment}{     * reconnection attempt. */}
01755     \textcolor{keywordflow}{if} (server.repl\_state == \hyperlink{server_8h_aa9951dea877e8e4f04d910ecf88f92fd}{REPL\_STATE\_SEND\_PSYNC}) \{
01756         \textcolor{keywordflow}{if} (slaveTryPartialResynchronization(fd,0) == \hyperlink{replication_8c_a63479df7aec0103920c029d735f6b4ba}{PSYNC\_WRITE\_ERROR}) \{
01757             err = sdsnew(\textcolor{stringliteral}{"Write error sending the PSYNC command."});
01758             \textcolor{keywordflow}{goto} write\_error;
01759         \}
01760         server.repl\_state = \hyperlink{server_8h_a31432ee96d5825316f1d96bcbda28d58}{REPL\_STATE\_RECEIVE\_PSYNC};
01761         \textcolor{keywordflow}{return};
01762     \}
01763 
01764     \textcolor{comment}{/* If reached this point, we should be in REPL\_STATE\_RECEIVE\_PSYNC. */}
01765     \textcolor{keywordflow}{if} (server.repl\_state != \hyperlink{server_8h_a31432ee96d5825316f1d96bcbda28d58}{REPL\_STATE\_RECEIVE\_PSYNC}) \{
01766         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"syncWithMaster(): state machine error, "}
01767                              \textcolor{stringliteral}{"state should be RECEIVE\_PSYNC but is %d"},
01768                              server.repl\_state);
01769         \textcolor{keywordflow}{goto} error;
01770     \}
01771 
01772     psync\_result = slaveTryPartialResynchronization(fd,1);
01773     \textcolor{keywordflow}{if} (psync\_result == \hyperlink{replication_8c_a4308c1e1292e0c34cf84d6e54b4869aa}{PSYNC\_WAIT\_REPLY}) \textcolor{keywordflow}{return}; \textcolor{comment}{/* Try again later... */}
01774 
01775     \textcolor{comment}{/* If the master is in an transient error, we should try to PSYNC}
01776 \textcolor{comment}{     * from scratch later, so go to the error path. This happens when}
01777 \textcolor{comment}{     * the server is loading the dataset or is not connected with its}
01778 \textcolor{comment}{     * master and so forth. */}
01779     \textcolor{keywordflow}{if} (psync\_result == \hyperlink{replication_8c_a033726631820c6ebdfb2f034a870e9da}{PSYNC\_TRY\_LATER}) \textcolor{keywordflow}{goto} error;
01780 
01781     \textcolor{comment}{/* Note: if PSYNC does not return WAIT\_REPLY, it will take care of}
01782 \textcolor{comment}{     * uninstalling the read handler from the file descriptor. */}
01783 
01784     \textcolor{keywordflow}{if} (psync\_result == \hyperlink{replication_8c_a96f39718bf5cfd2859bdaea530f509b9}{PSYNC\_CONTINUE}) \{
01785         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE}, \textcolor{stringliteral}{"MASTER <-> SLAVE sync: Master accepted a Partial
       Resynchronization."});
01786         \textcolor{keywordflow}{return};
01787     \}
01788 
01789     \textcolor{comment}{/* PSYNC failed or is not supported: we want our slaves to resync with us}
01790 \textcolor{comment}{     * as well, if we have any sub-slaves. The master may transfer us an}
01791 \textcolor{comment}{     * entirely different data set and we have no way to incrementally feed}
01792 \textcolor{comment}{     * our slaves after that. */}
01793     disconnectSlaves(); \textcolor{comment}{/* Force our slaves to resync with us as well. */}
01794     freeReplicationBacklog(); \textcolor{comment}{/* Don't allow our chained slaves to PSYNC. */}
01795 
01796     \textcolor{comment}{/* Fall back to SYNC if needed. Otherwise psync\_result == PSYNC\_FULLRESYNC}
01797 \textcolor{comment}{     * and the server.master\_replid and master\_initial\_offset are}
01798 \textcolor{comment}{     * already populated. */}
01799     \textcolor{keywordflow}{if} (psync\_result == \hyperlink{replication_8c_a9722855166099ab95f712e73ed819abf}{PSYNC\_NOT\_SUPPORTED}) \{
01800         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Retrying with SYNC..."});
01801         \textcolor{keywordflow}{if} (syncWrite(fd,\textcolor{stringliteral}{"SYNC\(\backslash\)r\(\backslash\)n"},6,server.repl\_syncio\_timeout*1000) == -1) \{
01802             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"I/O error writing to MASTER: %s"},
01803                 strerror(errno));
01804             \textcolor{keywordflow}{goto} error;
01805         \}
01806     \}
01807 
01808     \textcolor{comment}{/* Prepare a suitable temp file for bulk transfer */}
01809     \textcolor{keywordflow}{while}(maxtries--) \{
01810         snprintf(tmpfile,256,
01811             \textcolor{stringliteral}{"temp-%d.%ld.rdb"},(\textcolor{keywordtype}{int})server.unixtime,(\textcolor{keywordtype}{long} \textcolor{keywordtype}{int})getpid());
01812         dfd = open(tmpfile,O\_CREAT|O\_WRONLY|O\_EXCL,0644);
01813         \textcolor{keywordflow}{if} (dfd != -1) \textcolor{keywordflow}{break};
01814         sleep(1);
01815     \}
01816     \textcolor{keywordflow}{if} (dfd == -1) \{
01817         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Opening the temp file needed for MASTER <-> SLAVE
       synchronization: %s"},strerror(errno));
01818         \textcolor{keywordflow}{goto} error;
01819     \}
01820 
01821     \textcolor{comment}{/* Setup the non blocking download of the bulk file. */}
01822     \textcolor{keywordflow}{if} (aeCreateFileEvent(server.el,fd, \hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE},readSyncBulkPayload,NULL)
01823             == \hyperlink{ae_8h_aa16dcf7effdf8f8df97f51b1cb51a9df}{AE\_ERR})
01824     \{
01825         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01826             \textcolor{stringliteral}{"Can't create readable event for SYNC: %s (fd=%d)"},
01827             strerror(errno),fd);
01828         \textcolor{keywordflow}{goto} error;
01829     \}
01830 
01831     server.repl\_state = \hyperlink{server_8h_a1d27594a2d9c8d24e4ed5a2e88d1113e}{REPL\_STATE\_TRANSFER};
01832     server.repl\_transfer\_size = -1;
01833     server.repl\_transfer\_read = 0;
01834     server.repl\_transfer\_last\_fsync\_off = 0;
01835     server.repl\_transfer\_fd = dfd;
01836     server.repl\_transfer\_lastio = server.unixtime;
01837     server.repl\_transfer\_tmpfile = zstrdup(tmpfile);
01838     \textcolor{keywordflow}{return};
01839 
01840 error:
01841     aeDeleteFileEvent(server.el,fd,\hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE}|\hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE});
01842     \textcolor{keywordflow}{if} (dfd != -1) close(dfd);
01843     close(fd);
01844     server.repl\_transfer\_s = -1;
01845     server.repl\_state = \hyperlink{server_8h_adfe013d4a620f0b98b47b2144760e69f}{REPL\_STATE\_CONNECT};
01846     \textcolor{keywordflow}{return};
01847 
01848 write\_error: \textcolor{comment}{/* Handle sendSynchronousCommand(SYNC\_CMD\_WRITE) errors. */}
01849     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Sending command to master in replication handshake: %s"}, err);
01850     sdsfree(err);
01851     \textcolor{keywordflow}{goto} error;
01852 \}
01853 
01854 \textcolor{keywordtype}{int} connectWithMaster(\textcolor{keywordtype}{void}) \{
01855     \textcolor{keywordtype}{int} fd;
01856 
01857     fd = anetTcpNonBlockBestEffortBindConnect(NULL,
01858         server.masterhost,server.masterport,\hyperlink{server_8h_a53b900c09238a4ff78e0af9574335dfd}{NET\_FIRST\_BIND\_ADDR});
01859     \textcolor{keywordflow}{if} (fd == -1) \{
01860         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Unable to connect to MASTER: %s"},
01861             strerror(errno));
01862         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01863     \}
01864 
01865     \textcolor{keywordflow}{if} (aeCreateFileEvent(server.el,fd,\hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE}|\hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE},syncWithMaster,
      NULL) ==
01866             \hyperlink{ae_8h_aa16dcf7effdf8f8df97f51b1cb51a9df}{AE\_ERR})
01867     \{
01868         close(fd);
01869         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Can't create readable event for SYNC"});
01870         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01871     \}
01872 
01873     server.repl\_transfer\_lastio = server.unixtime;
01874     server.repl\_transfer\_s = fd;
01875     server.repl\_state = \hyperlink{server_8h_a5fd7ad86a4a65d6486d151151a59e9a5}{REPL\_STATE\_CONNECTING};
01876     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01877 \}
01878 
01879 \textcolor{comment}{/* This function can be called when a non blocking connection is currently}
01880 \textcolor{comment}{ * in progress to undo it.}
01881 \textcolor{comment}{ * Never call this function directly, use cancelReplicationHandshake() instead.}
01882 \textcolor{comment}{ */}
01883 \textcolor{keywordtype}{void} undoConnectWithMaster(\textcolor{keywordtype}{void}) \{
01884     \textcolor{keywordtype}{int} fd = server.repl\_transfer\_s;
01885 
01886     aeDeleteFileEvent(server.el,fd,\hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE}|\hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE});
01887     close(fd);
01888     server.repl\_transfer\_s = -1;
01889 \}
01890 
01891 \textcolor{comment}{/* Abort the async download of the bulk dataset while SYNC-ing with master.}
01892 \textcolor{comment}{ * Never call this function directly, use cancelReplicationHandshake() instead.}
01893 \textcolor{comment}{ */}
01894 \textcolor{keywordtype}{void} replicationAbortSyncTransfer(\textcolor{keywordtype}{void}) \{
01895     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(server.repl\_state == \hyperlink{server_8h_a1d27594a2d9c8d24e4ed5a2e88d1113e}{REPL\_STATE\_TRANSFER});
01896     undoConnectWithMaster();
01897     close(server.repl\_transfer\_fd);
01898     unlink(server.repl\_transfer\_tmpfile);
01899     zfree(server.repl\_transfer\_tmpfile);
01900 \}
01901 
01902 \textcolor{comment}{/* This function aborts a non blocking replication attempt if there is one}
01903 \textcolor{comment}{ * in progress, by canceling the non-blocking connect attempt or}
01904 \textcolor{comment}{ * the initial bulk transfer.}
01905 \textcolor{comment}{ *}
01906 \textcolor{comment}{ * If there was a replication handshake in progress 1 is returned and}
01907 \textcolor{comment}{ * the replication state (server.repl\_state) set to REPL\_STATE\_CONNECT.}
01908 \textcolor{comment}{ *}
01909 \textcolor{comment}{ * Otherwise zero is returned and no operation is perforemd at all. */}
01910 \textcolor{keywordtype}{int} cancelReplicationHandshake(\textcolor{keywordtype}{void}) \{
01911     \textcolor{keywordflow}{if} (server.repl\_state == \hyperlink{server_8h_a1d27594a2d9c8d24e4ed5a2e88d1113e}{REPL\_STATE\_TRANSFER}) \{
01912         replicationAbortSyncTransfer();
01913         server.repl\_state = \hyperlink{server_8h_adfe013d4a620f0b98b47b2144760e69f}{REPL\_STATE\_CONNECT};
01914     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.repl\_state == \hyperlink{server_8h_a5fd7ad86a4a65d6486d151151a59e9a5}{REPL\_STATE\_CONNECTING} ||
01915                slaveIsInHandshakeState())
01916     \{
01917         undoConnectWithMaster();
01918         server.repl\_state = \hyperlink{server_8h_adfe013d4a620f0b98b47b2144760e69f}{REPL\_STATE\_CONNECT};
01919     \} \textcolor{keywordflow}{else} \{
01920         \textcolor{keywordflow}{return} 0;
01921     \}
01922     \textcolor{keywordflow}{return} 1;
01923 \}
01924 
01925 \textcolor{comment}{/* Set replication to the specified master address and port. */}
01926 \textcolor{keywordtype}{void} replicationSetMaster(\textcolor{keywordtype}{char} *ip, \textcolor{keywordtype}{int} port) \{
01927     \textcolor{keywordtype}{int} was\_master = server.masterhost == NULL;
01928 
01929     sdsfree(server.masterhost);
01930     server.masterhost = sdsnew(ip);
01931     server.masterport = port;
01932     \textcolor{keywordflow}{if} (server.master) \{
01933         freeClient(server.master);
01934     \}
01935     disconnectAllBlockedClients(); \textcolor{comment}{/* Clients blocked in master, now slave. */}
01936 
01937     \textcolor{comment}{/* Force our slaves to resync with us as well. They may hopefully be able}
01938 \textcolor{comment}{     * to partially resync with us, but we can notify the replid change. */}
01939     disconnectSlaves();
01940     cancelReplicationHandshake();
01941     \textcolor{comment}{/* Before destroying our master state, create a cached master using}
01942 \textcolor{comment}{     * our own parameters, to later PSYNC with the new master. */}
01943     \textcolor{keywordflow}{if} (was\_master) replicationCacheMasterUsingMyself();
01944     server.repl\_state = \hyperlink{server_8h_adfe013d4a620f0b98b47b2144760e69f}{REPL\_STATE\_CONNECT};
01945     server.repl\_down\_since = 0;
01946 \}
01947 
01948 \textcolor{comment}{/* Cancel replication, setting the instance as a master itself. */}
01949 \textcolor{keywordtype}{void} replicationUnsetMaster(\textcolor{keywordtype}{void}) \{
01950     \textcolor{keywordflow}{if} (server.masterhost == NULL) \textcolor{keywordflow}{return}; \textcolor{comment}{/* Nothing to do. */}
01951     sdsfree(server.masterhost);
01952     server.masterhost = NULL;
01953     \textcolor{comment}{/* When a slave is turned into a master, the current replication ID}
01954 \textcolor{comment}{     * (that was inherited from the master at synchronization time) is}
01955 \textcolor{comment}{     * used as secondary ID up to the current offset, and a new replication}
01956 \textcolor{comment}{     * ID is created to continue with a new replication history. */}
01957     shiftReplicationId();
01958     \textcolor{keywordflow}{if} (server.master) freeClient(server.master);
01959     replicationDiscardCachedMaster();
01960     cancelReplicationHandshake();
01961     \textcolor{comment}{/* Disconnecting all the slaves is required: we need to inform slaves}
01962 \textcolor{comment}{     * of the replication ID change (see shiftReplicationId() call). However}
01963 \textcolor{comment}{     * the slaves will be able to partially resync with us, so it will be}
01964 \textcolor{comment}{     * a very fast reconnection. */}
01965     disconnectSlaves();
01966     server.repl\_state = \hyperlink{server_8h_a256b9506e551eaa7417f75f8fa9ed901}{REPL\_STATE\_NONE};
01967 
01968     \textcolor{comment}{/* We need to make sure the new master will start the replication stream}
01969 \textcolor{comment}{     * with a SELECT statement. This is forced after a full resync, but}
01970 \textcolor{comment}{     * with PSYNC version 2, there is no need for full resync after a}
01971 \textcolor{comment}{     * master switch. */}
01972     server.slaveseldb = -1;
01973 \}
01974 
01975 \textcolor{comment}{/* This function is called when the slave lose the connection with the}
01976 \textcolor{comment}{ * master into an unexpected way. */}
01977 \textcolor{keywordtype}{void} replicationHandleMasterDisconnection(\textcolor{keywordtype}{void}) \{
01978     server.master = NULL;
01979     server.repl\_state = \hyperlink{server_8h_adfe013d4a620f0b98b47b2144760e69f}{REPL\_STATE\_CONNECT};
01980     server.repl\_down\_since = server.unixtime;
01981     \textcolor{comment}{/* We lost connection with our master, don't disconnect slaves yet,}
01982 \textcolor{comment}{     * maybe we'll be able to PSYNC with our master later. We'll disconnect}
01983 \textcolor{comment}{     * the slaves only if we'll have to do a full resync with our master. */}
01984 \}
01985 
01986 \textcolor{keywordtype}{void} slaveofCommand(client *c) \{
01987     \textcolor{comment}{/* SLAVEOF is not allowed in cluster mode as replication is automatically}
01988 \textcolor{comment}{     * configured using the current address of the master node. */}
01989     \textcolor{keywordflow}{if} (server.cluster\_enabled) \{
01990         addReplyError(c,\textcolor{stringliteral}{"SLAVEOF not allowed in cluster mode."});
01991         \textcolor{keywordflow}{return};
01992     \}
01993 
01994     \textcolor{comment}{/* The special host/port combination "NO" "ONE" turns the instance}
01995 \textcolor{comment}{     * into a master. Otherwise the new master address is set. */}
01996     \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"no"}) &&
01997         !strcasecmp(c->argv[2]->ptr,\textcolor{stringliteral}{"one"})) \{
01998         \textcolor{keywordflow}{if} (server.masterhost) \{
01999             replicationUnsetMaster();
02000             sds client = catClientInfoString(sdsempty(),c);
02001             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"MASTER MODE enabled (user request from '%s')"},
02002                 client);
02003             sdsfree(client);
02004         \}
02005     \} \textcolor{keywordflow}{else} \{
02006         \textcolor{keywordtype}{long} port;
02007 
02008         \textcolor{keywordflow}{if} ((getLongFromObjectOrReply(c, c->argv[2], &port, NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}))
02009             \textcolor{keywordflow}{return};
02010 
02011         \textcolor{comment}{/* Check if we are already attached to the specified slave */}
02012         \textcolor{keywordflow}{if} (server.masterhost && !strcasecmp(server.masterhost,c->argv[1]->ptr)
02013             && server.masterport == port) \{
02014             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"SLAVE OF would result into synchronization with the master
       we are already connected with. No operation performed."});
02015             addReplySds(c,sdsnew(\textcolor{stringliteral}{"+OK Already connected to specified master\(\backslash\)r\(\backslash\)n"}));
02016             \textcolor{keywordflow}{return};
02017         \}
02018         \textcolor{comment}{/* There was no previous master or the user specified a different one,}
02019 \textcolor{comment}{         * we can continue. */}
02020         replicationSetMaster(c->argv[1]->ptr, port);
02021         sds client = catClientInfoString(sdsempty(),c);
02022         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"SLAVE OF %s:%d enabled (user request from '%s')"},
02023             server.masterhost, server.masterport, client);
02024         sdsfree(client);
02025     \}
02026     addReply(c,shared.ok);
02027 \}
02028 
02029 \textcolor{comment}{/* ROLE command: provide information about the role of the instance}
02030 \textcolor{comment}{ * (master or slave) and additional information related to replication}
02031 \textcolor{comment}{ * in an easy to process format. */}
02032 \textcolor{keywordtype}{void} roleCommand(client *c) \{
02033     \textcolor{keywordflow}{if} (server.masterhost == NULL) \{
02034         listIter li;
02035         listNode *ln;
02036         \textcolor{keywordtype}{void} *mbcount;
02037         \textcolor{keywordtype}{int} slaves = 0;
02038 
02039         addReplyMultiBulkLen(c,3);
02040         addReplyBulkCBuffer(c,\textcolor{stringliteral}{"master"},6);
02041         addReplyLongLong(c,server.master\_repl\_offset);
02042         mbcount = addDeferredMultiBulkLength(c);
02043         listRewind(server.slaves,&li);
02044         \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
02045             client *slave = ln->value;
02046             \textcolor{keywordtype}{char} ip[\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN}], *slaveip = slave->slave\_ip;
02047 
02048             \textcolor{keywordflow}{if} (slaveip[0] == \textcolor{stringliteral}{'\(\backslash\)0'}) \{
02049                 \textcolor{keywordflow}{if} (anetPeerToString(slave->fd,ip,\textcolor{keyword}{sizeof}(ip),NULL) == -1)
02050                     \textcolor{keywordflow}{continue};
02051                 slaveip = ip;
02052             \}
02053             \textcolor{keywordflow}{if} (slave->replstate != \hyperlink{server_8h_ad895fdf16e5ed5275d19ddf8578b900f}{SLAVE\_STATE\_ONLINE}) \textcolor{keywordflow}{continue};
02054             addReplyMultiBulkLen(c,3);
02055             addReplyBulkCString(c,slaveip);
02056             addReplyBulkLongLong(c,slave->slave\_listening\_port);
02057             addReplyBulkLongLong(c,slave->repl\_ack\_off);
02058             slaves++;
02059         \}
02060         setDeferredMultiBulkLength(c,mbcount,slaves);
02061     \} \textcolor{keywordflow}{else} \{
02062         \textcolor{keywordtype}{char} *slavestate = NULL;
02063 
02064         addReplyMultiBulkLen(c,5);
02065         addReplyBulkCBuffer(c,\textcolor{stringliteral}{"slave"},5);
02066         addReplyBulkCString(c,server.masterhost);
02067         addReplyLongLong(c,server.masterport);
02068         \textcolor{keywordflow}{if} (slaveIsInHandshakeState()) \{
02069             slavestate = \textcolor{stringliteral}{"handshake"};
02070         \} \textcolor{keywordflow}{else} \{
02071             \textcolor{keywordflow}{switch}(server.repl\_state) \{
02072             \textcolor{keywordflow}{case} \hyperlink{server_8h_a256b9506e551eaa7417f75f8fa9ed901}{REPL\_STATE\_NONE}: slavestate = \textcolor{stringliteral}{"none"}; \textcolor{keywordflow}{break};
02073             \textcolor{keywordflow}{case} \hyperlink{server_8h_adfe013d4a620f0b98b47b2144760e69f}{REPL\_STATE\_CONNECT}: slavestate = \textcolor{stringliteral}{"connect"}; \textcolor{keywordflow}{break};
02074             \textcolor{keywordflow}{case} \hyperlink{server_8h_a5fd7ad86a4a65d6486d151151a59e9a5}{REPL\_STATE\_CONNECTING}: slavestate = \textcolor{stringliteral}{"connecting"}; \textcolor{keywordflow}{break};
02075             \textcolor{keywordflow}{case} \hyperlink{server_8h_a1d27594a2d9c8d24e4ed5a2e88d1113e}{REPL\_STATE\_TRANSFER}: slavestate = \textcolor{stringliteral}{"sync"}; \textcolor{keywordflow}{break};
02076             \textcolor{keywordflow}{case} \hyperlink{server_8h_aed693b3a9cdfc05cf5ab7551a8c86fbe}{REPL\_STATE\_CONNECTED}: slavestate = \textcolor{stringliteral}{"connected"}; \textcolor{keywordflow}{break};
02077             \textcolor{keywordflow}{default}: slavestate = \textcolor{stringliteral}{"unknown"}; \textcolor{keywordflow}{break};
02078             \}
02079         \}
02080         addReplyBulkCString(c,slavestate);
02081         addReplyLongLong(c,server.master ? server.master->reploff : -1);
02082     \}
02083 \}
02084 
02085 \textcolor{comment}{/* Send a REPLCONF ACK command to the master to inform it about the current}
02086 \textcolor{comment}{ * processed offset. If we are not connected with a master, the command has}
02087 \textcolor{comment}{ * no effects. */}
02088 \textcolor{keywordtype}{void} replicationSendAck(\textcolor{keywordtype}{void}) \{
02089     client *c = server.master;
02090 
02091     \textcolor{keywordflow}{if} (c != NULL) \{
02092         c->flags |= \hyperlink{server_8h_a291fd012c9b504c52c371e7185f0a57c}{CLIENT\_MASTER\_FORCE\_REPLY};
02093         addReplyMultiBulkLen(c,3);
02094         addReplyBulkCString(c,\textcolor{stringliteral}{"REPLCONF"});
02095         addReplyBulkCString(c,\textcolor{stringliteral}{"ACK"});
02096         addReplyBulkLongLong(c,c->reploff);
02097         c->flags &= ~\hyperlink{server_8h_a291fd012c9b504c52c371e7185f0a57c}{CLIENT\_MASTER\_FORCE\_REPLY};
02098     \}
02099 \}
02100 
02101 \textcolor{comment}{/* ---------------------- MASTER CACHING FOR PSYNC -------------------------- */}
02102 
02103 \textcolor{comment}{/* In order to implement partial synchronization we need to be able to cache}
02104 \textcolor{comment}{ * our master's client structure after a transient disconnection.}
02105 \textcolor{comment}{ * It is cached into server.cached\_master and flushed away using the following}
02106 \textcolor{comment}{ * functions. */}
02107 
02108 \textcolor{comment}{/* This function is called by freeClient() in order to cache the master}
02109 \textcolor{comment}{ * client structure instead of destryoing it. freeClient() will return}
02110 \textcolor{comment}{ * ASAP after this function returns, so every action needed to avoid problems}
02111 \textcolor{comment}{ * with a client that is really "suspended" has to be done by this function.}
02112 \textcolor{comment}{ *}
02113 \textcolor{comment}{ * The other functions that will deal with the cached master are:}
02114 \textcolor{comment}{ *}
02115 \textcolor{comment}{ * replicationDiscardCachedMaster() that will make sure to kill the client}
02116 \textcolor{comment}{ * as for some reason we don't want to use it in the future.}
02117 \textcolor{comment}{ *}
02118 \textcolor{comment}{ * replicationResurrectCachedMaster() that is used after a successful PSYNC}
02119 \textcolor{comment}{ * handshake in order to reactivate the cached master.}
02120 \textcolor{comment}{ */}
02121 \textcolor{keywordtype}{void} replicationCacheMaster(client *c) \{
02122     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(server.master != NULL && server.cached\_master == NULL);
02123     serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Caching the disconnected master state."});
02124 
02125     \textcolor{comment}{/* Unlink the client from the server structures. */}
02126     unlinkClient(c);
02127 
02128     \textcolor{comment}{/* Reset the master client so that's ready to accept new commands:}
02129 \textcolor{comment}{     * we want to discard te non processed query buffers and non processed}
02130 \textcolor{comment}{     * offsets, including pending transactions, already populated arguments,}
02131 \textcolor{comment}{     * pending outputs to the master. */}
02132     sdsclear(server.master->querybuf);
02133     sdsclear(server.master->pending\_querybuf);
02134     server.master->read\_reploff = server.master->reploff;
02135     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI}) discardTransaction(c);
02136     listEmpty(c->reply);
02137     c->bufpos = 0;
02138     resetClient(c);
02139 
02140     \textcolor{comment}{/* Save the master. Server.master will be set to null later by}
02141 \textcolor{comment}{     * replicationHandleMasterDisconnection(). */}
02142     server.cached\_master = server.master;
02143 
02144     \textcolor{comment}{/* Invalidate the Peer ID cache. */}
02145     \textcolor{keywordflow}{if} (c->peerid) \{
02146         sdsfree(c->peerid);
02147         c->peerid = NULL;
02148     \}
02149 
02150     \textcolor{comment}{/* Caching the master happens instead of the actual freeClient() call,}
02151 \textcolor{comment}{     * so make sure to adjust the replication state. This function will}
02152 \textcolor{comment}{     * also set server.master to NULL. */}
02153     replicationHandleMasterDisconnection();
02154 \}
02155 
02156 \textcolor{comment}{/* This function is called when a master is turend into a slave, in order to}
02157 \textcolor{comment}{ * create from scratch a cached master for the new client, that will allow}
02158 \textcolor{comment}{ * to PSYNC with the slave that was promoted as the new master after a}
02159 \textcolor{comment}{ * failover.}
02160 \textcolor{comment}{ *}
02161 \textcolor{comment}{ * Assuming this instance was previously the master instance of the new master,}
02162 \textcolor{comment}{ * the new master will accept its replication ID, and potentiall also the}
02163 \textcolor{comment}{ * current offset if no data was lost during the failover. So we use our}
02164 \textcolor{comment}{ * current replication ID and offset in order to synthesize a cached master. */}
02165 \textcolor{keywordtype}{void} replicationCacheMasterUsingMyself(\textcolor{keywordtype}{void}) \{
02166     \textcolor{comment}{/* The master client we create can be set to any DBID, because}
02167 \textcolor{comment}{     * the new master will start its replication stream with SELECT. */}
02168     server.master\_initial\_offset = server.master\_repl\_offset;
02169     replicationCreateMasterClient(-1,-1);
02170 
02171     \textcolor{comment}{/* Use our own ID / offset. */}
02172     memcpy(server.master->replid, server.replid, \textcolor{keyword}{sizeof}(server.replid));
02173 
02174     \textcolor{comment}{/* Set as cached master. */}
02175     unlinkClient(server.master);
02176     server.cached\_master = server.master;
02177     server.master = NULL;
02178     serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Before turning into a slave, using my master parameters to
       synthesize a cached master: I may be able to synchronize with the new master with just a partial transfer."});
02179 \}
02180 
02181 \textcolor{comment}{/* Free a cached master, called when there are no longer the conditions for}
02182 \textcolor{comment}{ * a partial resync on reconnection. */}
02183 \textcolor{keywordtype}{void} replicationDiscardCachedMaster(\textcolor{keywordtype}{void}) \{
02184     \textcolor{keywordflow}{if} (server.cached\_master == NULL) \textcolor{keywordflow}{return};
02185 
02186     serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Discarding previously cached master state."});
02187     server.cached\_master->flags &= ~\hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER};
02188     freeClient(server.cached\_master);
02189     server.cached\_master = NULL;
02190 \}
02191 
02192 \textcolor{comment}{/* Turn the cached master into the current master, using the file descriptor}
02193 \textcolor{comment}{ * passed as argument as the socket for the new master.}
02194 \textcolor{comment}{ *}
02195 \textcolor{comment}{ * This function is called when successfully setup a partial resynchronization}
02196 \textcolor{comment}{ * so the stream of data that we'll receive will start from were this}
02197 \textcolor{comment}{ * master left. */}
02198 \textcolor{keywordtype}{void} replicationResurrectCachedMaster(\textcolor{keywordtype}{int} newfd) \{
02199     server.master = server.cached\_master;
02200     server.cached\_master = NULL;
02201     server.master->fd = newfd;
02202     server.master->flags &= ~(\hyperlink{server_8h_a8cff2154afcc2e87ac85bdbbe2814091}{CLIENT\_CLOSE\_AFTER\_REPLY}|
      \hyperlink{server_8h_ad6690c6231b67525b8b2057e092a8361}{CLIENT\_CLOSE\_ASAP});
02203     server.master->authenticated = 1;
02204     server.master->lastinteraction = server.unixtime;
02205     server.repl\_state = \hyperlink{server_8h_aed693b3a9cdfc05cf5ab7551a8c86fbe}{REPL\_STATE\_CONNECTED};
02206 
02207     \textcolor{comment}{/* Re-add to the list of clients. */}
02208     linkClient(server.master);
02209     \textcolor{keywordflow}{if} (aeCreateFileEvent(server.el, newfd, \hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE},
02210                           readQueryFromClient, server.master)) \{
02211         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Error resurrecting the cached master, impossible to add the
       readable handler: %s"}, strerror(errno));
02212         freeClientAsync(server.master); \textcolor{comment}{/* Close ASAP. */}
02213     \}
02214 
02215     \textcolor{comment}{/* We may also need to install the write handler as well if there is}
02216 \textcolor{comment}{     * pending data in the write buffers. */}
02217     \textcolor{keywordflow}{if} (clientHasPendingReplies(server.master)) \{
02218         \textcolor{keywordflow}{if} (aeCreateFileEvent(server.el, newfd, \hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE},
02219                           sendReplyToClient, server.master)) \{
02220             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Error resurrecting the cached master, impossible to add
       the writable handler: %s"}, strerror(errno));
02221             freeClientAsync(server.master); \textcolor{comment}{/* Close ASAP. */}
02222         \}
02223     \}
02224 \}
02225 
02226 \textcolor{comment}{/* ------------------------- MIN-SLAVES-TO-WRITE  --------------------------- */}
02227 
02228 \textcolor{comment}{/* This function counts the number of slaves with lag <= min-slaves-max-lag.}
02229 \textcolor{comment}{ * If the option is active, the server will prevent writes if there are not}
02230 \textcolor{comment}{ * enough connected slaves with the specified lag (or less). */}
02231 \textcolor{keywordtype}{void} refreshGoodSlavesCount(\textcolor{keywordtype}{void}) \{
02232     listIter li;
02233     listNode *ln;
02234     \textcolor{keywordtype}{int} good = 0;
02235 
02236     \textcolor{keywordflow}{if} (!server.repl\_min\_slaves\_to\_write ||
02237         !server.repl\_min\_slaves\_max\_lag) \textcolor{keywordflow}{return};
02238 
02239     listRewind(server.slaves,&li);
02240     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
02241         client *slave = ln->value;
02242         time\_t lag = server.unixtime - slave->repl\_ack\_time;
02243 
02244         \textcolor{keywordflow}{if} (slave->replstate == \hyperlink{server_8h_ad895fdf16e5ed5275d19ddf8578b900f}{SLAVE\_STATE\_ONLINE} &&
02245             lag <= server.repl\_min\_slaves\_max\_lag) good++;
02246     \}
02247     server.repl\_good\_slaves\_count = good;
02248 \}
02249 
02250 \textcolor{comment}{/* ----------------------- REPLICATION SCRIPT CACHE --------------------------}
02251 \textcolor{comment}{ * The goal of this code is to keep track of scripts already sent to every}
02252 \textcolor{comment}{ * connected slave, in order to be able to replicate EVALSHA as it is without}
02253 \textcolor{comment}{ * translating it to EVAL every time it is possible.}
02254 \textcolor{comment}{ *}
02255 \textcolor{comment}{ * We use a capped collection implemented by a hash table for fast lookup}
02256 \textcolor{comment}{ * of scripts we can send as EVALSHA, plus a linked list that is used for}
02257 \textcolor{comment}{ * eviction of the oldest entry when the max number of items is reached.}
02258 \textcolor{comment}{ *}
02259 \textcolor{comment}{ * We don't care about taking a different cache for every different slave}
02260 \textcolor{comment}{ * since to fill the cache again is not very costly, the goal of this code}
02261 \textcolor{comment}{ * is to avoid that the same big script is trasmitted a big number of times}
02262 \textcolor{comment}{ * per second wasting bandwidth and processor speed, but it is not a problem}
02263 \textcolor{comment}{ * if we need to rebuild the cache from scratch from time to time, every used}
02264 \textcolor{comment}{ * script will need to be transmitted a single time to reappear in the cache.}
02265 \textcolor{comment}{ *}
02266 \textcolor{comment}{ * This is how the system works:}
02267 \textcolor{comment}{ *}
02268 \textcolor{comment}{ * 1) Every time a new slave connects, we flush the whole script cache.}
02269 \textcolor{comment}{ * 2) We only send as EVALSHA what was sent to the master as EVALSHA, without}
02270 \textcolor{comment}{ *    trying to convert EVAL into EVALSHA specifically for slaves.}
02271 \textcolor{comment}{ * 3) Every time we trasmit a script as EVAL to the slaves, we also add the}
02272 \textcolor{comment}{ *    corresponding SHA1 of the script into the cache as we are sure every}
02273 \textcolor{comment}{ *    slave knows about the script starting from now.}
02274 \textcolor{comment}{ * 4) On SCRIPT FLUSH command, we replicate the command to all the slaves}
02275 \textcolor{comment}{ *    and at the same time flush the script cache.}
02276 \textcolor{comment}{ * 5) When the last slave disconnects, flush the cache.}
02277 \textcolor{comment}{ * 6) We handle SCRIPT LOAD as well since that's how scripts are loaded}
02278 \textcolor{comment}{ *    in the master sometimes.}
02279 \textcolor{comment}{ */}
02280 
02281 \textcolor{comment}{/* Initialize the script cache, only called at startup. */}
02282 \textcolor{keywordtype}{void} replicationScriptCacheInit(\textcolor{keywordtype}{void}) \{
02283     server.repl\_scriptcache\_size = 10000;
02284     server.repl\_scriptcache\_dict = dictCreate(&replScriptCacheDictType,NULL);
02285     server.repl\_scriptcache\_fifo = listCreate();
02286 \}
02287 
02288 \textcolor{comment}{/* Empty the script cache. Should be called every time we are no longer sure}
02289 \textcolor{comment}{ * that every slave knows about all the scripts in our set, or when the}
02290 \textcolor{comment}{ * current AOF "context" is no longer aware of the script. In general we}
02291 \textcolor{comment}{ * should flush the cache:}
02292 \textcolor{comment}{ *}
02293 \textcolor{comment}{ * 1) Every time a new slave reconnects to this master and performs a}
02294 \textcolor{comment}{ *    full SYNC (PSYNC does not require flushing).}
02295 \textcolor{comment}{ * 2) Every time an AOF rewrite is performed.}
02296 \textcolor{comment}{ * 3) Every time we are left without slaves at all, and AOF is off, in order}
02297 \textcolor{comment}{ *    to reclaim otherwise unused memory.}
02298 \textcolor{comment}{ */}
02299 \textcolor{keywordtype}{void} replicationScriptCacheFlush(\textcolor{keywordtype}{void}) \{
02300     dictEmpty(server.repl\_scriptcache\_dict,NULL);
02301     listRelease(server.repl\_scriptcache\_fifo);
02302     server.repl\_scriptcache\_fifo = listCreate();
02303 \}
02304 
02305 \textcolor{comment}{/* Add an entry into the script cache, if we reach max number of entries the}
02306 \textcolor{comment}{ * oldest is removed from the list. */}
02307 \textcolor{keywordtype}{void} replicationScriptCacheAdd(sds sha1) \{
02308     \textcolor{keywordtype}{int} retval;
02309     sds key = sdsdup(sha1);
02310 
02311     \textcolor{comment}{/* Evict oldest. */}
02312     \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.repl\_scriptcache\_fifo) == server.repl\_scriptcache\_size)
02313     \{
02314         listNode *ln = \hyperlink{adlist_8h_a5e0fad60032ef0fe9adcf9811e2f2fba}{listLast}(server.repl\_scriptcache\_fifo);
02315         sds oldest = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
02316 
02317         retval = dictDelete(server.repl\_scriptcache\_dict,oldest);
02318         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(retval == \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK});
02319         listDelNode(server.repl\_scriptcache\_fifo,ln);
02320     \}
02321 
02322     \textcolor{comment}{/* Add current. */}
02323     retval = dictAdd(server.repl\_scriptcache\_dict,key,NULL);
02324     listAddNodeHead(server.repl\_scriptcache\_fifo,key);
02325     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(retval == \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK});
02326 \}
02327 
02328 \textcolor{comment}{/* Returns non-zero if the specified entry exists inside the cache, that is,}
02329 \textcolor{comment}{ * if all the slaves are aware of this script SHA1. */}
02330 \textcolor{keywordtype}{int} replicationScriptCacheExists(sds sha1) \{
02331     \textcolor{keywordflow}{return} dictFind(server.repl\_scriptcache\_dict,sha1) != NULL;
02332 \}
02333 
02334 \textcolor{comment}{/* ----------------------- SYNCHRONOUS REPLICATION --------------------------}
02335 \textcolor{comment}{ * Redis synchronous replication design can be summarized in points:}
02336 \textcolor{comment}{ *}
02337 \textcolor{comment}{ * - Redis masters have a global replication offset, used by PSYNC.}
02338 \textcolor{comment}{ * - Master increment the offset every time new commands are sent to slaves.}
02339 \textcolor{comment}{ * - Slaves ping back masters with the offset processed so far.}
02340 \textcolor{comment}{ *}
02341 \textcolor{comment}{ * So synchronous replication adds a new WAIT command in the form:}
02342 \textcolor{comment}{ *}
02343 \textcolor{comment}{ *   WAIT <num\_replicas> <milliseconds\_timeout>}
02344 \textcolor{comment}{ *}
02345 \textcolor{comment}{ * That returns the number of replicas that processed the query when}
02346 \textcolor{comment}{ * we finally have at least num\_replicas, or when the timeout was}
02347 \textcolor{comment}{ * reached.}
02348 \textcolor{comment}{ *}
02349 \textcolor{comment}{ * The command is implemented in this way:}
02350 \textcolor{comment}{ *}
02351 \textcolor{comment}{ * - Every time a client processes a command, we remember the replication}
02352 \textcolor{comment}{ *   offset after sending that command to the slaves.}
02353 \textcolor{comment}{ * - When WAIT is called, we ask slaves to send an acknowledgement ASAP.}
02354 \textcolor{comment}{ *   The client is blocked at the same time (see blocked.c).}
02355 \textcolor{comment}{ * - Once we receive enough ACKs for a given offset or when the timeout}
02356 \textcolor{comment}{ *   is reached, the WAIT command is unblocked and the reply sent to the}
02357 \textcolor{comment}{ *   client.}
02358 \textcolor{comment}{ */}
02359 
02360 \textcolor{comment}{/* This just set a flag so that we broadcast a REPLCONF GETACK command}
02361 \textcolor{comment}{ * to all the slaves in the beforeSleep() function. Note that this way}
02362 \textcolor{comment}{ * we "group" all the clients that want to wait for synchronouns replication}
02363 \textcolor{comment}{ * in a given event loop iteration, and send a single GETACK for them all. */}
02364 \textcolor{keywordtype}{void} replicationRequestAckFromSlaves(\textcolor{keywordtype}{void}) \{
02365     server.get\_ack\_from\_slaves = 1;
02366 \}
02367 
02368 \textcolor{comment}{/* Return the number of slaves that already acknowledged the specified}
02369 \textcolor{comment}{ * replication offset. */}
02370 \textcolor{keywordtype}{int} replicationCountAcksByOffset(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} offset) \{
02371     listIter li;
02372     listNode *ln;
02373     \textcolor{keywordtype}{int} count = 0;
02374 
02375     listRewind(server.slaves,&li);
02376     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
02377         client *slave = ln->value;
02378 
02379         \textcolor{keywordflow}{if} (slave->replstate != \hyperlink{server_8h_ad895fdf16e5ed5275d19ddf8578b900f}{SLAVE\_STATE\_ONLINE}) \textcolor{keywordflow}{continue};
02380         \textcolor{keywordflow}{if} (slave->repl\_ack\_off >= offset) count++;
02381     \}
02382     \textcolor{keywordflow}{return} count;
02383 \}
02384 
02385 \textcolor{comment}{/* WAIT for N replicas to acknowledge the processing of our latest}
02386 \textcolor{comment}{ * write command (and all the previous commands). */}
02387 \textcolor{keywordtype}{void} waitCommand(client *c) \{
02388     mstime\_t timeout;
02389     \textcolor{keywordtype}{long} numreplicas, ackreplicas;
02390     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} offset = c->woff;
02391 
02392     \textcolor{keywordflow}{if} (server.masterhost) \{
02393         addReplyError(c,\textcolor{stringliteral}{"WAIT cannot be used with slave instances. Please also note that since Redis
       4.0 if a slave is configured to be writable (which is not the default) writes to slaves are just local and
       are not propagated."});
02394         \textcolor{keywordflow}{return};
02395     \}
02396 
02397     \textcolor{comment}{/* Argument parsing. */}
02398     \textcolor{keywordflow}{if} (getLongFromObjectOrReply(c,c->argv[1],&numreplicas,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
02399         \textcolor{keywordflow}{return};
02400     \textcolor{keywordflow}{if} (getTimeoutFromObjectOrReply(c,c->argv[2],&timeout,\hyperlink{server_8h_a259de972533409a75b736bfc799a8e2d}{UNIT\_MILLISECONDS})
02401         != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \textcolor{keywordflow}{return};
02402 
02403     \textcolor{comment}{/* First try without blocking at all. */}
02404     ackreplicas = replicationCountAcksByOffset(c->woff);
02405     \textcolor{keywordflow}{if} (ackreplicas >= numreplicas || c->flags & \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI}) \{
02406         addReplyLongLong(c,ackreplicas);
02407         \textcolor{keywordflow}{return};
02408     \}
02409 
02410     \textcolor{comment}{/* Otherwise block the client and put it into our list of clients}
02411 \textcolor{comment}{     * waiting for ack from slaves. */}
02412     c->bpop.timeout = timeout;
02413     c->bpop.reploffset = offset;
02414     c->bpop.numreplicas = numreplicas;
02415     listAddNodeTail(server.clients\_waiting\_acks,c);
02416     blockClient(c,\hyperlink{server_8h_accb912da92773eadb0b938af3fa95c63}{BLOCKED\_WAIT});
02417 
02418     \textcolor{comment}{/* Make sure that the server will send an ACK request to all the slaves}
02419 \textcolor{comment}{     * before returning to the event loop. */}
02420     replicationRequestAckFromSlaves();
02421 \}
02422 
02423 \textcolor{comment}{/* This is called by unblockClient() to perform the blocking op type}
02424 \textcolor{comment}{ * specific cleanup. We just remove the client from the list of clients}
02425 \textcolor{comment}{ * waiting for replica acks. Never call it directly, call unblockClient()}
02426 \textcolor{comment}{ * instead. */}
02427 \textcolor{keywordtype}{void} unblockClientWaitingReplicas(client *c) \{
02428     listNode *ln = listSearchKey(server.clients\_waiting\_acks,c);
02429     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(ln != NULL);
02430     listDelNode(server.clients\_waiting\_acks,ln);
02431 \}
02432 
02433 \textcolor{comment}{/* Check if there are clients blocked in WAIT that can be unblocked since}
02434 \textcolor{comment}{ * we received enough ACKs from slaves. */}
02435 \textcolor{keywordtype}{void} processClientsWaitingReplicas(\textcolor{keywordtype}{void}) \{
02436     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} last\_offset = 0;
02437     \textcolor{keywordtype}{int} last\_numreplicas = 0;
02438 
02439     listIter li;
02440     listNode *ln;
02441 
02442     listRewind(server.clients\_waiting\_acks,&li);
02443     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
02444         client *c = ln->value;
02445 
02446         \textcolor{comment}{/* Every time we find a client that is satisfied for a given}
02447 \textcolor{comment}{         * offset and number of replicas, we remember it so the next client}
02448 \textcolor{comment}{         * may be unblocked without calling replicationCountAcksByOffset()}
02449 \textcolor{comment}{         * if the requested offset / replicas were equal or less. */}
02450         \textcolor{keywordflow}{if} (last\_offset && last\_offset > c->bpop.reploffset &&
02451                            last\_numreplicas > c->bpop.numreplicas)
02452         \{
02453             unblockClient(c);
02454             addReplyLongLong(c,last\_numreplicas);
02455         \} \textcolor{keywordflow}{else} \{
02456             \textcolor{keywordtype}{int} numreplicas = replicationCountAcksByOffset(c->bpop.reploffset);
02457 
02458             \textcolor{keywordflow}{if} (numreplicas >= c->bpop.numreplicas) \{
02459                 last\_offset = c->bpop.reploffset;
02460                 last\_numreplicas = numreplicas;
02461                 unblockClient(c);
02462                 addReplyLongLong(c,numreplicas);
02463             \}
02464         \}
02465     \}
02466 \}
02467 
02468 \textcolor{comment}{/* Return the slave replication offset for this instance, that is}
02469 \textcolor{comment}{ * the offset for which we already processed the master replication stream. */}
02470 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} replicationGetSlaveOffset(\textcolor{keywordtype}{void}) \{
02471     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} offset = 0;
02472 
02473     \textcolor{keywordflow}{if} (server.masterhost != NULL) \{
02474         \textcolor{keywordflow}{if} (server.master) \{
02475             offset = server.master->reploff;
02476         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.cached\_master) \{
02477             offset = server.cached\_master->reploff;
02478         \}
02479     \}
02480     \textcolor{comment}{/* offset may be -1 when the master does not support it at all, however}
02481 \textcolor{comment}{     * this function is designed to return an offset that can express the}
02482 \textcolor{comment}{     * amount of data processed by the master, so we return a positive}
02483 \textcolor{comment}{     * integer. */}
02484     \textcolor{keywordflow}{if} (offset < 0) offset = 0;
02485     \textcolor{keywordflow}{return} offset;
02486 \}
02487 
02488 \textcolor{comment}{/* --------------------------- REPLICATION CRON  ---------------------------- */}
02489 
02490 \textcolor{comment}{/* Replication cron function, called 1 time per second. */}
02491 \textcolor{keywordtype}{void} replicationCron(\textcolor{keywordtype}{void}) \{
02492     \textcolor{keyword}{static} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} replication\_cron\_loops = 0;
02493 
02494     \textcolor{comment}{/* Non blocking connection timeout? */}
02495     \textcolor{keywordflow}{if} (server.masterhost &&
02496         (server.repl\_state == \hyperlink{server_8h_a5fd7ad86a4a65d6486d151151a59e9a5}{REPL\_STATE\_CONNECTING} ||
02497          slaveIsInHandshakeState()) &&
02498          (time(NULL)-server.repl\_transfer\_lastio) > server.repl\_timeout)
02499     \{
02500         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Timeout connecting to the MASTER..."});
02501         cancelReplicationHandshake();
02502     \}
02503 
02504     \textcolor{comment}{/* Bulk transfer I/O timeout? */}
02505     \textcolor{keywordflow}{if} (server.masterhost && server.repl\_state == \hyperlink{server_8h_a1d27594a2d9c8d24e4ed5a2e88d1113e}{REPL\_STATE\_TRANSFER} &&
02506         (time(NULL)-server.repl\_transfer\_lastio) > server.repl\_timeout)
02507     \{
02508         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Timeout receiving bulk data from MASTER... If the problem
       persists try to set the 'repl-timeout' parameter in redis.conf to a larger value."});
02509         cancelReplicationHandshake();
02510     \}
02511 
02512     \textcolor{comment}{/* Timed out master when we are an already connected slave? */}
02513     \textcolor{keywordflow}{if} (server.masterhost && server.repl\_state == \hyperlink{server_8h_aed693b3a9cdfc05cf5ab7551a8c86fbe}{REPL\_STATE\_CONNECTED} &&
02514         (time(NULL)-server.master->lastinteraction) > server.repl\_timeout)
02515     \{
02516         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"MASTER timeout: no data nor PING received..."});
02517         freeClient(server.master);
02518     \}
02519 
02520     \textcolor{comment}{/* Check if we should connect to a MASTER */}
02521     \textcolor{keywordflow}{if} (server.repl\_state == \hyperlink{server_8h_adfe013d4a620f0b98b47b2144760e69f}{REPL\_STATE\_CONNECT}) \{
02522         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Connecting to MASTER %s:%d"},
02523             server.masterhost, server.masterport);
02524         \textcolor{keywordflow}{if} (connectWithMaster() == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
02525             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"MASTER <-> SLAVE sync started"});
02526         \}
02527     \}
02528 
02529     \textcolor{comment}{/* Send ACK to master from time to time.}
02530 \textcolor{comment}{     * Note that we do not send periodic acks to masters that don't}
02531 \textcolor{comment}{     * support PSYNC and replication offsets. */}
02532     \textcolor{keywordflow}{if} (server.masterhost && server.master &&
02533         !(server.master->flags & \hyperlink{server_8h_ac13d62411270bd658f6d82e711e0f912}{CLIENT\_PRE\_PSYNC}))
02534         replicationSendAck();
02535 
02536     \textcolor{comment}{/* If we have attached slaves, PING them from time to time.}
02537 \textcolor{comment}{     * So slaves can implement an explicit timeout to masters, and will}
02538 \textcolor{comment}{     * be able to detect a link disconnection even if the TCP connection}
02539 \textcolor{comment}{     * will not actually go down. */}
02540     listIter li;
02541     listNode *ln;
02542     robj *ping\_argv[1];
02543 
02544     \textcolor{comment}{/* First, send PING according to ping\_slave\_period. */}
02545     \textcolor{keywordflow}{if} ((replication\_cron\_loops % server.repl\_ping\_slave\_period) == 0 &&
02546         \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.slaves))
02547     \{
02548         ping\_argv[0] = createStringObject(\textcolor{stringliteral}{"PING"},4);
02549         replicationFeedSlaves(server.slaves, server.slaveseldb,
02550             ping\_argv, 1);
02551         decrRefCount(ping\_argv[0]);
02552     \}
02553 
02554     \textcolor{comment}{/* Second, send a newline to all the slaves in pre-synchronization}
02555 \textcolor{comment}{     * stage, that is, slaves waiting for the master to create the RDB file.}
02556 \textcolor{comment}{     *}
02557 \textcolor{comment}{     * Also send the a newline to all the chained slaves we have, if we lost}
02558 \textcolor{comment}{     * connection from our master, to keep the slaves aware that their}
02559 \textcolor{comment}{     * master is online. This is needed since sub-slaves only receive proxied}
02560 \textcolor{comment}{     * data from top-level masters, so there is no explicit pinging in order}
02561 \textcolor{comment}{     * to avoid altering the replication offsets. This special out of band}
02562 \textcolor{comment}{     * pings (newlines) can be sent, they will have no effect in the offset.}
02563 \textcolor{comment}{     *}
02564 \textcolor{comment}{     * The newline will be ignored by the slave but will refresh the}
02565 \textcolor{comment}{     * last interaction timer preventing a timeout. In this case we ignore the}
02566 \textcolor{comment}{     * ping period and refresh the connection once per second since certain}
02567 \textcolor{comment}{     * timeouts are set at a few seconds (example: PSYNC response). */}
02568     listRewind(server.slaves,&li);
02569     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
02570         client *slave = ln->value;
02571 
02572         \textcolor{keywordtype}{int} is\_presync =
02573             (slave->replstate == \hyperlink{server_8h_a170ee2dd8cfefaf0d112edcc3152f8d7}{SLAVE\_STATE\_WAIT\_BGSAVE\_START} ||
02574             (slave->replstate == \hyperlink{server_8h_a2a1b586e8f326f831f6ab466c8c3f38a}{SLAVE\_STATE\_WAIT\_BGSAVE\_END} &&
02575              server.rdb\_child\_type != \hyperlink{server_8h_acdbf61346e1d2f54716e2ab6fe73e954}{RDB\_CHILD\_TYPE\_SOCKET}));
02576 
02577         \textcolor{keywordflow}{if} (is\_presync) \{
02578             \textcolor{keywordflow}{if} (write(slave->fd, \textcolor{stringliteral}{"\(\backslash\)n"}, 1) == -1) \{
02579                 \textcolor{comment}{/* Don't worry about socket errors, it's just a ping. */}
02580             \}
02581         \}
02582     \}
02583 
02584     \textcolor{comment}{/* Disconnect timedout slaves. */}
02585     \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.slaves)) \{
02586         listIter li;
02587         listNode *ln;
02588 
02589         listRewind(server.slaves,&li);
02590         \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
02591             client *slave = ln->value;
02592 
02593             \textcolor{keywordflow}{if} (slave->replstate != \hyperlink{server_8h_ad895fdf16e5ed5275d19ddf8578b900f}{SLAVE\_STATE\_ONLINE}) \textcolor{keywordflow}{continue};
02594             \textcolor{keywordflow}{if} (slave->flags & \hyperlink{server_8h_ac13d62411270bd658f6d82e711e0f912}{CLIENT\_PRE\_PSYNC}) \textcolor{keywordflow}{continue};
02595             \textcolor{keywordflow}{if} ((server.unixtime - slave->repl\_ack\_time) > server.repl\_timeout)
02596             \{
02597                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"Disconnecting timedout slave: %s"},
02598                     replicationGetSlaveName(slave));
02599                 freeClient(slave);
02600             \}
02601         \}
02602     \}
02603 
02604     \textcolor{comment}{/* If this is a master without attached slaves and there is a replication}
02605 \textcolor{comment}{     * backlog active, in order to reclaim memory we can free it after some}
02606 \textcolor{comment}{     * (configured) time. Note that this cannot be done for slaves: slaves}
02607 \textcolor{comment}{     * without sub-slaves attached should still accumulate data into the}
02608 \textcolor{comment}{     * backlog, in order to reply to PSYNC queries if they are turned into}
02609 \textcolor{comment}{     * masters after a failover. */}
02610     \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.slaves) == 0 && server.repl\_backlog\_time\_limit &&
02611         server.repl\_backlog && server.masterhost == NULL)
02612     \{
02613         time\_t idle = server.unixtime - server.repl\_no\_slaves\_since;
02614 
02615         \textcolor{keywordflow}{if} (idle > server.repl\_backlog\_time\_limit) \{
02616             \textcolor{comment}{/* When we free the backlog, we always use a new}
02617 \textcolor{comment}{             * replication ID and clear the ID2. This is needed}
02618 \textcolor{comment}{             * because when there is no backlog, the master\_repl\_offset}
02619 \textcolor{comment}{             * is not updated, but we would still retain our replication}
02620 \textcolor{comment}{             * ID, leading to the following problem:}
02621 \textcolor{comment}{             *}
02622 \textcolor{comment}{             * 1. We are a master instance.}
02623 \textcolor{comment}{             * 2. Our slave is promoted to master. It's repl-id-2 will}
02624 \textcolor{comment}{             *    be the same as our repl-id.}
02625 \textcolor{comment}{             * 3. We, yet as master, receive some updates, that will not}
02626 \textcolor{comment}{             *    increment the master\_repl\_offset.}
02627 \textcolor{comment}{             * 4. Later we are turned into a slave, connecto to the new}
02628 \textcolor{comment}{             *    master that will accept our PSYNC request by second}
02629 \textcolor{comment}{             *    replication ID, but there will be data inconsistency}
02630 \textcolor{comment}{             *    because we received writes. */}
02631             changeReplicationId();
02632             clearReplicationId2();
02633             freeReplicationBacklog();
02634             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
02635                 \textcolor{stringliteral}{"Replication backlog freed after %d seconds "}
02636                 \textcolor{stringliteral}{"without connected slaves."},
02637                 (\textcolor{keywordtype}{int}) server.repl\_backlog\_time\_limit);
02638         \}
02639     \}
02640 
02641     \textcolor{comment}{/* If AOF is disabled and we no longer have attached slaves, we can}
02642 \textcolor{comment}{     * free our Replication Script Cache as there is no need to propagate}
02643 \textcolor{comment}{     * EVALSHA at all. */}
02644     \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.slaves) == 0 &&
02645         server.aof\_state == \hyperlink{server_8h_a5226306fbcebcb6d5d02e0fef3c213c2}{AOF\_OFF} &&
02646         \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.repl\_scriptcache\_fifo) != 0)
02647     \{
02648         replicationScriptCacheFlush();
02649     \}
02650 
02651     \textcolor{comment}{/* Start a BGSAVE good for replication if we have slaves in}
02652 \textcolor{comment}{     * WAIT\_BGSAVE\_START state.}
02653 \textcolor{comment}{     *}
02654 \textcolor{comment}{     * In case of diskless replication, we make sure to wait the specified}
02655 \textcolor{comment}{     * number of seconds (according to configuration) so that other slaves}
02656 \textcolor{comment}{     * have the time to arrive before we start streaming. */}
02657     \textcolor{keywordflow}{if} (server.rdb\_child\_pid == -1 && server.aof\_child\_pid == -1) \{
02658         time\_t idle, max\_idle = 0;
02659         \textcolor{keywordtype}{int} slaves\_waiting = 0;
02660         \textcolor{keywordtype}{int} mincapa = -1;
02661         listNode *ln;
02662         listIter li;
02663 
02664         listRewind(server.slaves,&li);
02665         \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
02666             client *slave = ln->value;
02667             \textcolor{keywordflow}{if} (slave->replstate == \hyperlink{server_8h_a170ee2dd8cfefaf0d112edcc3152f8d7}{SLAVE\_STATE\_WAIT\_BGSAVE\_START}) \{
02668                 idle = server.unixtime - slave->lastinteraction;
02669                 \textcolor{keywordflow}{if} (idle > max\_idle) max\_idle = idle;
02670                 slaves\_waiting++;
02671                 mincapa = (mincapa == -1) ? slave->slave\_capa :
02672                                             (mincapa & slave->slave\_capa);
02673             \}
02674         \}
02675 
02676         \textcolor{keywordflow}{if} (slaves\_waiting &&
02677             (!server.repl\_diskless\_sync ||
02678              max\_idle > server.repl\_diskless\_sync\_delay))
02679         \{
02680             \textcolor{comment}{/* Start the BGSAVE. The called function may start a}
02681 \textcolor{comment}{             * BGSAVE with socket target or disk target depending on the}
02682 \textcolor{comment}{             * configuration and slaves capabilities. */}
02683             startBgsaveForReplication(mincapa);
02684         \}
02685     \}
02686 
02687     \textcolor{comment}{/* Refresh the number of slaves with lag <= min-slaves-max-lag. */}
02688     refreshGoodSlavesCount();
02689     replication\_cron\_loops++; \textcolor{comment}{/* Incremented with frequency 1 HZ. */}
02690 \}
\end{DoxyCode}
