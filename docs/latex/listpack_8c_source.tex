\hypertarget{listpack_8c_source}{}\section{listpack.\+c}
\label{listpack_8c_source}\index{src/listpack.\+c@{src/listpack.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* Listpack -- A lists of strings serialization format}
00002 \textcolor{comment}{ *}
00003 \textcolor{comment}{ * This file implements the specification you can find at:}
00004 \textcolor{comment}{ *}
00005 \textcolor{comment}{ *  https://github.com/antirez/listpack}
00006 \textcolor{comment}{ *}
00007 \textcolor{comment}{ * Copyright (c) 2017, Salvatore Sanfilippo <antirez at gmail dot com>}
00008 \textcolor{comment}{ * All rights reserved.}
00009 \textcolor{comment}{ *}
00010 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00011 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00012 \textcolor{comment}{ *}
00013 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00014 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00015 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00016 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00017 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00018 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00019 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00020 \textcolor{comment}{ *     specific prior written permission.}
00021 \textcolor{comment}{ *}
00022 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00023 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00024 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00025 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00026 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00027 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00028 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00029 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00030 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00031 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00032 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00033 \textcolor{comment}{ */}
00034 
00035 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdint}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00036 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{limits}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00037 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{types}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00038 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdlib}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00039 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{string}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00040 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdio}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00041 
00042 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{listpack_8h}{"listpack.h"}
00043 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{listpack__malloc_8h}{"listpack\_malloc.h"}
00044 
00045 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_HDR\_SIZE} 6       \textcolor{comment}{/* 32 bit total len + 16 bit number of elements. */}
00046 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_HDR\_NUMELE\_UNKNOWN} UINT16\_MAX
00047 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_MAX\_INT\_ENCODING\_LEN} 9
00048 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_MAX\_BACKLEN\_SIZE} 5
00049 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_MAX\_ENTRY\_BACKLEN} 34359738367ULL
00050 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_INT} 0
00051 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_STRING} 1
00052 
00053 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_7BIT\_UINT} 0
00054 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_7BIT\_UINT\_MASK} 0x80
00055 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_IS\_7BIT\_UINT}\textcolor{preprocessor}{(}\textcolor{preprocessor}{byte}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{byte}\textcolor{preprocessor}{)}\textcolor{preprocessor}{&}\hyperlink{listpack_8c_aba3f3787e93f67472017620bfe1bbb9e}{LP\_ENCODING\_7BIT\_UINT\_MASK}\textcolor{preprocessor}{)}\textcolor{preprocessor}{
      ==}\hyperlink{listpack_8c_ac949eb1675d053989cb72d263486d708}{LP\_ENCODING\_7BIT\_UINT}\textcolor{preprocessor}{)}
00056 
00057 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_6BIT\_STR} 0x80
00058 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_6BIT\_STR\_MASK} 0xC0
00059 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_IS\_6BIT\_STR}\textcolor{preprocessor}{(}\textcolor{preprocessor}{byte}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{byte}\textcolor{preprocessor}{)}\textcolor{preprocessor}{&}\hyperlink{listpack_8c_a0a64f1c1f90ecdcfc49ec3b738268601}{LP\_ENCODING\_6BIT\_STR\_MASK}\textcolor{preprocessor}{)}\textcolor{preprocessor}{==}
      \hyperlink{listpack_8c_aa03a77428cf5dd11a741306d35f08d6f}{LP\_ENCODING\_6BIT\_STR}\textcolor{preprocessor}{)}
00060 
00061 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_13BIT\_INT} 0xC0
00062 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_13BIT\_INT\_MASK} 0xE0
00063 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_IS\_13BIT\_INT}\textcolor{preprocessor}{(}\textcolor{preprocessor}{byte}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{byte}\textcolor{preprocessor}{)}\textcolor{preprocessor}{&}\hyperlink{listpack_8c_a0770ec079e38f29b013d6014e268ff1f}{LP\_ENCODING\_13BIT\_INT\_MASK}\textcolor{preprocessor}{)}\textcolor{preprocessor}{
      ==}\hyperlink{listpack_8c_a9cfea84c38c5cf0d152f0e40fdd7c1fc}{LP\_ENCODING\_13BIT\_INT}\textcolor{preprocessor}{)}
00064 
00065 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_12BIT\_STR} 0xE0
00066 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_12BIT\_STR\_MASK} 0xF0
00067 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_IS\_12BIT\_STR}\textcolor{preprocessor}{(}\textcolor{preprocessor}{byte}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{byte}\textcolor{preprocessor}{)}\textcolor{preprocessor}{&}\hyperlink{listpack_8c_a05220e3facf52ce6d8a3dcd337aec945}{LP\_ENCODING\_12BIT\_STR\_MASK}\textcolor{preprocessor}{)}\textcolor{preprocessor}{
      ==}\hyperlink{listpack_8c_acf85ac38dc36778e68c75963245a3959}{LP\_ENCODING\_12BIT\_STR}\textcolor{preprocessor}{)}
00068 
00069 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_16BIT\_INT} 0xF1
00070 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_16BIT\_INT\_MASK} 0xFF
00071 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_IS\_16BIT\_INT}\textcolor{preprocessor}{(}\textcolor{preprocessor}{byte}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{byte}\textcolor{preprocessor}{)}\textcolor{preprocessor}{&}\hyperlink{listpack_8c_acdb130b39e0800198f74fe031bddbfe2}{LP\_ENCODING\_16BIT\_INT\_MASK}\textcolor{preprocessor}{)}\textcolor{preprocessor}{
      ==}\hyperlink{listpack_8c_a4e888717b76a31a4ea334a03fea25047}{LP\_ENCODING\_16BIT\_INT}\textcolor{preprocessor}{)}
00072 
00073 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_24BIT\_INT} 0xF2
00074 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_24BIT\_INT\_MASK} 0xFF
00075 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_IS\_24BIT\_INT}\textcolor{preprocessor}{(}\textcolor{preprocessor}{byte}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{byte}\textcolor{preprocessor}{)}\textcolor{preprocessor}{&}\hyperlink{listpack_8c_abaa8acd1d2b43ceae41f6a7ffeeda368}{LP\_ENCODING\_24BIT\_INT\_MASK}\textcolor{preprocessor}{)}\textcolor{preprocessor}{
      ==}\hyperlink{listpack_8c_a431020d4a3ee70b22b181b52fd231a77}{LP\_ENCODING\_24BIT\_INT}\textcolor{preprocessor}{)}
00076 
00077 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_32BIT\_INT} 0xF3
00078 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_32BIT\_INT\_MASK} 0xFF
00079 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_IS\_32BIT\_INT}\textcolor{preprocessor}{(}\textcolor{preprocessor}{byte}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{byte}\textcolor{preprocessor}{)}\textcolor{preprocessor}{&}\hyperlink{listpack_8c_a91afb1463912e502f01583ece843b06d}{LP\_ENCODING\_32BIT\_INT\_MASK}\textcolor{preprocessor}{)}\textcolor{preprocessor}{
      ==}\hyperlink{listpack_8c_aaf5d2cb51cf79d9609347c1cf7985711}{LP\_ENCODING\_32BIT\_INT}\textcolor{preprocessor}{)}
00080 
00081 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_64BIT\_INT} 0xF4
00082 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_64BIT\_INT\_MASK} 0xFF
00083 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_IS\_64BIT\_INT}\textcolor{preprocessor}{(}\textcolor{preprocessor}{byte}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{byte}\textcolor{preprocessor}{)}\textcolor{preprocessor}{&}\hyperlink{listpack_8c_a3a5c4cb907946391c28b8202369122b7}{LP\_ENCODING\_64BIT\_INT\_MASK}\textcolor{preprocessor}{)}\textcolor{preprocessor}{
      ==}\hyperlink{listpack_8c_af93eef022c1590a9a592384e54df54c4}{LP\_ENCODING\_64BIT\_INT}\textcolor{preprocessor}{)}
00084 
00085 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_32BIT\_STR} 0xF0
00086 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_32BIT\_STR\_MASK} 0xFF
00087 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_IS\_32BIT\_STR}\textcolor{preprocessor}{(}\textcolor{preprocessor}{byte}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{byte}\textcolor{preprocessor}{)}\textcolor{preprocessor}{&}\hyperlink{listpack_8c_a80e656069b508dbd635201bcceaff88f}{LP\_ENCODING\_32BIT\_STR\_MASK}\textcolor{preprocessor}{)}\textcolor{preprocessor}{
      ==}\hyperlink{listpack_8c_aaf0cf5a0bd10428f4797894e10a3e92b}{LP\_ENCODING\_32BIT\_STR}\textcolor{preprocessor}{)}
00088 
00089 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_EOF} 0xFF
00090 
00091 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_6BIT\_STR\_LEN}\textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}0\textcolor{preprocessor}{]} \textcolor{preprocessor}{&} 0x3F\textcolor{preprocessor}{)}
00092 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_12BIT\_STR\_LEN}\textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}0\textcolor{preprocessor}{]} \textcolor{preprocessor}{&} 0xF\textcolor{preprocessor}{)} \textcolor{preprocessor}{<<} 8\textcolor{preprocessor}{)} \textcolor{preprocessor}{|} \textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}1\textcolor{preprocessor}{]}\textcolor{preprocessor}{)}
00093 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LP\_ENCODING\_32BIT\_STR\_LEN}\textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint32\_t}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}1\textcolor{preprocessor}{]}\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)} \textcolor{preprocessor}{|}
00094                                       \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint32\_t}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}2\textcolor{preprocessor}{]}\textcolor{preprocessor}{<<}8\textcolor{preprocessor}{)} \textcolor{preprocessor}{|}
00095                                       \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint32\_t}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}3\textcolor{preprocessor}{]}\textcolor{preprocessor}{<<}16\textcolor{preprocessor}{)} \textcolor{preprocessor}{|}
00096                                       \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint32\_t}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}4\textcolor{preprocessor}{]}\textcolor{preprocessor}{<<}24\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00097 
00098 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{lpGetTotalBytes}\textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}           \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint32\_t}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}0\textcolor{preprocessor}{]}\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)} \textcolor{preprocessor}{|}
00099                                       \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint32\_t}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}1\textcolor{preprocessor}{]}\textcolor{preprocessor}{<<}8\textcolor{preprocessor}{)} \textcolor{preprocessor}{|}
00100                                       \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint32\_t}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}2\textcolor{preprocessor}{]}\textcolor{preprocessor}{<<}16\textcolor{preprocessor}{)} \textcolor{preprocessor}{|}
00101                                       \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint32\_t}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}3\textcolor{preprocessor}{]}\textcolor{preprocessor}{<<}24\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00102 
00103 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{lpGetNumElements}\textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}          \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint32\_t}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}4\textcolor{preprocessor}{]}\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)} \textcolor{preprocessor}{|}
00104                                       \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint32\_t}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}5\textcolor{preprocessor}{]}\textcolor{preprocessor}{<<}8\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00105 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{lpSetTotalBytes}\textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{,}\textcolor{preprocessor}{v}\textcolor{preprocessor}{)} \textcolor{keywordflow}{do} \textcolor{preprocessor}{\{}
00106     \textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}0\textcolor{preprocessor}{]} \textcolor{preprocessor}{=} \textcolor{preprocessor}{(}\textcolor{preprocessor}{v}\textcolor{preprocessor}{)}\textcolor{preprocessor}{&}0xff\textcolor{preprocessor}{;}
00107     \textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}1\textcolor{preprocessor}{]} \textcolor{preprocessor}{=} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{v}\textcolor{preprocessor}{)}\textcolor{preprocessor}{>>}8\textcolor{preprocessor}{)}\textcolor{preprocessor}{&}0xff\textcolor{preprocessor}{;}
00108     \textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}2\textcolor{preprocessor}{]} \textcolor{preprocessor}{=} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{v}\textcolor{preprocessor}{)}\textcolor{preprocessor}{>>}16\textcolor{preprocessor}{)}\textcolor{preprocessor}{&}0xff\textcolor{preprocessor}{;}
00109     \textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}3\textcolor{preprocessor}{]} \textcolor{preprocessor}{=} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{v}\textcolor{preprocessor}{)}\textcolor{preprocessor}{>>}24\textcolor{preprocessor}{)}\textcolor{preprocessor}{&}0xff\textcolor{preprocessor}{;} \textcolor{preprocessor}{\(\backslash\)}
00110 \textcolor{preprocessor}{\}}\textcolor{keywordflow}{while}\textcolor{preprocessor}{(}0\textcolor{preprocessor}{)}
00111 
00112 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{lpSetNumElements}\textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{,}\textcolor{preprocessor}{v}\textcolor{preprocessor}{)} \textcolor{keywordflow}{do} \textcolor{preprocessor}{\{}
00113     \textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}4\textcolor{preprocessor}{]} \textcolor{preprocessor}{=} \textcolor{preprocessor}{(}\textcolor{preprocessor}{v}\textcolor{preprocessor}{)}\textcolor{preprocessor}{&}0xff\textcolor{preprocessor}{;}
00114     \textcolor{preprocessor}{(}\textcolor{preprocessor}{p}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}5\textcolor{preprocessor}{]} \textcolor{preprocessor}{=} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{v}\textcolor{preprocessor}{)}\textcolor{preprocessor}{>>}8\textcolor{preprocessor}{)}\textcolor{preprocessor}{&}0xff\textcolor{preprocessor}{;} \textcolor{preprocessor}{\(\backslash\)}
00115 \textcolor{preprocessor}{\}}\textcolor{keywordflow}{while}\textcolor{preprocessor}{(}0\textcolor{preprocessor}{)}
00116 
00117 \textcolor{comment}{/* Convert a string into a signed 64 bit integer.}
00118 \textcolor{comment}{ * The function returns 1 if the string could be parsed into a (non-overflowing)}
00119 \textcolor{comment}{ * signed 64 bit int, 0 otherwise. The 'value' will be set to the parsed value}
00120 \textcolor{comment}{ * when the function returns success.}
00121 \textcolor{comment}{ *}
00122 \textcolor{comment}{ * Note that this function demands that the string strictly represents}
00123 \textcolor{comment}{ * a int64 value: no spaces or other characters before or after the string}
00124 \textcolor{comment}{ * representing the number are accepted, nor zeroes at the start if not}
00125 \textcolor{comment}{ * for the string "0" representing the zero number.}
00126 \textcolor{comment}{ *}
00127 \textcolor{comment}{ * Because of its strictness, it is safe to use this function to check if}
00128 \textcolor{comment}{ * you can convert a string into a long long, and obtain back the string}
00129 \textcolor{comment}{ * from the number without any loss in the string representation. *}
00130 \textcolor{comment}{ *}
00131 \textcolor{comment}{ * -----------------------------------------------------------------------------}
00132 \textcolor{comment}{ *}
00133 \textcolor{comment}{ * Credits: this function was adapted from the Redis source code, file}
00134 \textcolor{comment}{ * "utils.c", function string2ll(), and is copyright:}
00135 \textcolor{comment}{ *}
00136 \textcolor{comment}{ * Copyright(C) 2011, Pieter Noordhuis}
00137 \textcolor{comment}{ * Copyright(C) 2011, Salvatore Sanfilippo}
00138 \textcolor{comment}{ *}
00139 \textcolor{comment}{ * The function is released under the BSD 3-clause license.}
00140 \textcolor{comment}{ */}
00141 \textcolor{keywordtype}{int} lpStringToInt64(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} slen, int64\_t *value) \{
00142     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *p = s;
00143     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} plen = 0;
00144     \textcolor{keywordtype}{int} negative = 0;
00145     uint64\_t v;
00146 
00147     \textcolor{keywordflow}{if} (plen == slen)
00148         \textcolor{keywordflow}{return} 0;
00149 
00150     \textcolor{comment}{/* Special case: first and only digit is 0. */}
00151     \textcolor{keywordflow}{if} (slen == 1 && p[0] == \textcolor{stringliteral}{'0'}) \{
00152         \textcolor{keywordflow}{if} (value != NULL) *value = 0;
00153         \textcolor{keywordflow}{return} 1;
00154     \}
00155 
00156     \textcolor{keywordflow}{if} (p[0] == \textcolor{stringliteral}{'-'}) \{
00157         negative = 1;
00158         p++; plen++;
00159 
00160         \textcolor{comment}{/* Abort on only a negative sign. */}
00161         \textcolor{keywordflow}{if} (plen == slen)
00162             \textcolor{keywordflow}{return} 0;
00163     \}
00164 
00165     \textcolor{comment}{/* First digit should be 1-9, otherwise the string should just be 0. */}
00166     \textcolor{keywordflow}{if} (p[0] >= \textcolor{stringliteral}{'1'} && p[0] <= \textcolor{stringliteral}{'9'}) \{
00167         v = p[0]-\textcolor{stringliteral}{'0'};
00168         p++; plen++;
00169     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (p[0] == \textcolor{stringliteral}{'0'} && slen == 1) \{
00170         *value = 0;
00171         \textcolor{keywordflow}{return} 1;
00172     \} \textcolor{keywordflow}{else} \{
00173         \textcolor{keywordflow}{return} 0;
00174     \}
00175 
00176     \textcolor{keywordflow}{while} (plen < slen && p[0] >= \textcolor{stringliteral}{'0'} && p[0] <= \textcolor{stringliteral}{'9'}) \{
00177         \textcolor{keywordflow}{if} (v > (UINT64\_MAX / 10)) \textcolor{comment}{/* Overflow. */}
00178             \textcolor{keywordflow}{return} 0;
00179         v *= 10;
00180 
00181         \textcolor{keywordflow}{if} (v > (UINT64\_MAX - (p[0]-\textcolor{stringliteral}{'0'}))) \textcolor{comment}{/* Overflow. */}
00182             \textcolor{keywordflow}{return} 0;
00183         v += p[0]-\textcolor{stringliteral}{'0'};
00184 
00185         p++; plen++;
00186     \}
00187 
00188     \textcolor{comment}{/* Return if not all bytes were used. */}
00189     \textcolor{keywordflow}{if} (plen < slen)
00190         \textcolor{keywordflow}{return} 0;
00191 
00192     \textcolor{keywordflow}{if} (negative) \{
00193         \textcolor{keywordflow}{if} (v > ((uint64\_t)(-(INT64\_MIN+1))+1)) \textcolor{comment}{/* Overflow. */}
00194             \textcolor{keywordflow}{return} 0;
00195         \textcolor{keywordflow}{if} (value != NULL) *value = -v;
00196     \} \textcolor{keywordflow}{else} \{
00197         \textcolor{keywordflow}{if} (v > INT64\_MAX) \textcolor{comment}{/* Overflow. */}
00198             \textcolor{keywordflow}{return} 0;
00199         \textcolor{keywordflow}{if} (value != NULL) *value = v;
00200     \}
00201     \textcolor{keywordflow}{return} 1;
00202 \}
00203 
00204 \textcolor{comment}{/* Create a new, empty listpack.}
00205 \textcolor{comment}{ * On success the new listpack is returned, otherwise an error is returned. */}
00206 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lpNew(\textcolor{keywordtype}{void}) \{
00207     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lp = \hyperlink{listpack__malloc_8h_ac3f4fb45221bef8d11ffe40df4ee0e31}{lp\_malloc}(\hyperlink{listpack_8c_aa3fb94110f69a73ee90b4e63d8524dba}{LP\_HDR\_SIZE}+1);
00208     \textcolor{keywordflow}{if} (lp == NULL) \textcolor{keywordflow}{return} NULL;
00209     \hyperlink{listpack_8c_a08a4fb5c67c9c38aa657ba8773b7e1ab}{lpSetTotalBytes}(lp,\hyperlink{listpack_8c_aa3fb94110f69a73ee90b4e63d8524dba}{LP\_HDR\_SIZE}+1);
00210     \hyperlink{listpack_8c_abd63c5b3f66f6d270759fa5e3c319ce8}{lpSetNumElements}(lp,0);
00211     lp[\hyperlink{listpack_8c_aa3fb94110f69a73ee90b4e63d8524dba}{LP\_HDR\_SIZE}] = \hyperlink{listpack_8c_aa11b422dc597c4352da2abf522692774}{LP\_EOF};
00212     \textcolor{keywordflow}{return} lp;
00213 \}
00214 
00215 \textcolor{comment}{/* Free the specified listpack. */}
00216 \textcolor{keywordtype}{void} lpFree(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lp) \{
00217     \hyperlink{listpack__malloc_8h_a395418499fa2976813d30cc739180199}{lp\_free}(lp);
00218 \}
00219 
00220 \textcolor{comment}{/* Given an element 'ele' of size 'size', determine if the element can be}
00221 \textcolor{comment}{ * represented inside the listpack encoded as integer, and returns}
00222 \textcolor{comment}{ * LP\_ENCODING\_INT if so. Otherwise returns LP\_ENCODING\_STR if no integer}
00223 \textcolor{comment}{ * encoding is possible.}
00224 \textcolor{comment}{ *}
00225 \textcolor{comment}{ * If the LP\_ENCODING\_INT is returned, the function stores the integer encoded}
00226 \textcolor{comment}{ * representation of the element in the 'intenc' buffer.}
00227 \textcolor{comment}{ *}
00228 \textcolor{comment}{ * Regardless of the returned encoding, 'enclen' is populated by reference to}
00229 \textcolor{comment}{ * the number of bytes that the string or integer encoded element will require}
00230 \textcolor{comment}{ * in order to be represented. */}
00231 \textcolor{keywordtype}{int} lpEncodeGetType(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ele, uint32\_t size, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *intenc, uint64\_t *enclen) \{
00232     int64\_t v;
00233     \textcolor{keywordflow}{if} (lpStringToInt64((\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)ele, size, &v)) \{
00234         \textcolor{keywordflow}{if} (v >= 0 && v <= 127) \{
00235             \textcolor{comment}{/* Single byte 0-127 integer. */}
00236             intenc[0] = v;
00237             *enclen = 1;
00238         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (v >= -4096 && v <= 4095) \{
00239             \textcolor{comment}{/* 13 bit integer. */}
00240             \textcolor{keywordflow}{if} (v < 0) v = ((int64\_t)1<<13)+v;
00241             intenc[0] = (v>>8)|\hyperlink{listpack_8c_a9cfea84c38c5cf0d152f0e40fdd7c1fc}{LP\_ENCODING\_13BIT\_INT};
00242             intenc[1] = v&0xff;
00243             *enclen = 2;
00244         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (v >= -32768 && v <= 32767) \{
00245             \textcolor{comment}{/* 16 bit integer. */}
00246             \textcolor{keywordflow}{if} (v < 0) v = ((int64\_t)1<<16)+v;
00247             intenc[0] = \hyperlink{listpack_8c_a4e888717b76a31a4ea334a03fea25047}{LP\_ENCODING\_16BIT\_INT};
00248             intenc[1] = v&0xff;
00249             intenc[2] = v>>8;
00250             *enclen = 3;
00251         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (v >= -8388608 && v <= 8388607) \{
00252             \textcolor{comment}{/* 24 bit integer. */}
00253             \textcolor{keywordflow}{if} (v < 0) v = ((int64\_t)1<<24)+v;
00254             intenc[0] = \hyperlink{listpack_8c_a431020d4a3ee70b22b181b52fd231a77}{LP\_ENCODING\_24BIT\_INT};
00255             intenc[1] = v&0xff;
00256             intenc[2] = (v>>8)&0xff;
00257             intenc[3] = v>>16;
00258             *enclen = 4;
00259         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (v >= -2147483648 && v <= 2147483647) \{
00260             \textcolor{comment}{/* 32 bit integer. */}
00261             \textcolor{keywordflow}{if} (v < 0) v = ((int64\_t)1<<32)+v;
00262             intenc[0] = \hyperlink{listpack_8c_aaf5d2cb51cf79d9609347c1cf7985711}{LP\_ENCODING\_32BIT\_INT};
00263             intenc[1] = v&0xff;
00264             intenc[2] = (v>>8)&0xff;
00265             intenc[3] = (v>>16)&0xff;
00266             intenc[4] = v>>24;
00267             *enclen = 5;
00268         \} \textcolor{keywordflow}{else} \{
00269             \textcolor{comment}{/* 64 bit integer. */}
00270             uint64\_t uv = v;
00271             intenc[0] = \hyperlink{listpack_8c_af93eef022c1590a9a592384e54df54c4}{LP\_ENCODING\_64BIT\_INT};
00272             intenc[1] = uv&0xff;
00273             intenc[2] = (uv>>8)&0xff;
00274             intenc[3] = (uv>>16)&0xff;
00275             intenc[4] = (uv>>24)&0xff;
00276             intenc[5] = (uv>>32)&0xff;
00277             intenc[6] = (uv>>40)&0xff;
00278             intenc[7] = (uv>>48)&0xff;
00279             intenc[8] = uv>>56;
00280             *enclen = 9;
00281         \}
00282         \textcolor{keywordflow}{return} \hyperlink{listpack_8c_a6f31184b7647732d04b0518b59261b62}{LP\_ENCODING\_INT};
00283     \} \textcolor{keywordflow}{else} \{
00284         \textcolor{keywordflow}{if} (size < 64) *enclen = 1+size;
00285         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (size < 4096) *enclen = 2+size;
00286         \textcolor{keywordflow}{else} *enclen = 5+size;
00287         \textcolor{keywordflow}{return} \hyperlink{listpack_8c_acc1f8e726cc13c4d44351668652cea05}{LP\_ENCODING\_STRING};
00288     \}
00289 \}
00290 
00291 \textcolor{comment}{/* Store a reverse-encoded variable length field, representing the length}
00292 \textcolor{comment}{ * of the previous element of size 'l', in the target buffer 'buf'.}
00293 \textcolor{comment}{ * The function returns the number of bytes used to encode it, from}
00294 \textcolor{comment}{ * 1 to 5. If 'buf' is NULL the funciton just returns the number of bytes}
00295 \textcolor{comment}{ * needed in order to encode the backlen. */}
00296 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} lpEncodeBacklen(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buf, uint64\_t l) \{
00297     \textcolor{keywordflow}{if} (l <= 127) \{
00298         \textcolor{keywordflow}{if} (buf) buf[0] = l;
00299         \textcolor{keywordflow}{return} 1;
00300     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (l < 16383) \{
00301         \textcolor{keywordflow}{if} (buf) \{
00302             buf[0] = l>>7;
00303             buf[1] = (l&127)|128;
00304         \}
00305         \textcolor{keywordflow}{return} 2;
00306     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (l < 2097151) \{
00307         \textcolor{keywordflow}{if} (buf) \{
00308             buf[0] = l>>14;
00309             buf[1] = ((l>>7)&127)|128;
00310             buf[2] = (l&127)|128;
00311         \}
00312         \textcolor{keywordflow}{return} 3;
00313     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (l < 268435455) \{
00314         \textcolor{keywordflow}{if} (buf) \{
00315             buf[0] = l>>21;
00316             buf[1] = ((l>>14)&127)|128;
00317             buf[2] = ((l>>7)&127)|128;
00318             buf[3] = (l&127)|128;
00319         \}
00320         \textcolor{keywordflow}{return} 4;
00321     \} \textcolor{keywordflow}{else} \{
00322         \textcolor{keywordflow}{if} (buf) \{
00323             buf[0] = l>>28;
00324             buf[1] = ((l>>21)&127)|128;
00325             buf[2] = ((l>>14)&127)|128;
00326             buf[3] = ((l>>7)&127)|128;
00327             buf[4] = (l&127)|128;
00328         \}
00329         \textcolor{keywordflow}{return} 5;
00330     \}
00331 \}
00332 
00333 \textcolor{comment}{/* Decode the backlen and returns it. If the encoding looks invalid (more than}
00334 \textcolor{comment}{ * 5 bytes are used), UINT64\_MAX is returned to report the problem. */}
00335 uint64\_t lpDecodeBacklen(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p) \{
00336     uint64\_t val = 0;
00337     uint64\_t shift = 0;
00338     \textcolor{keywordflow}{do} \{
00339         val |= (uint64\_t)(p[0] & 127) << shift;
00340         \textcolor{keywordflow}{if} (!(p[0] & 128)) \textcolor{keywordflow}{break};
00341         shift += 7;
00342         p--;
00343         \textcolor{keywordflow}{if} (shift > 28) \textcolor{keywordflow}{return} UINT64\_MAX;
00344     \} \textcolor{keywordflow}{while}(1);
00345     \textcolor{keywordflow}{return} val;
00346 \}
00347 
00348 \textcolor{comment}{/* Encode the string element pointed by 's' of size 'len' in the target}
00349 \textcolor{comment}{ * buffer 's'. The function should be called with 'buf' having always enough}
00350 \textcolor{comment}{ * space for encoding the string. This is done by calling lpEncodeGetType()}
00351 \textcolor{comment}{ * before calling this function. */}
00352 \textcolor{keywordtype}{void} lpEncodeString(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buf, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *s, uint32\_t len) \{
00353     \textcolor{keywordflow}{if} (len < 64) \{
00354         buf[0] = len | \hyperlink{listpack_8c_aa03a77428cf5dd11a741306d35f08d6f}{LP\_ENCODING\_6BIT\_STR};
00355         memcpy(buf+1,s,len);
00356     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (len < 4096) \{
00357         buf[0] = (len >> 8) | \hyperlink{listpack_8c_acf85ac38dc36778e68c75963245a3959}{LP\_ENCODING\_12BIT\_STR};
00358         buf[1] = len & 0xff;
00359         memcpy(buf+2,s,len);
00360     \} \textcolor{keywordflow}{else} \{
00361         buf[0] = \hyperlink{listpack_8c_aaf0cf5a0bd10428f4797894e10a3e92b}{LP\_ENCODING\_32BIT\_STR};
00362         buf[1] = len & 0xff;
00363         buf[2] = (len >> 8) & 0xff;
00364         buf[3] = (len >> 16) & 0xff;
00365         buf[4] = (len >> 24) & 0xff;
00366         memcpy(buf+5,s,len);
00367     \}
00368 \}
00369 
00370 \textcolor{comment}{/* Return the encoded length of the listpack element pointed by 'p'. If the}
00371 \textcolor{comment}{ * element encoding is wrong then 0 is returned. */}
00372 uint32\_t lpCurrentEncodedSize(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p) \{
00373     \textcolor{keywordflow}{if} (\hyperlink{listpack_8c_a4a6f30f71e802fffc5e9ab4ebf340a85}{LP\_ENCODING\_IS\_7BIT\_UINT}(p[0])) \textcolor{keywordflow}{return} 1;
00374     \textcolor{keywordflow}{if} (\hyperlink{listpack_8c_a6d358f2ea07af0f8624dcd6abc784503}{LP\_ENCODING\_IS\_6BIT\_STR}(p[0])) \textcolor{keywordflow}{return} 1+
      \hyperlink{listpack_8c_aa8f2d59ee3355ef504d3b9914e5bb71d}{LP\_ENCODING\_6BIT\_STR\_LEN}(p);
00375     \textcolor{keywordflow}{if} (\hyperlink{listpack_8c_a3b3582cd32282a865f4df2c8c7a2aa24}{LP\_ENCODING\_IS\_13BIT\_INT}(p[0])) \textcolor{keywordflow}{return} 2;
00376     \textcolor{keywordflow}{if} (\hyperlink{listpack_8c_a95d38c05519efabc4ee56f4562e98750}{LP\_ENCODING\_IS\_16BIT\_INT}(p[0])) \textcolor{keywordflow}{return} 3;
00377     \textcolor{keywordflow}{if} (\hyperlink{listpack_8c_a3ab45d5e21a9cb0f43d9fd91d55fad34}{LP\_ENCODING\_IS\_24BIT\_INT}(p[0])) \textcolor{keywordflow}{return} 4;
00378     \textcolor{keywordflow}{if} (\hyperlink{listpack_8c_a20bcd55f1ab106b65268239685b5b4bf}{LP\_ENCODING\_IS\_32BIT\_INT}(p[0])) \textcolor{keywordflow}{return} 5;
00379     \textcolor{keywordflow}{if} (\hyperlink{listpack_8c_a72330c9d476269713f068c215d605675}{LP\_ENCODING\_IS\_64BIT\_INT}(p[0])) \textcolor{keywordflow}{return} 9;
00380     \textcolor{keywordflow}{if} (\hyperlink{listpack_8c_a0bd78dfc25cc8b1956919beb5bf1dbcd}{LP\_ENCODING\_IS\_12BIT\_STR}(p[0])) \textcolor{keywordflow}{return} 2+
      \hyperlink{listpack_8c_aee98309526d5001f5a402405166e65d8}{LP\_ENCODING\_12BIT\_STR\_LEN}(p);
00381     \textcolor{keywordflow}{if} (\hyperlink{listpack_8c_afb8bf77b7f72a33b662e74d855725ac9}{LP\_ENCODING\_IS\_32BIT\_STR}(p[0])) \textcolor{keywordflow}{return} 5+
      \hyperlink{listpack_8c_a66a8fedf2589934bf597c7bea3f881ba}{LP\_ENCODING\_32BIT\_STR\_LEN}(p);
00382     \textcolor{keywordflow}{if} (p[0] == \hyperlink{listpack_8c_aa11b422dc597c4352da2abf522692774}{LP\_EOF}) \textcolor{keywordflow}{return} 1;
00383     \textcolor{keywordflow}{return} 0;
00384 \}
00385 
00386 \textcolor{comment}{/* Skip the current entry returning the next. It is invalid to call this}
00387 \textcolor{comment}{ * function if the current element is the EOF element at the end of the}
00388 \textcolor{comment}{ * listpack, however, while this function is used to implement lpNext(),}
00389 \textcolor{comment}{ * it does not return NULL when the EOF element is encountered. */}
00390 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lpSkip(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p) \{
00391     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} entrylen = lpCurrentEncodedSize(p);
00392     entrylen += lpEncodeBacklen(NULL,entrylen);
00393     p += entrylen;
00394     \textcolor{keywordflow}{return} p;
00395 \}
00396 
00397 \textcolor{comment}{/* If 'p' points to an element of the listpack, calling lpNext() will return}
00398 \textcolor{comment}{ * the pointer to the next element (the one on the right), or NULL if 'p'}
00399 \textcolor{comment}{ * already pointed to the last element of the listpack. */}
00400 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lpNext(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lp, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p) \{
00401     ((\textcolor{keywordtype}{void}) lp); \textcolor{comment}{/* lp is not used for now. However lpPrev() uses it. */}
00402     p = lpSkip(p);
00403     \textcolor{keywordflow}{if} (p[0] == \hyperlink{listpack_8c_aa11b422dc597c4352da2abf522692774}{LP\_EOF}) \textcolor{keywordflow}{return} NULL;
00404     \textcolor{keywordflow}{return} p;
00405 \}
00406 
00407 \textcolor{comment}{/* If 'p' points to an element of the listpack, calling lpPrev() will return}
00408 \textcolor{comment}{ * the pointer to the preivous element (the one on the left), or NULL if 'p'}
00409 \textcolor{comment}{ * already pointed to the first element of the listpack. */}
00410 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lpPrev(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lp, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p) \{
00411     \textcolor{keywordflow}{if} (p-lp == \hyperlink{listpack_8c_aa3fb94110f69a73ee90b4e63d8524dba}{LP\_HDR\_SIZE}) \textcolor{keywordflow}{return} NULL;
00412     p--; \textcolor{comment}{/* Seek the first backlen byte of the last element. */}
00413     uint64\_t prevlen = lpDecodeBacklen(p);
00414     prevlen += lpEncodeBacklen(NULL,prevlen);
00415     \textcolor{keywordflow}{return} p-prevlen+1; \textcolor{comment}{/* Seek the first byte of the previous entry. */}
00416 \}
00417 
00418 \textcolor{comment}{/* Return a pointer to the first element of the listpack, or NULL if the}
00419 \textcolor{comment}{ * listpack has no elements. */}
00420 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lpFirst(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lp) \{
00421     lp += \hyperlink{listpack_8c_aa3fb94110f69a73ee90b4e63d8524dba}{LP\_HDR\_SIZE}; \textcolor{comment}{/* Skip the header. */}
00422     \textcolor{keywordflow}{if} (lp[0] == \hyperlink{listpack_8c_aa11b422dc597c4352da2abf522692774}{LP\_EOF}) \textcolor{keywordflow}{return} NULL;
00423     \textcolor{keywordflow}{return} lp;
00424 \}
00425 
00426 \textcolor{comment}{/* Return a pointer to the last element of the listpack, or NULL if the}
00427 \textcolor{comment}{ * listpack has no elements. */}
00428 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lpLast(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lp) \{
00429     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p = lp+\hyperlink{listpack_8c_a18d79dc11f1002b8c367eab243912a36}{lpGetTotalBytes}(lp)-1; \textcolor{comment}{/* Seek EOF element. */}
00430     \textcolor{keywordflow}{return} lpPrev(lp,p); \textcolor{comment}{/* Will return NULL if EOF is the only element. */}
00431 \}
00432 
00433 \textcolor{comment}{/* Return the number of elements inside the listpack. This function attempts}
00434 \textcolor{comment}{ * to use the cached value when within range, otherwise a full scan is}
00435 \textcolor{comment}{ * needed. As a side effect of calling this function, the listpack header}
00436 \textcolor{comment}{ * could be modified, because if the count is found to be already within}
00437 \textcolor{comment}{ * the 'numele' header field range, the new value is set. */}
00438 uint32\_t lpLength(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lp) \{
00439     uint32\_t numele = \hyperlink{listpack_8c_a6c5657a15231eb538939e10677c8ef1f}{lpGetNumElements}(lp);
00440     \textcolor{keywordflow}{if} (numele != \hyperlink{listpack_8c_aabaec596aac6d7d8370b7d801638b022}{LP\_HDR\_NUMELE\_UNKNOWN}) \textcolor{keywordflow}{return} numele;
00441 
00442     \textcolor{comment}{/* Too many elements inside the listpack. We need to scan in order}
00443 \textcolor{comment}{     * to get the total number. */}
00444     uint32\_t count = 0;
00445     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p = lpFirst(lp);
00446     \textcolor{keywordflow}{while}(p) \{
00447         count++;
00448         p = lpNext(lp,p);
00449     \}
00450 
00451     \textcolor{comment}{/* If the count is again within range of the header numele field,}
00452 \textcolor{comment}{     * set it. */}
00453     \textcolor{keywordflow}{if} (count < \hyperlink{listpack_8c_aabaec596aac6d7d8370b7d801638b022}{LP\_HDR\_NUMELE\_UNKNOWN}) 
      \hyperlink{listpack_8c_abd63c5b3f66f6d270759fa5e3c319ce8}{lpSetNumElements}(lp,count);
00454     \textcolor{keywordflow}{return} count;
00455 \}
00456 
00457 \textcolor{comment}{/* Return the listpack element pointed by 'p'.}
00458 \textcolor{comment}{ *}
00459 \textcolor{comment}{ * The function changes behavior depending on the passed 'intbuf' value.}
00460 \textcolor{comment}{ * Specifically, if 'intbuf' is NULL:}
00461 \textcolor{comment}{ *}
00462 \textcolor{comment}{ * If the element is internally encoded as an integer, the function returns}
00463 \textcolor{comment}{ * NULL and populates the integer value by reference in 'count'. Otherwise if}
00464 \textcolor{comment}{ * the element is encoded as a string a pointer to the string (pointing inside}
00465 \textcolor{comment}{ * the listpack itself) is returned, and 'count' is set to the length of the}
00466 \textcolor{comment}{ * string.}
00467 \textcolor{comment}{ *}
00468 \textcolor{comment}{ * If instead 'intbuf' points to a buffer passed by the caller, that must be}
00469 \textcolor{comment}{ * at least LP\_INTBUF\_SIZE bytes, the function always returns the element as}
00470 \textcolor{comment}{ * it was a string (returning the pointer to the string and setting the}
00471 \textcolor{comment}{ * 'count' argument to the string length by reference). However if the element}
00472 \textcolor{comment}{ * is encoded as an integer, the 'intbuf' buffer is used in order to store}
00473 \textcolor{comment}{ * the string representation.}
00474 \textcolor{comment}{ *}
00475 \textcolor{comment}{ * The user should use one or the other form depending on what the value will}
00476 \textcolor{comment}{ * be used for. If there is immediate usage for an integer value returned}
00477 \textcolor{comment}{ * by the function, than to pass a buffer (and convert it back to a number)}
00478 \textcolor{comment}{ * is of course useless.}
00479 \textcolor{comment}{ *}
00480 \textcolor{comment}{ * If the function is called against a badly encoded ziplist, so that there}
00481 \textcolor{comment}{ * is no valid way to parse it, the function returns like if there was an}
00482 \textcolor{comment}{ * integer encoded with value 12345678900000000 + <unrecognized byte>, this may}
00483 \textcolor{comment}{ * be an hint to understand that something is wrong. To crash in this case is}
00484 \textcolor{comment}{ * not sensible because of the different requirements of the application using}
00485 \textcolor{comment}{ * this lib.}
00486 \textcolor{comment}{ *}
00487 \textcolor{comment}{ * Similarly, there is no error returned since the listpack normally can be}
00488 \textcolor{comment}{ * assumed to be valid, so that would be a very high API cost. However a function}
00489 \textcolor{comment}{ * in order to check the integrity of the listpack at load time is provided,}
00490 \textcolor{comment}{ * check lpIsValid(). */}
00491 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lpGet(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, int64\_t *count, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *intbuf) \{
00492     int64\_t val;
00493     uint64\_t uval, negstart, negmax;
00494 
00495     \textcolor{keywordflow}{if} (\hyperlink{listpack_8c_a4a6f30f71e802fffc5e9ab4ebf340a85}{LP\_ENCODING\_IS\_7BIT\_UINT}(p[0])) \{
00496         negstart = UINT64\_MAX; \textcolor{comment}{/* 7 bit ints are always positive. */}
00497         negmax = 0;
00498         uval = p[0] & 0x7f;
00499     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{listpack_8c_a6d358f2ea07af0f8624dcd6abc784503}{LP\_ENCODING\_IS\_6BIT\_STR}(p[0])) \{
00500         *count = \hyperlink{listpack_8c_aa8f2d59ee3355ef504d3b9914e5bb71d}{LP\_ENCODING\_6BIT\_STR\_LEN}(p);
00501         \textcolor{keywordflow}{return} p+1;
00502     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{listpack_8c_a3b3582cd32282a865f4df2c8c7a2aa24}{LP\_ENCODING\_IS\_13BIT\_INT}(p[0])) \{
00503         uval = ((p[0]&0x1f)<<8) | p[1];
00504         negstart = (uint64\_t)1<<12;
00505         negmax = 8191;
00506     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{listpack_8c_a95d38c05519efabc4ee56f4562e98750}{LP\_ENCODING\_IS\_16BIT\_INT}(p[0])) \{
00507         uval = (uint64\_t)p[1] |
00508                (uint64\_t)p[2]<<8;
00509         negstart = (uint64\_t)1<<15;
00510         negmax = UINT16\_MAX;
00511     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{listpack_8c_a3ab45d5e21a9cb0f43d9fd91d55fad34}{LP\_ENCODING\_IS\_24BIT\_INT}(p[0])) \{
00512         uval = (uint64\_t)p[1] |
00513                (uint64\_t)p[2]<<8 |
00514                (uint64\_t)p[3]<<16;
00515         negstart = (uint64\_t)1<<23;
00516         negmax = UINT32\_MAX>>8;
00517     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{listpack_8c_a20bcd55f1ab106b65268239685b5b4bf}{LP\_ENCODING\_IS\_32BIT\_INT}(p[0])) \{
00518         uval = (uint64\_t)p[1] |
00519                (uint64\_t)p[2]<<8 |
00520                (uint64\_t)p[3]<<16 |
00521                (uint64\_t)p[4]<<24;
00522         negstart = (uint64\_t)1<<31;
00523         negmax = UINT32\_MAX;
00524     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{listpack_8c_a72330c9d476269713f068c215d605675}{LP\_ENCODING\_IS\_64BIT\_INT}(p[0])) \{
00525         uval = (uint64\_t)p[1] |
00526                (uint64\_t)p[2]<<8 |
00527                (uint64\_t)p[3]<<16 |
00528                (uint64\_t)p[4]<<24 |
00529                (uint64\_t)p[5]<<32 |
00530                (uint64\_t)p[6]<<40 |
00531                (uint64\_t)p[7]<<48 |
00532                (uint64\_t)p[8]<<56;
00533         negstart = (uint64\_t)1<<63;
00534         negmax = UINT64\_MAX;
00535     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{listpack_8c_a0bd78dfc25cc8b1956919beb5bf1dbcd}{LP\_ENCODING\_IS\_12BIT\_STR}(p[0])) \{
00536         *count = \hyperlink{listpack_8c_aee98309526d5001f5a402405166e65d8}{LP\_ENCODING\_12BIT\_STR\_LEN}(p);
00537         \textcolor{keywordflow}{return} p+2;
00538     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{listpack_8c_afb8bf77b7f72a33b662e74d855725ac9}{LP\_ENCODING\_IS\_32BIT\_STR}(p[0])) \{
00539         *count = \hyperlink{listpack_8c_a66a8fedf2589934bf597c7bea3f881ba}{LP\_ENCODING\_32BIT\_STR\_LEN}(p);
00540         \textcolor{keywordflow}{return} p+5;
00541     \} \textcolor{keywordflow}{else} \{
00542         uval = 12345678900000000ULL + p[0];
00543         negstart = UINT64\_MAX;
00544         negmax = 0;
00545     \}
00546 
00547     \textcolor{comment}{/* We reach this code path only for integer encodings.}
00548 \textcolor{comment}{     * Convert the unsigned value to the signed one using two's complement}
00549 \textcolor{comment}{     * rule. */}
00550     \textcolor{keywordflow}{if} (uval >= negstart) \{
00551         \textcolor{comment}{/* This three steps conversion should avoid undefined behaviors}
00552 \textcolor{comment}{         * in the unsigned -> signed conversion. */}
00553         uval = negmax-uval;
00554         val = uval;
00555         val = -val-1;
00556     \} \textcolor{keywordflow}{else} \{
00557         val = uval;
00558     \}
00559 
00560     \textcolor{comment}{/* Return the string representation of the integer or the value itself}
00561 \textcolor{comment}{     * depending on intbuf being NULL or not. */}
00562     \textcolor{keywordflow}{if} (intbuf) \{
00563         *count = snprintf((\textcolor{keywordtype}{char}*)intbuf,\hyperlink{listpack_8h_ab31e5c173b595ae4e703b72eb435a6e9}{LP\_INTBUF\_SIZE},\textcolor{stringliteral}{"%lld"},val);
00564         \textcolor{keywordflow}{return} intbuf;
00565     \} \textcolor{keywordflow}{else} \{
00566         *count = val;
00567         \textcolor{keywordflow}{return} NULL;
00568     \}
00569 \}
00570 
00571 \textcolor{comment}{/* Insert, delete or replace the specified element 'ele' of lenght 'len' at}
00572 \textcolor{comment}{ * the specified position 'p', with 'p' being a listpack element pointer}
00573 \textcolor{comment}{ * obtained with lpFirst(), lpLast(), lpIndex(), lpNext(), lpPrev() or}
00574 \textcolor{comment}{ * lpSeek().}
00575 \textcolor{comment}{ *}
00576 \textcolor{comment}{ * The element is inserted before, after, or replaces the element pointed}
00577 \textcolor{comment}{ * by 'p' depending on the 'where' argument, that can be LP\_BEFORE, LP\_AFTER}
00578 \textcolor{comment}{ * or LP\_REPLACE.}
00579 \textcolor{comment}{ *}
00580 \textcolor{comment}{ * If 'ele' is set to NULL, the function removes the element pointed by 'p'}
00581 \textcolor{comment}{ * instead of inserting one.}
00582 \textcolor{comment}{ *}
00583 \textcolor{comment}{ * Returns NULL on out of memory or when the listpack total length would exceed}
00584 \textcolor{comment}{ * the max allowed size of 2^32-1, otherwise the new pointer to the listpack}
00585 \textcolor{comment}{ * holding the new element is returned (and the old pointer passed is no longer}
00586 \textcolor{comment}{ * considered valid)}
00587 \textcolor{comment}{ *}
00588 \textcolor{comment}{ * If 'newp' is not NULL, at the end of a successful call '*newp' will be set}
00589 \textcolor{comment}{ * to the address of the element just added, so that it will be possible to}
00590 \textcolor{comment}{ * continue an interation with lpNext() and lpPrev().}
00591 \textcolor{comment}{ *}
00592 \textcolor{comment}{ * For deletion operations ('ele' set to NULL) 'newp' is set to the next}
00593 \textcolor{comment}{ * element, on the right of the deleted one, or to NULL if the deleted element}
00594 \textcolor{comment}{ * was the last one. */}
00595 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lpInsert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lp, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ele, uint32\_t size, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, \textcolor{keywordtype}{int} 
      where, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **newp) \{
00596     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} intenc[\hyperlink{listpack_8c_a915406ff900007462e93d6db78ecd503}{LP\_MAX\_INT\_ENCODING\_LEN}];
00597     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} backlen[\hyperlink{listpack_8c_a366cd2ebf1ab1f0266b6629d52e9a35d}{LP\_MAX\_BACKLEN\_SIZE}];
00598 
00599     uint64\_t enclen; \textcolor{comment}{/* The length of the encoded element. */}
00600 
00601     \textcolor{comment}{/* An element pointer set to NULL means deletion, which is conceptually}
00602 \textcolor{comment}{     * replacing the element with a zero-length element. So whatever we}
00603 \textcolor{comment}{     * get passed as 'where', set it to LP\_REPLACE. */}
00604     \textcolor{keywordflow}{if} (ele == NULL) where = \hyperlink{listpack_8h_a29d3b9a55d47053582a5025dd85d7fe6}{LP\_REPLACE};
00605 
00606     \textcolor{comment}{/* If we need to insert after the current element, we just jump to the}
00607 \textcolor{comment}{     * next element (that could be the EOF one) and handle the case of}
00608 \textcolor{comment}{     * inserting before. So the function will actually deal with just two}
00609 \textcolor{comment}{     * cases: LP\_BEFORE and LP\_REPLACE. */}
00610     \textcolor{keywordflow}{if} (where == \hyperlink{listpack_8h_ab57438590a2e825529df34cf1174a3a5}{LP\_AFTER}) \{
00611         p = lpSkip(p);
00612         where = \hyperlink{listpack_8h_a64de9ded0fe5ccb80bc2bc9fb8c6c3b2}{LP\_BEFORE};
00613     \}
00614 
00615     \textcolor{comment}{/* Store the offset of the element 'p', so that we can obtain its}
00616 \textcolor{comment}{     * address again after a reallocation. */}
00617     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} poff = p-lp;
00618 
00619     \textcolor{comment}{/* Calling lpEncodeGetType() results into the encoded version of the}
00620 \textcolor{comment}{     * element to be stored into 'intenc' in case it is representable as}
00621 \textcolor{comment}{     * an integer: in that case, the function returns LP\_ENCODING\_INT.}
00622 \textcolor{comment}{     * Otherwise if LP\_ENCODING\_STR is returned, we'll have to call}
00623 \textcolor{comment}{     * lpEncodeString() to actually write the encoded string on place later.}
00624 \textcolor{comment}{     *}
00625 \textcolor{comment}{     * Whatever the returned encoding is, 'enclen' is populated with the}
00626 \textcolor{comment}{     * length of the encoded element. */}
00627     \textcolor{keywordtype}{int} enctype;
00628     \textcolor{keywordflow}{if} (ele) \{
00629         enctype = lpEncodeGetType(ele,size,intenc,&enclen);
00630     \} \textcolor{keywordflow}{else} \{
00631         enctype = -1;
00632         enclen = 0;
00633     \}
00634 
00635     \textcolor{comment}{/* We need to also encode the backward-parsable length of the element}
00636 \textcolor{comment}{     * and append it to the end: this allows to traverse the listpack from}
00637 \textcolor{comment}{     * the end to the start. */}
00638     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} backlen\_size = ele ? lpEncodeBacklen(backlen,enclen) : 0;
00639     uint64\_t old\_listpack\_bytes = \hyperlink{listpack_8c_a18d79dc11f1002b8c367eab243912a36}{lpGetTotalBytes}(lp);
00640     uint32\_t replaced\_len  = 0;
00641     \textcolor{keywordflow}{if} (where == \hyperlink{listpack_8h_a29d3b9a55d47053582a5025dd85d7fe6}{LP\_REPLACE}) \{
00642         replaced\_len = lpCurrentEncodedSize(p);
00643         replaced\_len += lpEncodeBacklen(NULL,replaced\_len);
00644     \}
00645 
00646     uint64\_t new\_listpack\_bytes = old\_listpack\_bytes + enclen + backlen\_size
00647                                   - replaced\_len;
00648     \textcolor{keywordflow}{if} (new\_listpack\_bytes > UINT32\_MAX) \textcolor{keywordflow}{return} NULL;
00649 
00650     \textcolor{comment}{/* We now need to reallocate in order to make space or shrink the}
00651 \textcolor{comment}{     * allocation (in case 'when' value is LP\_REPLACE and the new element is}
00652 \textcolor{comment}{     * smaller). However we do that before memmoving the memory to}
00653 \textcolor{comment}{     * make room for the new element if the final allocation will get}
00654 \textcolor{comment}{     * larger, or we do it after if the final allocation will get smaller. */}
00655 
00656     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *dst = lp + poff; \textcolor{comment}{/* May be updated after reallocation. */}
00657 
00658     \textcolor{comment}{/* Realloc before: we need more room. */}
00659     \textcolor{keywordflow}{if} (new\_listpack\_bytes > old\_listpack\_bytes) \{
00660         \textcolor{keywordflow}{if} ((lp = \hyperlink{listpack__malloc_8h_acb3fca076ed1f5c6437b4e13462bb716}{lp\_realloc}(lp,new\_listpack\_bytes)) == NULL) \textcolor{keywordflow}{return} NULL;
00661         dst = lp + poff;
00662     \}
00663 
00664     \textcolor{comment}{/* Setup the listpack relocating the elements to make the exact room}
00665 \textcolor{comment}{     * we need to store the new one. */}
00666     \textcolor{keywordflow}{if} (where == \hyperlink{listpack_8h_a64de9ded0fe5ccb80bc2bc9fb8c6c3b2}{LP\_BEFORE}) \{
00667         memmove(dst+enclen+backlen\_size,dst,old\_listpack\_bytes-poff);
00668     \} \textcolor{keywordflow}{else} \{ \textcolor{comment}{/* LP\_REPLACE. */}
00669         \textcolor{keywordtype}{long} lendiff = (enclen+backlen\_size)-replaced\_len;
00670         memmove(dst+replaced\_len+lendiff,
00671                 dst+replaced\_len,
00672                 old\_listpack\_bytes-poff-replaced\_len);
00673     \}
00674 
00675     \textcolor{comment}{/* Realloc after: we need to free space. */}
00676     \textcolor{keywordflow}{if} (new\_listpack\_bytes < old\_listpack\_bytes) \{
00677         \textcolor{keywordflow}{if} ((lp = \hyperlink{listpack__malloc_8h_acb3fca076ed1f5c6437b4e13462bb716}{lp\_realloc}(lp,new\_listpack\_bytes)) == NULL) \textcolor{keywordflow}{return} NULL;
00678         dst = lp + poff;
00679     \}
00680 
00681     \textcolor{comment}{/* Store the entry. */}
00682     \textcolor{keywordflow}{if} (newp) \{
00683         *newp = dst;
00684         \textcolor{comment}{/* In case of deletion, set 'newp' to NULL if the next element is}
00685 \textcolor{comment}{         * the EOF element. */}
00686         \textcolor{keywordflow}{if} (!ele && dst[0] == \hyperlink{listpack_8c_aa11b422dc597c4352da2abf522692774}{LP\_EOF}) *newp = NULL;
00687     \}
00688     \textcolor{keywordflow}{if} (ele) \{
00689         \textcolor{keywordflow}{if} (enctype == \hyperlink{listpack_8c_a6f31184b7647732d04b0518b59261b62}{LP\_ENCODING\_INT}) \{
00690             memcpy(dst,intenc,enclen);
00691         \} \textcolor{keywordflow}{else} \{
00692             lpEncodeString(dst,ele,size);
00693         \}
00694         dst += enclen;
00695         memcpy(dst,backlen,backlen\_size);
00696         dst += backlen\_size;
00697     \}
00698 
00699     \textcolor{comment}{/* Update header. */}
00700     \textcolor{keywordflow}{if} (where != \hyperlink{listpack_8h_a29d3b9a55d47053582a5025dd85d7fe6}{LP\_REPLACE} || ele == NULL) \{
00701         uint32\_t num\_elements = \hyperlink{listpack_8c_a6c5657a15231eb538939e10677c8ef1f}{lpGetNumElements}(lp);
00702         \textcolor{keywordflow}{if} (num\_elements != \hyperlink{listpack_8c_aabaec596aac6d7d8370b7d801638b022}{LP\_HDR\_NUMELE\_UNKNOWN}) \{
00703             \textcolor{keywordflow}{if} (ele)
00704                 \hyperlink{listpack_8c_abd63c5b3f66f6d270759fa5e3c319ce8}{lpSetNumElements}(lp,num\_elements+1);
00705             \textcolor{keywordflow}{else}
00706                 \hyperlink{listpack_8c_abd63c5b3f66f6d270759fa5e3c319ce8}{lpSetNumElements}(lp,num\_elements-1);
00707         \}
00708     \}
00709     \hyperlink{listpack_8c_a08a4fb5c67c9c38aa657ba8773b7e1ab}{lpSetTotalBytes}(lp,new\_listpack\_bytes);
00710     \textcolor{keywordflow}{return} lp;
00711 \}
00712 
00713 \textcolor{comment}{/* Append the specified element 'ele' of lenght 'len' at the end of the}
00714 \textcolor{comment}{ * listpack. It is implemented in terms of lpInsert(), so the return value is}
00715 \textcolor{comment}{ * the same as lpInsert(). */}
00716 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lpAppend(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lp, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ele, uint32\_t size) \{
00717     uint64\_t listpack\_bytes = \hyperlink{listpack_8c_a18d79dc11f1002b8c367eab243912a36}{lpGetTotalBytes}(lp);
00718     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eofptr = lp + listpack\_bytes - 1;
00719     \textcolor{keywordflow}{return} lpInsert(lp,ele,size,eofptr,\hyperlink{listpack_8h_a64de9ded0fe5ccb80bc2bc9fb8c6c3b2}{LP\_BEFORE},NULL);
00720 \}
00721 
00722 \textcolor{comment}{/* Remove the element pointed by 'p', and return the resulting listpack.}
00723 \textcolor{comment}{ * If 'newp' is not NULL, the next element pointer (to the right of the}
00724 \textcolor{comment}{ * deleted one) is returned by reference. If the deleted element was the}
00725 \textcolor{comment}{ * last one, '*newp' is set to NULL. */}
00726 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lpDelete(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lp, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **newp) \{
00727     \textcolor{keywordflow}{return} lpInsert(lp,NULL,0,p,\hyperlink{listpack_8h_a29d3b9a55d47053582a5025dd85d7fe6}{LP\_REPLACE},newp);
00728 \}
00729 
00730 \textcolor{comment}{/* Return the total number of bytes the listpack is composed of. */}
00731 uint32\_t lpBytes(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lp) \{
00732     \textcolor{keywordflow}{return} \hyperlink{listpack_8c_a18d79dc11f1002b8c367eab243912a36}{lpGetTotalBytes}(lp);
00733 \}
00734 
00735 \textcolor{comment}{/* Seek the specified element and returns the pointer to the seeked element.}
00736 \textcolor{comment}{ * Positive indexes specify the zero-based element to seek from the head to}
00737 \textcolor{comment}{ * the tail, negative indexes specify elements starting from the tail, where}
00738 \textcolor{comment}{ * -1 means the last element, -2 the penultimate and so forth. If the index}
00739 \textcolor{comment}{ * is out of range, NULL is returned. */}
00740 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lpSeek(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lp, \textcolor{keywordtype}{long} index) \{
00741     \textcolor{keywordtype}{int} forward = 1; \textcolor{comment}{/* Seek forward by default. */}
00742 
00743     \textcolor{comment}{/* We want to seek from left to right or the other way around}
00744 \textcolor{comment}{     * depending on the listpack length and the element position.}
00745 \textcolor{comment}{     * However if the listpack length cannot be obtained in constant time,}
00746 \textcolor{comment}{     * we always seek from left to right. */}
00747     uint32\_t numele = \hyperlink{listpack_8c_a6c5657a15231eb538939e10677c8ef1f}{lpGetNumElements}(lp);
00748     \textcolor{keywordflow}{if} (numele != \hyperlink{listpack_8c_aabaec596aac6d7d8370b7d801638b022}{LP\_HDR\_NUMELE\_UNKNOWN}) \{
00749         \textcolor{keywordflow}{if} (index < 0) index = (\textcolor{keywordtype}{long})numele+index;
00750         \textcolor{keywordflow}{if} (index < 0) \textcolor{keywordflow}{return} NULL; \textcolor{comment}{/* Index still < 0 means out of range. */}
00751         \textcolor{keywordflow}{if} (index >= numele) \textcolor{keywordflow}{return} NULL; \textcolor{comment}{/* Out of range the other side. */}
00752         \textcolor{comment}{/* We want to scan right-to-left if the element we are looking for}
00753 \textcolor{comment}{         * is past the half of the listpack. */}
00754         \textcolor{keywordflow}{if} (index > numele/2) \{
00755             forward = 0;
00756             \textcolor{comment}{/* Left to right scanning always expects a negative index. Convert}
00757 \textcolor{comment}{             * our index to negative form. */}
00758             index -= numele;
00759         \}
00760     \} \textcolor{keywordflow}{else} \{
00761         \textcolor{comment}{/* If the listpack length is unspecified, for negative indexes we}
00762 \textcolor{comment}{         * want to always scan left-to-right. */}
00763         \textcolor{keywordflow}{if} (index < 0) forward = 0;
00764     \}
00765 
00766     \textcolor{comment}{/* Forward and backward scanning is trivially based on lpNext()/lpPrev(). */}
00767     \textcolor{keywordflow}{if} (forward) \{
00768         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ele = lpFirst(lp);
00769         \textcolor{keywordflow}{while} (index > 0 && ele) \{
00770             ele = lpNext(lp,ele);
00771             index--;
00772         \}
00773         \textcolor{keywordflow}{return} ele;
00774     \} \textcolor{keywordflow}{else} \{
00775         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ele = lpLast(lp);
00776         \textcolor{keywordflow}{while} (index < -1 && ele) \{
00777             ele = lpPrev(lp,ele);
00778             index++;
00779         \}
00780         \textcolor{keywordflow}{return} ele;
00781     \}
00782 \}
\end{DoxyCode}
