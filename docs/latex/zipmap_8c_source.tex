\hypertarget{zipmap_8c_source}{}\section{zipmap.\+c}
\label{zipmap_8c_source}\index{src/zipmap.\+c@{src/zipmap.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* String -> String Map data structure optimized for size.}
00002 \textcolor{comment}{ * This file implements a data structure mapping strings to other strings}
00003 \textcolor{comment}{ * implementing an O(n) lookup data structure designed to be very memory}
00004 \textcolor{comment}{ * efficient.}
00005 \textcolor{comment}{ *}
00006 \textcolor{comment}{ * The Redis Hash type uses this data structure for hashes composed of a small}
00007 \textcolor{comment}{ * number of elements, to switch to a hash table once a given number of}
00008 \textcolor{comment}{ * elements is reached.}
00009 \textcolor{comment}{ *}
00010 \textcolor{comment}{ * Given that many times Redis Hashes are used to represent objects composed}
00011 \textcolor{comment}{ * of few fields, this is a very big win in terms of used memory.}
00012 \textcolor{comment}{ *}
00013 \textcolor{comment}{ * --------------------------------------------------------------------------}
00014 \textcolor{comment}{ *}
00015 \textcolor{comment}{ * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>}
00016 \textcolor{comment}{ * All rights reserved.}
00017 \textcolor{comment}{ *}
00018 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00019 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00020 \textcolor{comment}{ *}
00021 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00022 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00023 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00024 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00025 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00026 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00027 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00028 \textcolor{comment}{ *     specific prior written permission.}
00029 \textcolor{comment}{ *}
00030 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00031 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00032 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00033 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00034 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00035 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00036 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00037 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00038 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00039 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00040 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00041 \textcolor{comment}{ */}
00042 
00043 \textcolor{comment}{/* Memory layout of a zipmap, for the map "foo" => "bar", "hello" => "world":}
00044 \textcolor{comment}{ *}
00045 \textcolor{comment}{ * <zmlen><len>"foo"<len><free>"bar"<len>"hello"<len><free>"world"}
00046 \textcolor{comment}{ *}
00047 \textcolor{comment}{ * <zmlen> is 1 byte length that holds the current size of the zipmap.}
00048 \textcolor{comment}{ * When the zipmap length is greater than or equal to 254, this value}
00049 \textcolor{comment}{ * is not used and the zipmap needs to be traversed to find out the length.}
00050 \textcolor{comment}{ *}
00051 \textcolor{comment}{ * <len> is the length of the following string (key or value).}
00052 \textcolor{comment}{ * <len> lengths are encoded in a single value or in a 5 bytes value.}
00053 \textcolor{comment}{ * If the first byte value (as an unsigned 8 bit value) is between 0 and}
00054 \textcolor{comment}{ * 253, it's a single-byte length. If it is 254 then a four bytes unsigned}
00055 \textcolor{comment}{ * integer follows (in the host byte ordering). A value of 255 is used to}
00056 \textcolor{comment}{ * signal the end of the hash.}
00057 \textcolor{comment}{ *}
00058 \textcolor{comment}{ * <free> is the number of free unused bytes after the string, resulting}
00059 \textcolor{comment}{ * from modification of values associated to a key. For instance if "foo"}
00060 \textcolor{comment}{ * is set to "bar", and later "foo" will be set to "hi", it will have a}
00061 \textcolor{comment}{ * free byte to use if the value will enlarge again later, or even in}
00062 \textcolor{comment}{ * order to add a key/value pair if it fits.}
00063 \textcolor{comment}{ *}
00064 \textcolor{comment}{ * <free> is always an unsigned 8 bit number, because if after an}
00065 \textcolor{comment}{ * update operation there are more than a few free bytes, the zipmap will be}
00066 \textcolor{comment}{ * reallocated to make sure it is as small as possible.}
00067 \textcolor{comment}{ *}
00068 \textcolor{comment}{ * The most compact representation of the above two elements hash is actually:}
00069 \textcolor{comment}{ *}
00070 \textcolor{comment}{ * "\(\backslash\)x02\(\backslash\)x03foo\(\backslash\)x03\(\backslash\)x00bar\(\backslash\)x05hello\(\backslash\)x05\(\backslash\)x00world\(\backslash\)xff"}
00071 \textcolor{comment}{ *}
00072 \textcolor{comment}{ * Note that because keys and values are prefixed length "objects",}
00073 \textcolor{comment}{ * the lookup will take O(N) where N is the number of elements}
00074 \textcolor{comment}{ * in the zipmap and *not* the number of bytes needed to represent the zipmap.}
00075 \textcolor{comment}{ * This lowers the constant times considerably.}
00076 \textcolor{comment}{ */}
00077 
00078 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdio}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00079 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{string}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00080 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{zmalloc_8h}{"zmalloc.h"}
00081 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{endianconv_8h}{"endianconv.h"}
00082 
00083 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIPMAP\_BIGLEN} 254
00084 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIPMAP\_END} 255
00085 
00086 \textcolor{comment}{/* The following defines the max value for the <free> field described in the}
00087 \textcolor{comment}{ * comments above, that is, the max number of trailing bytes in a value. */}
00088 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIPMAP\_VALUE\_MAX\_FREE} 4
00089 
00090 \textcolor{comment}{/* The following macro returns the number of bytes needed to encode the length}
00091 \textcolor{comment}{ * for the integer value \_l, that is, 1 byte for lengths < ZIPMAP\_BIGLEN and}
00092 \textcolor{comment}{ * 5 bytes for all the other lengths. */}
00093 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIPMAP\_LEN\_BYTES}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_l}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_l}\textcolor{preprocessor}{)} \textcolor{preprocessor}{<} \hyperlink{zipmap_8c_a1173592dbfaa84c6b2419d0a699c97f5}{ZIPMAP\_BIGLEN}\textcolor{preprocessor}{)} \textcolor{preprocessor}{?} 1 \textcolor{preprocessor}{:} \textcolor{keyword}{sizeof}\textcolor{preprocessor}{(}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{preprocessor}{)}\textcolor{preprocessor}{+}1\textcolor{preprocessor}{)}
00094 
00095 \textcolor{comment}{/* Create a new empty zipmap. */}
00096 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zipmapNew(\textcolor{keywordtype}{void}) \{
00097     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zm = zmalloc(2);
00098 
00099     zm[0] = 0; \textcolor{comment}{/* Length */}
00100     zm[1] = \hyperlink{zipmap_8c_a7074100d2ecc0c8971936a4edc208782}{ZIPMAP\_END};
00101     \textcolor{keywordflow}{return} zm;
00102 \}
00103 
00104 \textcolor{comment}{/* Decode the encoded length pointed by 'p' */}
00105 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} zipmapDecodeLength(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p) \{
00106     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len = *p;
00107 
00108     \textcolor{keywordflow}{if} (len < \hyperlink{zipmap_8c_a1173592dbfaa84c6b2419d0a699c97f5}{ZIPMAP\_BIGLEN}) \textcolor{keywordflow}{return} len;
00109     memcpy(&len,p+1,\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));
00110     \hyperlink{endianconv_8h_a771f3656eb7d11a1e7f7294b657d8978}{memrev32ifbe}(&len);
00111     \textcolor{keywordflow}{return} len;
00112 \}
00113 
00114 \textcolor{comment}{/* Encode the length 'l' writing it in 'p'. If p is NULL it just returns}
00115 \textcolor{comment}{ * the amount of bytes required to encode such a length. */}
00116 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} zipmapEncodeLength(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len) \{
00117     \textcolor{keywordflow}{if} (p == NULL) \{
00118         \textcolor{keywordflow}{return} \hyperlink{zipmap_8c_a3e2d7a4d7208d88fc1b254a2da9bec13}{ZIPMAP\_LEN\_BYTES}(len);
00119     \} \textcolor{keywordflow}{else} \{
00120         \textcolor{keywordflow}{if} (len < \hyperlink{zipmap_8c_a1173592dbfaa84c6b2419d0a699c97f5}{ZIPMAP\_BIGLEN}) \{
00121             p[0] = len;
00122             \textcolor{keywordflow}{return} 1;
00123         \} \textcolor{keywordflow}{else} \{
00124             p[0] = \hyperlink{zipmap_8c_a1173592dbfaa84c6b2419d0a699c97f5}{ZIPMAP\_BIGLEN};
00125             memcpy(p+1,&len,\textcolor{keyword}{sizeof}(len));
00126             \hyperlink{endianconv_8h_a771f3656eb7d11a1e7f7294b657d8978}{memrev32ifbe}(p+1);
00127             \textcolor{keywordflow}{return} 1+\textcolor{keyword}{sizeof}(len);
00128         \}
00129     \}
00130 \}
00131 
00132 \textcolor{comment}{/* Search for a matching key, returning a pointer to the entry inside the}
00133 \textcolor{comment}{ * zipmap. Returns NULL if the key is not found.}
00134 \textcolor{comment}{ *}
00135 \textcolor{comment}{ * If NULL is returned, and totlen is not NULL, it is set to the entire}
00136 \textcolor{comment}{ * size of the zimap, so that the calling function will be able to}
00137 \textcolor{comment}{ * reallocate the original zipmap to make room for more entries. */}
00138 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zipmapLookupRaw(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zm, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *key, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} klen, \textcolor{keywordtype}{
      unsigned} \textcolor{keywordtype}{int} *totlen) \{
00139     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p = zm+1, *k = NULL;
00140     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l,llen;
00141 
00142     \textcolor{keywordflow}{while}(*p != \hyperlink{zipmap_8c_a7074100d2ecc0c8971936a4edc208782}{ZIPMAP\_END}) \{
00143         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} free;
00144 
00145         \textcolor{comment}{/* Match or skip the key */}
00146         l = zipmapDecodeLength(p);
00147         llen = zipmapEncodeLength(NULL,l);
00148         \textcolor{keywordflow}{if} (key != NULL && k == NULL && l == klen && !memcmp(p+llen,key,l)) \{
00149             \textcolor{comment}{/* Only return when the user doesn't care}
00150 \textcolor{comment}{             * for the total length of the zipmap. */}
00151             \textcolor{keywordflow}{if} (totlen != NULL) \{
00152                 k = p;
00153             \} \textcolor{keywordflow}{else} \{
00154                 \textcolor{keywordflow}{return} p;
00155             \}
00156         \}
00157         p += llen+l;
00158         \textcolor{comment}{/* Skip the value as well */}
00159         l = zipmapDecodeLength(p);
00160         p += zipmapEncodeLength(NULL,l);
00161         free = p[0];
00162         p += l+1+free; \textcolor{comment}{/* +1 to skip the free byte */}
00163     \}
00164     \textcolor{keywordflow}{if} (totlen != NULL) *totlen = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})(p-zm)+1;
00165     \textcolor{keywordflow}{return} k;
00166 \}
00167 
00168 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} zipmapRequiredLength(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} klen, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen) \{
00169     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l;
00170 
00171     l = klen+vlen+3;
00172     \textcolor{keywordflow}{if} (klen >= \hyperlink{zipmap_8c_a1173592dbfaa84c6b2419d0a699c97f5}{ZIPMAP\_BIGLEN}) l += 4;
00173     \textcolor{keywordflow}{if} (vlen >= \hyperlink{zipmap_8c_a1173592dbfaa84c6b2419d0a699c97f5}{ZIPMAP\_BIGLEN}) l += 4;
00174     \textcolor{keywordflow}{return} l;
00175 \}
00176 
00177 \textcolor{comment}{/* Return the total amount used by a key (encoded length + payload) */}
00178 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} zipmapRawKeyLength(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p) \{
00179     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l = zipmapDecodeLength(p);
00180     \textcolor{keywordflow}{return} zipmapEncodeLength(NULL,l) + l;
00181 \}
00182 
00183 \textcolor{comment}{/* Return the total amount used by a value}
00184 \textcolor{comment}{ * (encoded length + single byte free count + payload) */}
00185 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} zipmapRawValueLength(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p) \{
00186     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l = zipmapDecodeLength(p);
00187     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} used;
00188 
00189     used = zipmapEncodeLength(NULL,l);
00190     used += p[used] + 1 + l;
00191     \textcolor{keywordflow}{return} used;
00192 \}
00193 
00194 \textcolor{comment}{/* If 'p' points to a key, this function returns the total amount of}
00195 \textcolor{comment}{ * bytes used to store this entry (entry = key + associated value + trailing}
00196 \textcolor{comment}{ * free space if any). */}
00197 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} zipmapRawEntryLength(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p) \{
00198     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l = zipmapRawKeyLength(p);
00199     \textcolor{keywordflow}{return} l + zipmapRawValueLength(p+l);
00200 \}
00201 
00202 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zipmapResize(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zm, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len) \{
00203     zm = zrealloc(zm, len);
00204     zm[len-1] = \hyperlink{zipmap_8c_a7074100d2ecc0c8971936a4edc208782}{ZIPMAP\_END};
00205     \textcolor{keywordflow}{return} zm;
00206 \}
00207 
00208 \textcolor{comment}{/* Set key to value, creating the key if it does not already exist.}
00209 \textcolor{comment}{ * If 'update' is not NULL, *update is set to 1 if the key was}
00210 \textcolor{comment}{ * already preset, otherwise to 0. */}
00211 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zipmapSet(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zm, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *key, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} klen, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *val,
       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen, \textcolor{keywordtype}{int} *update) \{
00212     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} zmlen, offset;
00213     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} freelen, reqlen = zipmapRequiredLength(klen,vlen);
00214     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} empty, vempty;
00215     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p;
00216 
00217     freelen = reqlen;
00218     \textcolor{keywordflow}{if} (update) *update = 0;
00219     p = zipmapLookupRaw(zm,key,klen,&zmlen);
00220     \textcolor{keywordflow}{if} (p == NULL) \{
00221         \textcolor{comment}{/* Key not found: enlarge */}
00222         zm = zipmapResize(zm, zmlen+reqlen);
00223         p = zm+zmlen-1;
00224         zmlen = zmlen+reqlen;
00225 
00226         \textcolor{comment}{/* Increase zipmap length (this is an insert) */}
00227         \textcolor{keywordflow}{if} (zm[0] < \hyperlink{zipmap_8c_a1173592dbfaa84c6b2419d0a699c97f5}{ZIPMAP\_BIGLEN}) zm[0]++;
00228     \} \textcolor{keywordflow}{else} \{
00229         \textcolor{comment}{/* Key found. Is there enough space for the new value? */}
00230         \textcolor{comment}{/* Compute the total length: */}
00231         \textcolor{keywordflow}{if} (update) *update = 1;
00232         freelen = zipmapRawEntryLength(p);
00233         \textcolor{keywordflow}{if} (freelen < reqlen) \{
00234             \textcolor{comment}{/* Store the offset of this key within the current zipmap, so}
00235 \textcolor{comment}{             * it can be resized. Then, move the tail backwards so this}
00236 \textcolor{comment}{             * pair fits at the current position. */}
00237             offset = p-zm;
00238             zm = zipmapResize(zm, zmlen-freelen+reqlen);
00239             p = zm+offset;
00240 
00241             \textcolor{comment}{/* The +1 in the number of bytes to be moved is caused by the}
00242 \textcolor{comment}{             * end-of-zipmap byte. Note: the *original* zmlen is used. */}
00243             memmove(p+reqlen, p+freelen, zmlen-(offset+freelen+1));
00244             zmlen = zmlen-freelen+reqlen;
00245             freelen = reqlen;
00246         \}
00247     \}
00248 
00249     \textcolor{comment}{/* We now have a suitable block where the key/value entry can}
00250 \textcolor{comment}{     * be written. If there is too much free space, move the tail}
00251 \textcolor{comment}{     * of the zipmap a few bytes to the front and shrink the zipmap,}
00252 \textcolor{comment}{     * as we want zipmaps to be very space efficient. */}
00253     empty = freelen-reqlen;
00254     \textcolor{keywordflow}{if} (empty >= \hyperlink{zipmap_8c_a6c9247ef956b971a52b9d265083e6990}{ZIPMAP\_VALUE\_MAX\_FREE}) \{
00255         \textcolor{comment}{/* First, move the tail <empty> bytes to the front, then resize}
00256 \textcolor{comment}{         * the zipmap to be <empty> bytes smaller. */}
00257         offset = p-zm;
00258         memmove(p+reqlen, p+freelen, zmlen-(offset+freelen+1));
00259         zmlen -= empty;
00260         zm = zipmapResize(zm, zmlen);
00261         p = zm+offset;
00262         vempty = 0;
00263     \} \textcolor{keywordflow}{else} \{
00264         vempty = empty;
00265     \}
00266 
00267     \textcolor{comment}{/* Just write the key + value and we are done. */}
00268     \textcolor{comment}{/* Key: */}
00269     p += zipmapEncodeLength(p,klen);
00270     memcpy(p,key,klen);
00271     p += klen;
00272     \textcolor{comment}{/* Value: */}
00273     p += zipmapEncodeLength(p,vlen);
00274     *p++ = vempty;
00275     memcpy(p,val,vlen);
00276     \textcolor{keywordflow}{return} zm;
00277 \}
00278 
00279 \textcolor{comment}{/* Remove the specified key. If 'deleted' is not NULL the pointed integer is}
00280 \textcolor{comment}{ * set to 0 if the key was not found, to 1 if it was found and deleted. */}
00281 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zipmapDel(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zm, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *key, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} klen, \textcolor{keywordtype}{int} *deleted) \{
00282     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} zmlen, freelen;
00283     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p = zipmapLookupRaw(zm,key,klen,&zmlen);
00284     \textcolor{keywordflow}{if} (p) \{
00285         freelen = zipmapRawEntryLength(p);
00286         memmove(p, p+freelen, zmlen-((p-zm)+freelen+1));
00287         zm = zipmapResize(zm, zmlen-freelen);
00288 
00289         \textcolor{comment}{/* Decrease zipmap length */}
00290         \textcolor{keywordflow}{if} (zm[0] < \hyperlink{zipmap_8c_a1173592dbfaa84c6b2419d0a699c97f5}{ZIPMAP\_BIGLEN}) zm[0]--;
00291 
00292         \textcolor{keywordflow}{if} (deleted) *deleted = 1;
00293     \} \textcolor{keywordflow}{else} \{
00294         \textcolor{keywordflow}{if} (deleted) *deleted = 0;
00295     \}
00296     \textcolor{keywordflow}{return} zm;
00297 \}
00298 
00299 \textcolor{comment}{/* Call before iterating through elements via zipmapNext() */}
00300 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zipmapRewind(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zm) \{
00301     \textcolor{keywordflow}{return} zm+1;
00302 \}
00303 
00304 \textcolor{comment}{/* This function is used to iterate through all the zipmap elements.}
00305 \textcolor{comment}{ * In the first call the first argument is the pointer to the zipmap + 1.}
00306 \textcolor{comment}{ * In the next calls what zipmapNext returns is used as first argument.}
00307 \textcolor{comment}{ * Example:}
00308 \textcolor{comment}{ *}
00309 \textcolor{comment}{ * unsigned char *i = zipmapRewind(my\_zipmap);}
00310 \textcolor{comment}{ * while((i = zipmapNext(i,&key,&klen,&value,&vlen)) != NULL) \{}
00311 \textcolor{comment}{ *     printf("%d bytes key at $p\(\backslash\)n", klen, key);}
00312 \textcolor{comment}{ *     printf("%d bytes value at $p\(\backslash\)n", vlen, value);}
00313 \textcolor{comment}{ * \}}
00314 \textcolor{comment}{ */}
00315 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zipmapNext(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zm, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **key, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *klen, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **
      value, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *vlen) \{
00316     \textcolor{keywordflow}{if} (zm[0] == \hyperlink{zipmap_8c_a7074100d2ecc0c8971936a4edc208782}{ZIPMAP\_END}) \textcolor{keywordflow}{return} NULL;
00317     \textcolor{keywordflow}{if} (key) \{
00318         *key = zm;
00319         *klen = zipmapDecodeLength(zm);
00320         *key += \hyperlink{zipmap_8c_a3e2d7a4d7208d88fc1b254a2da9bec13}{ZIPMAP\_LEN\_BYTES}(*klen);
00321     \}
00322     zm += zipmapRawKeyLength(zm);
00323     \textcolor{keywordflow}{if} (value) \{
00324         *value = zm+1;
00325         *vlen = zipmapDecodeLength(zm);
00326         *value += \hyperlink{zipmap_8c_a3e2d7a4d7208d88fc1b254a2da9bec13}{ZIPMAP\_LEN\_BYTES}(*vlen);
00327     \}
00328     zm += zipmapRawValueLength(zm);
00329     \textcolor{keywordflow}{return} zm;
00330 \}
00331 
00332 \textcolor{comment}{/* Search a key and retrieve the pointer and len of the associated value.}
00333 \textcolor{comment}{ * If the key is found the function returns 1, otherwise 0. */}
00334 \textcolor{keywordtype}{int} zipmapGet(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zm, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *key, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} klen, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **value, \textcolor{keywordtype}{
      unsigned} \textcolor{keywordtype}{int} *vlen) \{
00335     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p;
00336 
00337     \textcolor{keywordflow}{if} ((p = zipmapLookupRaw(zm,key,klen,NULL)) == NULL) \textcolor{keywordflow}{return} 0;
00338     p += zipmapRawKeyLength(p);
00339     *vlen = zipmapDecodeLength(p);
00340     *value = p + \hyperlink{zipmap_8c_a3e2d7a4d7208d88fc1b254a2da9bec13}{ZIPMAP\_LEN\_BYTES}(*vlen) + 1;
00341     \textcolor{keywordflow}{return} 1;
00342 \}
00343 
00344 \textcolor{comment}{/* Return 1 if the key exists, otherwise 0 is returned. */}
00345 \textcolor{keywordtype}{int} zipmapExists(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zm, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *key, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} klen) \{
00346     \textcolor{keywordflow}{return} zipmapLookupRaw(zm,key,klen,NULL) != NULL;
00347 \}
00348 
00349 \textcolor{comment}{/* Return the number of entries inside a zipmap */}
00350 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} zipmapLen(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zm) \{
00351     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len = 0;
00352     \textcolor{keywordflow}{if} (zm[0] < \hyperlink{zipmap_8c_a1173592dbfaa84c6b2419d0a699c97f5}{ZIPMAP\_BIGLEN}) \{
00353         len = zm[0];
00354     \} \textcolor{keywordflow}{else} \{
00355         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p = zipmapRewind(zm);
00356         \textcolor{keywordflow}{while}((p = zipmapNext(p,NULL,NULL,NULL,NULL)) != NULL) len++;
00357 
00358         \textcolor{comment}{/* Re-store length if small enough */}
00359         \textcolor{keywordflow}{if} (len < \hyperlink{zipmap_8c_a1173592dbfaa84c6b2419d0a699c97f5}{ZIPMAP\_BIGLEN}) zm[0] = len;
00360     \}
00361     \textcolor{keywordflow}{return} len;
00362 \}
00363 
00364 \textcolor{comment}{/* Return the raw size in bytes of a zipmap, so that we can serialize}
00365 \textcolor{comment}{ * the zipmap on disk (or everywhere is needed) just writing the returned}
00366 \textcolor{comment}{ * amount of bytes of the C array starting at the zipmap pointer. */}
00367 size\_t zipmapBlobLen(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zm) \{
00368     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} totlen;
00369     zipmapLookupRaw(zm,NULL,0,&totlen);
00370     \textcolor{keywordflow}{return} totlen;
00371 \}
00372 
00373 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \textcolor{preprocessor}{REDIS\_TEST}
00374 \textcolor{keyword}{static} \textcolor{keywordtype}{void} zipmapRepr(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p) \{
00375     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l;
00376 
00377     printf(\textcolor{stringliteral}{"\{status %u\}"},*p++);
00378     \textcolor{keywordflow}{while}(1) \{
00379         \textcolor{keywordflow}{if} (p[0] == ZIPMAP\_END) \{
00380             printf(\textcolor{stringliteral}{"\{end\}"});
00381             \textcolor{keywordflow}{break};
00382         \} \textcolor{keywordflow}{else} \{
00383             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} e;
00384 
00385             l = zipmapDecodeLength(p);
00386             printf(\textcolor{stringliteral}{"\{key %u\}"},l);
00387             p += zipmapEncodeLength(NULL,l);
00388             \textcolor{keywordflow}{if} (l != 0 && fwrite(p,l,1,stdout) == 0) perror(\textcolor{stringliteral}{"fwrite"});
00389             p += l;
00390 
00391             l = zipmapDecodeLength(p);
00392             printf(\textcolor{stringliteral}{"\{value %u\}"},l);
00393             p += zipmapEncodeLength(NULL,l);
00394             e = *p++;
00395             \textcolor{keywordflow}{if} (l != 0 && fwrite(p,l,1,stdout) == 0) perror(\textcolor{stringliteral}{"fwrite"});
00396             p += l+e;
00397             \textcolor{keywordflow}{if} (e) \{
00398                 printf(\textcolor{stringliteral}{"["});
00399                 \textcolor{keywordflow}{while}(e--) printf(\textcolor{stringliteral}{"."});
00400                 printf(\textcolor{stringliteral}{"]"});
00401             \}
00402         \}
00403     \}
00404     printf(\textcolor{stringliteral}{"\(\backslash\)n"});
00405 \}
00406 
00407 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{UNUSED}\textcolor{preprocessor}{(}\textcolor{preprocessor}{x}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{void}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{preprocessor}{x}\textcolor{preprocessor}{)}
00408 \textcolor{keywordtype}{int} zipmapTest(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[]) \{
00409     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zm;
00410 
00411     UNUSED(argc);
00412     UNUSED(argv);
00413 
00414     zm = zipmapNew();
00415 
00416     zm = zipmapSet(zm,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"name"},4, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"foo"},3,NULL);
00417     zm = zipmapSet(zm,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"surname"},7, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"foo"},3,NULL);
00418     zm = zipmapSet(zm,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"age"},3, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"foo"},3,NULL);
00419     zipmapRepr(zm);
00420 
00421     zm = zipmapSet(zm,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"hello"},5, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"world!"},6,NULL);
00422     zm = zipmapSet(zm,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"foo"},3, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"bar"},3,NULL);
00423     zm = zipmapSet(zm,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"foo"},3, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"!"},1,NULL);
00424     zipmapRepr(zm);
00425     zm = zipmapSet(zm,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"foo"},3, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"12345"},5,NULL);
00426     zipmapRepr(zm);
00427     zm = zipmapSet(zm,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"new"},3, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"xx"},2,NULL);
00428     zm = zipmapSet(zm,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"noval"},5, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{""},0,NULL);
00429     zipmapRepr(zm);
00430     zm = zipmapDel(zm,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"new"},3,NULL);
00431     zipmapRepr(zm);
00432 
00433     printf(\textcolor{stringliteral}{"\(\backslash\)nLook up large key:\(\backslash\)n"});
00434     \{
00435         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[512];
00436         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *value;
00437         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen, i;
00438         \textcolor{keywordflow}{for} (i = 0; i < 512; i++) buf[i] = \textcolor{stringliteral}{'a'};
00439 
00440         zm = zipmapSet(zm,buf,512,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"long"},4,NULL);
00441         \textcolor{keywordflow}{if} (zipmapGet(zm,buf,512,&value,&vlen)) \{
00442             printf(\textcolor{stringliteral}{"  <long key> is associated to the %d bytes value: %.*s\(\backslash\)n"},
00443                 vlen, vlen, value);
00444         \}
00445     \}
00446 
00447     printf(\textcolor{stringliteral}{"\(\backslash\)nPerform a direct lookup:\(\backslash\)n"});
00448     \{
00449         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *value;
00450         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen;
00451 
00452         \textcolor{keywordflow}{if} (zipmapGet(zm,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) \textcolor{stringliteral}{"foo"},3,&value,&vlen)) \{
00453             printf(\textcolor{stringliteral}{"  foo is associated to the %d bytes value: %.*s\(\backslash\)n"},
00454                 vlen, vlen, value);
00455         \}
00456     \}
00457     printf(\textcolor{stringliteral}{"\(\backslash\)nIterate through elements:\(\backslash\)n"});
00458     \{
00459         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *i = zipmapRewind(zm);
00460         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *key, *value;
00461         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} klen, vlen;
00462 
00463         \textcolor{keywordflow}{while}((i = zipmapNext(i,&key,&klen,&value,&vlen)) != NULL) \{
00464             printf(\textcolor{stringliteral}{"  %d:%.*s => %d:%.*s\(\backslash\)n"}, klen, klen, key, vlen, vlen, value);
00465         \}
00466     \}
00467     \textcolor{keywordflow}{return} 0;
00468 \}
00469 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
\end{DoxyCode}
