\hypertarget{blocked_8c_source}{}\section{blocked.\+c}
\label{blocked_8c_source}\index{src/blocked.\+c@{src/blocked.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* blocked.c - generic support for blocking operations like BLPOP & WAIT.}
00002 \textcolor{comment}{ *}
00003 \textcolor{comment}{ * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>}
00004 \textcolor{comment}{ * All rights reserved.}
00005 \textcolor{comment}{ *}
00006 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00007 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00008 \textcolor{comment}{ *}
00009 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00010 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00011 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00012 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00013 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00014 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00015 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00016 \textcolor{comment}{ *     specific prior written permission.}
00017 \textcolor{comment}{ *}
00018 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00019 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00020 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00021 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00022 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00023 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00024 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00025 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00026 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00027 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00028 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00029 \textcolor{comment}{ *}
00030 \textcolor{comment}{ * ---------------------------------------------------------------------------}
00031 \textcolor{comment}{ *}
00032 \textcolor{comment}{ * API:}
00033 \textcolor{comment}{ *}
00034 \textcolor{comment}{ * getTimeoutFromObjectOrReply() is just an utility function to parse a}
00035 \textcolor{comment}{ * timeout argument since blocking operations usually require a timeout.}
00036 \textcolor{comment}{ *}
00037 \textcolor{comment}{ * blockClient() set the CLIENT\_BLOCKED flag in the client, and set the}
00038 \textcolor{comment}{ * specified block type 'btype' filed to one of BLOCKED\_* macros.}
00039 \textcolor{comment}{ *}
00040 \textcolor{comment}{ * unblockClient() unblocks the client doing the following:}
00041 \textcolor{comment}{ * 1) It calls the btype-specific function to cleanup the state.}
00042 \textcolor{comment}{ * 2) It unblocks the client by unsetting the CLIENT\_BLOCKED flag.}
00043 \textcolor{comment}{ * 3) It puts the client into a list of just unblocked clients that are}
00044 \textcolor{comment}{ *    processed ASAP in the beforeSleep() event loop callback, so that}
00045 \textcolor{comment}{ *    if there is some query buffer to process, we do it. This is also}
00046 \textcolor{comment}{ *    required because otherwise there is no 'readable' event fired, we}
00047 \textcolor{comment}{ *    already read the pending commands. We also set the CLIENT\_UNBLOCKED}
00048 \textcolor{comment}{ *    flag to remember the client is in the unblocked\_clients list.}
00049 \textcolor{comment}{ *}
00050 \textcolor{comment}{ * processUnblockedClients() is called inside the beforeSleep() function}
00051 \textcolor{comment}{ * to process the query buffer from unblocked clients and remove the clients}
00052 \textcolor{comment}{ * from the blocked\_clients queue.}
00053 \textcolor{comment}{ *}
00054 \textcolor{comment}{ * replyToBlockedClientTimedOut() is called by the cron function when}
00055 \textcolor{comment}{ * a client blocked reaches the specified timeout (if the timeout is set}
00056 \textcolor{comment}{ * to 0, no timeout is processed).}
00057 \textcolor{comment}{ * It usually just needs to send a reply to the client.}
00058 \textcolor{comment}{ *}
00059 \textcolor{comment}{ * When implementing a new type of blocking opeation, the implementation}
00060 \textcolor{comment}{ * should modify unblockClient() and replyToBlockedClientTimedOut() in order}
00061 \textcolor{comment}{ * to handle the btype-specific behavior of this two functions.}
00062 \textcolor{comment}{ * If the blocking operation waits for certain keys to change state, the}
00063 \textcolor{comment}{ * clusterRedirectBlockedClientIfNeeded() function should also be updated.}
00064 \textcolor{comment}{ */}
00065 
00066 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{server_8h}{"server.h"}
00067 
00068 \textcolor{keywordtype}{int} serveClientBlockedOnList(\hyperlink{structclient}{client} *receiver, robj *key, robj *dstkey, redisDb *db, robj *value
      , \textcolor{keywordtype}{int} where);
00069 
00070 \textcolor{comment}{/* Get a timeout value from an object and store it into 'timeout'.}
00071 \textcolor{comment}{ * The final timeout is always stored as milliseconds as a time where the}
00072 \textcolor{comment}{ * timeout will expire, however the parsing is performed according to}
00073 \textcolor{comment}{ * the 'unit' that can be seconds or milliseconds.}
00074 \textcolor{comment}{ *}
00075 \textcolor{comment}{ * Note that if the timeout is zero (usually from the point of view of}
00076 \textcolor{comment}{ * commands API this means no timeout) the value stored into 'timeout'}
00077 \textcolor{comment}{ * is zero. */}
00078 \textcolor{keywordtype}{int} getTimeoutFromObjectOrReply(\hyperlink{structclient}{client} *c, robj *object, mstime\_t *timeout, \textcolor{keywordtype}{int} unit) \{
00079     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} tval;
00080 
00081     \textcolor{keywordflow}{if} (getLongLongFromObjectOrReply(c,object,&tval,
00082         \textcolor{stringliteral}{"timeout is not an integer or out of range"}) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
00083         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00084 
00085     \textcolor{keywordflow}{if} (tval < 0) \{
00086         addReplyError(c,\textcolor{stringliteral}{"timeout is negative"});
00087         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00088     \}
00089 
00090     \textcolor{keywordflow}{if} (tval > 0) \{
00091         \textcolor{keywordflow}{if} (unit == \hyperlink{server_8h_a8553b0a6c729b15594731a0d37b4fb0d}{UNIT\_SECONDS}) tval *= 1000;
00092         tval += mstime();
00093     \}
00094     *timeout = tval;
00095 
00096     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00097 \}
00098 
00099 \textcolor{comment}{/* Block a client for the specific operation type. Once the CLIENT\_BLOCKED}
00100 \textcolor{comment}{ * flag is set client query buffer is not longer processed, but accumulated,}
00101 \textcolor{comment}{ * and will be processed when the client is unblocked. */}
00102 \textcolor{keywordtype}{void} blockClient(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} btype) \{
00103     c->flags |= \hyperlink{server_8h_a503ad979164a52f0f5e2a63e4c7da3a0}{CLIENT\_BLOCKED};
00104     c->btype = btype;
00105     server.blocked\_clients++;
00106     server.blocked\_clients\_by\_type[btype]++;
00107 \}
00108 
00109 \textcolor{comment}{/* This function is called in the beforeSleep() function of the event loop}
00110 \textcolor{comment}{ * in order to process the pending input buffer of clients that were}
00111 \textcolor{comment}{ * unblocked after a blocking operation. */}
00112 \textcolor{keywordtype}{void} processUnblockedClients(\textcolor{keywordtype}{void}) \{
00113     listNode *ln;
00114     \hyperlink{structclient}{client} *c;
00115 
00116     \textcolor{keywordflow}{while} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.unblocked\_clients)) \{
00117         ln = \hyperlink{adlist_8h_aa8dc514bbe217bb2e87c1c77cfa84690}{listFirst}(server.unblocked\_clients);
00118         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(ln != NULL);
00119         c = ln->value;
00120         listDelNode(server.unblocked\_clients,ln);
00121         c->flags &= ~\hyperlink{server_8h_a1252372d6834686c29e958d9d96367a8}{CLIENT\_UNBLOCKED};
00122 
00123         \textcolor{comment}{/* Process remaining data in the input buffer, unless the client}
00124 \textcolor{comment}{         * is blocked again. Actually processInputBuffer() checks that the}
00125 \textcolor{comment}{         * client is not blocked before to proceed, but things may change and}
00126 \textcolor{comment}{         * the code is conceptually more correct this way. */}
00127         \textcolor{keywordflow}{if} (!(c->flags & \hyperlink{server_8h_a503ad979164a52f0f5e2a63e4c7da3a0}{CLIENT\_BLOCKED})) \{
00128             \textcolor{keywordflow}{if} (c->querybuf && sdslen(c->querybuf) > 0) \{
00129                 processInputBuffer(c);
00130             \}
00131         \}
00132     \}
00133 \}
00134 
00135 \textcolor{comment}{/* Unblock a client calling the right function depending on the kind}
00136 \textcolor{comment}{ * of operation the client is blocking for. */}
00137 \textcolor{keywordtype}{void} unblockClient(\hyperlink{structclient}{client} *c) \{
00138     \textcolor{keywordflow}{if} (c->btype == \hyperlink{server_8h_a279f6a31729ba24d6dab0944b82e0b55}{BLOCKED\_LIST} || c->btype == \hyperlink{server_8h_a1f48bb63f9d0c061421044b92b46f679}{BLOCKED\_STREAM}) \{
00139         unblockClientWaitingData(c);
00140     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->btype == \hyperlink{server_8h_accb912da92773eadb0b938af3fa95c63}{BLOCKED\_WAIT}) \{
00141         unblockClientWaitingReplicas(c);
00142     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->btype == \hyperlink{server_8h_a6bdaa78b1c4c376ebf666afb891ace42}{BLOCKED\_MODULE}) \{
00143         unblockClientFromModule(c);
00144     \} \textcolor{keywordflow}{else} \{
00145         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown btype in unblockClient()."});
00146     \}
00147     \textcolor{comment}{/* Clear the flags, and put the client in the unblocked list so that}
00148 \textcolor{comment}{     * we'll process new commands in its query buffer ASAP. */}
00149     server.blocked\_clients--;
00150     server.blocked\_clients\_by\_type[c->btype]--;
00151     c->flags &= ~\hyperlink{server_8h_a503ad979164a52f0f5e2a63e4c7da3a0}{CLIENT\_BLOCKED};
00152     c->btype = \hyperlink{server_8h_a89cf259b265c26cd1e09de67ade457dc}{BLOCKED\_NONE};
00153     \textcolor{comment}{/* The client may already be into the unblocked list because of a previous}
00154 \textcolor{comment}{     * blocking operation, don't add back it into the list multiple times. */}
00155     \textcolor{keywordflow}{if} (!(c->flags & \hyperlink{server_8h_a1252372d6834686c29e958d9d96367a8}{CLIENT\_UNBLOCKED})) \{
00156         c->flags |= \hyperlink{server_8h_a1252372d6834686c29e958d9d96367a8}{CLIENT\_UNBLOCKED};
00157         listAddNodeTail(server.unblocked\_clients,c);
00158     \}
00159 \}
00160 
00161 \textcolor{comment}{/* This function gets called when a blocked client timed out in order to}
00162 \textcolor{comment}{ * send it a reply of some kind. After this function is called,}
00163 \textcolor{comment}{ * unblockClient() will be called with the same client as argument. */}
00164 \textcolor{keywordtype}{void} replyToBlockedClientTimedOut(\hyperlink{structclient}{client} *c) \{
00165     \textcolor{keywordflow}{if} (c->btype == \hyperlink{server_8h_a279f6a31729ba24d6dab0944b82e0b55}{BLOCKED\_LIST} || c->btype == \hyperlink{server_8h_a1f48bb63f9d0c061421044b92b46f679}{BLOCKED\_STREAM}) \{
00166         addReply(c,shared.nullmultibulk);
00167     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->btype == \hyperlink{server_8h_accb912da92773eadb0b938af3fa95c63}{BLOCKED\_WAIT}) \{
00168         addReplyLongLong(c,replicationCountAcksByOffset(c->bpop.reploffset));
00169     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->btype == \hyperlink{server_8h_a6bdaa78b1c4c376ebf666afb891ace42}{BLOCKED\_MODULE}) \{
00170         moduleBlockedClientTimedOut(c);
00171     \} \textcolor{keywordflow}{else} \{
00172         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown btype in replyToBlockedClientTimedOut()."});
00173     \}
00174 \}
00175 
00176 \textcolor{comment}{/* Mass-unblock clients because something changed in the instance that makes}
00177 \textcolor{comment}{ * blocking no longer safe. For example clients blocked in list operations}
00178 \textcolor{comment}{ * in an instance which turns from master to slave is unsafe, so this function}
00179 \textcolor{comment}{ * is called when a master turns into a slave.}
00180 \textcolor{comment}{ *}
00181 \textcolor{comment}{ * The semantics is to send an -UNBLOCKED error to the client, disconnecting}
00182 \textcolor{comment}{ * it at the same time. */}
00183 \textcolor{keywordtype}{void} disconnectAllBlockedClients(\textcolor{keywordtype}{void}) \{
00184     listNode *ln;
00185     listIter li;
00186 
00187     listRewind(server.clients,&li);
00188     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
00189         \hyperlink{structclient}{client} *c = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
00190 
00191         \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a503ad979164a52f0f5e2a63e4c7da3a0}{CLIENT\_BLOCKED}) \{
00192             addReplySds(c,sdsnew(
00193                 \textcolor{stringliteral}{"-UNBLOCKED force unblock from blocking operation, "}
00194                 \textcolor{stringliteral}{"instance state changed (master -> slave?)\(\backslash\)r\(\backslash\)n"}));
00195             unblockClient(c);
00196             c->flags |= \hyperlink{server_8h_a8cff2154afcc2e87ac85bdbbe2814091}{CLIENT\_CLOSE\_AFTER\_REPLY};
00197         \}
00198     \}
00199 \}
00200 
00201 \textcolor{comment}{/* This function should be called by Redis every time a single command,}
00202 \textcolor{comment}{ * a MULTI/EXEC block, or a Lua script, terminated its execution after}
00203 \textcolor{comment}{ * being called by a client.}
00204 \textcolor{comment}{ *}
00205 \textcolor{comment}{ * All the keys with at least one client blocked that received at least}
00206 \textcolor{comment}{ * one new element via some PUSH/XADD operation are accumulated into}
00207 \textcolor{comment}{ * the server.ready\_keys list. This function will run the list and will}
00208 \textcolor{comment}{ * serve clients accordingly. Note that the function will iterate again and}
00209 \textcolor{comment}{ * again as a result of serving BRPOPLPUSH we can have new blocking clients}
00210 \textcolor{comment}{ * to serve because of the PUSH side of BRPOPLPUSH. */}
00211 \textcolor{keywordtype}{void} handleClientsBlockedOnKeys(\textcolor{keywordtype}{void}) \{
00212     \textcolor{keywordflow}{while}(\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.ready\_keys) != 0) \{
00213         list *l;
00214 
00215         \textcolor{comment}{/* Point server.ready\_keys to a fresh list and save the current one}
00216 \textcolor{comment}{         * locally. This way as we run the old list we are free to call}
00217 \textcolor{comment}{         * signalKeyAsReady() that may push new elements in server.ready\_keys}
00218 \textcolor{comment}{         * when handling clients blocked into BRPOPLPUSH. */}
00219         l = server.ready\_keys;
00220         server.ready\_keys = listCreate();
00221 
00222         \textcolor{keywordflow}{while}(\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(l) != 0) \{
00223             listNode *ln = \hyperlink{adlist_8h_aa8dc514bbe217bb2e87c1c77cfa84690}{listFirst}(l);
00224             readyList *rl = ln->value;
00225 
00226             \textcolor{comment}{/* First of all remove this key from db->ready\_keys so that}
00227 \textcolor{comment}{             * we can safely call signalKeyAsReady() against this key. */}
00228             dictDelete(rl->db->ready\_keys,rl->key);
00229 
00230             \textcolor{comment}{/* Serve clients blocked on list key. */}
00231             robj *o = lookupKeyWrite(rl->db,rl->key);
00232             \textcolor{keywordflow}{if} (o != NULL && o->type == \hyperlink{server_8h_a4a5f22a280949c97a0cb0d4213275126}{OBJ\_LIST}) \{
00233                 dictEntry *de;
00234 
00235                 \textcolor{comment}{/* We serve clients in the same order they blocked for}
00236 \textcolor{comment}{                 * this key, from the first blocked to the last. */}
00237                 de = dictFind(rl->db->blocking\_keys,rl->key);
00238                 \textcolor{keywordflow}{if} (de) \{
00239                     list *clients = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
00240                     \textcolor{keywordtype}{int} numclients = \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(clients);
00241 
00242                     \textcolor{keywordflow}{while}(numclients--) \{
00243                         listNode *clientnode = \hyperlink{adlist_8h_aa8dc514bbe217bb2e87c1c77cfa84690}{listFirst}(clients);
00244                         \hyperlink{structclient}{client} *receiver = clientnode->value;
00245 
00246                         \textcolor{keywordflow}{if} (receiver->btype != \hyperlink{server_8h_a279f6a31729ba24d6dab0944b82e0b55}{BLOCKED\_LIST}) \{
00247                             \textcolor{comment}{/* Put on the tail, so that at the next call}
00248 \textcolor{comment}{                             * we'll not run into it again. */}
00249                             listDelNode(clients,clientnode);
00250                             listAddNodeTail(clients,receiver);
00251                             \textcolor{keywordflow}{continue};
00252                         \}
00253 
00254                         robj *dstkey = receiver->bpop.target;
00255                         \textcolor{keywordtype}{int} where = (receiver->lastcmd &&
00256                                      receiver->lastcmd->proc == blpopCommand) ?
00257                                     \hyperlink{server_8h_a5fc6a15ca26c6208f66ad2768a3108ef}{LIST\_HEAD} : \hyperlink{server_8h_a745de98bef5b645df56479181803235b}{LIST\_TAIL};
00258                         robj *value = listTypePop(o,where);
00259 
00260                         \textcolor{keywordflow}{if} (value) \{
00261                             \textcolor{comment}{/* Protect receiver->bpop.target, that will be}
00262 \textcolor{comment}{                             * freed by the next unblockClient()}
00263 \textcolor{comment}{                             * call. */}
00264                             \textcolor{keywordflow}{if} (dstkey) incrRefCount(dstkey);
00265                             unblockClient(receiver);
00266 
00267                             \textcolor{keywordflow}{if} (serveClientBlockedOnList(receiver,
00268                                 rl->key,dstkey,rl->db,value,
00269                                 where) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR})
00270                             \{
00271                                 \textcolor{comment}{/* If we failed serving the client we need}
00272 \textcolor{comment}{                                 * to also undo the POP operation. */}
00273                                     listTypePush(o,value,where);
00274                             \}
00275 
00276                             \textcolor{keywordflow}{if} (dstkey) decrRefCount(dstkey);
00277                             decrRefCount(value);
00278                         \} \textcolor{keywordflow}{else} \{
00279                             \textcolor{keywordflow}{break};
00280                         \}
00281                     \}
00282                 \}
00283 
00284                 \textcolor{keywordflow}{if} (listTypeLength(o) == 0) \{
00285                     dbDelete(rl->db,rl->key);
00286                 \}
00287                 \textcolor{comment}{/* We don't call signalModifiedKey() as it was already called}
00288 \textcolor{comment}{                 * when an element was pushed on the list. */}
00289             \}
00290 
00291             \textcolor{comment}{/* Serve clients blocked on stream key. */}
00292             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o != NULL && o->type == \hyperlink{server_8h_a2c2cc41300ca6b9daca7ea8a6d66edc6}{OBJ\_STREAM}) \{
00293                 dictEntry *de = dictFind(rl->db->blocking\_keys,rl->key);
00294                 stream *s = o->ptr;
00295 
00296                 \textcolor{comment}{/* We need to provide the new data arrived on the stream}
00297 \textcolor{comment}{                 * to all the clients that are waiting for an offset smaller}
00298 \textcolor{comment}{                 * than the current top item. */}
00299                 \textcolor{keywordflow}{if} (de) \{
00300                     list *clients = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
00301                     listNode *ln;
00302                     listIter li;
00303                     listRewind(clients,&li);
00304 
00305                     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
00306                         \hyperlink{structclient}{client} *receiver = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
00307                         \textcolor{keywordflow}{if} (receiver->btype != \hyperlink{server_8h_a1f48bb63f9d0c061421044b92b46f679}{BLOCKED\_STREAM}) \textcolor{keywordflow}{continue};
00308                         streamID *gt = dictFetchValue(receiver->bpop.keys,
00309                                                       rl->key);
00310                         \textcolor{keywordflow}{if} (s->last\_id.ms > gt->ms ||
00311                             (s->last\_id.ms == gt->ms &&
00312                              s->last\_id.seq > gt->seq))
00313                         \{
00314                             streamID start = *gt;
00315                             start.seq++; \textcolor{comment}{/* Can't overflow, it's an uint64\_t */}
00316                             \textcolor{comment}{/* Note that after we unblock the client, 'gt'}
00317 \textcolor{comment}{                             * is no longer valid, so we must do it after}
00318 \textcolor{comment}{                             * we copied the ID into the 'start' variable. */}
00319                             unblockClient(receiver);
00320 
00321                             \textcolor{comment}{/* Emit the two elements sub-array consisting of}
00322 \textcolor{comment}{                             * the name of the stream and the data we}
00323 \textcolor{comment}{                             * extracted from it. Wrapped in a single-item}
00324 \textcolor{comment}{                             * array, since we have just one key. */}
00325                             addReplyMultiBulkLen(receiver,1);
00326                             addReplyMultiBulkLen(receiver,2);
00327                             addReplyBulk(receiver,rl->key);
00328                             streamReplyWithRange(receiver,s,&start,NULL,
00329                                                  receiver->bpop.xread\_count,0);
00330                         \}
00331                     \}
00332                 \}
00333             \}
00334 
00335             \textcolor{comment}{/* Free this item. */}
00336             decrRefCount(rl->key);
00337             zfree(rl);
00338             listDelNode(l,ln);
00339         \}
00340         listRelease(l); \textcolor{comment}{/* We have the new list on place at this point. */}
00341     \}
00342 \}
00343 
00344 \textcolor{comment}{/* This is how the current blocking lists/streams work, we use BLPOP as}
00345 \textcolor{comment}{ * example, but the concept is the same for other list ops and XREAD.}
00346 \textcolor{comment}{ * - If the user calls BLPOP and the key exists and contains a non empty list}
00347 \textcolor{comment}{ *   then LPOP is called instead. So BLPOP is semantically the same as LPOP}
00348 \textcolor{comment}{ *   if blocking is not required.}
00349 \textcolor{comment}{ * - If instead BLPOP is called and the key does not exists or the list is}
00350 \textcolor{comment}{ *   empty we need to block. In order to do so we remove the notification for}
00351 \textcolor{comment}{ *   new data to read in the client socket (so that we'll not serve new}
00352 \textcolor{comment}{ *   requests if the blocking request is not served). Also we put the client}
00353 \textcolor{comment}{ *   in a dictionary (db->blocking\_keys) mapping keys to a list of clients}
00354 \textcolor{comment}{ *   blocking for this keys.}
00355 \textcolor{comment}{ * - If a PUSH operation against a key with blocked clients waiting is}
00356 \textcolor{comment}{ *   performed, we mark this key as "ready", and after the current command,}
00357 \textcolor{comment}{ *   MULTI/EXEC block, or script, is executed, we serve all the clients waiting}
00358 \textcolor{comment}{ *   for this list, from the one that blocked first, to the last, accordingly}
00359 \textcolor{comment}{ *   to the number of elements we have in the ready list.}
00360 \textcolor{comment}{ */}
00361 
00362 \textcolor{comment}{/* Set a client in blocking mode for the specified key (list or stream), with}
00363 \textcolor{comment}{ * the specified timeout. The 'type' argument is BLOCKED\_LIST or BLOCKED\_STREAM}
00364 \textcolor{comment}{ * depending on the kind of operation we are waiting for an empty key in}
00365 \textcolor{comment}{ * order to awake the client. The client is blocked for all the 'numkeys'}
00366 \textcolor{comment}{ * keys as in the 'keys' argument. When we block for stream keys, we also}
00367 \textcolor{comment}{ * provide an array of streamID structures: clients will be unblocked only}
00368 \textcolor{comment}{ * when items with an ID greater or equal to the specified one is appended}
00369 \textcolor{comment}{ * to the stream. */}
00370 \textcolor{keywordtype}{void} blockForKeys(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} btype, robj **keys, \textcolor{keywordtype}{int} numkeys, mstime\_t timeout, robj *target
      , streamID *ids) \{
00371     dictEntry *de;
00372     list *l;
00373     \textcolor{keywordtype}{int} j;
00374 
00375     c->bpop.timeout = timeout;
00376     c->bpop.target = target;
00377 
00378     \textcolor{keywordflow}{if} (target != NULL) incrRefCount(target);
00379 
00380     \textcolor{keywordflow}{for} (j = 0; j < numkeys; j++) \{
00381         \textcolor{comment}{/* The value associated with the key name in the bpop.keys dictionary}
00382 \textcolor{comment}{         * is NULL for lists, or the stream ID for streams. */}
00383         \textcolor{keywordtype}{void} *key\_data = NULL;
00384         \textcolor{keywordflow}{if} (btype == \hyperlink{server_8h_a1f48bb63f9d0c061421044b92b46f679}{BLOCKED\_STREAM}) \{
00385             key\_data = zmalloc(\textcolor{keyword}{sizeof}(streamID));
00386             memcpy(key\_data,ids+j,\textcolor{keyword}{sizeof}(streamID));
00387         \}
00388 
00389         \textcolor{comment}{/* If the key already exists in the dictionary ignore it. */}
00390         \textcolor{keywordflow}{if} (dictAdd(c->bpop.keys,keys[j],key\_data) != \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK}) \{
00391             zfree(key\_data);
00392             \textcolor{keywordflow}{continue};
00393         \}
00394         incrRefCount(keys[j]);
00395 
00396         \textcolor{comment}{/* And in the other "side", to map keys -> clients */}
00397         de = dictFind(c->db->blocking\_keys,keys[j]);
00398         \textcolor{keywordflow}{if} (de == NULL) \{
00399             \textcolor{keywordtype}{int} retval;
00400 
00401             \textcolor{comment}{/* For every key we take a list of clients blocked for it */}
00402             l = listCreate();
00403             retval = dictAdd(c->db->blocking\_keys,keys[j],l);
00404             incrRefCount(keys[j]);
00405             \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,keys[j],retval == 
      \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK});
00406         \} \textcolor{keywordflow}{else} \{
00407             l = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
00408         \}
00409         listAddNodeTail(l,c);
00410     \}
00411     blockClient(c,btype);
00412 \}
00413 
00414 \textcolor{comment}{/* Unblock a client that's waiting in a blocking operation such as BLPOP.}
00415 \textcolor{comment}{ * You should never call this function directly, but unblockClient() instead. */}
00416 \textcolor{keywordtype}{void} unblockClientWaitingData(\hyperlink{structclient}{client} *c) \{
00417     dictEntry *de;
00418     dictIterator *di;
00419     list *l;
00420 
00421     \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(c->bpop.keys) != 0);
00422     di = dictGetIterator(c->bpop.keys);
00423     \textcolor{comment}{/* The client may wait for multiple keys, so unblock it for every key. */}
00424     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
00425         robj *key = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
00426 
00427         \textcolor{comment}{/* Remove this client from the list of clients waiting for this key. */}
00428         l = dictFetchValue(c->db->blocking\_keys,key);
00429         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,key,l != NULL);
00430         listDelNode(l,listSearchKey(l,c));
00431         \textcolor{comment}{/* If the list is empty we need to remove it to avoid wasting memory */}
00432         \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(l) == 0)
00433             dictDelete(c->db->blocking\_keys,key);
00434     \}
00435     dictReleaseIterator(di);
00436 
00437     \textcolor{comment}{/* Cleanup the client structure */}
00438     dictEmpty(c->bpop.keys,NULL);
00439     \textcolor{keywordflow}{if} (c->bpop.target) \{
00440         decrRefCount(c->bpop.target);
00441         c->bpop.target = NULL;
00442     \}
00443     \textcolor{keywordflow}{if} (c->bpop.xread\_group) \{
00444         decrRefCount(c->bpop.xread\_group);
00445         c->bpop.xread\_group = NULL;
00446     \}
00447 \}
00448 
00449 \textcolor{comment}{/* If the specified key has clients blocked waiting for list pushes, this}
00450 \textcolor{comment}{ * function will put the key reference into the server.ready\_keys list.}
00451 \textcolor{comment}{ * Note that db->ready\_keys is a hash table that allows us to avoid putting}
00452 \textcolor{comment}{ * the same key again and again in the list in case of multiple pushes}
00453 \textcolor{comment}{ * made by a script or in the context of MULTI/EXEC.}
00454 \textcolor{comment}{ *}
00455 \textcolor{comment}{ * The list will be finally processed by handleClientsBlockedOnLists() */}
00456 \textcolor{keywordtype}{void} signalKeyAsReady(redisDb *db, robj *key) \{
00457     readyList *rl;
00458 
00459     \textcolor{comment}{/* No clients blocking for this key? No need to queue it. */}
00460     \textcolor{keywordflow}{if} (dictFind(db->blocking\_keys,key) == NULL) \textcolor{keywordflow}{return};
00461 
00462     \textcolor{comment}{/* Key was already signaled? No need to queue it again. */}
00463     \textcolor{keywordflow}{if} (dictFind(db->ready\_keys,key) != NULL) \textcolor{keywordflow}{return};
00464 
00465     \textcolor{comment}{/* Ok, we need to queue this key into server.ready\_keys. */}
00466     rl = zmalloc(\textcolor{keyword}{sizeof}(*rl));
00467     rl->key = key;
00468     rl->db = db;
00469     incrRefCount(key);
00470     listAddNodeTail(server.ready\_keys,rl);
00471 
00472     \textcolor{comment}{/* We also add the key in the db->ready\_keys dictionary in order}
00473 \textcolor{comment}{     * to avoid adding it multiple times into a list with a simple O(1)}
00474 \textcolor{comment}{     * check. */}
00475     incrRefCount(key);
00476     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(dictAdd(db->ready\_keys,key,NULL) == \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK});
00477 \}
\end{DoxyCode}
