\hypertarget{networking_8c_source}{}\section{networking.\+c}
\label{networking_8c_source}\index{src/networking.\+c@{src/networking.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>}
00003 \textcolor{comment}{ * All rights reserved.}
00004 \textcolor{comment}{ *}
00005 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00006 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00007 \textcolor{comment}{ *}
00008 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00009 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00010 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00011 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00012 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00013 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00014 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00015 \textcolor{comment}{ *     specific prior written permission.}
00016 \textcolor{comment}{ *}
00017 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00018 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00019 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00020 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00021 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00022 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00023 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00024 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00025 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00026 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00027 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00028 \textcolor{comment}{ */}
00029 
00030 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{server_8h}{"server.h"}
00031 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{atomicvar_8h}{"atomicvar.h"}
00032 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{uio}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00033 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{math}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00034 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{ctype}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00035 
00036 \textcolor{keyword}{static} \textcolor{keywordtype}{void} setProtocolError(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *errstr, \hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} pos);
00037 
00038 \textcolor{comment}{/* Return the size consumed from the allocator, for the specified SDS string,}
00039 \textcolor{comment}{ * including internal fragmentation. This function is used in order to compute}
00040 \textcolor{comment}{ * the client output buffer size. */}
00041 size\_t sdsZmallocSize(sds s) \{
00042     \textcolor{keywordtype}{void} *sh = sdsAllocPtr(s);
00043     \textcolor{keywordflow}{return} zmalloc\_size(sh);
00044 \}
00045 
00046 \textcolor{comment}{/* Return the amount of memory used by the sds string at object->ptr}
00047 \textcolor{comment}{ * for a string object. */}
00048 size\_t getStringObjectSdsUsedMemory(robj *o) \{
00049     \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(NULL,o,o->type == \hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING});
00050     \textcolor{keywordflow}{switch}(o->encoding) \{
00051     \textcolor{keywordflow}{case} \hyperlink{server_8h_a148bc85e3074e324a6dc5eebcad1bcd5}{OBJ\_ENCODING\_RAW}: \textcolor{keywordflow}{return} sdsZmallocSize(o->ptr);
00052     \textcolor{keywordflow}{case} \hyperlink{server_8h_ac5bb76b546161fd0da4b0ff89b3142ee}{OBJ\_ENCODING\_EMBSTR}: \textcolor{keywordflow}{return} zmalloc\_size(o)-\textcolor{keyword}{sizeof}(robj);
00053     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* Just integer encoding for now. */}
00054     \}
00055 \}
00056 
00057 \textcolor{comment}{/* Client.reply list dup and free methods. */}
00058 \textcolor{keywordtype}{void} *dupClientReplyValue(\textcolor{keywordtype}{void} *o) \{
00059     \textcolor{keywordflow}{return} sdsdup(o);
00060 \}
00061 
00062 \textcolor{keywordtype}{void} freeClientReplyValue(\textcolor{keywordtype}{void} *o) \{
00063     sdsfree(o);
00064 \}
00065 
00066 \textcolor{keywordtype}{int} listMatchObjects(\textcolor{keywordtype}{void} *a, \textcolor{keywordtype}{void} *b) \{
00067     \textcolor{keywordflow}{return} equalStringObjects(a,b);
00068 \}
00069 
00070 \textcolor{comment}{/* This function links the client to the global linked list of clients.}
00071 \textcolor{comment}{ * unlinkClient() does the opposite, among other things. */}
00072 \textcolor{keywordtype}{void} linkClient(\hyperlink{structclient}{client} *c) \{
00073     listAddNodeTail(server.clients,c);
00074     \textcolor{comment}{/* Note that we remember the linked list node where the client is stored,}
00075 \textcolor{comment}{     * this way removing the client in unlinkClient() will not require}
00076 \textcolor{comment}{     * a linear scan, but just a constant time operation. */}
00077     c->client\_list\_node = \hyperlink{adlist_8h_a5e0fad60032ef0fe9adcf9811e2f2fba}{listLast}(server.clients);
00078 \}
00079 
00080 \hyperlink{structclient}{client} *createClient(\textcolor{keywordtype}{int} fd) \{
00081     \hyperlink{structclient}{client} *c = zmalloc(\textcolor{keyword}{sizeof}(client));
00082 
00083     \textcolor{comment}{/* passing -1 as fd it is possible to create a non connected client.}
00084 \textcolor{comment}{     * This is useful since all the commands needs to be executed}
00085 \textcolor{comment}{     * in the context of a client. When commands are executed in other}
00086 \textcolor{comment}{     * contexts (for instance a Lua script) we need a non connected client. */}
00087     \textcolor{keywordflow}{if} (fd != -1) \{
00088         anetNonBlock(NULL,fd);
00089         anetEnableTcpNoDelay(NULL,fd);
00090         \textcolor{keywordflow}{if} (server.tcpkeepalive)
00091             anetKeepAlive(NULL,fd,server.tcpkeepalive);
00092         \textcolor{keywordflow}{if} (aeCreateFileEvent(server.el,fd,\hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE},
00093             readQueryFromClient, c) == \hyperlink{ae_8h_aa16dcf7effdf8f8df97f51b1cb51a9df}{AE\_ERR})
00094         \{
00095             close(fd);
00096             zfree(c);
00097             \textcolor{keywordflow}{return} NULL;
00098         \}
00099     \}
00100 
00101     selectDb(c,0);
00102     uint64\_t client\_id;
00103     \hyperlink{atomicvar_8h_a4cc5946482e11623904ce637b9b7d7fc}{atomicGetIncr}(server.next\_client\_id,client\_id,1);
00104     c->id = client\_id;
00105     c->fd = fd;
00106     c->name = NULL;
00107     c->bufpos = 0;
00108     c->querybuf = sdsempty();
00109     c->pending\_querybuf = sdsempty();
00110     c->querybuf\_peak = 0;
00111     c->reqtype = 0;
00112     c->argc = 0;
00113     c->argv = NULL;
00114     c->cmd = c->lastcmd = NULL;
00115     c->multibulklen = 0;
00116     c->bulklen = -1;
00117     c->sentlen = 0;
00118     c->flags = 0;
00119     c->ctime = c->lastinteraction = server.unixtime;
00120     c->authenticated = 0;
00121     c->replstate = \hyperlink{server_8h_a256b9506e551eaa7417f75f8fa9ed901}{REPL\_STATE\_NONE};
00122     c->repl\_put\_online\_on\_ack = 0;
00123     c->reploff = 0;
00124     c->read\_reploff = 0;
00125     c->repl\_ack\_off = 0;
00126     c->repl\_ack\_time = 0;
00127     c->slave\_listening\_port = 0;
00128     c->slave\_ip[0] = \textcolor{stringliteral}{'\(\backslash\)0'};
00129     c->slave\_capa = \hyperlink{server_8h_a3159f891b4d0af83f56eea4b2699cefc}{SLAVE\_CAPA\_NONE};
00130     c->reply = listCreate();
00131     c->reply\_bytes = 0;
00132     c->obuf\_soft\_limit\_reached\_time = 0;
00133     \hyperlink{adlist_8h_a648e4a2d20decff3182a72a608b0b8f2}{listSetFreeMethod}(c->reply,freeClientReplyValue);
00134     \hyperlink{adlist_8h_ab575839d09f454c02e06bcec5addb06b}{listSetDupMethod}(c->reply,dupClientReplyValue);
00135     c->btype = \hyperlink{server_8h_a89cf259b265c26cd1e09de67ade457dc}{BLOCKED\_NONE};
00136     c->bpop.timeout = 0;
00137     c->bpop.keys = dictCreate(&objectKeyHeapPointerValueDictType,NULL);
00138     c->bpop.target = NULL;
00139     c->bpop.xread\_group = NULL;
00140     c->bpop.numreplicas = 0;
00141     c->bpop.reploffset = 0;
00142     c->woff = 0;
00143     c->watched\_keys = listCreate();
00144     c->pubsub\_channels = dictCreate(&objectKeyPointerValueDictType,NULL);
00145     c->pubsub\_patterns = listCreate();
00146     c->peerid = NULL;
00147     c->client\_list\_node = NULL;
00148     \hyperlink{adlist_8h_a648e4a2d20decff3182a72a608b0b8f2}{listSetFreeMethod}(c->pubsub\_patterns,decrRefCountVoid);
00149     \hyperlink{adlist_8h_a3dac429a545f8def9a2bf9077eb66ddc}{listSetMatchMethod}(c->pubsub\_patterns,listMatchObjects);
00150     \textcolor{keywordflow}{if} (fd != -1) linkClient(c);
00151     initClientMultiState(c);
00152     \textcolor{keywordflow}{return} c;
00153 \}
00154 
00155 \textcolor{comment}{/* This function is called every time we are going to transmit new data}
00156 \textcolor{comment}{ * to the client. The behavior is the following:}
00157 \textcolor{comment}{ *}
00158 \textcolor{comment}{ * If the client should receive new data (normal clients will) the function}
00159 \textcolor{comment}{ * returns C\_OK, and make sure to install the write handler in our event}
00160 \textcolor{comment}{ * loop so that when the socket is writable new data gets written.}
00161 \textcolor{comment}{ *}
00162 \textcolor{comment}{ * If the client should not receive new data, because it is a fake client}
00163 \textcolor{comment}{ * (used to load AOF in memory), a master or because the setup of the write}
00164 \textcolor{comment}{ * handler failed, the function returns C\_ERR.}
00165 \textcolor{comment}{ *}
00166 \textcolor{comment}{ * The function may return C\_OK without actually installing the write}
00167 \textcolor{comment}{ * event handler in the following cases:}
00168 \textcolor{comment}{ *}
00169 \textcolor{comment}{ * 1) The event handler should already be installed since the output buffer}
00170 \textcolor{comment}{ *    already contains something.}
00171 \textcolor{comment}{ * 2) The client is a slave but not yet online, so we want to just accumulate}
00172 \textcolor{comment}{ *    writes in the buffer but not actually sending them yet.}
00173 \textcolor{comment}{ *}
00174 \textcolor{comment}{ * Typically gets called every time a reply is built, before adding more}
00175 \textcolor{comment}{ * data to the clients output buffers. If the function returns C\_ERR no}
00176 \textcolor{comment}{ * data should be appended to the output buffers. */}
00177 \textcolor{keywordtype}{int} prepareClientToWrite(\hyperlink{structclient}{client} *c) \{
00178     \textcolor{comment}{/* If it's the Lua client we always return ok without installing any}
00179 \textcolor{comment}{     * handler since there is no socket at all. */}
00180     \textcolor{keywordflow}{if} (c->flags & (\hyperlink{server_8h_af9d0b0f45ef2c1fd29ac714a300de706}{CLIENT\_LUA}|\hyperlink{server_8h_a633251b1c4bbfe09c54a5c88920d8eda}{CLIENT\_MODULE})) \textcolor{keywordflow}{return} 
      \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00181 
00182     \textcolor{comment}{/* CLIENT REPLY OFF / SKIP handling: don't send replies. */}
00183     \textcolor{keywordflow}{if} (c->flags & (\hyperlink{server_8h_a9e2a01b79b4567285f1eccbbe0ed35d1}{CLIENT\_REPLY\_OFF}|\hyperlink{server_8h_a792a906c445537043944477fdaad11f4}{CLIENT\_REPLY\_SKIP})) \textcolor{keywordflow}{return} 
      \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00184 
00185     \textcolor{comment}{/* Masters don't receive replies, unless CLIENT\_MASTER\_FORCE\_REPLY flag}
00186 \textcolor{comment}{     * is set. */}
00187     \textcolor{keywordflow}{if} ((c->flags & \hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER}) &&
00188         !(c->flags & \hyperlink{server_8h_a291fd012c9b504c52c371e7185f0a57c}{CLIENT\_MASTER\_FORCE\_REPLY})) \textcolor{keywordflow}{return} 
      \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00189 
00190     \textcolor{keywordflow}{if} (c->fd <= 0) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}; \textcolor{comment}{/* Fake client for AOF loading. */}
00191 
00192     \textcolor{comment}{/* Schedule the client to write the output buffers to the socket only}
00193 \textcolor{comment}{     * if not already done (there were no pending writes already and the client}
00194 \textcolor{comment}{     * was yet not flagged), and, for slaves, if the slave can actually}
00195 \textcolor{comment}{     * receive writes at this stage. */}
00196     \textcolor{keywordflow}{if} (!clientHasPendingReplies(c) &&
00197         !(c->flags & \hyperlink{server_8h_addd2e991874faef411339e9ae9619023}{CLIENT\_PENDING\_WRITE}) &&
00198         (c->replstate == \hyperlink{server_8h_a256b9506e551eaa7417f75f8fa9ed901}{REPL\_STATE\_NONE} ||
00199          (c->replstate == \hyperlink{server_8h_ad895fdf16e5ed5275d19ddf8578b900f}{SLAVE\_STATE\_ONLINE} && !c->repl\_put\_online\_on\_ack)))
00200     \{
00201         \textcolor{comment}{/* Here instead of installing the write handler, we just flag the}
00202 \textcolor{comment}{         * client and put it into a list of clients that have something}
00203 \textcolor{comment}{         * to write to the socket. This way before re-entering the event}
00204 \textcolor{comment}{         * loop, we can try to directly write to the client sockets avoiding}
00205 \textcolor{comment}{         * a system call. We'll only really install the write handler if}
00206 \textcolor{comment}{         * we'll not be able to write the whole reply at once. */}
00207         c->flags |= \hyperlink{server_8h_addd2e991874faef411339e9ae9619023}{CLIENT\_PENDING\_WRITE};
00208         listAddNodeHead(server.clients\_pending\_write,c);
00209     \}
00210 
00211     \textcolor{comment}{/* Authorize the caller to queue in the output buffer of this client. */}
00212     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00213 \}
00214 
00215 \textcolor{comment}{/* -----------------------------------------------------------------------------}
00216 \textcolor{comment}{ * Low level functions to add more data to output buffers.}
00217 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
00218 
00219 \textcolor{keywordtype}{int} \_addReplyToBuffer(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, size\_t len) \{
00220     size\_t available = \textcolor{keyword}{sizeof}(c->buf)-c->bufpos;
00221 
00222     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a8cff2154afcc2e87ac85bdbbe2814091}{CLIENT\_CLOSE\_AFTER\_REPLY}) \textcolor{keywordflow}{return} 
      \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00223 
00224     \textcolor{comment}{/* If there already are entries in the reply list, we cannot}
00225 \textcolor{comment}{     * add anything more to the static buffer. */}
00226     \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(c->reply) > 0) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00227 
00228     \textcolor{comment}{/* Check that the buffer has enough space available for this string. */}
00229     \textcolor{keywordflow}{if} (len > available) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00230 
00231     memcpy(c->buf+c->bufpos,s,len);
00232     c->bufpos+=len;
00233     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00234 \}
00235 
00236 \textcolor{keywordtype}{void} \_addReplyObjectToList(\hyperlink{structclient}{client} *c, robj *o) \{
00237     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a8cff2154afcc2e87ac85bdbbe2814091}{CLIENT\_CLOSE\_AFTER\_REPLY}) \textcolor{keywordflow}{return};
00238 
00239     \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(c->reply) == 0) \{
00240         sds s = sdsdup(o->ptr);
00241         listAddNodeTail(c->reply,s);
00242         c->reply\_bytes += sdslen(s);
00243     \} \textcolor{keywordflow}{else} \{
00244         listNode *ln = \hyperlink{adlist_8h_a5e0fad60032ef0fe9adcf9811e2f2fba}{listLast}(c->reply);
00245         sds tail = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
00246 
00247         \textcolor{comment}{/* Append to this object when possible. If tail == NULL it was}
00248 \textcolor{comment}{         * set via addDeferredMultiBulkLength(). */}
00249         \textcolor{keywordflow}{if} (tail && sdslen(tail)+sdslen(o->ptr) <= \hyperlink{server_8h_ab467e0a40be9097e85445616d9bb32e3}{PROTO\_REPLY\_CHUNK\_BYTES}) \{
00250             tail = sdscatsds(tail,o->ptr);
00251             \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln) = tail;
00252             c->reply\_bytes += sdslen(o->ptr);
00253         \} \textcolor{keywordflow}{else} \{
00254             sds s = sdsdup(o->ptr);
00255             listAddNodeTail(c->reply,s);
00256             c->reply\_bytes += sdslen(s);
00257         \}
00258     \}
00259     asyncCloseClientOnOutputBufferLimitReached(c);
00260 \}
00261 
00262 \textcolor{comment}{/* This method takes responsibility over the sds. When it is no longer}
00263 \textcolor{comment}{ * needed it will be free'd, otherwise it ends up in a robj. */}
00264 \textcolor{keywordtype}{void} \_addReplySdsToList(\hyperlink{structclient}{client} *c, sds s) \{
00265     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a8cff2154afcc2e87ac85bdbbe2814091}{CLIENT\_CLOSE\_AFTER\_REPLY}) \{
00266         sdsfree(s);
00267         \textcolor{keywordflow}{return};
00268     \}
00269 
00270     \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(c->reply) == 0) \{
00271         listAddNodeTail(c->reply,s);
00272         c->reply\_bytes += sdslen(s);
00273     \} \textcolor{keywordflow}{else} \{
00274         listNode *ln = \hyperlink{adlist_8h_a5e0fad60032ef0fe9adcf9811e2f2fba}{listLast}(c->reply);
00275         sds tail = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
00276 
00277         \textcolor{comment}{/* Append to this object when possible. If tail == NULL it was}
00278 \textcolor{comment}{         * set via addDeferredMultiBulkLength(). */}
00279         \textcolor{keywordflow}{if} (tail && sdslen(tail)+sdslen(s) <= \hyperlink{server_8h_ab467e0a40be9097e85445616d9bb32e3}{PROTO\_REPLY\_CHUNK\_BYTES}) \{
00280             tail = sdscatsds(tail,s);
00281             \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln) = tail;
00282             c->reply\_bytes += sdslen(s);
00283             sdsfree(s);
00284         \} \textcolor{keywordflow}{else} \{
00285             listAddNodeTail(c->reply,s);
00286             c->reply\_bytes += sdslen(s);
00287         \}
00288     \}
00289     asyncCloseClientOnOutputBufferLimitReached(c);
00290 \}
00291 
00292 \textcolor{keywordtype}{void} \_addReplyStringToList(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, size\_t len) \{
00293     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a8cff2154afcc2e87ac85bdbbe2814091}{CLIENT\_CLOSE\_AFTER\_REPLY}) \textcolor{keywordflow}{return};
00294 
00295     \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(c->reply) == 0) \{
00296         sds node = sdsnewlen(s,len);
00297         listAddNodeTail(c->reply,node);
00298         c->reply\_bytes += len;
00299     \} \textcolor{keywordflow}{else} \{
00300         listNode *ln = \hyperlink{adlist_8h_a5e0fad60032ef0fe9adcf9811e2f2fba}{listLast}(c->reply);
00301         sds tail = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
00302 
00303         \textcolor{comment}{/* Append to this object when possible. If tail == NULL it was}
00304 \textcolor{comment}{         * set via addDeferredMultiBulkLength(). */}
00305         \textcolor{keywordflow}{if} (tail && sdslen(tail)+len <= \hyperlink{server_8h_ab467e0a40be9097e85445616d9bb32e3}{PROTO\_REPLY\_CHUNK\_BYTES}) \{
00306             tail = sdscatlen(tail,s,len);
00307             \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln) = tail;
00308             c->reply\_bytes += len;
00309         \} \textcolor{keywordflow}{else} \{
00310             sds node = sdsnewlen(s,len);
00311             listAddNodeTail(c->reply,node);
00312             c->reply\_bytes += len;
00313         \}
00314     \}
00315     asyncCloseClientOnOutputBufferLimitReached(c);
00316 \}
00317 
00318 \textcolor{comment}{/* -----------------------------------------------------------------------------}
00319 \textcolor{comment}{ * Higher level functions to queue data on the client output buffer.}
00320 \textcolor{comment}{ * The following functions are the ones that commands implementations will call.}
00321 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
00322 
00323 \textcolor{keywordtype}{void} addReply(\hyperlink{structclient}{client} *c, robj *obj) \{
00324     \textcolor{keywordflow}{if} (prepareClientToWrite(c) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \textcolor{keywordflow}{return};
00325 
00326     \textcolor{comment}{/* This is an important place where we can avoid copy-on-write}
00327 \textcolor{comment}{     * when there is a saving child running, avoiding touching the}
00328 \textcolor{comment}{     * refcount field of the object if it's not needed.}
00329 \textcolor{comment}{     *}
00330 \textcolor{comment}{     * If the encoding is RAW and there is room in the static buffer}
00331 \textcolor{comment}{     * we'll be able to send the object to the client without}
00332 \textcolor{comment}{     * messing with its page. */}
00333     \textcolor{keywordflow}{if} (\hyperlink{server_8h_afcfb5bd97af52d1dbce331745cae030c}{sdsEncodedObject}(obj)) \{
00334         \textcolor{keywordflow}{if} (\_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
00335             \_addReplyObjectToList(c,obj);
00336     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (obj->encoding == \hyperlink{server_8h_ae934cf008a0be0ef009c92c2d006a816}{OBJ\_ENCODING\_INT}) \{
00337         \textcolor{comment}{/* Optimization: if there is room in the static buffer for 32 bytes}
00338 \textcolor{comment}{         * (more than the max chars a 64 bit integer can take as string) we}
00339 \textcolor{comment}{         * avoid decoding the object and go for the lower level approach. */}
00340         \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(c->reply) == 0 && (\textcolor{keyword}{sizeof}(c->buf) - c->bufpos) >= 32) \{
00341             \textcolor{keywordtype}{char} buf[32];
00342             \textcolor{keywordtype}{int} len;
00343 
00344             len = ll2string(buf,\textcolor{keyword}{sizeof}(buf),(\textcolor{keywordtype}{long})obj->ptr);
00345             \textcolor{keywordflow}{if} (\_addReplyToBuffer(c,buf,len) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
00346                 \textcolor{keywordflow}{return};
00347             \textcolor{comment}{/* else... continue with the normal code path, but should never}
00348 \textcolor{comment}{             * happen actually since we verified there is room. */}
00349         \}
00350         obj = getDecodedObject(obj);
00351         \textcolor{keywordflow}{if} (\_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
00352             \_addReplyObjectToList(c,obj);
00353         decrRefCount(obj);
00354     \} \textcolor{keywordflow}{else} \{
00355         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Wrong obj->encoding in addReply()"});
00356     \}
00357 \}
00358 
00359 \textcolor{keywordtype}{void} addReplySds(\hyperlink{structclient}{client} *c, sds s) \{
00360     \textcolor{keywordflow}{if} (prepareClientToWrite(c) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
00361         \textcolor{comment}{/* The caller expects the sds to be free'd. */}
00362         sdsfree(s);
00363         \textcolor{keywordflow}{return};
00364     \}
00365     \textcolor{keywordflow}{if} (\_addReplyToBuffer(c,s,sdslen(s)) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
00366         sdsfree(s);
00367     \} \textcolor{keywordflow}{else} \{
00368         \textcolor{comment}{/* This method free's the sds when it is no longer needed. */}
00369         \_addReplySdsToList(c,s);
00370     \}
00371 \}
00372 
00373 \textcolor{comment}{/* This low level function just adds whatever protocol you send it to the}
00374 \textcolor{comment}{ * client buffer, trying the static buffer initially, and using the string}
00375 \textcolor{comment}{ * of objects if not possible.}
00376 \textcolor{comment}{ *}
00377 \textcolor{comment}{ * It is efficient because does not create an SDS object nor an Redis object}
00378 \textcolor{comment}{ * if not needed. The object will only be created by calling}
00379 \textcolor{comment}{ * \_addReplyStringToList() if we fail to extend the existing tail object}
00380 \textcolor{comment}{ * in the list of objects. */}
00381 \textcolor{keywordtype}{void} addReplyString(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, size\_t len) \{
00382     \textcolor{keywordflow}{if} (prepareClientToWrite(c) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \textcolor{keywordflow}{return};
00383     \textcolor{keywordflow}{if} (\_addReplyToBuffer(c,s,len) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
00384         \_addReplyStringToList(c,s,len);
00385 \}
00386 
00387 \textcolor{keywordtype}{void} addReplyErrorLength(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, size\_t len) \{
00388     addReplyString(c,\textcolor{stringliteral}{"-ERR "},5);
00389     addReplyString(c,s,len);
00390     addReplyString(c,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"},2);
00391 \}
00392 
00393 \textcolor{keywordtype}{void} addReplyError(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *err) \{
00394     addReplyErrorLength(c,err,strlen(err));
00395 \}
00396 
00397 \textcolor{keywordtype}{void} addReplyErrorFormat(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, ...) \{
00398     size\_t l, j;
00399     va\_list ap;
00400     va\_start(ap,fmt);
00401     sds s = sdscatvprintf(sdsempty(),fmt,ap);
00402     va\_end(ap);
00403     \textcolor{comment}{/* Make sure there are no newlines in the string, otherwise invalid protocol}
00404 \textcolor{comment}{     * is emitted. */}
00405     l = sdslen(s);
00406     \textcolor{keywordflow}{for} (j = 0; j < l; j++) \{
00407         \textcolor{keywordflow}{if} (s[j] == \textcolor{stringliteral}{'\(\backslash\)r'} || s[j] == \textcolor{stringliteral}{'\(\backslash\)n'}) s[j] = \textcolor{stringliteral}{' '};
00408     \}
00409     addReplyErrorLength(c,s,sdslen(s));
00410     sdsfree(s);
00411 \}
00412 
00413 \textcolor{keywordtype}{void} addReplyStatusLength(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, size\_t len) \{
00414     addReplyString(c,\textcolor{stringliteral}{"+"},1);
00415     addReplyString(c,s,len);
00416     addReplyString(c,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"},2);
00417 \}
00418 
00419 \textcolor{keywordtype}{void} addReplyStatus(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *status) \{
00420     addReplyStatusLength(c,status,strlen(status));
00421 \}
00422 
00423 \textcolor{keywordtype}{void} addReplyStatusFormat(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, ...) \{
00424     va\_list ap;
00425     va\_start(ap,fmt);
00426     sds s = sdscatvprintf(sdsempty(),fmt,ap);
00427     va\_end(ap);
00428     addReplyStatusLength(c,s,sdslen(s));
00429     sdsfree(s);
00430 \}
00431 
00432 \textcolor{comment}{/* Adds an empty object to the reply list that will contain the multi bulk}
00433 \textcolor{comment}{ * length, which is not known when this function is called. */}
00434 \textcolor{keywordtype}{void} *addDeferredMultiBulkLength(\hyperlink{structclient}{client} *c) \{
00435     \textcolor{comment}{/* Note that we install the write event here even if the object is not}
00436 \textcolor{comment}{     * ready to be sent, since we are sure that before returning to the}
00437 \textcolor{comment}{     * event loop setDeferredMultiBulkLength() will be called. */}
00438     \textcolor{keywordflow}{if} (prepareClientToWrite(c) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \textcolor{keywordflow}{return} NULL;
00439     listAddNodeTail(c->reply,NULL); \textcolor{comment}{/* NULL is our placeholder. */}
00440     \textcolor{keywordflow}{return} \hyperlink{adlist_8h_a5e0fad60032ef0fe9adcf9811e2f2fba}{listLast}(c->reply);
00441 \}
00442 
00443 \textcolor{comment}{/* Populate the length object and try gluing it to the next chunk. */}
00444 \textcolor{keywordtype}{void} setDeferredMultiBulkLength(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{void} *node, \textcolor{keywordtype}{long} length) \{
00445     listNode *ln = (listNode*)node;
00446     sds len, next;
00447 
00448     \textcolor{comment}{/* Abort when *node is NULL: when the client should not accept writes}
00449 \textcolor{comment}{     * we return NULL in addDeferredMultiBulkLength() */}
00450     \textcolor{keywordflow}{if} (node == NULL) \textcolor{keywordflow}{return};
00451 
00452     len = sdscatprintf(sdsnewlen(\textcolor{stringliteral}{"*"},1),\textcolor{stringliteral}{"%ld\(\backslash\)r\(\backslash\)n"},length);
00453     \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln) = len;
00454     c->reply\_bytes += sdslen(len);
00455     \textcolor{keywordflow}{if} (ln->next != NULL) \{
00456         next = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln->next);
00457 
00458         \textcolor{comment}{/* Only glue when the next node is non-NULL (an sds in this case) */}
00459         \textcolor{keywordflow}{if} (next != NULL) \{
00460             len = sdscatsds(len,next);
00461             listDelNode(c->reply,ln->next);
00462             \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln) = len;
00463             \textcolor{comment}{/* No need to update c->reply\_bytes: we are just moving the same}
00464 \textcolor{comment}{             * amount of bytes from one node to another. */}
00465         \}
00466     \}
00467     asyncCloseClientOnOutputBufferLimitReached(c);
00468 \}
00469 
00470 \textcolor{comment}{/* Add a double as a bulk reply */}
00471 \textcolor{keywordtype}{void} addReplyDouble(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{double} d) \{
00472     \textcolor{keywordtype}{char} dbuf[128], sbuf[128];
00473     \textcolor{keywordtype}{int} dlen, slen;
00474     \textcolor{keywordflow}{if} (isinf(d)) \{
00475         \textcolor{comment}{/* Libc in odd systems (Hi Solaris!) will format infinite in a}
00476 \textcolor{comment}{         * different way, so better to handle it in an explicit way. */}
00477         addReplyBulkCString(c, d > 0 ? \textcolor{stringliteral}{"inf"} : \textcolor{stringliteral}{"-inf"});
00478     \} \textcolor{keywordflow}{else} \{
00479         dlen = snprintf(dbuf,\textcolor{keyword}{sizeof}(dbuf),\textcolor{stringliteral}{"%.17g"},d);
00480         slen = snprintf(sbuf,\textcolor{keyword}{sizeof}(sbuf),\textcolor{stringliteral}{"$%d\(\backslash\)r\(\backslash\)n%s\(\backslash\)r\(\backslash\)n"},dlen,dbuf);
00481         addReplyString(c,sbuf,slen);
00482     \}
00483 \}
00484 
00485 \textcolor{comment}{/* Add a long double as a bulk reply, but uses a human readable formatting}
00486 \textcolor{comment}{ * of the double instead of exposing the crude behavior of doubles to the}
00487 \textcolor{comment}{ * dear user. */}
00488 \textcolor{keywordtype}{void} addReplyHumanLongDouble(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} d) \{
00489     robj *o = createStringObjectFromLongDouble(d,1);
00490     addReplyBulk(c,o);
00491     decrRefCount(o);
00492 \}
00493 
00494 \textcolor{comment}{/* Add a long long as integer reply or bulk len / multi bulk count.}
00495 \textcolor{comment}{ * Basically this is used to output <prefix><long long><crlf>. */}
00496 \textcolor{keywordtype}{void} addReplyLongLongWithPrefix(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ll, \textcolor{keywordtype}{char} prefix) \{
00497     \textcolor{keywordtype}{char} buf[128];
00498     \textcolor{keywordtype}{int} len;
00499 
00500     \textcolor{comment}{/* Things like $3\(\backslash\)r\(\backslash\)n or *2\(\backslash\)r\(\backslash\)n are emitted very often by the protocol}
00501 \textcolor{comment}{     * so we have a few shared objects to use if the integer is small}
00502 \textcolor{comment}{     * like it is most of the times. */}
00503     \textcolor{keywordflow}{if} (prefix == \textcolor{stringliteral}{'*'} && ll < \hyperlink{server_8h_aff2f6e62c729d3f8b119d761818be317}{OBJ\_SHARED\_BULKHDR\_LEN} && ll >= 0) \{
00504         addReply(c,shared.mbulkhdr[ll]);
00505         \textcolor{keywordflow}{return};
00506     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (prefix == \textcolor{stringliteral}{'$'} && ll < \hyperlink{server_8h_aff2f6e62c729d3f8b119d761818be317}{OBJ\_SHARED\_BULKHDR\_LEN} && ll >= 0) \{
00507         addReply(c,shared.bulkhdr[ll]);
00508         \textcolor{keywordflow}{return};
00509     \}
00510 
00511     buf[0] = prefix;
00512     len = ll2string(buf+1,\textcolor{keyword}{sizeof}(buf)-1,ll);
00513     buf[len+1] = \textcolor{stringliteral}{'\(\backslash\)r'};
00514     buf[len+2] = \textcolor{stringliteral}{'\(\backslash\)n'};
00515     addReplyString(c,buf,len+3);
00516 \}
00517 
00518 \textcolor{keywordtype}{void} addReplyLongLong(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ll) \{
00519     \textcolor{keywordflow}{if} (ll == 0)
00520         addReply(c,shared.czero);
00521     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ll == 1)
00522         addReply(c,shared.cone);
00523     \textcolor{keywordflow}{else}
00524         addReplyLongLongWithPrefix(c,ll,\textcolor{stringliteral}{':'});
00525 \}
00526 
00527 \textcolor{keywordtype}{void} addReplyMultiBulkLen(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{long} length) \{
00528     \textcolor{keywordflow}{if} (length < \hyperlink{server_8h_aff2f6e62c729d3f8b119d761818be317}{OBJ\_SHARED\_BULKHDR\_LEN})
00529         addReply(c,shared.mbulkhdr[length]);
00530     \textcolor{keywordflow}{else}
00531         addReplyLongLongWithPrefix(c,length,\textcolor{stringliteral}{'*'});
00532 \}
00533 
00534 \textcolor{comment}{/* Create the length prefix of a bulk reply, example: $2234 */}
00535 \textcolor{keywordtype}{void} addReplyBulkLen(\hyperlink{structclient}{client} *c, robj *obj) \{
00536     size\_t len;
00537 
00538     \textcolor{keywordflow}{if} (\hyperlink{server_8h_afcfb5bd97af52d1dbce331745cae030c}{sdsEncodedObject}(obj)) \{
00539         len = sdslen(obj->ptr);
00540     \} \textcolor{keywordflow}{else} \{
00541         \textcolor{keywordtype}{long} n = (\textcolor{keywordtype}{long})obj->ptr;
00542 
00543         \textcolor{comment}{/* Compute how many bytes will take this integer as a radix 10 string */}
00544         len = 1;
00545         \textcolor{keywordflow}{if} (n < 0) \{
00546             len++;
00547             n = -n;
00548         \}
00549         \textcolor{keywordflow}{while}((n = n/10) != 0) \{
00550             len++;
00551         \}
00552     \}
00553 
00554     \textcolor{keywordflow}{if} (len < \hyperlink{server_8h_aff2f6e62c729d3f8b119d761818be317}{OBJ\_SHARED\_BULKHDR\_LEN})
00555         addReply(c,shared.bulkhdr[len]);
00556     \textcolor{keywordflow}{else}
00557         addReplyLongLongWithPrefix(c,len,\textcolor{stringliteral}{'$'});
00558 \}
00559 
00560 \textcolor{comment}{/* Add a Redis Object as a bulk reply */}
00561 \textcolor{keywordtype}{void} addReplyBulk(\hyperlink{structclient}{client} *c, robj *obj) \{
00562     addReplyBulkLen(c,obj);
00563     addReply(c,obj);
00564     addReply(c,shared.crlf);
00565 \}
00566 
00567 \textcolor{comment}{/* Add a C buffer as bulk reply */}
00568 \textcolor{keywordtype}{void} addReplyBulkCBuffer(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *p, size\_t len) \{
00569     addReplyLongLongWithPrefix(c,len,\textcolor{stringliteral}{'$'});
00570     addReplyString(c,p,len);
00571     addReply(c,shared.crlf);
00572 \}
00573 
00574 \textcolor{comment}{/* Add sds to reply (takes ownership of sds and frees it) */}
00575 \textcolor{keywordtype}{void} addReplyBulkSds(\hyperlink{structclient}{client} *c, sds s)  \{
00576     addReplyLongLongWithPrefix(c,sdslen(s),\textcolor{stringliteral}{'$'});
00577     addReplySds(c,s);
00578     addReply(c,shared.crlf);
00579 \}
00580 
00581 \textcolor{comment}{/* Add a C null term string as bulk reply */}
00582 \textcolor{keywordtype}{void} addReplyBulkCString(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s) \{
00583     \textcolor{keywordflow}{if} (s == NULL) \{
00584         addReply(c,shared.nullbulk);
00585     \} \textcolor{keywordflow}{else} \{
00586         addReplyBulkCBuffer(c,s,strlen(s));
00587     \}
00588 \}
00589 
00590 \textcolor{comment}{/* Add a long long as a bulk reply */}
00591 \textcolor{keywordtype}{void} addReplyBulkLongLong(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ll) \{
00592     \textcolor{keywordtype}{char} buf[64];
00593     \textcolor{keywordtype}{int} len;
00594 
00595     len = ll2string(buf,64,ll);
00596     addReplyBulkCBuffer(c,buf,len);
00597 \}
00598 
00599 \textcolor{comment}{/* Add an array of C strings as status replies with a heading.}
00600 \textcolor{comment}{ * This function is typically invoked by from commands that support}
00601 \textcolor{comment}{ * subcommands in response to the 'help' subcommand. The help array}
00602 \textcolor{comment}{ * is terminated by NULL sentinel. */}
00603 \textcolor{keywordtype}{void} addReplyHelp(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **help) \{
00604     sds cmd = sdsnew((\textcolor{keywordtype}{char}*) c->argv[0]->ptr);
00605     \textcolor{keywordtype}{void} *blenp = addDeferredMultiBulkLength(c);
00606     \textcolor{keywordtype}{int} blen = 0;
00607 
00608     sdstoupper(cmd);
00609     addReplyStatusFormat(c,
00610         \textcolor{stringliteral}{"%s <subcommand> arg arg ... arg. Subcommands are:"},cmd);
00611     sdsfree(cmd);
00612 
00613     \textcolor{keywordflow}{while} (help[blen]) addReplyStatus(c,help[blen++]);
00614 
00615     blen++;  \textcolor{comment}{/* Account for the header line(s). */}
00616     setDeferredMultiBulkLength(c,blenp,blen);
00617 \}
00618 
00619 \textcolor{comment}{/* Copy 'src' client output buffers into 'dst' client output buffers.}
00620 \textcolor{comment}{ * The function takes care of freeing the old output buffers of the}
00621 \textcolor{comment}{ * destination client. */}
00622 \textcolor{keywordtype}{void} copyClientOutputBuffer(\hyperlink{structclient}{client} *dst, \hyperlink{structclient}{client} *src) \{
00623     listRelease(dst->reply);
00624     dst->reply = listDup(src->reply);
00625     memcpy(dst->buf,src->buf,src->bufpos);
00626     dst->bufpos = src->bufpos;
00627     dst->reply\_bytes = src->reply\_bytes;
00628 \}
00629 
00630 \textcolor{comment}{/* Return true if the specified client has pending reply buffers to write to}
00631 \textcolor{comment}{ * the socket. */}
00632 \textcolor{keywordtype}{int} clientHasPendingReplies(\hyperlink{structclient}{client} *c) \{
00633     \textcolor{keywordflow}{return} c->bufpos || \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(c->reply);
00634 \}
00635 
00636 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{MAX\_ACCEPTS\_PER\_CALL} 1000
00637 \textcolor{keyword}{static} \textcolor{keywordtype}{void} acceptCommonHandler(\textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{int} flags, \textcolor{keywordtype}{char} *ip) \{
00638     \hyperlink{structclient}{client} *c;
00639     \textcolor{keywordflow}{if} ((c = createClient(fd)) == NULL) \{
00640         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
00641             \textcolor{stringliteral}{"Error registering fd event for the new client: %s (fd=%d)"},
00642             strerror(errno),fd);
00643         close(fd); \textcolor{comment}{/* May be already closed, just ignore errors */}
00644         \textcolor{keywordflow}{return};
00645     \}
00646     \textcolor{comment}{/* If maxclient directive is set and this is one client more... close the}
00647 \textcolor{comment}{     * connection. Note that we create the client instead to check before}
00648 \textcolor{comment}{     * for this condition, since now the socket is already set in non-blocking}
00649 \textcolor{comment}{     * mode and we can send an error for free using the Kernel I/O */}
00650     \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.clients) > server.maxclients) \{
00651         \textcolor{keywordtype}{char} *err = \textcolor{stringliteral}{"-ERR max number of clients reached\(\backslash\)r\(\backslash\)n"};
00652 
00653         \textcolor{comment}{/* That's a best effort error message, don't check write errors */}
00654         \textcolor{keywordflow}{if} (write(c->fd,err,strlen(err)) == -1) \{
00655             \textcolor{comment}{/* Nothing to do, Just to avoid the warning... */}
00656         \}
00657         server.stat\_rejected\_conn++;
00658         freeClient(c);
00659         \textcolor{keywordflow}{return};
00660     \}
00661 
00662     \textcolor{comment}{/* If the server is running in protected mode (the default) and there}
00663 \textcolor{comment}{     * is no password set, nor a specific interface is bound, we don't accept}
00664 \textcolor{comment}{     * requests from non loopback interfaces. Instead we try to explain the}
00665 \textcolor{comment}{     * user what to do to fix it if needed. */}
00666     \textcolor{keywordflow}{if} (server.protected\_mode &&
00667         server.bindaddr\_count == 0 &&
00668         server.requirepass == NULL &&
00669         !(flags & \hyperlink{server_8h_ae19f45757ef3ffb2f3abb86cbc3b67a2}{CLIENT\_UNIX\_SOCKET}) &&
00670         ip != NULL)
00671     \{
00672         \textcolor{keywordflow}{if} (strcmp(ip,\textcolor{stringliteral}{"127.0.0.1"}) && strcmp(ip,\textcolor{stringliteral}{"::1"})) \{
00673             \textcolor{keywordtype}{char} *err =
00674                 \textcolor{stringliteral}{"-DENIED Redis is running in protected mode because protected "}
00675                 \textcolor{stringliteral}{"mode is enabled, no bind address was specified, no "}
00676                 \textcolor{stringliteral}{"authentication password is requested to clients. In this mode "}
00677                 \textcolor{stringliteral}{"connections are only accepted from the loopback interface. "}
00678                 \textcolor{stringliteral}{"If you want to connect from external computers to Redis you "}
00679                 \textcolor{stringliteral}{"may adopt one of the following solutions: "}
00680                 \textcolor{stringliteral}{"1) Just disable protected mode sending the command "}
00681                 \textcolor{stringliteral}{"'CONFIG SET protected-mode no' from the loopback interface "}
00682                 \textcolor{stringliteral}{"by connecting to Redis from the same host the server is "}
00683                 \textcolor{stringliteral}{"running, however MAKE SURE Redis is not publicly accessible "}
00684                 \textcolor{stringliteral}{"from internet if you do so. Use CONFIG REWRITE to make this "}
00685                 \textcolor{stringliteral}{"change permanent. "}
00686                 \textcolor{stringliteral}{"2) Alternatively you can just disable the protected mode by "}
00687                 \textcolor{stringliteral}{"editing the Redis configuration file, and setting the protected "}
00688                 \textcolor{stringliteral}{"mode option to 'no', and then restarting the server. "}
00689                 \textcolor{stringliteral}{"3) If you started the server manually just for testing, restart "}
00690                 \textcolor{stringliteral}{"it with the '--protected-mode no' option. "}
00691                 \textcolor{stringliteral}{"4) Setup a bind address or an authentication password. "}
00692                 \textcolor{stringliteral}{"NOTE: You only need to do one of the above things in order for "}
00693                 \textcolor{stringliteral}{"the server to start accepting connections from the outside.\(\backslash\)r\(\backslash\)n"};
00694             \textcolor{keywordflow}{if} (write(c->fd,err,strlen(err)) == -1) \{
00695                 \textcolor{comment}{/* Nothing to do, Just to avoid the warning... */}
00696             \}
00697             server.stat\_rejected\_conn++;
00698             freeClient(c);
00699             \textcolor{keywordflow}{return};
00700         \}
00701     \}
00702 
00703     server.stat\_numconnections++;
00704     c->flags |= flags;
00705 \}
00706 
00707 \textcolor{keywordtype}{void} acceptTcpHandler(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask) \{
00708     \textcolor{keywordtype}{int} cport, cfd, max = \hyperlink{networking_8c_a49d737d8dce68303493f75ea5512ca16}{MAX\_ACCEPTS\_PER\_CALL};
00709     \textcolor{keywordtype}{char} cip[\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN}];
00710     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(el);
00711     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(mask);
00712     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(privdata);
00713 
00714     \textcolor{keywordflow}{while}(max--) \{
00715         cfd = anetTcpAccept(server.neterr, fd, cip, \textcolor{keyword}{sizeof}(cip), &cport);
00716         \textcolor{keywordflow}{if} (cfd == \hyperlink{anet_8h_a0697b7774a7e0f4ef141839fe93536fe}{ANET\_ERR}) \{
00717             \textcolor{keywordflow}{if} (errno != EWOULDBLOCK)
00718                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
00719                     \textcolor{stringliteral}{"Accepting client connection: %s"}, server.neterr);
00720             \textcolor{keywordflow}{return};
00721         \}
00722         serverLog(\hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE},\textcolor{stringliteral}{"Accepted %s:%d"}, cip, cport);
00723         acceptCommonHandler(cfd,0,cip);
00724     \}
00725 \}
00726 
00727 \textcolor{keywordtype}{void} acceptUnixHandler(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask) \{
00728     \textcolor{keywordtype}{int} cfd, max = \hyperlink{networking_8c_a49d737d8dce68303493f75ea5512ca16}{MAX\_ACCEPTS\_PER\_CALL};
00729     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(el);
00730     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(mask);
00731     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(privdata);
00732 
00733     \textcolor{keywordflow}{while}(max--) \{
00734         cfd = anetUnixAccept(server.neterr, fd);
00735         \textcolor{keywordflow}{if} (cfd == \hyperlink{anet_8h_a0697b7774a7e0f4ef141839fe93536fe}{ANET\_ERR}) \{
00736             \textcolor{keywordflow}{if} (errno != EWOULDBLOCK)
00737                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
00738                     \textcolor{stringliteral}{"Accepting client connection: %s"}, server.neterr);
00739             \textcolor{keywordflow}{return};
00740         \}
00741         serverLog(\hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE},\textcolor{stringliteral}{"Accepted connection to %s"}, server.unixsocket);
00742         acceptCommonHandler(cfd,\hyperlink{server_8h_ae19f45757ef3ffb2f3abb86cbc3b67a2}{CLIENT\_UNIX\_SOCKET},NULL);
00743     \}
00744 \}
00745 
00746 \textcolor{keyword}{static} \textcolor{keywordtype}{void} freeClientArgv(\hyperlink{structclient}{client} *c) \{
00747     \textcolor{keywordtype}{int} j;
00748     \textcolor{keywordflow}{for} (j = 0; j < c->argc; j++)
00749         decrRefCount(c->argv[j]);
00750     c->argc = 0;
00751     c->cmd = NULL;
00752 \}
00753 
00754 \textcolor{comment}{/* Close all the slaves connections. This is useful in chained replication}
00755 \textcolor{comment}{ * when we resync with our own master and want to force all our slaves to}
00756 \textcolor{comment}{ * resync with us as well. */}
00757 \textcolor{keywordtype}{void} disconnectSlaves(\textcolor{keywordtype}{void}) \{
00758     \textcolor{keywordflow}{while} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.slaves)) \{
00759         listNode *ln = \hyperlink{adlist_8h_aa8dc514bbe217bb2e87c1c77cfa84690}{listFirst}(server.slaves);
00760         freeClient((\hyperlink{structclient}{client}*)ln->value);
00761     \}
00762 \}
00763 
00764 \textcolor{comment}{/* Remove the specified client from global lists where the client could}
00765 \textcolor{comment}{ * be referenced, not including the Pub/Sub channels.}
00766 \textcolor{comment}{ * This is used by freeClient() and replicationCacheMaster(). */}
00767 \textcolor{keywordtype}{void} unlinkClient(\hyperlink{structclient}{client} *c) \{
00768     listNode *ln;
00769 
00770     \textcolor{comment}{/* If this is marked as current client unset it. */}
00771     \textcolor{keywordflow}{if} (server.current\_client == c) server.current\_client = NULL;
00772 
00773     \textcolor{comment}{/* Certain operations must be done only if the client has an active socket.}
00774 \textcolor{comment}{     * If the client was already unlinked or if it's a "fake client" the}
00775 \textcolor{comment}{     * fd is already set to -1. */}
00776     \textcolor{keywordflow}{if} (c->fd != -1) \{
00777         \textcolor{comment}{/* Remove from the list of active clients. */}
00778         \textcolor{keywordflow}{if} (c->client\_list\_node) \{
00779             listDelNode(server.clients,c->client\_list\_node);
00780             c->client\_list\_node = NULL;
00781         \}
00782 
00783         \textcolor{comment}{/* Unregister async I/O handlers and close the socket. */}
00784         aeDeleteFileEvent(server.el,c->fd,\hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE});
00785         aeDeleteFileEvent(server.el,c->fd,\hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE});
00786         close(c->fd);
00787         c->fd = -1;
00788     \}
00789 
00790     \textcolor{comment}{/* Remove from the list of pending writes if needed. */}
00791     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_addd2e991874faef411339e9ae9619023}{CLIENT\_PENDING\_WRITE}) \{
00792         ln = listSearchKey(server.clients\_pending\_write,c);
00793         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(ln != NULL);
00794         listDelNode(server.clients\_pending\_write,ln);
00795         c->flags &= ~\hyperlink{server_8h_addd2e991874faef411339e9ae9619023}{CLIENT\_PENDING\_WRITE};
00796     \}
00797 
00798     \textcolor{comment}{/* When client was just unblocked because of a blocking operation,}
00799 \textcolor{comment}{     * remove it from the list of unblocked clients. */}
00800     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a1252372d6834686c29e958d9d96367a8}{CLIENT\_UNBLOCKED}) \{
00801         ln = listSearchKey(server.unblocked\_clients,c);
00802         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(ln != NULL);
00803         listDelNode(server.unblocked\_clients,ln);
00804         c->flags &= ~\hyperlink{server_8h_a1252372d6834686c29e958d9d96367a8}{CLIENT\_UNBLOCKED};
00805     \}
00806 \}
00807 
00808 \textcolor{keywordtype}{void} freeClient(\hyperlink{structclient}{client} *c) \{
00809     listNode *ln;
00810 
00811     \textcolor{comment}{/* If it is our master that's beging disconnected we should make sure}
00812 \textcolor{comment}{     * to cache the state to try a partial resynchronization later.}
00813 \textcolor{comment}{     *}
00814 \textcolor{comment}{     * Note that before doing this we make sure that the client is not in}
00815 \textcolor{comment}{     * some unexpected state, by checking its flags. */}
00816     \textcolor{keywordflow}{if} (server.master && c->flags & \hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER}) \{
00817         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Connection with master lost."});
00818         \textcolor{keywordflow}{if} (!(c->flags & (\hyperlink{server_8h_a8cff2154afcc2e87ac85bdbbe2814091}{CLIENT\_CLOSE\_AFTER\_REPLY}|
00819                           \hyperlink{server_8h_ad6690c6231b67525b8b2057e092a8361}{CLIENT\_CLOSE\_ASAP}|
00820                           \hyperlink{server_8h_a503ad979164a52f0f5e2a63e4c7da3a0}{CLIENT\_BLOCKED}|
00821                           \hyperlink{server_8h_a1252372d6834686c29e958d9d96367a8}{CLIENT\_UNBLOCKED})))
00822         \{
00823             replicationCacheMaster(c);
00824             \textcolor{keywordflow}{return};
00825         \}
00826     \}
00827 
00828     \textcolor{comment}{/* Log link disconnection with slave */}
00829     \textcolor{keywordflow}{if} ((c->flags & \hyperlink{server_8h_ae9f6995948253652bc9454d79a72f4a7}{CLIENT\_SLAVE}) && !(c->flags & 
      \hyperlink{server_8h_a7724350e4f0ddbf1c80740699fac78be}{CLIENT\_MONITOR})) \{
00830         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Connection with slave %s lost."},
00831             replicationGetSlaveName(c));
00832     \}
00833 
00834     \textcolor{comment}{/* Free the query buffer */}
00835     sdsfree(c->querybuf);
00836     sdsfree(c->pending\_querybuf);
00837     c->querybuf = NULL;
00838 
00839     \textcolor{comment}{/* Deallocate structures used to block on blocking ops. */}
00840     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a503ad979164a52f0f5e2a63e4c7da3a0}{CLIENT\_BLOCKED}) unblockClient(c);
00841     dictRelease(c->bpop.keys);
00842 
00843     \textcolor{comment}{/* UNWATCH all the keys */}
00844     unwatchAllKeys(c);
00845     listRelease(c->watched\_keys);
00846 
00847     \textcolor{comment}{/* Unsubscribe from all the pubsub channels */}
00848     pubsubUnsubscribeAllChannels(c,0);
00849     pubsubUnsubscribeAllPatterns(c,0);
00850     dictRelease(c->pubsub\_channels);
00851     listRelease(c->pubsub\_patterns);
00852 
00853     \textcolor{comment}{/* Free data structures. */}
00854     listRelease(c->reply);
00855     freeClientArgv(c);
00856 
00857     \textcolor{comment}{/* Unlink the client: this will close the socket, remove the I/O}
00858 \textcolor{comment}{     * handlers, and remove references of the client from different}
00859 \textcolor{comment}{     * places where active clients may be referenced. */}
00860     unlinkClient(c);
00861 
00862     \textcolor{comment}{/* Master/slave cleanup Case 1:}
00863 \textcolor{comment}{     * we lost the connection with a slave. */}
00864     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_ae9f6995948253652bc9454d79a72f4a7}{CLIENT\_SLAVE}) \{
00865         \textcolor{keywordflow}{if} (c->replstate == \hyperlink{server_8h_ada38427ad2d0c09875081868a53cc51f}{SLAVE\_STATE\_SEND\_BULK}) \{
00866             \textcolor{keywordflow}{if} (c->repldbfd != -1) close(c->repldbfd);
00867             \textcolor{keywordflow}{if} (c->replpreamble) sdsfree(c->replpreamble);
00868         \}
00869         list *l = (c->flags & \hyperlink{server_8h_a7724350e4f0ddbf1c80740699fac78be}{CLIENT\_MONITOR}) ? server.monitors : server.slaves;
00870         ln = listSearchKey(l,c);
00871         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(ln != NULL);
00872         listDelNode(l,ln);
00873         \textcolor{comment}{/* We need to remember the time when we started to have zero}
00874 \textcolor{comment}{         * attached slaves, as after some time we'll free the replication}
00875 \textcolor{comment}{         * backlog. */}
00876         \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_ae9f6995948253652bc9454d79a72f4a7}{CLIENT\_SLAVE} && \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.slaves) == 0)
00877             server.repl\_no\_slaves\_since = server.unixtime;
00878         refreshGoodSlavesCount();
00879     \}
00880 
00881     \textcolor{comment}{/* Master/slave cleanup Case 2:}
00882 \textcolor{comment}{     * we lost the connection with the master. */}
00883     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER}) replicationHandleMasterDisconnection();
00884 
00885     \textcolor{comment}{/* If this client was scheduled for async freeing we need to remove it}
00886 \textcolor{comment}{     * from the queue. */}
00887     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_ad6690c6231b67525b8b2057e092a8361}{CLIENT\_CLOSE\_ASAP}) \{
00888         ln = listSearchKey(server.clients\_to\_close,c);
00889         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(ln != NULL);
00890         listDelNode(server.clients\_to\_close,ln);
00891     \}
00892 
00893     \textcolor{comment}{/* Release other dynamically allocated client structure fields,}
00894 \textcolor{comment}{     * and finally release the client structure itself. */}
00895     \textcolor{keywordflow}{if} (c->name) decrRefCount(c->name);
00896     zfree(c->argv);
00897     freeClientMultiState(c);
00898     sdsfree(c->peerid);
00899     zfree(c);
00900 \}
00901 
00902 \textcolor{comment}{/* Schedule a client to free it at a safe time in the serverCron() function.}
00903 \textcolor{comment}{ * This function is useful when we need to terminate a client but we are in}
00904 \textcolor{comment}{ * a context where calling freeClient() is not possible, because the client}
00905 \textcolor{comment}{ * should be valid for the continuation of the flow of the program. */}
00906 \textcolor{keywordtype}{void} freeClientAsync(\hyperlink{structclient}{client} *c) \{
00907     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_ad6690c6231b67525b8b2057e092a8361}{CLIENT\_CLOSE\_ASAP} || c->flags & 
      \hyperlink{server_8h_af9d0b0f45ef2c1fd29ac714a300de706}{CLIENT\_LUA}) \textcolor{keywordflow}{return};
00908     c->flags |= \hyperlink{server_8h_ad6690c6231b67525b8b2057e092a8361}{CLIENT\_CLOSE\_ASAP};
00909     listAddNodeTail(server.clients\_to\_close,c);
00910 \}
00911 
00912 \textcolor{keywordtype}{void} freeClientsInAsyncFreeQueue(\textcolor{keywordtype}{void}) \{
00913     \textcolor{keywordflow}{while} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.clients\_to\_close)) \{
00914         listNode *ln = \hyperlink{adlist_8h_aa8dc514bbe217bb2e87c1c77cfa84690}{listFirst}(server.clients\_to\_close);
00915         \hyperlink{structclient}{client} *c = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
00916 
00917         c->flags &= ~\hyperlink{server_8h_ad6690c6231b67525b8b2057e092a8361}{CLIENT\_CLOSE\_ASAP};
00918         freeClient(c);
00919         listDelNode(server.clients\_to\_close,ln);
00920     \}
00921 \}
00922 
00923 \textcolor{comment}{/* Write data in output buffers to client. Return C\_OK if the client}
00924 \textcolor{comment}{ * is still valid after the call, C\_ERR if it was freed. */}
00925 \textcolor{keywordtype}{int} writeToClient(\textcolor{keywordtype}{int} fd, \hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} handler\_installed) \{
00926     ssize\_t nwritten = 0, totwritten = 0;
00927     size\_t objlen;
00928     sds o;
00929 
00930     \textcolor{keywordflow}{while}(clientHasPendingReplies(c)) \{
00931         \textcolor{keywordflow}{if} (c->bufpos > 0) \{
00932             nwritten = write(fd,c->buf+c->sentlen,c->bufpos-c->sentlen);
00933             \textcolor{keywordflow}{if} (nwritten <= 0) \textcolor{keywordflow}{break};
00934             c->sentlen += nwritten;
00935             totwritten += nwritten;
00936 
00937             \textcolor{comment}{/* If the buffer was sent, set bufpos to zero to continue with}
00938 \textcolor{comment}{             * the remainder of the reply. */}
00939             \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{int})c->sentlen == c->bufpos) \{
00940                 c->bufpos = 0;
00941                 c->sentlen = 0;
00942             \}
00943         \} \textcolor{keywordflow}{else} \{
00944             o = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(\hyperlink{adlist_8h_aa8dc514bbe217bb2e87c1c77cfa84690}{listFirst}(c->reply));
00945             objlen = sdslen(o);
00946 
00947             \textcolor{keywordflow}{if} (objlen == 0) \{
00948                 listDelNode(c->reply,\hyperlink{adlist_8h_aa8dc514bbe217bb2e87c1c77cfa84690}{listFirst}(c->reply));
00949                 \textcolor{keywordflow}{continue};
00950             \}
00951 
00952             nwritten = write(fd, o + c->sentlen, objlen - c->sentlen);
00953             \textcolor{keywordflow}{if} (nwritten <= 0) \textcolor{keywordflow}{break};
00954             c->sentlen += nwritten;
00955             totwritten += nwritten;
00956 
00957             \textcolor{comment}{/* If we fully sent the object on head go to the next one */}
00958             \textcolor{keywordflow}{if} (c->sentlen == objlen) \{
00959                 listDelNode(c->reply,\hyperlink{adlist_8h_aa8dc514bbe217bb2e87c1c77cfa84690}{listFirst}(c->reply));
00960                 c->sentlen = 0;
00961                 c->reply\_bytes -= objlen;
00962                 \textcolor{comment}{/* If there are no longer objects in the list, we expect}
00963 \textcolor{comment}{                 * the count of reply bytes to be exactly zero. */}
00964                 \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(c->reply) == 0)
00965                     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(c->reply\_bytes == 0);
00966             \}
00967         \}
00968         \textcolor{comment}{/* Note that we avoid to send more than NET\_MAX\_WRITES\_PER\_EVENT}
00969 \textcolor{comment}{         * bytes, in a single threaded server it's a good idea to serve}
00970 \textcolor{comment}{         * other clients as well, even if a very large request comes from}
00971 \textcolor{comment}{         * super fast link that is always able to accept data (in real world}
00972 \textcolor{comment}{         * scenario think about 'KEYS *' against the loopback interface).}
00973 \textcolor{comment}{         *}
00974 \textcolor{comment}{         * However if we are over the maxmemory limit we ignore that and}
00975 \textcolor{comment}{         * just deliver as much data as it is possible to deliver. */}
00976         \textcolor{keywordflow}{if} (totwritten > \hyperlink{server_8h_abbdb0d4ea3a77e70614d6b0cd0311c61}{NET\_MAX\_WRITES\_PER\_EVENT} &&
00977             (server.maxmemory == 0 ||
00978              zmalloc\_used\_memory() < server.maxmemory)) \textcolor{keywordflow}{break};
00979     \}
00980     server.stat\_net\_output\_bytes += totwritten;
00981     \textcolor{keywordflow}{if} (nwritten == -1) \{
00982         \textcolor{keywordflow}{if} (errno == EAGAIN) \{
00983             nwritten = 0;
00984         \} \textcolor{keywordflow}{else} \{
00985             serverLog(\hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE},
00986                 \textcolor{stringliteral}{"Error writing to client: %s"}, strerror(errno));
00987             freeClient(c);
00988             \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00989         \}
00990     \}
00991     \textcolor{keywordflow}{if} (totwritten > 0) \{
00992         \textcolor{comment}{/* For clients representing masters we don't count sending data}
00993 \textcolor{comment}{         * as an interaction, since we always send REPLCONF ACK commands}
00994 \textcolor{comment}{         * that take some time to just fill the socket output buffer.}
00995 \textcolor{comment}{         * We just rely on data / pings received for timeout detection. */}
00996         \textcolor{keywordflow}{if} (!(c->flags & \hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER})) c->lastinteraction = server.unixtime;
00997     \}
00998     \textcolor{keywordflow}{if} (!clientHasPendingReplies(c)) \{
00999         c->sentlen = 0;
01000         \textcolor{keywordflow}{if} (handler\_installed) aeDeleteFileEvent(server.el,c->fd,
      \hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE});
01001 
01002         \textcolor{comment}{/* Close connection after entire reply has been sent. */}
01003         \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a8cff2154afcc2e87ac85bdbbe2814091}{CLIENT\_CLOSE\_AFTER\_REPLY}) \{
01004             freeClient(c);
01005             \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01006         \}
01007     \}
01008     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01009 \}
01010 
01011 \textcolor{comment}{/* Write event handler. Just send data to the client. */}
01012 \textcolor{keywordtype}{void} sendReplyToClient(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask) \{
01013     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(el);
01014     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(mask);
01015     writeToClient(fd,privdata,1);
01016 \}
01017 
01018 \textcolor{comment}{/* This function is called just before entering the event loop, in the hope}
01019 \textcolor{comment}{ * we can just write the replies to the client output buffer without any}
01020 \textcolor{comment}{ * need to use a syscall in order to install the writable event handler,}
01021 \textcolor{comment}{ * get it called, and so forth. */}
01022 \textcolor{keywordtype}{int} handleClientsWithPendingWrites(\textcolor{keywordtype}{void}) \{
01023     listIter li;
01024     listNode *ln;
01025     \textcolor{keywordtype}{int} processed = \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.clients\_pending\_write);
01026 
01027     listRewind(server.clients\_pending\_write,&li);
01028     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
01029         \hyperlink{structclient}{client} *c = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
01030         c->flags &= ~\hyperlink{server_8h_addd2e991874faef411339e9ae9619023}{CLIENT\_PENDING\_WRITE};
01031         listDelNode(server.clients\_pending\_write,ln);
01032 
01033         \textcolor{comment}{/* Try to write buffers to the client socket. */}
01034         \textcolor{keywordflow}{if} (writeToClient(c->fd,c,0) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \textcolor{keywordflow}{continue};
01035 
01036         \textcolor{comment}{/* If there is nothing left, do nothing. Otherwise install}
01037 \textcolor{comment}{         * the write handler. */}
01038         \textcolor{keywordflow}{if} (clientHasPendingReplies(c) &&
01039             aeCreateFileEvent(server.el, c->fd, \hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE},
01040                 sendReplyToClient, c) == \hyperlink{ae_8h_aa16dcf7effdf8f8df97f51b1cb51a9df}{AE\_ERR})
01041         \{
01042             freeClientAsync(c);
01043         \}
01044     \}
01045     \textcolor{keywordflow}{return} processed;
01046 \}
01047 
01048 \textcolor{comment}{/* resetClient prepare the client to process the next command */}
01049 \textcolor{keywordtype}{void} resetClient(\hyperlink{structclient}{client} *c) \{
01050     redisCommandProc *prevcmd = c->cmd ? c->cmd->proc : NULL;
01051 
01052     freeClientArgv(c);
01053     c->reqtype = 0;
01054     c->multibulklen = 0;
01055     c->bulklen = -1;
01056 
01057     \textcolor{comment}{/* We clear the ASKING flag as well if we are not inside a MULTI, and}
01058 \textcolor{comment}{     * if what we just executed is not the ASKING command itself. */}
01059     \textcolor{keywordflow}{if} (!(c->flags & \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI}) && prevcmd != askingCommand)
01060         c->flags &= ~\hyperlink{server_8h_a108ac316dfd847430daf3c97f28557d3}{CLIENT\_ASKING};
01061 
01062     \textcolor{comment}{/* Remove the CLIENT\_REPLY\_SKIP flag if any so that the reply}
01063 \textcolor{comment}{     * to the next command will be sent, but set the flag if the command}
01064 \textcolor{comment}{     * we just processed was "CLIENT REPLY SKIP". */}
01065     c->flags &= ~\hyperlink{server_8h_a792a906c445537043944477fdaad11f4}{CLIENT\_REPLY\_SKIP};
01066     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a8d5a7abb547f5b34961d11900bd95b00}{CLIENT\_REPLY\_SKIP\_NEXT}) \{
01067         c->flags |= \hyperlink{server_8h_a792a906c445537043944477fdaad11f4}{CLIENT\_REPLY\_SKIP};
01068         c->flags &= ~\hyperlink{server_8h_a8d5a7abb547f5b34961d11900bd95b00}{CLIENT\_REPLY\_SKIP\_NEXT};
01069     \}
01070 \}
01071 
01072 \textcolor{comment}{/* Like processMultibulkBuffer(), but for the inline protocol instead of RESP,}
01073 \textcolor{comment}{ * this function consumes the client query buffer and creates a command ready}
01074 \textcolor{comment}{ * to be executed inside the client structure. Returns C\_OK if the command}
01075 \textcolor{comment}{ * is ready to be executed, or C\_ERR if there is still protocol to read to}
01076 \textcolor{comment}{ * have a well formed command. The function also returns C\_ERR when there is}
01077 \textcolor{comment}{ * a protocol error: in such a case the client structure is setup to reply}
01078 \textcolor{comment}{ * with the error and close the connection. */}
01079 \textcolor{keywordtype}{int} processInlineBuffer(\hyperlink{structclient}{client} *c) \{
01080     \textcolor{keywordtype}{char} *newline;
01081     \textcolor{keywordtype}{int} argc, j;
01082     sds *argv, aux;
01083     size\_t querylen;
01084 
01085     \textcolor{comment}{/* Search for end of line */}
01086     newline = strchr(c->querybuf,\textcolor{stringliteral}{'\(\backslash\)n'});
01087 
01088     \textcolor{comment}{/* Nothing to do without a \(\backslash\)r\(\backslash\)n */}
01089     \textcolor{keywordflow}{if} (newline == NULL) \{
01090         \textcolor{keywordflow}{if} (sdslen(c->querybuf) > \hyperlink{server_8h_a8214e9e04b3a27e8e38d35cda0f55874}{PROTO\_INLINE\_MAX\_SIZE}) \{
01091             addReplyError(c,\textcolor{stringliteral}{"Protocol error: too big inline request"});
01092             setProtocolError(\textcolor{stringliteral}{"too big inline request"},c,0);
01093         \}
01094         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01095     \}
01096 
01097     \textcolor{comment}{/* Handle the \(\backslash\)r\(\backslash\)n case. */}
01098     \textcolor{keywordflow}{if} (newline && newline != c->querybuf && *(newline-1) == \textcolor{stringliteral}{'\(\backslash\)r'})
01099         newline--;
01100 
01101     \textcolor{comment}{/* Split the input buffer up to the \(\backslash\)r\(\backslash\)n */}
01102     querylen = newline-(c->querybuf);
01103     aux = sdsnewlen(c->querybuf,querylen);
01104     argv = sdssplitargs(aux,&argc);
01105     sdsfree(aux);
01106     \textcolor{keywordflow}{if} (argv == NULL) \{
01107         addReplyError(c,\textcolor{stringliteral}{"Protocol error: unbalanced quotes in request"});
01108         setProtocolError(\textcolor{stringliteral}{"unbalanced quotes in inline request"},c,0);
01109         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01110     \}
01111 
01112     \textcolor{comment}{/* Newline from slaves can be used to refresh the last ACK time.}
01113 \textcolor{comment}{     * This is useful for a slave to ping back while loading a big}
01114 \textcolor{comment}{     * RDB file. */}
01115     \textcolor{keywordflow}{if} (querylen == 0 && c->flags & \hyperlink{server_8h_ae9f6995948253652bc9454d79a72f4a7}{CLIENT\_SLAVE})
01116         c->repl\_ack\_time = server.unixtime;
01117 
01118     \textcolor{comment}{/* Leave data after the first line of the query in the buffer */}
01119     sdsrange(c->querybuf,querylen+2,-1);
01120 
01121     \textcolor{comment}{/* Setup argv array on client structure */}
01122     \textcolor{keywordflow}{if} (argc) \{
01123         \textcolor{keywordflow}{if} (c->argv) zfree(c->argv);
01124         c->argv = zmalloc(\textcolor{keyword}{sizeof}(robj*)*argc);
01125     \}
01126 
01127     \textcolor{comment}{/* Create redis objects for all arguments. */}
01128     \textcolor{keywordflow}{for} (c->argc = 0, j = 0; j < argc; j++) \{
01129         \textcolor{keywordflow}{if} (sdslen(argv[j])) \{
01130             c->argv[c->argc] = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},argv[j]);
01131             c->argc++;
01132         \} \textcolor{keywordflow}{else} \{
01133             sdsfree(argv[j]);
01134         \}
01135     \}
01136     zfree(argv);
01137     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01138 \}
01139 
01140 \textcolor{comment}{/* Helper function. Trims query buffer to make the function that processes}
01141 \textcolor{comment}{ * multi bulk requests idempotent. */}
01142 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{PROTO\_DUMP\_LEN} 128
01143 \textcolor{keyword}{static} \textcolor{keywordtype}{void} setProtocolError(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *errstr, \hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} pos) \{
01144     \textcolor{keywordflow}{if} (server.verbosity <= \hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE}) \{
01145         sds client = catClientInfoString(sdsempty(),c);
01146 
01147         \textcolor{comment}{/* Sample some protocol to given an idea about what was inside. */}
01148         \textcolor{keywordtype}{char} buf[256];
01149         \textcolor{keywordflow}{if} (sdslen(c->querybuf) < \hyperlink{networking_8c_a2731718953e1ee7483e585b664ae8cb7}{PROTO\_DUMP\_LEN}) \{
01150             snprintf(buf,\textcolor{keyword}{sizeof}(buf),\textcolor{stringliteral}{"Query buffer during protocol error: '%s'"}, c->querybuf);
01151         \} \textcolor{keywordflow}{else} \{
01152             snprintf(buf,\textcolor{keyword}{sizeof}(buf),\textcolor{stringliteral}{"Query buffer during protocol error: '%.*s' (... more %zu bytes
       ...) '%.*s'"}, \hyperlink{networking_8c_a2731718953e1ee7483e585b664ae8cb7}{PROTO\_DUMP\_LEN}/2, c->querybuf, sdslen(c->querybuf)-
      \hyperlink{networking_8c_a2731718953e1ee7483e585b664ae8cb7}{PROTO\_DUMP\_LEN}, \hyperlink{networking_8c_a2731718953e1ee7483e585b664ae8cb7}{PROTO\_DUMP\_LEN}/2, c->querybuf+sdslen(c->querybuf)-
      \hyperlink{networking_8c_a2731718953e1ee7483e585b664ae8cb7}{PROTO\_DUMP\_LEN}/2);
01153         \}
01154 
01155         \textcolor{comment}{/* Remove non printable chars. */}
01156         \textcolor{keywordtype}{char} *p = buf;
01157         \textcolor{keywordflow}{while} (*p != \textcolor{stringliteral}{'\(\backslash\)0'}) \{
01158             \textcolor{keywordflow}{if} (!isprint(*p)) *p = \textcolor{stringliteral}{'.'};
01159             p++;
01160         \}
01161 
01162         \textcolor{comment}{/* Log all the client and protocol info. */}
01163         serverLog(\hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE},
01164             \textcolor{stringliteral}{"Protocol error (%s) from client: %s. %s"}, errstr, client, buf);
01165         sdsfree(client);
01166     \}
01167     c->flags |= \hyperlink{server_8h_a8cff2154afcc2e87ac85bdbbe2814091}{CLIENT\_CLOSE\_AFTER\_REPLY};
01168     sdsrange(c->querybuf,pos,-1);
01169 \}
01170 
01171 \textcolor{comment}{/* Process the query buffer for client 'c', setting up the client argument}
01172 \textcolor{comment}{ * vector for command execution. Returns C\_OK if after running the function}
01173 \textcolor{comment}{ * the client has a well-formed ready to be processed command, otherwise}
01174 \textcolor{comment}{ * C\_ERR if there is still to read more buffer to get the full command.}
01175 \textcolor{comment}{ * The function also returns C\_ERR when there is a protocol error: in such a}
01176 \textcolor{comment}{ * case the client structure is setup to reply with the error and close}
01177 \textcolor{comment}{ * the connection.}
01178 \textcolor{comment}{ *}
01179 \textcolor{comment}{ * This function is called if processInputBuffer() detects that the next}
01180 \textcolor{comment}{ * command is in RESP format, so the first byte in the command is found}
01181 \textcolor{comment}{ * to be '*'. Otherwise for inline commands processInlineBuffer() is called. */}
01182 \textcolor{keywordtype}{int} processMultibulkBuffer(\hyperlink{structclient}{client} *c) \{
01183     \textcolor{keywordtype}{char} *newline = NULL;
01184     \textcolor{keywordtype}{int} pos = 0, ok;
01185     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ll;
01186 
01187     \textcolor{keywordflow}{if} (c->multibulklen == 0) \{
01188         \textcolor{comment}{/* The client should have been reset */}
01189         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,c->argc == 0);
01190 
01191         \textcolor{comment}{/* Multi bulk length cannot be read without a \(\backslash\)r\(\backslash\)n */}
01192         newline = strchr(c->querybuf,\textcolor{stringliteral}{'\(\backslash\)r'});
01193         \textcolor{keywordflow}{if} (newline == NULL) \{
01194             \textcolor{keywordflow}{if} (sdslen(c->querybuf) > \hyperlink{server_8h_a8214e9e04b3a27e8e38d35cda0f55874}{PROTO\_INLINE\_MAX\_SIZE}) \{
01195                 addReplyError(c,\textcolor{stringliteral}{"Protocol error: too big mbulk count string"});
01196                 setProtocolError(\textcolor{stringliteral}{"too big mbulk count string"},c,0);
01197             \}
01198             \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01199         \}
01200 
01201         \textcolor{comment}{/* Buffer should also contain \(\backslash\)n */}
01202         \textcolor{keywordflow}{if} (newline-(c->querybuf) > ((\textcolor{keywordtype}{signed})sdslen(c->querybuf)-2))
01203             \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01204 
01205         \textcolor{comment}{/* We know for sure there is a whole line since newline != NULL,}
01206 \textcolor{comment}{         * so go ahead and find out the multi bulk length. */}
01207         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,c->querybuf[0] == \textcolor{stringliteral}{'*'});
01208         ok = string2ll(c->querybuf+1,newline-(c->querybuf+1),&ll);
01209         \textcolor{keywordflow}{if} (!ok || ll > 1024*1024) \{
01210             addReplyError(c,\textcolor{stringliteral}{"Protocol error: invalid multibulk length"});
01211             setProtocolError(\textcolor{stringliteral}{"invalid mbulk count"},c,pos);
01212             \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01213         \}
01214 
01215         pos = (newline-c->querybuf)+2;
01216         \textcolor{keywordflow}{if} (ll <= 0) \{
01217             sdsrange(c->querybuf,pos,-1);
01218             \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01219         \}
01220 
01221         c->multibulklen = ll;
01222 
01223         \textcolor{comment}{/* Setup argv array on client structure */}
01224         \textcolor{keywordflow}{if} (c->argv) zfree(c->argv);
01225         c->argv = zmalloc(\textcolor{keyword}{sizeof}(robj*)*c->multibulklen);
01226     \}
01227 
01228     \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,c->multibulklen > 0);
01229     \textcolor{keywordflow}{while}(c->multibulklen) \{
01230         \textcolor{comment}{/* Read bulk length if unknown */}
01231         \textcolor{keywordflow}{if} (c->bulklen == -1) \{
01232             newline = strchr(c->querybuf+pos,\textcolor{stringliteral}{'\(\backslash\)r'});
01233             \textcolor{keywordflow}{if} (newline == NULL) \{
01234                 \textcolor{keywordflow}{if} (sdslen(c->querybuf) > \hyperlink{server_8h_a8214e9e04b3a27e8e38d35cda0f55874}{PROTO\_INLINE\_MAX\_SIZE}) \{
01235                     addReplyError(c,
01236                         \textcolor{stringliteral}{"Protocol error: too big bulk count string"});
01237                     setProtocolError(\textcolor{stringliteral}{"too big bulk count string"},c,0);
01238                     \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01239                 \}
01240                 \textcolor{keywordflow}{break};
01241             \}
01242 
01243             \textcolor{comment}{/* Buffer should also contain \(\backslash\)n */}
01244             \textcolor{keywordflow}{if} (newline-(c->querybuf) > ((\textcolor{keywordtype}{signed})sdslen(c->querybuf)-2))
01245                 \textcolor{keywordflow}{break};
01246 
01247             \textcolor{keywordflow}{if} (c->querybuf[pos] != \textcolor{stringliteral}{'$'}) \{
01248                 addReplyErrorFormat(c,
01249                     \textcolor{stringliteral}{"Protocol error: expected '$', got '%c'"},
01250                     c->querybuf[pos]);
01251                 setProtocolError(\textcolor{stringliteral}{"expected $ but got something else"},c,pos);
01252                 \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01253             \}
01254 
01255             ok = string2ll(c->querybuf+pos+1,newline-(c->querybuf+pos+1),&ll);
01256             \textcolor{keywordflow}{if} (!ok || ll < 0 || ll > 512*1024*1024) \{
01257                 addReplyError(c,\textcolor{stringliteral}{"Protocol error: invalid bulk length"});
01258                 setProtocolError(\textcolor{stringliteral}{"invalid bulk length"},c,pos);
01259                 \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01260             \}
01261 
01262             pos += newline-(c->querybuf+pos)+2;
01263             \textcolor{keywordflow}{if} (ll >= \hyperlink{server_8h_afb6bccf6f1ac66b1d563330ab499fb32}{PROTO\_MBULK\_BIG\_ARG}) \{
01264                 size\_t qblen;
01265 
01266                 \textcolor{comment}{/* If we are going to read a large object from network}
01267 \textcolor{comment}{                 * try to make it likely that it will start at c->querybuf}
01268 \textcolor{comment}{                 * boundary so that we can optimize object creation}
01269 \textcolor{comment}{                 * avoiding a large copy of data. */}
01270                 sdsrange(c->querybuf,pos,-1);
01271                 pos = 0;
01272                 qblen = sdslen(c->querybuf);
01273                 \textcolor{comment}{/* Hint the sds library about the amount of bytes this string is}
01274 \textcolor{comment}{                 * going to contain. */}
01275                 \textcolor{keywordflow}{if} (qblen < (size\_t)ll+2)
01276                     c->querybuf = sdsMakeRoomFor(c->querybuf,ll+2-qblen);
01277             \}
01278             c->bulklen = ll;
01279         \}
01280 
01281         \textcolor{comment}{/* Read bulk argument */}
01282         \textcolor{keywordflow}{if} (sdslen(c->querybuf)-pos < (\textcolor{keywordtype}{unsigned})(c->bulklen+2)) \{
01283             \textcolor{comment}{/* Not enough data (+2 == trailing \(\backslash\)r\(\backslash\)n) */}
01284             \textcolor{keywordflow}{break};
01285         \} \textcolor{keywordflow}{else} \{
01286             \textcolor{comment}{/* Optimization: if the buffer contains JUST our bulk element}
01287 \textcolor{comment}{             * instead of creating a new object by *copying* the sds we}
01288 \textcolor{comment}{             * just use the current sds string. */}
01289             \textcolor{keywordflow}{if} (pos == 0 &&
01290                 c->bulklen >= \hyperlink{server_8h_afb6bccf6f1ac66b1d563330ab499fb32}{PROTO\_MBULK\_BIG\_ARG} &&
01291                 (\textcolor{keywordtype}{signed}) sdslen(c->querybuf) == c->bulklen+2)
01292             \{
01293                 c->argv[c->argc++] = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},c->querybuf);
01294                 sdsIncrLen(c->querybuf,-2); \textcolor{comment}{/* remove CRLF */}
01295                 \textcolor{comment}{/* Assume that if we saw a fat argument we'll see another one}
01296 \textcolor{comment}{                 * likely... */}
01297                 c->querybuf = sdsnewlen(NULL,c->bulklen+2);
01298                 sdsclear(c->querybuf);
01299                 pos = 0;
01300             \} \textcolor{keywordflow}{else} \{
01301                 c->argv[c->argc++] =
01302                     createStringObject(c->querybuf+pos,c->bulklen);
01303                 pos += c->bulklen+2;
01304             \}
01305             c->bulklen = -1;
01306             c->multibulklen--;
01307         \}
01308     \}
01309 
01310     \textcolor{comment}{/* Trim to pos */}
01311     \textcolor{keywordflow}{if} (pos) sdsrange(c->querybuf,pos,-1);
01312 
01313     \textcolor{comment}{/* We're done when c->multibulk == 0 */}
01314     \textcolor{keywordflow}{if} (c->multibulklen == 0) \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01315 
01316     \textcolor{comment}{/* Still not ready to process the command */}
01317     \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01318 \}
01319 
01320 \textcolor{comment}{/* This function is called every time, in the client structure 'c', there is}
01321 \textcolor{comment}{ * more query buffer to process, because we read more data from the socket}
01322 \textcolor{comment}{ * or because a client was blocked and later reactivated, so there could be}
01323 \textcolor{comment}{ * pending query buffer, already representing a full command, to process. */}
01324 \textcolor{keywordtype}{void} processInputBuffer(\hyperlink{structclient}{client} *c) \{
01325     server.current\_client = c;
01326     \textcolor{comment}{/* Keep processing while there is something in the input buffer */}
01327     \textcolor{keywordflow}{while}(sdslen(c->querybuf)) \{
01328         \textcolor{comment}{/* Return if clients are paused. */}
01329         \textcolor{keywordflow}{if} (!(c->flags & \hyperlink{server_8h_ae9f6995948253652bc9454d79a72f4a7}{CLIENT\_SLAVE}) && clientsArePaused()) \textcolor{keywordflow}{break};
01330 
01331         \textcolor{comment}{/* Immediately abort if the client is in the middle of something. */}
01332         \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a503ad979164a52f0f5e2a63e4c7da3a0}{CLIENT\_BLOCKED}) \textcolor{keywordflow}{break};
01333 
01334         \textcolor{comment}{/* CLIENT\_CLOSE\_AFTER\_REPLY closes the connection once the reply is}
01335 \textcolor{comment}{         * written to the client. Make sure to not let the reply grow after}
01336 \textcolor{comment}{         * this flag has been set (i.e. don't process more commands).}
01337 \textcolor{comment}{         *}
01338 \textcolor{comment}{         * The same applies for clients we want to terminate ASAP. */}
01339         \textcolor{keywordflow}{if} (c->flags & (\hyperlink{server_8h_a8cff2154afcc2e87ac85bdbbe2814091}{CLIENT\_CLOSE\_AFTER\_REPLY}|
      \hyperlink{server_8h_ad6690c6231b67525b8b2057e092a8361}{CLIENT\_CLOSE\_ASAP})) \textcolor{keywordflow}{break};
01340 
01341         \textcolor{comment}{/* Determine request type when unknown. */}
01342         \textcolor{keywordflow}{if} (!c->reqtype) \{
01343             \textcolor{keywordflow}{if} (c->querybuf[0] == \textcolor{stringliteral}{'*'}) \{
01344                 c->reqtype = \hyperlink{server_8h_a50727b40ccd59633a681f9d09a9b9d72}{PROTO\_REQ\_MULTIBULK};
01345             \} \textcolor{keywordflow}{else} \{
01346                 c->reqtype = \hyperlink{server_8h_ad4314f4e8ae551ef0fd4e75c63eb5bc6}{PROTO\_REQ\_INLINE};
01347             \}
01348         \}
01349 
01350         \textcolor{keywordflow}{if} (c->reqtype == \hyperlink{server_8h_ad4314f4e8ae551ef0fd4e75c63eb5bc6}{PROTO\_REQ\_INLINE}) \{
01351             \textcolor{keywordflow}{if} (processInlineBuffer(c) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \textcolor{keywordflow}{break};
01352         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->reqtype == \hyperlink{server_8h_a50727b40ccd59633a681f9d09a9b9d72}{PROTO\_REQ\_MULTIBULK}) \{
01353             \textcolor{keywordflow}{if} (processMultibulkBuffer(c) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \textcolor{keywordflow}{break};
01354         \} \textcolor{keywordflow}{else} \{
01355             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown request type"});
01356         \}
01357 
01358         \textcolor{comment}{/* Multibulk processing could see a <= 0 length. */}
01359         \textcolor{keywordflow}{if} (c->argc == 0) \{
01360             resetClient(c);
01361         \} \textcolor{keywordflow}{else} \{
01362             \textcolor{comment}{/* Only reset the client when the command was executed. */}
01363             \textcolor{keywordflow}{if} (processCommand(c) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
01364                 \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER} && !(c->flags & 
      \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI})) \{
01365                     \textcolor{comment}{/* Update the applied replication offset of our master. */}
01366                     c->reploff = c->read\_reploff - sdslen(c->querybuf);
01367                 \}
01368 
01369                 \textcolor{comment}{/* Don't reset the client structure for clients blocked in a}
01370 \textcolor{comment}{                 * module blocking command, so that the reply callback will}
01371 \textcolor{comment}{                 * still be able to access the client argv and argc field.}
01372 \textcolor{comment}{                 * The client will be reset in unblockClientFromModule(). */}
01373                 \textcolor{keywordflow}{if} (!(c->flags & \hyperlink{server_8h_a503ad979164a52f0f5e2a63e4c7da3a0}{CLIENT\_BLOCKED}) || c->btype != 
      \hyperlink{server_8h_a6bdaa78b1c4c376ebf666afb891ace42}{BLOCKED\_MODULE})
01374                     resetClient(c);
01375             \}
01376             \textcolor{comment}{/* freeMemoryIfNeeded may flush slave output buffers. This may}
01377 \textcolor{comment}{             * result into a slave, that may be the active client, to be}
01378 \textcolor{comment}{             * freed. */}
01379             \textcolor{keywordflow}{if} (server.current\_client == NULL) \textcolor{keywordflow}{break};
01380         \}
01381     \}
01382     server.current\_client = NULL;
01383 \}
01384 
01385 \textcolor{keywordtype}{void} readQueryFromClient(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask) \{
01386     \hyperlink{structclient}{client} *c = (\hyperlink{structclient}{client}*) privdata;
01387     \textcolor{keywordtype}{int} nread, readlen;
01388     size\_t qblen;
01389     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(el);
01390     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(mask);
01391 
01392     readlen = \hyperlink{server_8h_ac30919814359f46fb41e9fc497dd8e05}{PROTO\_IOBUF\_LEN};
01393     \textcolor{comment}{/* If this is a multi bulk request, and we are processing a bulk reply}
01394 \textcolor{comment}{     * that is large enough, try to maximize the probability that the query}
01395 \textcolor{comment}{     * buffer contains exactly the SDS string representing the object, even}
01396 \textcolor{comment}{     * at the risk of requiring more read(2) calls. This way the function}
01397 \textcolor{comment}{     * processMultiBulkBuffer() can avoid copying buffers to create the}
01398 \textcolor{comment}{     * Redis Object representing the argument. */}
01399     \textcolor{keywordflow}{if} (c->reqtype == \hyperlink{server_8h_a50727b40ccd59633a681f9d09a9b9d72}{PROTO\_REQ\_MULTIBULK} && c->multibulklen && c->bulklen != -1
01400         && c->bulklen >= \hyperlink{server_8h_afb6bccf6f1ac66b1d563330ab499fb32}{PROTO\_MBULK\_BIG\_ARG})
01401     \{
01402         \textcolor{keywordtype}{int} remaining = (\textcolor{keywordtype}{unsigned})(c->bulklen+2)-sdslen(c->querybuf);
01403 
01404         \textcolor{keywordflow}{if} (remaining < readlen) readlen = remaining;
01405     \}
01406 
01407     qblen = sdslen(c->querybuf);
01408     \textcolor{keywordflow}{if} (c->querybuf\_peak < qblen) c->querybuf\_peak = qblen;
01409     c->querybuf = sdsMakeRoomFor(c->querybuf, readlen);
01410     nread = read(fd, c->querybuf+qblen, readlen);
01411     \textcolor{keywordflow}{if} (nread == -1) \{
01412         \textcolor{keywordflow}{if} (errno == EAGAIN) \{
01413             \textcolor{keywordflow}{return};
01414         \} \textcolor{keywordflow}{else} \{
01415             serverLog(\hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE}, \textcolor{stringliteral}{"Reading from client: %s"},strerror(errno));
01416             freeClient(c);
01417             \textcolor{keywordflow}{return};
01418         \}
01419     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nread == 0) \{
01420         serverLog(\hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE}, \textcolor{stringliteral}{"Client closed connection"});
01421         freeClient(c);
01422         \textcolor{keywordflow}{return};
01423     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER}) \{
01424         \textcolor{comment}{/* Append the query buffer to the pending (not applied) buffer}
01425 \textcolor{comment}{         * of the master. We'll use this buffer later in order to have a}
01426 \textcolor{comment}{         * copy of the string applied by the last command executed. */}
01427         c->pending\_querybuf = sdscatlen(c->pending\_querybuf,
01428                                         c->querybuf+qblen,nread);
01429     \}
01430 
01431     sdsIncrLen(c->querybuf,nread);
01432     c->lastinteraction = server.unixtime;
01433     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER}) c->read\_reploff += nread;
01434     server.stat\_net\_input\_bytes += nread;
01435     \textcolor{keywordflow}{if} (sdslen(c->querybuf) > server.client\_max\_querybuf\_len) \{
01436         sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();
01437 
01438         bytes = sdscatrepr(bytes,c->querybuf,64);
01439         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Closing client that reached max query buffer length: %s (qbuf
       initial bytes: %s)"}, ci, bytes);
01440         sdsfree(ci);
01441         sdsfree(bytes);
01442         freeClient(c);
01443         \textcolor{keywordflow}{return};
01444     \}
01445 
01446     \textcolor{comment}{/* Time to process the buffer. If the client is a master we need to}
01447 \textcolor{comment}{     * compute the difference between the applied offset before and after}
01448 \textcolor{comment}{     * processing the buffer, to understand how much of the replication stream}
01449 \textcolor{comment}{     * was actually applied to the master state: this quantity, and its}
01450 \textcolor{comment}{     * corresponding part of the replication stream, will be propagated to}
01451 \textcolor{comment}{     * the sub-slaves and to the replication backlog. */}
01452     \textcolor{keywordflow}{if} (!(c->flags & \hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER})) \{
01453         processInputBuffer(c);
01454     \} \textcolor{keywordflow}{else} \{
01455         size\_t prev\_offset = c->reploff;
01456         processInputBuffer(c);
01457         size\_t applied = c->reploff - prev\_offset;
01458         \textcolor{keywordflow}{if} (applied) \{
01459             replicationFeedSlavesFromMasterStream(server.slaves,
01460                     c->pending\_querybuf, applied);
01461             sdsrange(c->pending\_querybuf,applied,-1);
01462         \}
01463     \}
01464 \}
01465 
01466 \textcolor{keywordtype}{void} getClientsMaxBuffers(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *longest\_output\_list,
01467                           \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *biggest\_input\_buffer) \{
01468     \hyperlink{structclient}{client} *c;
01469     listNode *ln;
01470     listIter li;
01471     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} lol = 0, bib = 0;
01472 
01473     listRewind(server.clients,&li);
01474     \textcolor{keywordflow}{while} ((ln = listNext(&li)) != NULL) \{
01475         c = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
01476 
01477         \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(c->reply) > lol) lol = \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(c->reply);
01478         \textcolor{keywordflow}{if} (sdslen(c->querybuf) > bib) bib = sdslen(c->querybuf);
01479     \}
01480     *longest\_output\_list = lol;
01481     *biggest\_input\_buffer = bib;
01482 \}
01483 
01484 \textcolor{comment}{/* A Redis "Peer ID" is a colon separated ip:port pair.}
01485 \textcolor{comment}{ * For IPv4 it's in the form x.y.z.k:port, example: "127.0.0.1:1234".}
01486 \textcolor{comment}{ * For IPv6 addresses we use [] around the IP part, like in "[::1]:1234".}
01487 \textcolor{comment}{ * For Unix sockets we use path:0, like in "/tmp/redis:0".}
01488 \textcolor{comment}{ *}
01489 \textcolor{comment}{ * A Peer ID always fits inside a buffer of NET\_PEER\_ID\_LEN bytes, including}
01490 \textcolor{comment}{ * the null term.}
01491 \textcolor{comment}{ *}
01492 \textcolor{comment}{ * On failure the function still populates 'peerid' with the "?:0" string}
01493 \textcolor{comment}{ * in case you want to relax error checking or need to display something}
01494 \textcolor{comment}{ * anyway (see anetPeerToString implementation for more info). */}
01495 \textcolor{keywordtype}{void} genClientPeerId(\hyperlink{structclient}{client} *client, \textcolor{keywordtype}{char} *peerid,
01496                             size\_t peerid\_len) \{
01497     \textcolor{keywordflow}{if} (client->flags & \hyperlink{server_8h_ae19f45757ef3ffb2f3abb86cbc3b67a2}{CLIENT\_UNIX\_SOCKET}) \{
01498         \textcolor{comment}{/* Unix socket client. */}
01499         snprintf(peerid,peerid\_len,\textcolor{stringliteral}{"%s:0"},server.unixsocket);
01500     \} \textcolor{keywordflow}{else} \{
01501         \textcolor{comment}{/* TCP client. */}
01502         anetFormatPeer(client->fd,peerid,peerid\_len);
01503     \}
01504 \}
01505 
01506 \textcolor{comment}{/* This function returns the client peer id, by creating and caching it}
01507 \textcolor{comment}{ * if client->peerid is NULL, otherwise returning the cached value.}
01508 \textcolor{comment}{ * The Peer ID never changes during the life of the client, however it}
01509 \textcolor{comment}{ * is expensive to compute. */}
01510 \textcolor{keywordtype}{char} *getClientPeerId(\hyperlink{structclient}{client} *c) \{
01511     \textcolor{keywordtype}{char} peerid[\hyperlink{server_8h_a39a30f77e23c1994e70b6c9bc892dee9}{NET\_PEER\_ID\_LEN}];
01512 
01513     \textcolor{keywordflow}{if} (c->peerid == NULL) \{
01514         genClientPeerId(c,peerid,\textcolor{keyword}{sizeof}(peerid));
01515         c->peerid = sdsnew(peerid);
01516     \}
01517     \textcolor{keywordflow}{return} c->peerid;
01518 \}
01519 
01520 \textcolor{comment}{/* Concatenate a string representing the state of a client in an human}
01521 \textcolor{comment}{ * readable format, into the sds string 's'. */}
01522 sds catClientInfoString(sds s, \hyperlink{structclient}{client} *client) \{
01523     \textcolor{keywordtype}{char} flags[16], events[3], *p;
01524     \textcolor{keywordtype}{int} emask;
01525 
01526     p = flags;
01527     \textcolor{keywordflow}{if} (client->flags & \hyperlink{server_8h_ae9f6995948253652bc9454d79a72f4a7}{CLIENT\_SLAVE}) \{
01528         \textcolor{keywordflow}{if} (client->flags & \hyperlink{server_8h_a7724350e4f0ddbf1c80740699fac78be}{CLIENT\_MONITOR})
01529             *p++ = \textcolor{stringliteral}{'O'};
01530         \textcolor{keywordflow}{else}
01531             *p++ = \textcolor{stringliteral}{'S'};
01532     \}
01533     \textcolor{keywordflow}{if} (client->flags & \hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER}) *p++ = \textcolor{stringliteral}{'M'};
01534     \textcolor{keywordflow}{if} (client->flags & \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI}) *p++ = \textcolor{stringliteral}{'x'};
01535     \textcolor{keywordflow}{if} (client->flags & \hyperlink{server_8h_a503ad979164a52f0f5e2a63e4c7da3a0}{CLIENT\_BLOCKED}) *p++ = \textcolor{stringliteral}{'b'};
01536     \textcolor{keywordflow}{if} (client->flags & \hyperlink{server_8h_a0f4df645d72b6b3e9a0d07afbe502a51}{CLIENT\_DIRTY\_CAS}) *p++ = \textcolor{stringliteral}{'d'};
01537     \textcolor{keywordflow}{if} (client->flags & \hyperlink{server_8h_a8cff2154afcc2e87ac85bdbbe2814091}{CLIENT\_CLOSE\_AFTER\_REPLY}) *p++ = \textcolor{stringliteral}{'c'};
01538     \textcolor{keywordflow}{if} (client->flags & \hyperlink{server_8h_a1252372d6834686c29e958d9d96367a8}{CLIENT\_UNBLOCKED}) *p++ = \textcolor{stringliteral}{'u'};
01539     \textcolor{keywordflow}{if} (client->flags & \hyperlink{server_8h_ad6690c6231b67525b8b2057e092a8361}{CLIENT\_CLOSE\_ASAP}) *p++ = \textcolor{stringliteral}{'A'};
01540     \textcolor{keywordflow}{if} (client->flags & \hyperlink{server_8h_ae19f45757ef3ffb2f3abb86cbc3b67a2}{CLIENT\_UNIX\_SOCKET}) *p++ = \textcolor{stringliteral}{'U'};
01541     \textcolor{keywordflow}{if} (client->flags & \hyperlink{server_8h_a84ba0494755e2f4f0faf6017175b5e0a}{CLIENT\_READONLY}) *p++ = \textcolor{stringliteral}{'r'};
01542     \textcolor{keywordflow}{if} (p == flags) *p++ = \textcolor{stringliteral}{'N'};
01543     *p++ = \textcolor{stringliteral}{'\(\backslash\)0'};
01544 
01545     emask = client->fd == -1 ? 0 : aeGetFileEvents(server.el,client->fd);
01546     p = events;
01547     \textcolor{keywordflow}{if} (emask & \hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE}) *p++ = \textcolor{stringliteral}{'r'};
01548     \textcolor{keywordflow}{if} (emask & \hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE}) *p++ = \textcolor{stringliteral}{'w'};
01549     *p = \textcolor{stringliteral}{'\(\backslash\)0'};
01550     \textcolor{keywordflow}{return} sdscatfmt(s,
01551         \textcolor{stringliteral}{"id=%U addr=%s fd=%i name=%s age=%I idle=%I flags=%s db=%i sub=%i psub=%i multi=%i qbuf=%U
       qbuf-free=%U obl=%U oll=%U omem=%U events=%s cmd=%s"},
01552         (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) client->id,
01553         getClientPeerId(client),
01554         client->fd,
01555         client->name ? (\textcolor{keywordtype}{char}*)client->name->ptr : \textcolor{stringliteral}{""},
01556         (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long})(server.unixtime - client->ctime),
01557         (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long})(server.unixtime - client->lastinteraction),
01558         flags,
01559         client->db->id,
01560         (\textcolor{keywordtype}{int}) \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(client->pubsub\_channels),
01561         (\textcolor{keywordtype}{int}) \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(client->pubsub\_patterns),
01562         (client->flags & \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI}) ? client->mstate.count : -1,
01563         (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) sdslen(client->querybuf),
01564         (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) sdsavail(client->querybuf),
01565         (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) client->bufpos,
01566         (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(client->reply),
01567         (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) getClientOutputBufferMemoryUsage(client),
01568         events,
01569         client->lastcmd ? client->lastcmd->name : \textcolor{stringliteral}{"NULL"});
01570 \}
01571 
01572 sds getAllClientsInfoString(\textcolor{keywordtype}{void}) \{
01573     listNode *ln;
01574     listIter li;
01575     \hyperlink{structclient}{client} *client;
01576     sds o = sdsnewlen(NULL,200*\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.clients));
01577     sdsclear(o);
01578     listRewind(server.clients,&li);
01579     \textcolor{keywordflow}{while} ((ln = listNext(&li)) != NULL) \{
01580         client = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
01581         o = catClientInfoString(o,client);
01582         o = sdscatlen(o,\textcolor{stringliteral}{"\(\backslash\)n"},1);
01583     \}
01584     \textcolor{keywordflow}{return} o;
01585 \}
01586 
01587 \textcolor{keywordtype}{void} clientCommand(\hyperlink{structclient}{client} *c) \{
01588     listNode *ln;
01589     listIter li;
01590     \hyperlink{structclient}{client} *client;
01591 
01592     \textcolor{keywordflow}{if} (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"help"})) \{
01593         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *help[] = \{
01594 \textcolor{stringliteral}{"getname -- Return the name of the current connection."},
01595 \textcolor{stringliteral}{"kill <ip:port> -- Kill connection made from <ip:port>."},
01596 \textcolor{stringliteral}{"kill <option> <value> [option value ...] -- Kill connections. Options are:"},
01597 \textcolor{stringliteral}{"     addr <ip:port> -- Kill connection made from <ip:port>."},
01598 \textcolor{stringliteral}{"     type (normal|master|slave|pubsub) -- Kill connections by type."},
01599 \textcolor{stringliteral}{"     skipme (yes|no) -- Skip killing current connection (default: yes)."},
01600 \textcolor{stringliteral}{"list -- Return information about client connections."},
01601 \textcolor{stringliteral}{"pause <timeout> -- Suspend all Redis clients for <timout> milliseconds."},
01602 \textcolor{stringliteral}{"reply (on|off|skip) -- Control the replies sent to the current connection."},
01603 \textcolor{stringliteral}{"setname <name> -- Assign the name <name> to the current connection."},
01604 NULL
01605         \};
01606         addReplyHelp(c, help);
01607     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"list"}) && c->argc == 2) \{
01608         \textcolor{comment}{/* CLIENT LIST */}
01609         sds o = getAllClientsInfoString();
01610         addReplyBulkCBuffer(c,o,sdslen(o));
01611         sdsfree(o);
01612     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"reply"}) && c->argc == 3) \{
01613         \textcolor{comment}{/* CLIENT REPLY ON|OFF|SKIP */}
01614         \textcolor{keywordflow}{if} (!strcasecmp(c->argv[2]->ptr,\textcolor{stringliteral}{"on"})) \{
01615             c->flags &= ~(\hyperlink{server_8h_a792a906c445537043944477fdaad11f4}{CLIENT\_REPLY\_SKIP}|
      \hyperlink{server_8h_a9e2a01b79b4567285f1eccbbe0ed35d1}{CLIENT\_REPLY\_OFF});
01616             addReply(c,shared.ok);
01617         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[2]->ptr,\textcolor{stringliteral}{"off"})) \{
01618             c->flags |= \hyperlink{server_8h_a9e2a01b79b4567285f1eccbbe0ed35d1}{CLIENT\_REPLY\_OFF};
01619         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[2]->ptr,\textcolor{stringliteral}{"skip"})) \{
01620             \textcolor{keywordflow}{if} (!(c->flags & \hyperlink{server_8h_a9e2a01b79b4567285f1eccbbe0ed35d1}{CLIENT\_REPLY\_OFF}))
01621                 c->flags |= \hyperlink{server_8h_a8d5a7abb547f5b34961d11900bd95b00}{CLIENT\_REPLY\_SKIP\_NEXT};
01622         \} \textcolor{keywordflow}{else} \{
01623             addReply(c,shared.syntaxerr);
01624             \textcolor{keywordflow}{return};
01625         \}
01626     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"kill"})) \{
01627         \textcolor{comment}{/* CLIENT KILL <ip:port>}
01628 \textcolor{comment}{         * CLIENT KILL <option> [value] ... <option> [value] */}
01629         \textcolor{keywordtype}{char} *addr = NULL;
01630         \textcolor{keywordtype}{int} type = -1;
01631         uint64\_t id = 0;
01632         \textcolor{keywordtype}{int} skipme = 1;
01633         \textcolor{keywordtype}{int} killed = 0, close\_this\_client = 0;
01634 
01635         \textcolor{keywordflow}{if} (c->argc == 3) \{
01636             \textcolor{comment}{/* Old style syntax: CLIENT KILL <addr> */}
01637             addr = c->argv[2]->ptr;
01638             skipme = 0; \textcolor{comment}{/* With the old form, you can kill yourself. */}
01639         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->argc > 3) \{
01640             \textcolor{keywordtype}{int} i = 2; \textcolor{comment}{/* Next option index. */}
01641 
01642             \textcolor{comment}{/* New style syntax: parse options. */}
01643             \textcolor{keywordflow}{while}(i < c->argc) \{
01644                 \textcolor{keywordtype}{int} moreargs = c->argc > i+1;
01645 
01646                 \textcolor{keywordflow}{if} (!strcasecmp(c->argv[i]->ptr,\textcolor{stringliteral}{"id"}) && moreargs) \{
01647                     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} tmp;
01648 
01649                     \textcolor{keywordflow}{if} (getLongLongFromObjectOrReply(c,c->argv[i+1],&tmp,NULL)
01650                         != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \textcolor{keywordflow}{return};
01651                     id = tmp;
01652                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[i]->ptr,\textcolor{stringliteral}{"type"}) && moreargs) \{
01653                     type = getClientTypeByName(c->argv[i+1]->ptr);
01654                     \textcolor{keywordflow}{if} (type == -1) \{
01655                         addReplyErrorFormat(c,\textcolor{stringliteral}{"Unknown client type '%s'"},
01656                             (\textcolor{keywordtype}{char}*) c->argv[i+1]->ptr);
01657                         \textcolor{keywordflow}{return};
01658                     \}
01659                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[i]->ptr,\textcolor{stringliteral}{"addr"}) && moreargs) \{
01660                     addr = c->argv[i+1]->ptr;
01661                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[i]->ptr,\textcolor{stringliteral}{"skipme"}) && moreargs) \{
01662                     \textcolor{keywordflow}{if} (!strcasecmp(c->argv[i+1]->ptr,\textcolor{stringliteral}{"yes"})) \{
01663                         skipme = 1;
01664                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[i+1]->ptr,\textcolor{stringliteral}{"no"})) \{
01665                         skipme = 0;
01666                     \} \textcolor{keywordflow}{else} \{
01667                         addReply(c,shared.syntaxerr);
01668                         \textcolor{keywordflow}{return};
01669                     \}
01670                 \} \textcolor{keywordflow}{else} \{
01671                     addReply(c,shared.syntaxerr);
01672                     \textcolor{keywordflow}{return};
01673                 \}
01674                 i += 2;
01675             \}
01676         \} \textcolor{keywordflow}{else} \{
01677             addReply(c,shared.syntaxerr);
01678             \textcolor{keywordflow}{return};
01679         \}
01680 
01681         \textcolor{comment}{/* Iterate clients killing all the matching clients. */}
01682         listRewind(server.clients,&li);
01683         \textcolor{keywordflow}{while} ((ln = listNext(&li)) != NULL) \{
01684             client = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
01685             \textcolor{keywordflow}{if} (addr && strcmp(getClientPeerId(client),addr) != 0) \textcolor{keywordflow}{continue};
01686             \textcolor{keywordflow}{if} (type != -1 && getClientType(client) != type) \textcolor{keywordflow}{continue};
01687             \textcolor{keywordflow}{if} (id != 0 && client->id != id) \textcolor{keywordflow}{continue};
01688             \textcolor{keywordflow}{if} (c == client && skipme) \textcolor{keywordflow}{continue};
01689 
01690             \textcolor{comment}{/* Kill it. */}
01691             \textcolor{keywordflow}{if} (c == client) \{
01692                 close\_this\_client = 1;
01693             \} \textcolor{keywordflow}{else} \{
01694                 freeClient(client);
01695             \}
01696             killed++;
01697         \}
01698 
01699         \textcolor{comment}{/* Reply according to old/new format. */}
01700         \textcolor{keywordflow}{if} (c->argc == 3) \{
01701             \textcolor{keywordflow}{if} (killed == 0)
01702                 addReplyError(c,\textcolor{stringliteral}{"No such client"});
01703             \textcolor{keywordflow}{else}
01704                 addReply(c,shared.ok);
01705         \} \textcolor{keywordflow}{else} \{
01706             addReplyLongLong(c,killed);
01707         \}
01708 
01709         \textcolor{comment}{/* If this client has to be closed, flag it as CLOSE\_AFTER\_REPLY}
01710 \textcolor{comment}{         * only after we queued the reply to its output buffers. */}
01711         \textcolor{keywordflow}{if} (close\_this\_client) c->flags |= \hyperlink{server_8h_a8cff2154afcc2e87ac85bdbbe2814091}{CLIENT\_CLOSE\_AFTER\_REPLY};
01712     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"setname"}) && c->argc == 3) \{
01713         \textcolor{keywordtype}{int} j, len = sdslen(c->argv[2]->ptr);
01714         \textcolor{keywordtype}{char} *p = c->argv[2]->ptr;
01715 
01716         \textcolor{comment}{/* Setting the client name to an empty string actually removes}
01717 \textcolor{comment}{         * the current name. */}
01718         \textcolor{keywordflow}{if} (len == 0) \{
01719             \textcolor{keywordflow}{if} (c->name) decrRefCount(c->name);
01720             c->name = NULL;
01721             addReply(c,shared.ok);
01722             \textcolor{keywordflow}{return};
01723         \}
01724 
01725         \textcolor{comment}{/* Otherwise check if the charset is ok. We need to do this otherwise}
01726 \textcolor{comment}{         * CLIENT LIST format will break. You should always be able to}
01727 \textcolor{comment}{         * split by space to get the different fields. */}
01728         \textcolor{keywordflow}{for} (j = 0; j < len; j++) \{
01729             \textcolor{keywordflow}{if} (p[j] < \textcolor{stringliteral}{'!'} || p[j] > \textcolor{stringliteral}{'~'}) \{ \textcolor{comment}{/* ASCII is assumed. */}
01730                 addReplyError(c,
01731                     \textcolor{stringliteral}{"Client names cannot contain spaces, "}
01732                     \textcolor{stringliteral}{"newlines or special characters."});
01733                 \textcolor{keywordflow}{return};
01734             \}
01735         \}
01736         \textcolor{keywordflow}{if} (c->name) decrRefCount(c->name);
01737         c->name = c->argv[2];
01738         incrRefCount(c->name);
01739         addReply(c,shared.ok);
01740     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"getname"}) && c->argc == 2) \{
01741         \textcolor{keywordflow}{if} (c->name)
01742             addReplyBulk(c,c->name);
01743         \textcolor{keywordflow}{else}
01744             addReply(c,shared.nullbulk);
01745     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"pause"}) && c->argc == 3) \{
01746         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} duration;
01747 
01748         \textcolor{keywordflow}{if} (getTimeoutFromObjectOrReply(c,c->argv[2],&duration,
      \hyperlink{server_8h_a259de972533409a75b736bfc799a8e2d}{UNIT\_MILLISECONDS})
01749                                         != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \textcolor{keywordflow}{return};
01750         pauseClients(duration);
01751         addReply(c,shared.ok);
01752     \} \textcolor{keywordflow}{else} \{
01753         addReplyErrorFormat(c, \textcolor{stringliteral}{"Unknown subcommand or wrong number of arguments for '%s'. Try CLIENT
       HELP"}, (\textcolor{keywordtype}{char}*)c->argv[1]->ptr);
01754     \}
01755 \}
01756 
01757 \textcolor{comment}{/* This callback is bound to POST and "Host:" command names. Those are not}
01758 \textcolor{comment}{ * really commands, but are used in security attacks in order to talk to}
01759 \textcolor{comment}{ * Redis instances via HTTP, with a technique called "cross protocol scripting"}
01760 \textcolor{comment}{ * which exploits the fact that services like Redis will discard invalid}
01761 \textcolor{comment}{ * HTTP headers and will process what follows.}
01762 \textcolor{comment}{ *}
01763 \textcolor{comment}{ * As a protection against this attack, Redis will terminate the connection}
01764 \textcolor{comment}{ * when a POST or "Host:" header is seen, and will log the event from}
01765 \textcolor{comment}{ * time to time (to avoid creating a DOS as a result of too many logs). */}
01766 \textcolor{keywordtype}{void} securityWarningCommand(\hyperlink{structclient}{client} *c) \{
01767     \textcolor{keyword}{static} time\_t logged\_time;
01768     time\_t now = time(NULL);
01769 
01770     \textcolor{keywordflow}{if} (labs(now-logged\_time) > 60) \{
01771         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Possible SECURITY ATTACK detected. It looks like somebody is
       sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol
       Scripting to compromise your Redis instance. Connection aborted."});
01772         logged\_time = now;
01773     \}
01774     freeClientAsync(c);
01775 \}
01776 
01777 \textcolor{comment}{/* Rewrite the command vector of the client. All the new objects ref count}
01778 \textcolor{comment}{ * is incremented. The old command vector is freed, and the old objects}
01779 \textcolor{comment}{ * ref count is decremented. */}
01780 \textcolor{keywordtype}{void} rewriteClientCommandVector(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} argc, ...) \{
01781     va\_list ap;
01782     \textcolor{keywordtype}{int} j;
01783     robj **argv; \textcolor{comment}{/* The new argument vector */}
01784 
01785     argv = zmalloc(\textcolor{keyword}{sizeof}(robj*)*argc);
01786     va\_start(ap,argc);
01787     \textcolor{keywordflow}{for} (j = 0; j < argc; j++) \{
01788         robj *a;
01789 
01790         a = va\_arg(ap, robj*);
01791         argv[j] = a;
01792         incrRefCount(a);
01793     \}
01794     \textcolor{comment}{/* We free the objects in the original vector at the end, so we are}
01795 \textcolor{comment}{     * sure that if the same objects are reused in the new vector the}
01796 \textcolor{comment}{     * refcount gets incremented before it gets decremented. */}
01797     \textcolor{keywordflow}{for} (j = 0; j < c->argc; j++) decrRefCount(c->argv[j]);
01798     zfree(c->argv);
01799     \textcolor{comment}{/* Replace argv and argc with our new versions. */}
01800     c->argv = argv;
01801     c->argc = argc;
01802     c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
01803     \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,c->cmd != NULL);
01804     va\_end(ap);
01805 \}
01806 
01807 \textcolor{comment}{/* Completely replace the client command vector with the provided one. */}
01808 \textcolor{keywordtype}{void} replaceClientCommandVector(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} argc, robj **argv) \{
01809     freeClientArgv(c);
01810     zfree(c->argv);
01811     c->argv = argv;
01812     c->argc = argc;
01813     c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
01814     \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,c->cmd != NULL);
01815 \}
01816 
01817 \textcolor{comment}{/* Rewrite a single item in the command vector.}
01818 \textcolor{comment}{ * The new val ref count is incremented, and the old decremented.}
01819 \textcolor{comment}{ *}
01820 \textcolor{comment}{ * It is possible to specify an argument over the current size of the}
01821 \textcolor{comment}{ * argument vector: in this case the array of objects gets reallocated}
01822 \textcolor{comment}{ * and c->argc set to the max value. However it's up to the caller to}
01823 \textcolor{comment}{ *}
01824 \textcolor{comment}{ * 1. Make sure there are no "holes" and all the arguments are set.}
01825 \textcolor{comment}{ * 2. If the original argument vector was longer than the one we}
01826 \textcolor{comment}{ *    want to end with, it's up to the caller to set c->argc and}
01827 \textcolor{comment}{ *    free the no longer used objects on c->argv. */}
01828 \textcolor{keywordtype}{void} rewriteClientCommandArgument(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} i, robj *newval) \{
01829     robj *oldval;
01830 
01831     \textcolor{keywordflow}{if} (i >= c->argc) \{
01832         c->argv = zrealloc(c->argv,\textcolor{keyword}{sizeof}(robj*)*(i+1));
01833         c->argc = i+1;
01834         c->argv[i] = NULL;
01835     \}
01836     oldval = c->argv[i];
01837     c->argv[i] = newval;
01838     incrRefCount(newval);
01839     \textcolor{keywordflow}{if} (oldval) decrRefCount(oldval);
01840 
01841     \textcolor{comment}{/* If this is the command name make sure to fix c->cmd. */}
01842     \textcolor{keywordflow}{if} (i == 0) \{
01843         c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
01844         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,c->cmd != NULL);
01845     \}
01846 \}
01847 
01848 \textcolor{comment}{/* This function returns the number of bytes that Redis is virtually}
01849 \textcolor{comment}{ * using to store the reply still not read by the client.}
01850 \textcolor{comment}{ * It is "virtual" since the reply output list may contain objects that}
01851 \textcolor{comment}{ * are shared and are not really using additional memory.}
01852 \textcolor{comment}{ *}
01853 \textcolor{comment}{ * The function returns the total sum of the length of all the objects}
01854 \textcolor{comment}{ * stored in the output list, plus the memory used to allocate every}
01855 \textcolor{comment}{ * list node. The static reply buffer is not taken into account since it}
01856 \textcolor{comment}{ * is allocated anyway.}
01857 \textcolor{comment}{ *}
01858 \textcolor{comment}{ * Note: this function is very fast so can be called as many time as}
01859 \textcolor{comment}{ * the caller wishes. The main usage of this function currently is}
01860 \textcolor{comment}{ * enforcing the client output length limits. */}
01861 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} getClientOutputBufferMemoryUsage(\hyperlink{structclient}{client} *c) \{
01862     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} list\_item\_size = \textcolor{keyword}{sizeof}(listNode)+5;
01863     \textcolor{comment}{/* The +5 above means we assume an sds16 hdr, may not be true}
01864 \textcolor{comment}{     * but is not going to be a problem. */}
01865 
01866     \textcolor{keywordflow}{return} c->reply\_bytes + (list\_item\_size*\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(c->reply));
01867 \}
01868 
01869 \textcolor{comment}{/* Get the class of a client, used in order to enforce limits to different}
01870 \textcolor{comment}{ * classes of clients.}
01871 \textcolor{comment}{ *}
01872 \textcolor{comment}{ * The function will return one of the following:}
01873 \textcolor{comment}{ * CLIENT\_TYPE\_NORMAL -> Normal client}
01874 \textcolor{comment}{ * CLIENT\_TYPE\_SLAVE  -> Slave or client executing MONITOR command}
01875 \textcolor{comment}{ * CLIENT\_TYPE\_PUBSUB -> Client subscribed to Pub/Sub channels}
01876 \textcolor{comment}{ * CLIENT\_TYPE\_MASTER -> The client representing our replication master.}
01877 \textcolor{comment}{ */}
01878 \textcolor{keywordtype}{int} getClientType(\hyperlink{structclient}{client} *c) \{
01879     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER}) \textcolor{keywordflow}{return} \hyperlink{server_8h_ae96c04932d9a47108994d8f337fd8563}{CLIENT\_TYPE\_MASTER};
01880     \textcolor{keywordflow}{if} ((c->flags & \hyperlink{server_8h_ae9f6995948253652bc9454d79a72f4a7}{CLIENT\_SLAVE}) && !(c->flags & 
      \hyperlink{server_8h_a7724350e4f0ddbf1c80740699fac78be}{CLIENT\_MONITOR}))
01881         \textcolor{keywordflow}{return} \hyperlink{server_8h_a406b5d22cf6437efe61ae25156471b49}{CLIENT\_TYPE\_SLAVE};
01882     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a20f2f5380db97cd09013118ffc9411cc}{CLIENT\_PUBSUB}) \textcolor{keywordflow}{return} \hyperlink{server_8h_a2376a35dc691e54127260d5cd818f7dd}{CLIENT\_TYPE\_PUBSUB};
01883     \textcolor{keywordflow}{return} \hyperlink{server_8h_abd88c3450a5175a5c4a766741f361d5b}{CLIENT\_TYPE\_NORMAL};
01884 \}
01885 
01886 \textcolor{keywordtype}{int} getClientTypeByName(\textcolor{keywordtype}{char} *name) \{
01887     \textcolor{keywordflow}{if} (!strcasecmp(name,\textcolor{stringliteral}{"normal"})) \textcolor{keywordflow}{return} \hyperlink{server_8h_abd88c3450a5175a5c4a766741f361d5b}{CLIENT\_TYPE\_NORMAL};
01888     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(name,\textcolor{stringliteral}{"slave"})) \textcolor{keywordflow}{return} \hyperlink{server_8h_a406b5d22cf6437efe61ae25156471b49}{CLIENT\_TYPE\_SLAVE};
01889     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(name,\textcolor{stringliteral}{"pubsub"})) \textcolor{keywordflow}{return} \hyperlink{server_8h_a2376a35dc691e54127260d5cd818f7dd}{CLIENT\_TYPE\_PUBSUB};
01890     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(name,\textcolor{stringliteral}{"master"})) \textcolor{keywordflow}{return} \hyperlink{server_8h_ae96c04932d9a47108994d8f337fd8563}{CLIENT\_TYPE\_MASTER};
01891     \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} -1;
01892 \}
01893 
01894 \textcolor{keywordtype}{char} *getClientTypeName(\textcolor{keywordtype}{int} \textcolor{keyword}{class}) \{
01895     \textcolor{keywordflow}{switch}(\textcolor{keyword}{class}) \{
01896     \textcolor{keywordflow}{case} \hyperlink{server_8h_abd88c3450a5175a5c4a766741f361d5b}{CLIENT\_TYPE\_NORMAL}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"normal"};
01897     \textcolor{keywordflow}{case} \hyperlink{server_8h_a406b5d22cf6437efe61ae25156471b49}{CLIENT\_TYPE\_SLAVE}:  \textcolor{keywordflow}{return} \textcolor{stringliteral}{"slave"};
01898     \textcolor{keywordflow}{case} \hyperlink{server_8h_a2376a35dc691e54127260d5cd818f7dd}{CLIENT\_TYPE\_PUBSUB}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"pubsub"};
01899     \textcolor{keywordflow}{case} \hyperlink{server_8h_ae96c04932d9a47108994d8f337fd8563}{CLIENT\_TYPE\_MASTER}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"master"};
01900     \textcolor{keywordflow}{default}:                       \textcolor{keywordflow}{return} NULL;
01901     \}
01902 \}
01903 
01904 \textcolor{comment}{/* The function checks if the client reached output buffer soft or hard}
01905 \textcolor{comment}{ * limit, and also update the state needed to check the soft limit as}
01906 \textcolor{comment}{ * a side effect.}
01907 \textcolor{comment}{ *}
01908 \textcolor{comment}{ * Return value: non-zero if the client reached the soft or the hard limit.}
01909 \textcolor{comment}{ *               Otherwise zero is returned. */}
01910 \textcolor{keywordtype}{int} checkClientOutputBufferLimits(client *c) \{
01911     \textcolor{keywordtype}{int} soft = 0, hard = 0, \textcolor{keyword}{class};
01912     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} used\_mem = getClientOutputBufferMemoryUsage(c);
01913 
01914     \textcolor{keyword}{class} = getClientType(c);
01915     \textcolor{comment}{/* For the purpose of output buffer limiting, masters are handled}
01916 \textcolor{comment}{     * like normal clients. */}
01917     \textcolor{keywordflow}{if} (\textcolor{keyword}{class} == \hyperlink{server_8h_ae96c04932d9a47108994d8f337fd8563}{CLIENT\_TYPE\_MASTER}) \textcolor{keyword}{class} = 
      \hyperlink{server_8h_abd88c3450a5175a5c4a766741f361d5b}{CLIENT\_TYPE\_NORMAL};
01918 
01919     \textcolor{keywordflow}{if} (server.client\_obuf\_limits[\textcolor{keyword}{class}].hard\_limit\_bytes &&
01920         used\_mem >= server.client\_obuf\_limits[\textcolor{keyword}{class}].hard\_limit\_bytes)
01921         hard = 1;
01922     \textcolor{keywordflow}{if} (server.client\_obuf\_limits[\textcolor{keyword}{class}].soft\_limit\_bytes &&
01923         used\_mem >= server.client\_obuf\_limits[\textcolor{keyword}{class}].soft\_limit\_bytes)
01924         soft = 1;
01925 
01926     \textcolor{comment}{/* We need to check if the soft limit is reached continuously for the}
01927 \textcolor{comment}{     * specified amount of seconds. */}
01928     \textcolor{keywordflow}{if} (soft) \{
01929         \textcolor{keywordflow}{if} (c->obuf\_soft\_limit\_reached\_time == 0) \{
01930             c->obuf\_soft\_limit\_reached\_time = server.unixtime;
01931             soft = 0; \textcolor{comment}{/* First time we see the soft limit reached */}
01932         \} \textcolor{keywordflow}{else} \{
01933             time\_t elapsed = server.unixtime - c->obuf\_soft\_limit\_reached\_time;
01934 
01935             \textcolor{keywordflow}{if} (elapsed <=
01936                 server.client\_obuf\_limits[\textcolor{keyword}{class}].soft\_limit\_seconds) \{
01937                 soft = 0; \textcolor{comment}{/* The client still did not reached the max number of}
01938 \textcolor{comment}{                             seconds for the soft limit to be considered}
01939 \textcolor{comment}{                             reached. */}
01940             \}
01941         \}
01942     \} \textcolor{keywordflow}{else} \{
01943         c->obuf\_soft\_limit\_reached\_time = 0;
01944     \}
01945     \textcolor{keywordflow}{return} soft || hard;
01946 \}
01947 
01948 \textcolor{comment}{/* Asynchronously close a client if soft or hard limit is reached on the}
01949 \textcolor{comment}{ * output buffer size. The caller can check if the client will be closed}
01950 \textcolor{comment}{ * checking if the client CLIENT\_CLOSE\_ASAP flag is set.}
01951 \textcolor{comment}{ *}
01952 \textcolor{comment}{ * Note: we need to close the client asynchronously because this function is}
01953 \textcolor{comment}{ * called from contexts where the client can't be freed safely, i.e. from the}
01954 \textcolor{comment}{ * lower level functions pushing data inside the client output buffers. */}
01955 \textcolor{keywordtype}{void} asyncCloseClientOnOutputBufferLimitReached(client *c) \{
01956     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(c->reply\_bytes < SIZE\_MAX-(1024*64));
01957     \textcolor{keywordflow}{if} (c->reply\_bytes == 0 || c->flags & \hyperlink{server_8h_ad6690c6231b67525b8b2057e092a8361}{CLIENT\_CLOSE\_ASAP}) \textcolor{keywordflow}{return};
01958     \textcolor{keywordflow}{if} (checkClientOutputBufferLimits(c)) \{
01959         sds client = catClientInfoString(sdsempty(),c);
01960 
01961         freeClientAsync(c);
01962         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Client %s scheduled to be closed ASAP for overcoming of output
       buffer limits."}, client);
01963         sdsfree(client);
01964     \}
01965 \}
01966 
01967 \textcolor{comment}{/* Helper function used by freeMemoryIfNeeded() in order to flush slaves}
01968 \textcolor{comment}{ * output buffers without returning control to the event loop.}
01969 \textcolor{comment}{ * This is also called by SHUTDOWN for a best-effort attempt to send}
01970 \textcolor{comment}{ * slaves the latest writes. */}
01971 \textcolor{keywordtype}{void} flushSlavesOutputBuffers(\textcolor{keywordtype}{void}) \{
01972     listIter li;
01973     listNode *ln;
01974 
01975     listRewind(server.slaves,&li);
01976     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
01977         client *slave = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
01978         \textcolor{keywordtype}{int} events;
01979 
01980         \textcolor{comment}{/* Note that the following will not flush output buffers of slaves}
01981 \textcolor{comment}{         * in STATE\_ONLINE but having put\_online\_on\_ack set to true: in this}
01982 \textcolor{comment}{         * case the writable event is never installed, since the purpose}
01983 \textcolor{comment}{         * of put\_online\_on\_ack is to postpone the moment it is installed.}
01984 \textcolor{comment}{         * This is what we want since slaves in this state should not receive}
01985 \textcolor{comment}{         * writes before the first ACK. */}
01986         events = aeGetFileEvents(server.el,slave->fd);
01987         \textcolor{keywordflow}{if} (events & \hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE} &&
01988             slave->replstate == \hyperlink{server_8h_ad895fdf16e5ed5275d19ddf8578b900f}{SLAVE\_STATE\_ONLINE} &&
01989             clientHasPendingReplies(slave))
01990         \{
01991             writeToClient(slave->fd,slave,0);
01992         \}
01993     \}
01994 \}
01995 
01996 \textcolor{comment}{/* Pause clients up to the specified unixtime (in ms). While clients}
01997 \textcolor{comment}{ * are paused no command is processed from clients, so the data set can't}
01998 \textcolor{comment}{ * change during that time.}
01999 \textcolor{comment}{ *}
02000 \textcolor{comment}{ * However while this function pauses normal and Pub/Sub clients, slaves are}
02001 \textcolor{comment}{ * still served, so this function can be used on server upgrades where it is}
02002 \textcolor{comment}{ * required that slaves process the latest bytes from the replication stream}
02003 \textcolor{comment}{ * before being turned to masters.}
02004 \textcolor{comment}{ *}
02005 \textcolor{comment}{ * This function is also internally used by Redis Cluster for the manual}
02006 \textcolor{comment}{ * failover procedure implemented by CLUSTER FAILOVER.}
02007 \textcolor{comment}{ *}
02008 \textcolor{comment}{ * The function always succeed, even if there is already a pause in progress.}
02009 \textcolor{comment}{ * In such a case, the pause is extended if the duration is more than the}
02010 \textcolor{comment}{ * time left for the previous duration. However if the duration is smaller}
02011 \textcolor{comment}{ * than the time left for the previous pause, no change is made to the}
02012 \textcolor{comment}{ * left duration. */}
02013 \textcolor{keywordtype}{void} pauseClients(mstime\_t end) \{
02014     \textcolor{keywordflow}{if} (!server.clients\_paused || end > server.clients\_pause\_end\_time)
02015         server.clients\_pause\_end\_time = end;
02016     server.clients\_paused = 1;
02017 \}
02018 
02019 \textcolor{comment}{/* Return non-zero if clients are currently paused. As a side effect the}
02020 \textcolor{comment}{ * function checks if the pause time was reached and clear it. */}
02021 \textcolor{keywordtype}{int} clientsArePaused(\textcolor{keywordtype}{void}) \{
02022     \textcolor{keywordflow}{if} (server.clients\_paused &&
02023         server.clients\_pause\_end\_time < server.mstime)
02024     \{
02025         listNode *ln;
02026         listIter li;
02027         client *c;
02028 
02029         server.clients\_paused = 0;
02030 
02031         \textcolor{comment}{/* Put all the clients in the unblocked clients queue in order to}
02032 \textcolor{comment}{         * force the re-processing of the input buffer if any. */}
02033         listRewind(server.clients,&li);
02034         \textcolor{keywordflow}{while} ((ln = listNext(&li)) != NULL) \{
02035             c = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
02036 
02037             \textcolor{comment}{/* Don't touch slaves and blocked clients. The latter pending}
02038 \textcolor{comment}{             * requests be processed when unblocked. */}
02039             \textcolor{keywordflow}{if} (c->flags & (\hyperlink{server_8h_ae9f6995948253652bc9454d79a72f4a7}{CLIENT\_SLAVE}|\hyperlink{server_8h_a503ad979164a52f0f5e2a63e4c7da3a0}{CLIENT\_BLOCKED})) \textcolor{keywordflow}{continue};
02040             c->flags |= \hyperlink{server_8h_a1252372d6834686c29e958d9d96367a8}{CLIENT\_UNBLOCKED};
02041             listAddNodeTail(server.unblocked\_clients,c);
02042         \}
02043     \}
02044     \textcolor{keywordflow}{return} server.clients\_paused;
02045 \}
02046 
02047 \textcolor{comment}{/* This function is called by Redis in order to process a few events from}
02048 \textcolor{comment}{ * time to time while blocked into some not interruptible operation.}
02049 \textcolor{comment}{ * This allows to reply to clients with the -LOADING error while loading the}
02050 \textcolor{comment}{ * data set at startup or after a full resynchronization with the master}
02051 \textcolor{comment}{ * and so forth.}
02052 \textcolor{comment}{ *}
02053 \textcolor{comment}{ * It calls the event loop in order to process a few events. Specifically we}
02054 \textcolor{comment}{ * try to call the event loop 4 times as long as we receive acknowledge that}
02055 \textcolor{comment}{ * some event was processed, in order to go forward with the accept, read,}
02056 \textcolor{comment}{ * write, close sequence needed to serve a client.}
02057 \textcolor{comment}{ *}
02058 \textcolor{comment}{ * The function returns the total number of events processed. */}
02059 \textcolor{keywordtype}{int} processEventsWhileBlocked(\textcolor{keywordtype}{void}) \{
02060     \textcolor{keywordtype}{int} iterations = 4; \textcolor{comment}{/* See the function top-comment. */}
02061     \textcolor{keywordtype}{int} count = 0;
02062     \textcolor{keywordflow}{while} (iterations--) \{
02063         \textcolor{keywordtype}{int} events = 0;
02064         events += aeProcessEvents(server.el, \hyperlink{ae_8h_ac3fe42c648aaa679f6bffaeb1f8f9ea8}{AE\_FILE\_EVENTS}|
      \hyperlink{ae_8h_a95ce6d5997d5b55cef5e1977dc80af28}{AE\_DONT\_WAIT});
02065         events += handleClientsWithPendingWrites();
02066         \textcolor{keywordflow}{if} (!events) \textcolor{keywordflow}{break};
02067         count += events;
02068     \}
02069     \textcolor{keywordflow}{return} count;
02070 \}
\end{DoxyCode}
