\hypertarget{t__string_8c_source}{}\section{t\+\_\+string.\+c}
\label{t__string_8c_source}\index{src/t\+\_\+string.\+c@{src/t\+\_\+string.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>}
00003 \textcolor{comment}{ * All rights reserved.}
00004 \textcolor{comment}{ *}
00005 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00006 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00007 \textcolor{comment}{ *}
00008 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00009 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00010 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00011 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00012 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00013 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00014 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00015 \textcolor{comment}{ *     specific prior written permission.}
00016 \textcolor{comment}{ *}
00017 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00018 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00019 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00020 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00021 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00022 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00023 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00024 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00025 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00026 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00027 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00028 \textcolor{comment}{ */}
00029 
00030 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{server_8h}{"server.h"}
00031 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{math}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>} \textcolor{comment}{/* isnan(), isinf() */}
00032 
00033 \textcolor{comment}{/*-----------------------------------------------------------------------------}
00034 \textcolor{comment}{ * String Commands}
00035 \textcolor{comment}{ *----------------------------------------------------------------------------*/}
00036 
00037 \textcolor{keyword}{static} \textcolor{keywordtype}{int} checkStringLength(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} size) \{
00038     \textcolor{keywordflow}{if} (size > 512*1024*1024) \{
00039         addReplyError(c,\textcolor{stringliteral}{"string exceeds maximum allowed size (512MB)"});
00040         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00041     \}
00042     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00043 \}
00044 
00045 \textcolor{comment}{/* The setGenericCommand() function implements the SET operation with different}
00046 \textcolor{comment}{ * options and variants. This function is called in order to implement the}
00047 \textcolor{comment}{ * following commands: SET, SETEX, PSETEX, SETNX.}
00048 \textcolor{comment}{ *}
00049 \textcolor{comment}{ * 'flags' changes the behavior of the command (NX or XX, see belove).}
00050 \textcolor{comment}{ *}
00051 \textcolor{comment}{ * 'expire' represents an expire to set in form of a Redis object as passed}
00052 \textcolor{comment}{ * by the user. It is interpreted according to the specified 'unit'.}
00053 \textcolor{comment}{ *}
00054 \textcolor{comment}{ * 'ok\_reply' and 'abort\_reply' is what the function will reply to the client}
00055 \textcolor{comment}{ * if the operation is performed, or when it is not because of NX or}
00056 \textcolor{comment}{ * XX flags.}
00057 \textcolor{comment}{ *}
00058 \textcolor{comment}{ * If ok\_reply is NULL "+OK" is used.}
00059 \textcolor{comment}{ * If abort\_reply is NULL, "$-1" is used. */}
00060 
00061 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_SET\_NO\_FLAGS} 0
00062 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_SET\_NX} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)}     \textcolor{comment}{/* Set if key not exists. */}
00063 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_SET\_XX} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}1\textcolor{preprocessor}{)}     \textcolor{comment}{/* Set if key exists. */}
00064 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_SET\_EX} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}2\textcolor{preprocessor}{)}     \textcolor{comment}{/* Set if time in seconds is given */}
00065 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_SET\_PX} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}3\textcolor{preprocessor}{)}     \textcolor{comment}{/* Set if time in ms in given */}
00066 
00067 \textcolor{keywordtype}{void} setGenericCommand(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} flags, robj *key, robj *val, robj *expire, \textcolor{keywordtype}{int} unit, robj 
      *ok\_reply, robj *abort\_reply) \{
00068     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} milliseconds = 0; \textcolor{comment}{/* initialized to avoid any harmness warning */}
00069 
00070     \textcolor{keywordflow}{if} (expire) \{
00071         \textcolor{keywordflow}{if} (getLongLongFromObjectOrReply(c, expire, &milliseconds, NULL) != 
      \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
00072             \textcolor{keywordflow}{return};
00073         \textcolor{keywordflow}{if} (milliseconds <= 0) \{
00074             addReplyErrorFormat(c,\textcolor{stringliteral}{"invalid expire time in %s"},c->cmd->name);
00075             \textcolor{keywordflow}{return};
00076         \}
00077         \textcolor{keywordflow}{if} (unit == \hyperlink{server_8h_a8553b0a6c729b15594731a0d37b4fb0d}{UNIT\_SECONDS}) milliseconds *= 1000;
00078     \}
00079 
00080     \textcolor{keywordflow}{if} ((flags & \hyperlink{t__string_8c_ad2c320e7c632cb6c42ff431ec0d0bfaf}{OBJ\_SET\_NX} && lookupKeyWrite(c->db,key) != NULL) ||
00081         (flags & \hyperlink{t__string_8c_a01e9fee690658334c3fa5fb0dfed3ed8}{OBJ\_SET\_XX} && lookupKeyWrite(c->db,key) == NULL))
00082     \{
00083         addReply(c, abort\_reply ? abort\_reply : shared.nullbulk);
00084         \textcolor{keywordflow}{return};
00085     \}
00086     setKey(c->db,key,val);
00087     server.dirty++;
00088     \textcolor{keywordflow}{if} (expire) setExpire(c,c->db,key,mstime()+milliseconds);
00089     notifyKeyspaceEvent(\hyperlink{server_8h_a1902292b73b71baa65d86db2d61b47ce}{NOTIFY\_STRING},\textcolor{stringliteral}{"set"},key,c->db->id);
00090     \textcolor{keywordflow}{if} (expire) notifyKeyspaceEvent(\hyperlink{server_8h_a9fa53dd1068e62365f3964ad3479eec2}{NOTIFY\_GENERIC},
00091         \textcolor{stringliteral}{"expire"},key,c->db->id);
00092     addReply(c, ok\_reply ? ok\_reply : shared.ok);
00093 \}
00094 
00095 \textcolor{comment}{/* SET key value [NX] [XX] [EX <seconds>] [PX <milliseconds>] */}
00096 \textcolor{keywordtype}{void} setCommand(\hyperlink{structclient}{client} *c) \{
00097     \textcolor{keywordtype}{int} j;
00098     robj *expire = NULL;
00099     \textcolor{keywordtype}{int} unit = \hyperlink{server_8h_a8553b0a6c729b15594731a0d37b4fb0d}{UNIT\_SECONDS};
00100     \textcolor{keywordtype}{int} flags = \hyperlink{t__string_8c_a066d0cea68eb46959e4de40ad0115c5b}{OBJ\_SET\_NO\_FLAGS};
00101 
00102     \textcolor{keywordflow}{for} (j = 3; j < c->argc; j++) \{
00103         \textcolor{keywordtype}{char} *a = c->argv[j]->ptr;
00104         robj *next = (j == c->argc-1) ? NULL : c->argv[j+1];
00105 
00106         \textcolor{keywordflow}{if} ((a[0] == \textcolor{stringliteral}{'n'} || a[0] == \textcolor{stringliteral}{'N'}) &&
00107             (a[1] == \textcolor{stringliteral}{'x'} || a[1] == \textcolor{stringliteral}{'X'}) && a[2] == \textcolor{stringliteral}{'\(\backslash\)0'} &&
00108             !(flags & \hyperlink{t__string_8c_a01e9fee690658334c3fa5fb0dfed3ed8}{OBJ\_SET\_XX}))
00109         \{
00110             flags |= \hyperlink{t__string_8c_ad2c320e7c632cb6c42ff431ec0d0bfaf}{OBJ\_SET\_NX};
00111         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((a[0] == \textcolor{stringliteral}{'x'} || a[0] == \textcolor{stringliteral}{'X'}) &&
00112                    (a[1] == \textcolor{stringliteral}{'x'} || a[1] == \textcolor{stringliteral}{'X'}) && a[2] == \textcolor{stringliteral}{'\(\backslash\)0'} &&
00113                    !(flags & \hyperlink{t__string_8c_ad2c320e7c632cb6c42ff431ec0d0bfaf}{OBJ\_SET\_NX}))
00114         \{
00115             flags |= \hyperlink{t__string_8c_a01e9fee690658334c3fa5fb0dfed3ed8}{OBJ\_SET\_XX};
00116         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((a[0] == \textcolor{stringliteral}{'e'} || a[0] == \textcolor{stringliteral}{'E'}) &&
00117                    (a[1] == \textcolor{stringliteral}{'x'} || a[1] == \textcolor{stringliteral}{'X'}) && a[2] == \textcolor{stringliteral}{'\(\backslash\)0'} &&
00118                    !(flags & \hyperlink{t__string_8c_a7b6e95f021b2885665c3ac078df68509}{OBJ\_SET\_PX}) && next)
00119         \{
00120             flags |= \hyperlink{t__string_8c_a57e6bca7c3405142669c40d9d254a81e}{OBJ\_SET\_EX};
00121             unit = \hyperlink{server_8h_a8553b0a6c729b15594731a0d37b4fb0d}{UNIT\_SECONDS};
00122             expire = next;
00123             j++;
00124         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((a[0] == \textcolor{stringliteral}{'p'} || a[0] == \textcolor{stringliteral}{'P'}) &&
00125                    (a[1] == \textcolor{stringliteral}{'x'} || a[1] == \textcolor{stringliteral}{'X'}) && a[2] == \textcolor{stringliteral}{'\(\backslash\)0'} &&
00126                    !(flags & \hyperlink{t__string_8c_a57e6bca7c3405142669c40d9d254a81e}{OBJ\_SET\_EX}) && next)
00127         \{
00128             flags |= \hyperlink{t__string_8c_a7b6e95f021b2885665c3ac078df68509}{OBJ\_SET\_PX};
00129             unit = \hyperlink{server_8h_a259de972533409a75b736bfc799a8e2d}{UNIT\_MILLISECONDS};
00130             expire = next;
00131             j++;
00132         \} \textcolor{keywordflow}{else} \{
00133             addReply(c,shared.syntaxerr);
00134             \textcolor{keywordflow}{return};
00135         \}
00136     \}
00137 
00138     c->argv[2] = tryObjectEncoding(c->argv[2]);
00139     setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
00140 \}
00141 
00142 \textcolor{keywordtype}{void} setnxCommand(\hyperlink{structclient}{client} *c) \{
00143     c->argv[2] = tryObjectEncoding(c->argv[2]);
00144     setGenericCommand(c,\hyperlink{t__string_8c_ad2c320e7c632cb6c42ff431ec0d0bfaf}{OBJ\_SET\_NX},c->argv[1],c->argv[2],NULL,0,shared.cone,shared.czero);
00145 \}
00146 
00147 \textcolor{keywordtype}{void} setexCommand(\hyperlink{structclient}{client} *c) \{
00148     c->argv[3] = tryObjectEncoding(c->argv[3]);
00149     setGenericCommand(c,\hyperlink{t__string_8c_a066d0cea68eb46959e4de40ad0115c5b}{OBJ\_SET\_NO\_FLAGS},c->argv[1],c->argv[3],c->argv[2],
      \hyperlink{server_8h_a8553b0a6c729b15594731a0d37b4fb0d}{UNIT\_SECONDS},NULL,NULL);
00150 \}
00151 
00152 \textcolor{keywordtype}{void} psetexCommand(\hyperlink{structclient}{client} *c) \{
00153     c->argv[3] = tryObjectEncoding(c->argv[3]);
00154     setGenericCommand(c,\hyperlink{t__string_8c_a066d0cea68eb46959e4de40ad0115c5b}{OBJ\_SET\_NO\_FLAGS},c->argv[1],c->argv[3],c->argv[2],
      \hyperlink{server_8h_a259de972533409a75b736bfc799a8e2d}{UNIT\_MILLISECONDS},NULL,NULL);
00155 \}
00156 
00157 \textcolor{keywordtype}{int} getGenericCommand(\hyperlink{structclient}{client} *c) \{
00158     robj *o;
00159 
00160     \textcolor{keywordflow}{if} ((o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL)
00161         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00162 
00163     \textcolor{keywordflow}{if} (o->type != \hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING}) \{
00164         addReply(c,shared.wrongtypeerr);
00165         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00166     \} \textcolor{keywordflow}{else} \{
00167         addReplyBulk(c,o);
00168         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00169     \}
00170 \}
00171 
00172 \textcolor{keywordtype}{void} getCommand(\hyperlink{structclient}{client} *c) \{
00173     getGenericCommand(c);
00174 \}
00175 
00176 \textcolor{keywordtype}{void} getsetCommand(\hyperlink{structclient}{client} *c) \{
00177     \textcolor{keywordflow}{if} (getGenericCommand(c) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \textcolor{keywordflow}{return};
00178     c->argv[2] = tryObjectEncoding(c->argv[2]);
00179     setKey(c->db,c->argv[1],c->argv[2]);
00180     notifyKeyspaceEvent(\hyperlink{server_8h_a1902292b73b71baa65d86db2d61b47ce}{NOTIFY\_STRING},\textcolor{stringliteral}{"set"},c->argv[1],c->db->id);
00181     server.dirty++;
00182 \}
00183 
00184 \textcolor{keywordtype}{void} setrangeCommand(\hyperlink{structclient}{client} *c) \{
00185     robj *o;
00186     \textcolor{keywordtype}{long} offset;
00187     sds value = c->argv[3]->ptr;
00188 
00189     \textcolor{keywordflow}{if} (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
00190         \textcolor{keywordflow}{return};
00191 
00192     \textcolor{keywordflow}{if} (offset < 0) \{
00193         addReplyError(c,\textcolor{stringliteral}{"offset is out of range"});
00194         \textcolor{keywordflow}{return};
00195     \}
00196 
00197     o = lookupKeyWrite(c->db,c->argv[1]);
00198     \textcolor{keywordflow}{if} (o == NULL) \{
00199         \textcolor{comment}{/* Return 0 when setting nothing on a non-existing string */}
00200         \textcolor{keywordflow}{if} (sdslen(value) == 0) \{
00201             addReply(c,shared.czero);
00202             \textcolor{keywordflow}{return};
00203         \}
00204 
00205         \textcolor{comment}{/* Return when the resulting string exceeds allowed size */}
00206         \textcolor{keywordflow}{if} (checkStringLength(c,offset+sdslen(value)) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
00207             \textcolor{keywordflow}{return};
00208 
00209         o = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnewlen(NULL, offset+sdslen(value)));
00210         dbAdd(c->db,c->argv[1],o);
00211     \} \textcolor{keywordflow}{else} \{
00212         size\_t olen;
00213 
00214         \textcolor{comment}{/* Key exists, check type */}
00215         \textcolor{keywordflow}{if} (checkType(c,o,\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING}))
00216             \textcolor{keywordflow}{return};
00217 
00218         \textcolor{comment}{/* Return existing string length when setting nothing */}
00219         olen = stringObjectLen(o);
00220         \textcolor{keywordflow}{if} (sdslen(value) == 0) \{
00221             addReplyLongLong(c,olen);
00222             \textcolor{keywordflow}{return};
00223         \}
00224 
00225         \textcolor{comment}{/* Return when the resulting string exceeds allowed size */}
00226         \textcolor{keywordflow}{if} (checkStringLength(c,offset+sdslen(value)) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
00227             \textcolor{keywordflow}{return};
00228 
00229         \textcolor{comment}{/* Create a copy when the object is shared or encoded. */}
00230         o = dbUnshareStringValue(c->db,c->argv[1],o);
00231     \}
00232 
00233     \textcolor{keywordflow}{if} (sdslen(value) > 0) \{
00234         o->ptr = sdsgrowzero(o->ptr,offset+sdslen(value));
00235         memcpy((\textcolor{keywordtype}{char}*)o->ptr+offset,value,sdslen(value));
00236         signalModifiedKey(c->db,c->argv[1]);
00237         notifyKeyspaceEvent(\hyperlink{server_8h_a1902292b73b71baa65d86db2d61b47ce}{NOTIFY\_STRING},
00238             \textcolor{stringliteral}{"setrange"},c->argv[1],c->db->id);
00239         server.dirty++;
00240     \}
00241     addReplyLongLong(c,sdslen(o->ptr));
00242 \}
00243 
00244 \textcolor{keywordtype}{void} getrangeCommand(\hyperlink{structclient}{client} *c) \{
00245     robj *o;
00246     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} start, end;
00247     \textcolor{keywordtype}{char} *str, llbuf[32];
00248     size\_t strlen;
00249 
00250     \textcolor{keywordflow}{if} (getLongLongFromObjectOrReply(c,c->argv[2],&start,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
00251         \textcolor{keywordflow}{return};
00252     \textcolor{keywordflow}{if} (getLongLongFromObjectOrReply(c,c->argv[3],&end,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
00253         \textcolor{keywordflow}{return};
00254     \textcolor{keywordflow}{if} ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptybulk)) == NULL ||
00255         checkType(c,o,\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING})) \textcolor{keywordflow}{return};
00256 
00257     \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_ae934cf008a0be0ef009c92c2d006a816}{OBJ\_ENCODING\_INT}) \{
00258         str = llbuf;
00259         strlen = ll2string(llbuf,\textcolor{keyword}{sizeof}(llbuf),(\textcolor{keywordtype}{long})o->ptr);
00260     \} \textcolor{keywordflow}{else} \{
00261         str = o->ptr;
00262         strlen = sdslen(str);
00263     \}
00264 
00265     \textcolor{comment}{/* Convert negative indexes */}
00266     \textcolor{keywordflow}{if} (start < 0 && end < 0 && start > end) \{
00267         addReply(c,shared.emptybulk);
00268         \textcolor{keywordflow}{return};
00269     \}
00270     \textcolor{keywordflow}{if} (start < 0) start = strlen+start;
00271     \textcolor{keywordflow}{if} (end < 0) end = strlen+end;
00272     \textcolor{keywordflow}{if} (start < 0) start = 0;
00273     \textcolor{keywordflow}{if} (end < 0) end = 0;
00274     \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long})end >= strlen) end = strlen-1;
00275 
00276     \textcolor{comment}{/* Precondition: end >= 0 && end < strlen, so the only condition where}
00277 \textcolor{comment}{     * nothing can be returned is: start > end. */}
00278     \textcolor{keywordflow}{if} (start > end || strlen == 0) \{
00279         addReply(c,shared.emptybulk);
00280     \} \textcolor{keywordflow}{else} \{
00281         addReplyBulkCBuffer(c,(\textcolor{keywordtype}{char}*)str+start,end-start+1);
00282     \}
00283 \}
00284 
00285 \textcolor{keywordtype}{void} mgetCommand(\hyperlink{structclient}{client} *c) \{
00286     \textcolor{keywordtype}{int} j;
00287 
00288     addReplyMultiBulkLen(c,c->argc-1);
00289     \textcolor{keywordflow}{for} (j = 1; j < c->argc; j++) \{
00290         robj *o = lookupKeyRead(c->db,c->argv[j]);
00291         \textcolor{keywordflow}{if} (o == NULL) \{
00292             addReply(c,shared.nullbulk);
00293         \} \textcolor{keywordflow}{else} \{
00294             \textcolor{keywordflow}{if} (o->type != \hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING}) \{
00295                 addReply(c,shared.nullbulk);
00296             \} \textcolor{keywordflow}{else} \{
00297                 addReplyBulk(c,o);
00298             \}
00299         \}
00300     \}
00301 \}
00302 
00303 \textcolor{keywordtype}{void} msetGenericCommand(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} nx) \{
00304     \textcolor{keywordtype}{int} j, busykeys = 0;
00305 
00306     \textcolor{keywordflow}{if} ((c->argc % 2) == 0) \{
00307         addReplyError(c,\textcolor{stringliteral}{"wrong number of arguments for MSET"});
00308         \textcolor{keywordflow}{return};
00309     \}
00310     \textcolor{comment}{/* Handle the NX flag. The MSETNX semantic is to return zero and don't}
00311 \textcolor{comment}{     * set nothing at all if at least one already key exists. */}
00312     \textcolor{keywordflow}{if} (nx) \{
00313         \textcolor{keywordflow}{for} (j = 1; j < c->argc; j += 2) \{
00314             \textcolor{keywordflow}{if} (lookupKeyWrite(c->db,c->argv[j]) != NULL) \{
00315                 busykeys++;
00316             \}
00317         \}
00318         \textcolor{keywordflow}{if} (busykeys) \{
00319             addReply(c, shared.czero);
00320             \textcolor{keywordflow}{return};
00321         \}
00322     \}
00323 
00324     \textcolor{keywordflow}{for} (j = 1; j < c->argc; j += 2) \{
00325         c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);
00326         setKey(c->db,c->argv[j],c->argv[j+1]);
00327         notifyKeyspaceEvent(\hyperlink{server_8h_a1902292b73b71baa65d86db2d61b47ce}{NOTIFY\_STRING},\textcolor{stringliteral}{"set"},c->argv[j],c->db->id);
00328     \}
00329     server.dirty += (c->argc-1)/2;
00330     addReply(c, nx ? shared.cone : shared.ok);
00331 \}
00332 
00333 \textcolor{keywordtype}{void} msetCommand(\hyperlink{structclient}{client} *c) \{
00334     msetGenericCommand(c,0);
00335 \}
00336 
00337 \textcolor{keywordtype}{void} msetnxCommand(\hyperlink{structclient}{client} *c) \{
00338     msetGenericCommand(c,1);
00339 \}
00340 
00341 \textcolor{keywordtype}{void} incrDecrCommand(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} incr) \{
00342     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value, oldvalue;
00343     robj *o, *\textcolor{keyword}{new};
00344 
00345     o = lookupKeyWrite(c->db,c->argv[1]);
00346     \textcolor{keywordflow}{if} (o != NULL && checkType(c,o,\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING})) \textcolor{keywordflow}{return};
00347     \textcolor{keywordflow}{if} (getLongLongFromObjectOrReply(c,o,&value,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \textcolor{keywordflow}{return};
00348 
00349     oldvalue = value;
00350     \textcolor{keywordflow}{if} ((incr < 0 && oldvalue < 0 && incr < (LLONG\_MIN-oldvalue)) ||
00351         (incr > 0 && oldvalue > 0 && incr > (LLONG\_MAX-oldvalue))) \{
00352         addReplyError(c,\textcolor{stringliteral}{"increment or decrement would overflow"});
00353         \textcolor{keywordflow}{return};
00354     \}
00355     value += incr;
00356 
00357     \textcolor{keywordflow}{if} (o && o->refcount == 1 && o->encoding == \hyperlink{server_8h_ae934cf008a0be0ef009c92c2d006a816}{OBJ\_ENCODING\_INT} &&
00358         (value < 0 || value >= \hyperlink{server_8h_a311fc8b18b93af94e1ad418f1386b519}{OBJ\_SHARED\_INTEGERS}) &&
00359         value >= LONG\_MIN && value <= LONG\_MAX)
00360     \{
00361         \textcolor{keyword}{new} = o;
00362         o->ptr = (\textcolor{keywordtype}{void}*)((\textcolor{keywordtype}{long})value);
00363     \} \textcolor{keywordflow}{else} \{
00364         \textcolor{keyword}{new} = createStringObjectFromLongLong(value);
00365         \textcolor{keywordflow}{if} (o) \{
00366             dbOverwrite(c->db,c->argv[1],\textcolor{keyword}{new});
00367         \} \textcolor{keywordflow}{else} \{
00368             dbAdd(c->db,c->argv[1],\textcolor{keyword}{new});
00369         \}
00370     \}
00371     signalModifiedKey(c->db,c->argv[1]);
00372     notifyKeyspaceEvent(\hyperlink{server_8h_a1902292b73b71baa65d86db2d61b47ce}{NOTIFY\_STRING},\textcolor{stringliteral}{"incrby"},c->argv[1],c->db->id);
00373     server.dirty++;
00374     addReply(c,shared.colon);
00375     addReply(c,\textcolor{keyword}{new});
00376     addReply(c,shared.crlf);
00377 \}
00378 
00379 \textcolor{keywordtype}{void} incrCommand(client *c) \{
00380     incrDecrCommand(c,1);
00381 \}
00382 
00383 \textcolor{keywordtype}{void} decrCommand(client *c) \{
00384     incrDecrCommand(c,-1);
00385 \}
00386 
00387 \textcolor{keywordtype}{void} incrbyCommand(client *c) \{
00388     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} incr;
00389 
00390     \textcolor{keywordflow}{if} (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \textcolor{keywordflow}{return};
00391     incrDecrCommand(c,incr);
00392 \}
00393 
00394 \textcolor{keywordtype}{void} decrbyCommand(client *c) \{
00395     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} incr;
00396 
00397     \textcolor{keywordflow}{if} (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \textcolor{keywordflow}{return};
00398     incrDecrCommand(c,-incr);
00399 \}
00400 
00401 \textcolor{keywordtype}{void} incrbyfloatCommand(client *c) \{
00402     \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} incr, value;
00403     robj *o, *\textcolor{keyword}{new}, *aux;
00404 
00405     o = lookupKeyWrite(c->db,c->argv[1]);
00406     \textcolor{keywordflow}{if} (o != NULL && checkType(c,o,\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING})) \textcolor{keywordflow}{return};
00407     \textcolor{keywordflow}{if} (getLongDoubleFromObjectOrReply(c,o,&value,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK} ||
00408         getLongDoubleFromObjectOrReply(c,c->argv[2],&incr,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
00409         \textcolor{keywordflow}{return};
00410 
00411     value += incr;
00412     \textcolor{keywordflow}{if} (isnan(value) || isinf(value)) \{
00413         addReplyError(c,\textcolor{stringliteral}{"increment would produce NaN or Infinity"});
00414         \textcolor{keywordflow}{return};
00415     \}
00416     \textcolor{keyword}{new} = createStringObjectFromLongDouble(value,1);
00417     \textcolor{keywordflow}{if} (o)
00418         dbOverwrite(c->db,c->argv[1],\textcolor{keyword}{new});
00419     \textcolor{keywordflow}{else}
00420         dbAdd(c->db,c->argv[1],\textcolor{keyword}{new});
00421     signalModifiedKey(c->db,c->argv[1]);
00422     notifyKeyspaceEvent(\hyperlink{server_8h_a1902292b73b71baa65d86db2d61b47ce}{NOTIFY\_STRING},\textcolor{stringliteral}{"incrbyfloat"},c->argv[1],c->db->id);
00423     server.dirty++;
00424     addReplyBulk(c,\textcolor{keyword}{new});
00425 
00426     \textcolor{comment}{/* Always replicate INCRBYFLOAT as a SET command with the final value}
00427 \textcolor{comment}{     * in order to make sure that differences in float precision or formatting}
00428 \textcolor{comment}{     * will not create differences in replicas or after an AOF restart. */}
00429     aux = createStringObject(\textcolor{stringliteral}{"SET"},3);
00430     rewriteClientCommandArgument(c,0,aux);
00431     decrRefCount(aux);
00432     rewriteClientCommandArgument(c,2,\textcolor{keyword}{new});
00433 \}
00434 
00435 \textcolor{keywordtype}{void} appendCommand(client *c) \{
00436     size\_t totlen;
00437     robj *o, *append;
00438 
00439     o = lookupKeyWrite(c->db,c->argv[1]);
00440     \textcolor{keywordflow}{if} (o == NULL) \{
00441         \textcolor{comment}{/* Create the key */}
00442         c->argv[2] = tryObjectEncoding(c->argv[2]);
00443         dbAdd(c->db,c->argv[1],c->argv[2]);
00444         incrRefCount(c->argv[2]);
00445         totlen = stringObjectLen(c->argv[2]);
00446     \} \textcolor{keywordflow}{else} \{
00447         \textcolor{comment}{/* Key exists, check type */}
00448         \textcolor{keywordflow}{if} (checkType(c,o,\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING}))
00449             \textcolor{keywordflow}{return};
00450 
00451         \textcolor{comment}{/* "append" is an argument, so always an sds */}
00452         append = c->argv[2];
00453         totlen = stringObjectLen(o)+sdslen(append->ptr);
00454         \textcolor{keywordflow}{if} (checkStringLength(c,totlen) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
00455             \textcolor{keywordflow}{return};
00456 
00457         \textcolor{comment}{/* Append the value */}
00458         o = dbUnshareStringValue(c->db,c->argv[1],o);
00459         o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));
00460         totlen = sdslen(o->ptr);
00461     \}
00462     signalModifiedKey(c->db,c->argv[1]);
00463     notifyKeyspaceEvent(\hyperlink{server_8h_a1902292b73b71baa65d86db2d61b47ce}{NOTIFY\_STRING},\textcolor{stringliteral}{"append"},c->argv[1],c->db->id);
00464     server.dirty++;
00465     addReplyLongLong(c,totlen);
00466 \}
00467 
00468 \textcolor{keywordtype}{void} strlenCommand(client *c) \{
00469     robj *o;
00470     \textcolor{keywordflow}{if} ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
00471         checkType(c,o,\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING})) \textcolor{keywordflow}{return};
00472     addReplyLongLong(c,stringObjectLen(o));
00473 \}
\end{DoxyCode}
