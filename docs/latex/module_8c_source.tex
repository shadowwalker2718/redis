\hypertarget{module_8c_source}{}\section{module.\+c}
\label{module_8c_source}\index{src/module.\+c@{src/module.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ * Copyright (c) 2016, Salvatore Sanfilippo <antirez at gmail dot com>}
00003 \textcolor{comment}{ * All rights reserved.}
00004 \textcolor{comment}{ *}
00005 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00006 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00007 \textcolor{comment}{ *}
00008 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00009 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00010 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00011 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00012 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00013 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00014 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00015 \textcolor{comment}{ *     specific prior written permission.}
00016 \textcolor{comment}{ *}
00017 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00018 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00019 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00020 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00021 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00022 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00023 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00024 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00025 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00026 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00027 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00028 \textcolor{comment}{ */}
00029 
00030 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{server_8h}{"server.h"}
00031 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{cluster_8h}{"cluster.h"}
00032 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{dlfcn}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00033 
00034 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_CORE} 1
00035 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{redismodule_8h}{"redismodule.h"}
00036 
00037 \textcolor{comment}{/* --------------------------------------------------------------------------}
00038 \textcolor{comment}{ * Private data structures used by the modules system. Those are data}
00039 \textcolor{comment}{ * structures that are never exposed to Redis Modules, if not as void}
00040 \textcolor{comment}{ * pointers that have an API the module can call with them)}
00041 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
00042 
00043 \textcolor{comment}{/* This structure represents a module inside the system. */}
\Hypertarget{module_8c_source_l00044}\hyperlink{structRedisModule}{00044} \textcolor{keyword}{struct} \hyperlink{structRedisModule}{RedisModule} \{
00045     \textcolor{keywordtype}{void} *handle;   \textcolor{comment}{/* Module dlopen() handle. */}
00046     \textcolor{keywordtype}{char} *name;     \textcolor{comment}{/* Module name. */}
00047     \textcolor{keywordtype}{int} ver;        \textcolor{comment}{/* Module version. We use just progressive integers. */}
00048     \textcolor{keywordtype}{int} apiver;     \textcolor{comment}{/* Module API version as requested during initialization.*/}
00049     list *types;    \textcolor{comment}{/* Module data types. */}
00050 \};
00051 \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structRedisModule}{RedisModule} RedisModule;
00052 
00053 \textcolor{keyword}{static} dict *modules; \textcolor{comment}{/* Hash table of modules. SDS -> RedisModule ptr.*/}
00054 
00055 \textcolor{comment}{/* Entries in the context->amqueue array, representing objects to free}
00056 \textcolor{comment}{ * when the callback returns. */}
\Hypertarget{module_8c_source_l00057}\hyperlink{structAutoMemEntry}{00057} \textcolor{keyword}{struct} \hyperlink{structAutoMemEntry}{AutoMemEntry} \{
00058     \textcolor{keywordtype}{void} *ptr;
00059     \textcolor{keywordtype}{int} type;
00060 \};
00061 
00062 \textcolor{comment}{/* AutMemEntry type field values. */}
00063 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_AM\_KEY} 0
00064 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_AM\_STRING} 1
00065 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_AM\_REPLY} 2
00066 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_AM\_FREED} 3 \textcolor{comment}{/* Explicitly freed by user already. */}
00067 
00068 \textcolor{comment}{/* The pool allocator block. Redis Modules can allocate memory via this special}
00069 \textcolor{comment}{ * allocator that will automatically release it all once the callback returns.}
00070 \textcolor{comment}{ * This means that it can only be used for ephemeral allocations. However}
00071 \textcolor{comment}{ * there are two advantages for modules to use this API:}
00072 \textcolor{comment}{ *}
00073 \textcolor{comment}{ * 1) The memory is automatically released when the callback returns.}
00074 \textcolor{comment}{ * 2) This allocator is faster for many small allocations since whole blocks}
00075 \textcolor{comment}{ *    are allocated, and small pieces returned to the caller just advancing}
00076 \textcolor{comment}{ *    the index of the allocation.}
00077 \textcolor{comment}{ *}
00078 \textcolor{comment}{ * Allocations are always rounded to the size of the void pointer in order}
00079 \textcolor{comment}{ * to always return aligned memory chunks. */}
00080 
00081 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_POOL\_ALLOC\_MIN\_SIZE} \textcolor{preprocessor}{(}1024\textcolor{preprocessor}{*}8\textcolor{preprocessor}{)}
00082 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_POOL\_ALLOC\_ALIGN} \textcolor{preprocessor}{(}\textcolor{keyword}{sizeof}\textcolor{preprocessor}{(}\textcolor{keywordtype}{void}\textcolor{preprocessor}{*}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00083 
\Hypertarget{module_8c_source_l00084}\hyperlink{structRedisModulePoolAllocBlock}{00084} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structRedisModulePoolAllocBlock}{RedisModulePoolAllocBlock} \{
00085     uint32\_t size;
00086     uint32\_t used;
00087     \textcolor{keyword}{struct} \hyperlink{structRedisModulePoolAllocBlock}{RedisModulePoolAllocBlock} *next;
00088     \textcolor{keywordtype}{char} memory[];
00089 \} RedisModulePoolAllocBlock;
00090 
00091 \textcolor{comment}{/* This structure represents the context in which Redis modules operate.}
00092 \textcolor{comment}{ * Most APIs module can access, get a pointer to the context, so that the API}
00093 \textcolor{comment}{ * implementation can hold state across calls, or remember what to free after}
00094 \textcolor{comment}{ * the call and so forth.}
00095 \textcolor{comment}{ *}
00096 \textcolor{comment}{ * Note that not all the context structure is always filled with actual values}
00097 \textcolor{comment}{ * but only the fields needed in a given context. */}
00098 
00099 \textcolor{keyword}{struct} \hyperlink{structRedisModuleBlockedClient}{RedisModuleBlockedClient};
00100 
\Hypertarget{module_8c_source_l00101}\hyperlink{structRedisModuleCtx}{00101} \textcolor{keyword}{struct} \hyperlink{structRedisModuleCtx}{RedisModuleCtx} \{
00102     \textcolor{keywordtype}{void} *getapifuncptr;            \textcolor{comment}{/* NOTE: Must be the first field. */}
00103     \textcolor{keyword}{struct} \hyperlink{structRedisModule}{RedisModule} *module;     \textcolor{comment}{/* Module reference. */}
00104     \hyperlink{structclient}{client} *client;                 \textcolor{comment}{/* Client calling a command. */}
00105     \textcolor{keyword}{struct} \hyperlink{structRedisModuleBlockedClient}{RedisModuleBlockedClient} *blocked\_client; \textcolor{comment}{/* Blocked client for}
00106 \textcolor{comment}{                                                        thread safe context. */}
00107     \textcolor{keyword}{struct} \hyperlink{structAutoMemEntry}{AutoMemEntry} *amqueue;   \textcolor{comment}{/* Auto memory queue of objects to free. */}
00108     \textcolor{keywordtype}{int} amqueue\_len;                \textcolor{comment}{/* Number of slots in amqueue. */}
00109     \textcolor{keywordtype}{int} amqueue\_used;               \textcolor{comment}{/* Number of used slots in amqueue. */}
00110     \textcolor{keywordtype}{int} flags;                      \textcolor{comment}{/* REDISMODULE\_CTX\_... flags. */}
00111     \textcolor{keywordtype}{void} **postponed\_arrays;        \textcolor{comment}{/* To set with RM\_ReplySetArrayLength(). */}
00112     \textcolor{keywordtype}{int} postponed\_arrays\_count;     \textcolor{comment}{/* Number of entries in postponed\_arrays. */}
00113     \textcolor{keywordtype}{void} *blocked\_privdata;         \textcolor{comment}{/* Privdata set when unblocking a client. */}
00114 
00115     \textcolor{comment}{/* Used if there is the REDISMODULE\_CTX\_KEYS\_POS\_REQUEST flag set. */}
00116     \textcolor{keywordtype}{int} *keys\_pos;
00117     \textcolor{keywordtype}{int} keys\_count;
00118 
00119     \textcolor{keyword}{struct} \hyperlink{structRedisModulePoolAllocBlock}{RedisModulePoolAllocBlock} *pa\_head;
00120 \};
00121 \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structRedisModuleCtx}{RedisModuleCtx} RedisModuleCtx;
00122 
00123 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_CTX\_INIT} \textcolor{preprocessor}{\{}\textcolor{preprocessor}{(}\textcolor{keywordtype}{void}\textcolor{preprocessor}{*}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}\textcolor{preprocessor}{)}\textcolor{preprocessor}{&}\textcolor{preprocessor}{RM\_GetApi}\textcolor{preprocessor}{,} NULL\textcolor{preprocessor}{,} NULL\textcolor{preprocessor}{,} NULL\textcolor{preprocessor}{,} NULL\textcolor{preprocessor}{,} 0\textcolor{preprocessor}{,} 0\textcolor{preprocessor}{,} 0\textcolor{preprocessor}{,} NULL\textcolor{preprocessor}{,}
       0\textcolor{preprocessor}{,} NULL\textcolor{preprocessor}{,} NULL\textcolor{preprocessor}{,} 0\textcolor{preprocessor}{,} NULL\textcolor{preprocessor}{\}}
00124 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_CTX\_MULTI\_EMITTED} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)}
00125 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_CTX\_AUTO\_MEMORY} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}1\textcolor{preprocessor}{)}
00126 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_CTX\_KEYS\_POS\_REQUEST} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}2\textcolor{preprocessor}{)}
00127 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_CTX\_BLOCKED\_REPLY} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}3\textcolor{preprocessor}{)}
00128 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_CTX\_BLOCKED\_TIMEOUT} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}4\textcolor{preprocessor}{)}
00129 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_CTX\_THREAD\_SAFE} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}5\textcolor{preprocessor}{)}
00130 
00131 \textcolor{comment}{/* This represents a Redis key opened with RM\_OpenKey(). */}
\Hypertarget{module_8c_source_l00132}\hyperlink{structRedisModuleKey}{00132} \textcolor{keyword}{struct} \hyperlink{structRedisModuleKey}{RedisModuleKey} \{
00133     RedisModuleCtx *ctx;
00134     redisDb *db;
00135     robj *key;      \textcolor{comment}{/* Key name object. */}
00136     robj *value;    \textcolor{comment}{/* Value object, or NULL if the key was not found. */}
00137     \textcolor{keywordtype}{void} *iter;     \textcolor{comment}{/* Iterator. */}
00138     \textcolor{keywordtype}{int} mode;       \textcolor{comment}{/* Opening mode. */}
00139 
00140     \textcolor{comment}{/* Zset iterator. */}
00141     uint32\_t ztype;         \textcolor{comment}{/* REDISMODULE\_ZSET\_RANGE\_* */}
00142     zrangespec zrs;         \textcolor{comment}{/* Score range. */}
00143     zlexrangespec zlrs;     \textcolor{comment}{/* Lex range. */}
00144     uint32\_t zstart;        \textcolor{comment}{/* Start pos for positional ranges. */}
00145     uint32\_t zend;          \textcolor{comment}{/* End pos for positional ranges. */}
00146     \textcolor{keywordtype}{void} *zcurrent;         \textcolor{comment}{/* Zset iterator current node. */}
00147     \textcolor{keywordtype}{int} zer;                \textcolor{comment}{/* Zset iterator end reached flag}
00148 \textcolor{comment}{                               (true if end was reached). */}
00149 \};
00150 \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structRedisModuleKey}{RedisModuleKey} RedisModuleKey;
00151 
00152 \textcolor{comment}{/* RedisModuleKey 'ztype' values. */}
00153 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_ZSET\_RANGE\_NONE} 0       \textcolor{comment}{/* This must always be 0. */}
00154 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_ZSET\_RANGE\_LEX} 1
00155 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_ZSET\_RANGE\_SCORE} 2
00156 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_ZSET\_RANGE\_POS} 3
00157 
00158 \textcolor{comment}{/* Function pointer type of a function representing a command inside}
00159 \textcolor{comment}{ * a Redis module. */}
00160 \textcolor{keyword}{typedef} \textcolor{keywordtype}{int} (*RedisModuleCmdFunc) (RedisModuleCtx *ctx, \textcolor{keywordtype}{void} **argv, \textcolor{keywordtype}{int} argc);
00161 
00162 \textcolor{comment}{/* This struct holds the information about a command registered by a module.*/}
\Hypertarget{module_8c_source_l00163}\hyperlink{structRedisModuleCommandProxy}{00163} \textcolor{keyword}{struct} \hyperlink{structRedisModuleCommandProxy}{RedisModuleCommandProxy} \{
00164     \textcolor{keyword}{struct} \hyperlink{structRedisModule}{RedisModule} *module;
00165     RedisModuleCmdFunc func;
00166     \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *rediscmd;
00167 \};
00168 \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structRedisModuleCommandProxy}{RedisModuleCommandProxy} RedisModuleCommandProxy;
00169 
00170 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_REPLYFLAG\_NONE} 0
00171 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_REPLYFLAG\_TOPARSE} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)} \textcolor{comment}{/* Protocol must be parsed. */}
00172 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_REPLYFLAG\_NESTED} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}1\textcolor{preprocessor}{)}  \textcolor{comment}{/* Nested reply object. No proto}
00173 \textcolor{comment}{                                                or struct free. */}
00174 
00175 \textcolor{comment}{/* Reply of RM\_Call() function. The function is filled in a lazy}
00176 \textcolor{comment}{ * way depending on the function called on the reply structure. By default}
00177 \textcolor{comment}{ * only the type, proto and protolen are filled. */}
\Hypertarget{module_8c_source_l00178}\hyperlink{structRedisModuleCallReply}{00178} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} \{
00179     RedisModuleCtx *ctx;
00180     \textcolor{keywordtype}{int} type;       \textcolor{comment}{/* REDISMODULE\_REPLY\_... */}
00181     \textcolor{keywordtype}{int} flags;      \textcolor{comment}{/* REDISMODULE\_REPLYFLAG\_...  */}
00182     size\_t len;     \textcolor{comment}{/* Len of strings or num of elements of arrays. */}
00183     \textcolor{keywordtype}{char} *proto;    \textcolor{comment}{/* Raw reply protocol. An SDS string at top-level object. */}
00184     size\_t protolen;\textcolor{comment}{/* Length of protocol. */}
\Hypertarget{module_8c_source_l00185}\hyperlink{unionRedisModuleCallReply_8val}{00185}     \textcolor{keyword}{union} \{
00186         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *str; \textcolor{comment}{/* String pointer for string and error replies. This}
00187 \textcolor{comment}{                            does not need to be freed, always points inside}
00188 \textcolor{comment}{                            a reply->proto buffer of the reply object or, in}
00189 \textcolor{comment}{                            case of array elements, of parent reply objects. */}
00190         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ll;    \textcolor{comment}{/* Reply value for integer reply. */}
00191         \textcolor{keyword}{struct} \hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *array; \textcolor{comment}{/* Array of sub-reply elements. */}
00192     \} val;
00193 \} RedisModuleCallReply;
00194 
00195 \textcolor{comment}{/* Structure representing a blocked client. We get a pointer to such}
00196 \textcolor{comment}{ * an object when blocking from modules. */}
\Hypertarget{module_8c_source_l00197}\hyperlink{structRedisModuleBlockedClient}{00197} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structRedisModuleBlockedClient}{RedisModuleBlockedClient} \{
00198     \hyperlink{structclient}{client} *client;  \textcolor{comment}{/* Pointer to the blocked client. or NULL if the client}
00199 \textcolor{comment}{                        was destroyed during the life of this object. */}
00200     RedisModule *module;    \textcolor{comment}{/* Module blocking the client. */}
00201     RedisModuleCmdFunc reply\_callback; \textcolor{comment}{/* Reply callback on normal completion.*/}
00202     RedisModuleCmdFunc timeout\_callback; \textcolor{comment}{/* Reply callback on timeout. */}
00203     \textcolor{keywordtype}{void} (*free\_privdata)(\textcolor{keywordtype}{void} *);       \textcolor{comment}{/* privdata cleanup callback. */}
00204     \textcolor{keywordtype}{void} *privdata;     \textcolor{comment}{/* Module private data that may be used by the reply}
00205 \textcolor{comment}{                           or timeout callback. It is set via the}
00206 \textcolor{comment}{                           RedisModule\_UnblockClient() API. */}
00207     \hyperlink{structclient}{client} *reply\_client;           \textcolor{comment}{/* Fake client used to accumulate replies}
00208 \textcolor{comment}{                                       in thread safe contexts. */}
00209     \textcolor{keywordtype}{int} dbid;           \textcolor{comment}{/* Database number selected by the original client. */}
00210 \} RedisModuleBlockedClient;
00211 
00212 \textcolor{keyword}{static} pthread\_mutex\_t moduleUnblockedClientsMutex = PTHREAD\_MUTEX\_INITIALIZER;
00213 \textcolor{keyword}{static} list *moduleUnblockedClients;
00214 
00215 \textcolor{comment}{/* We need a mutex that is unlocked / relocked in beforeSleep() in order to}
00216 \textcolor{comment}{ * allow thread safe contexts to execute commands at a safe moment. */}
00217 \textcolor{keyword}{static} pthread\_mutex\_t moduleGIL = PTHREAD\_MUTEX\_INITIALIZER;
00218 
00219 \textcolor{comment}{/* --------------------------------------------------------------------------}
00220 \textcolor{comment}{ * Prototypes}
00221 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
00222 
00223 \textcolor{keywordtype}{void} RM\_FreeCallReply(\hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply);
00224 \textcolor{keywordtype}{void} RM\_CloseKey(RedisModuleKey *key);
00225 \textcolor{keywordtype}{void} autoMemoryCollect(RedisModuleCtx *ctx);
00226 robj **moduleCreateArgvFromUserFormat(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *cmdname, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, \textcolor{keywordtype}{int} *argcp, \textcolor{keywordtype}{int} *flags, 
      va\_list ap);
00227 \textcolor{keywordtype}{void} moduleReplicateMultiIfNeeded(RedisModuleCtx *ctx);
00228 \textcolor{keywordtype}{void} RM\_ZsetRangeStop(RedisModuleKey *kp);
00229 \textcolor{keyword}{static} \textcolor{keywordtype}{void} zsetKeyReset(RedisModuleKey *key);
00230 
00231 \textcolor{comment}{/* --------------------------------------------------------------------------}
00232 \textcolor{comment}{ * Heap allocation raw functions}
00233 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
00234 
00235 \textcolor{comment}{/* Use like malloc(). Memory allocated with this function is reported in}
00236 \textcolor{comment}{ * Redis INFO memory, used for keys eviction according to maxmemory settings}
00237 \textcolor{comment}{ * and in general is taken into account as memory allocated by Redis.}
00238 \textcolor{comment}{ * You should avoid using malloc(). */}
00239 \textcolor{keywordtype}{void} *RM\_Alloc(size\_t bytes) \{
00240     \textcolor{keywordflow}{return} zmalloc(bytes);
00241 \}
00242 
00243 \textcolor{comment}{/* Use like calloc(). Memory allocated with this function is reported in}
00244 \textcolor{comment}{ * Redis INFO memory, used for keys eviction according to maxmemory settings}
00245 \textcolor{comment}{ * and in general is taken into account as memory allocated by Redis.}
00246 \textcolor{comment}{ * You should avoid using calloc() directly. */}
00247 \textcolor{keywordtype}{void} *RM\_Calloc(size\_t nmemb, size\_t size) \{
00248     \textcolor{keywordflow}{return} zcalloc(nmemb*size);
00249 \}
00250 
00251 \textcolor{comment}{/* Use like realloc() for memory obtained with RedisModule\_Alloc(). */}
00252 \textcolor{keywordtype}{void}* RM\_Realloc(\textcolor{keywordtype}{void} *ptr, size\_t bytes) \{
00253     \textcolor{keywordflow}{return} zrealloc(ptr,bytes);
00254 \}
00255 
00256 \textcolor{comment}{/* Use like free() for memory obtained by RedisModule\_Alloc() and}
00257 \textcolor{comment}{ * RedisModule\_Realloc(). However you should never try to free with}
00258 \textcolor{comment}{ * RedisModule\_Free() memory allocated with malloc() inside your module. */}
00259 \textcolor{keywordtype}{void} RM\_Free(\textcolor{keywordtype}{void} *ptr) \{
00260     zfree(ptr);
00261 \}
00262 
00263 \textcolor{comment}{/* Like strdup() but returns memory allocated with RedisModule\_Alloc(). */}
00264 \textcolor{keywordtype}{char} *RM\_Strdup(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *str) \{
00265     \textcolor{keywordflow}{return} zstrdup(str);
00266 \}
00267 
00268 \textcolor{comment}{/* --------------------------------------------------------------------------}
00269 \textcolor{comment}{ * Pool allocator}
00270 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
00271 
00272 \textcolor{comment}{/* Release the chain of blocks used for pool allocations. */}
00273 \textcolor{keywordtype}{void} poolAllocRelease(RedisModuleCtx *ctx) \{
00274     RedisModulePoolAllocBlock *head = ctx->pa\_head, *next;
00275 
00276     \textcolor{keywordflow}{while}(head != NULL) \{
00277         next = head->next;
00278         zfree(head);
00279         head = next;
00280     \}
00281     ctx->pa\_head = NULL;
00282 \}
00283 
00284 \textcolor{comment}{/* Return heap allocated memory that will be freed automatically when the}
00285 \textcolor{comment}{ * module callback function returns. Mostly suitable for small allocations}
00286 \textcolor{comment}{ * that are short living and must be released when the callback returns}
00287 \textcolor{comment}{ * anyway. The returned memory is aligned to the architecture word size}
00288 \textcolor{comment}{ * if at least word size bytes are requested, otherwise it is just}
00289 \textcolor{comment}{ * aligned to the next power of two, so for example a 3 bytes request is}
00290 \textcolor{comment}{ * 4 bytes aligned while a 2 bytes request is 2 bytes aligned.}
00291 \textcolor{comment}{ *}
00292 \textcolor{comment}{ * There is no realloc style function since when this is needed to use the}
00293 \textcolor{comment}{ * pool allocator is not a good idea.}
00294 \textcolor{comment}{ *}
00295 \textcolor{comment}{ * The function returns NULL if `bytes` is 0. */}
00296 \textcolor{keywordtype}{void} *RM\_PoolAlloc(RedisModuleCtx *ctx, size\_t bytes) \{
00297     \textcolor{keywordflow}{if} (bytes == 0) \textcolor{keywordflow}{return} NULL;
00298     RedisModulePoolAllocBlock *b = ctx->pa\_head;
00299     size\_t left = b ? b->size - b->used : 0;
00300 
00301     \textcolor{comment}{/* Fix alignment. */}
00302     \textcolor{keywordflow}{if} (left >= bytes) \{
00303         size\_t alignment = \hyperlink{module_8c_aea20ee5f4dfeeaa2ae088904127efc2c}{REDISMODULE\_POOL\_ALLOC\_ALIGN};
00304         \textcolor{keywordflow}{while} (bytes < alignment && alignment/2 >= bytes) alignment /= 2;
00305         \textcolor{keywordflow}{if} (b->used % alignment)
00306             b->used += alignment - (b->used % alignment);
00307         left = (b->used > b->size) ? 0 : b->size - b->used;
00308     \}
00309 
00310     \textcolor{comment}{/* Create a new block if needed. */}
00311     \textcolor{keywordflow}{if} (left < bytes) \{
00312         size\_t blocksize = \hyperlink{module_8c_ae7dda44c0d73e50e241dd638550c4e18}{REDISMODULE\_POOL\_ALLOC\_MIN\_SIZE};
00313         \textcolor{keywordflow}{if} (blocksize < bytes) blocksize = bytes;
00314         b = zmalloc(\textcolor{keyword}{sizeof}(*b) + blocksize);
00315         b->size = blocksize;
00316         b->used = 0;
00317         b->next = ctx->pa\_head;
00318         ctx->pa\_head = b;
00319     \}
00320 
00321     \textcolor{keywordtype}{char} *retval = b->memory + b->used;
00322     b->used += bytes;
00323     \textcolor{keywordflow}{return} retval;
00324 \}
00325 
00326 \textcolor{comment}{/* --------------------------------------------------------------------------}
00327 \textcolor{comment}{ * Helpers for modules API implementation}
00328 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
00329 
00330 \textcolor{comment}{/* Create an empty key of the specified type. 'kp' must point to a key object}
00331 \textcolor{comment}{ * opened for writing where the .value member is set to NULL because the}
00332 \textcolor{comment}{ * key was found to be non existing.}
00333 \textcolor{comment}{ *}
00334 \textcolor{comment}{ * On success REDISMODULE\_OK is returned and the key is populated with}
00335 \textcolor{comment}{ * the value of the specified type. The function fails and returns}
00336 \textcolor{comment}{ * REDISMODULE\_ERR if:}
00337 \textcolor{comment}{ *}
00338 \textcolor{comment}{ * 1) The key is not open for writing.}
00339 \textcolor{comment}{ * 2) The key is not empty.}
00340 \textcolor{comment}{ * 3) The specified type is unknown.}
00341 \textcolor{comment}{ */}
00342 \textcolor{keywordtype}{int} moduleCreateEmptyKey(RedisModuleKey *key, \textcolor{keywordtype}{int} type) \{
00343     robj *obj;
00344 
00345     \textcolor{comment}{/* The key must be open for writing and non existing to proceed. */}
00346     \textcolor{keywordflow}{if} (!(key->mode & \hyperlink{redismodule_8h_a73b37117ef94cb4a904361afcc51b6b4}{REDISMODULE\_WRITE}) || key->value)
00347         \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
00348 
00349     \textcolor{keywordflow}{switch}(type) \{
00350     \textcolor{keywordflow}{case} \hyperlink{redismodule_8h_a4c01058971d9d8fe1cfa02071fa87fa6}{REDISMODULE\_KEYTYPE\_LIST}:
00351         obj = createQuicklistObject();
00352         quicklistSetOptions(obj->ptr, server.list\_max\_ziplist\_size,
00353                             server.list\_compress\_depth);
00354         \textcolor{keywordflow}{break};
00355     \textcolor{keywordflow}{case} \hyperlink{redismodule_8h_a93d1514d4c11cc65551b36cfd9a72cc2}{REDISMODULE\_KEYTYPE\_ZSET}:
00356         obj = createZsetZiplistObject();
00357         \textcolor{keywordflow}{break};
00358     \textcolor{keywordflow}{case} \hyperlink{redismodule_8h_ac019575ac57520c325597e2fb54c5b71}{REDISMODULE\_KEYTYPE\_HASH}:
00359         obj = createHashObject();
00360         \textcolor{keywordflow}{break};
00361     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
00362     \}
00363     dbAdd(key->db,key->key,obj);
00364     key->value = obj;
00365     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
00366 \}
00367 
00368 \textcolor{comment}{/* This function is called in low-level API implementation functions in order}
00369 \textcolor{comment}{ * to check if the value associated with the key remained empty after an}
00370 \textcolor{comment}{ * operation that removed elements from an aggregate data type.}
00371 \textcolor{comment}{ *}
00372 \textcolor{comment}{ * If this happens, the key is deleted from the DB and the key object state}
00373 \textcolor{comment}{ * is set to the right one in order to be targeted again by write operations}
00374 \textcolor{comment}{ * possibly recreating the key if needed.}
00375 \textcolor{comment}{ *}
00376 \textcolor{comment}{ * The function returns 1 if the key value object is found empty and is}
00377 \textcolor{comment}{ * deleted, otherwise 0 is returned. */}
00378 \textcolor{keywordtype}{int} moduleDelKeyIfEmpty(RedisModuleKey *key) \{
00379     \textcolor{keywordflow}{if} (!(key->mode & \hyperlink{redismodule_8h_a73b37117ef94cb4a904361afcc51b6b4}{REDISMODULE\_WRITE}) || key->value == NULL) \textcolor{keywordflow}{return} 0;
00380     \textcolor{keywordtype}{int} isempty;
00381     robj *o = key->value;
00382 
00383     \textcolor{keywordflow}{switch}(o->type) \{
00384     \textcolor{keywordflow}{case} \hyperlink{server_8h_a4a5f22a280949c97a0cb0d4213275126}{OBJ\_LIST}: isempty = listTypeLength(o) == 0; \textcolor{keywordflow}{break};
00385     \textcolor{keywordflow}{case} \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET}: isempty = setTypeSize(o) == 0; \textcolor{keywordflow}{break};
00386     \textcolor{keywordflow}{case} \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}: isempty = zsetLength(o) == 0; \textcolor{keywordflow}{break};
00387     \textcolor{keywordflow}{case} \hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH} : isempty = hashTypeLength(o) == 0; \textcolor{keywordflow}{break};
00388     \textcolor{keywordflow}{default}: isempty = 0;
00389     \}
00390 
00391     \textcolor{keywordflow}{if} (isempty) \{
00392         dbDelete(key->db,key->key);
00393         key->value = NULL;
00394         \textcolor{keywordflow}{return} 1;
00395     \} \textcolor{keywordflow}{else} \{
00396         \textcolor{keywordflow}{return} 0;
00397     \}
00398 \}
00399 
00400 \textcolor{comment}{/* --------------------------------------------------------------------------}
00401 \textcolor{comment}{ * Service API exported to modules}
00402 \textcolor{comment}{ *}
00403 \textcolor{comment}{ * Note that all the exported APIs are called RM\_<funcname> in the core}
00404 \textcolor{comment}{ * and RedisModule\_<funcname> in the module side (defined as function}
00405 \textcolor{comment}{ * pointers in redismodule.h). In this way the dynamic linker does not}
00406 \textcolor{comment}{ * mess with our global function pointers, overriding it with the symbols}
00407 \textcolor{comment}{ * defined in the main executable having the same names.}
00408 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
00409 
00410 \textcolor{comment}{/* Lookup the requested module API and store the function pointer into the}
00411 \textcolor{comment}{ * target pointer. The function returns REDISMODULE\_ERR if there is no such}
00412 \textcolor{comment}{ * named API, otherwise REDISMODULE\_OK.}
00413 \textcolor{comment}{ *}
00414 \textcolor{comment}{ * This function is not meant to be used by modules developer, it is only}
00415 \textcolor{comment}{ * used implicitly by including redismodule.h. */}
00416 \textcolor{keywordtype}{int} RM\_GetApi(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *funcname, \textcolor{keywordtype}{void} **targetPtrPtr) \{
00417     dictEntry *he = dictFind(server.moduleapi, funcname);
00418     \textcolor{keywordflow}{if} (!he) \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
00419     *targetPtrPtr = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(he);
00420     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
00421 \}
00422 
00423 \textcolor{comment}{/* Free the context after the user function was called. */}
00424 \textcolor{keywordtype}{void} moduleFreeContext(RedisModuleCtx *ctx) \{
00425     autoMemoryCollect(ctx);
00426     poolAllocRelease(ctx);
00427     \textcolor{keywordflow}{if} (ctx->postponed\_arrays) \{
00428         zfree(ctx->postponed\_arrays);
00429         ctx->postponed\_arrays\_count = 0;
00430         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
00431             \textcolor{stringliteral}{"API misuse detected in module %s: "}
00432             \textcolor{stringliteral}{"RedisModule\_ReplyWithArray(REDISMODULE\_POSTPONED\_ARRAY\_LEN) "}
00433             \textcolor{stringliteral}{"not matched by the same number of RedisModule\_SetReplyArrayLen() "}
00434             \textcolor{stringliteral}{"calls."},
00435             ctx->module->name);
00436     \}
00437     \textcolor{keywordflow}{if} (ctx->flags & \hyperlink{module_8c_a884fbd2b3a1b008f1635afaeb87ca52a}{REDISMODULE\_CTX\_THREAD\_SAFE}) freeClient(ctx->client);
00438 \}
00439 
00440 \textcolor{comment}{/* Helper function for when a command callback is called, in order to handle}
00441 \textcolor{comment}{ * details needed to correctly replicate commands. */}
00442 \textcolor{keywordtype}{void} moduleHandlePropagationAfterCommandCallback(RedisModuleCtx *ctx) \{
00443     \hyperlink{structclient}{client} *c = ctx->client;
00444 
00445     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_af9d0b0f45ef2c1fd29ac714a300de706}{CLIENT\_LUA}) \textcolor{keywordflow}{return};
00446 
00447     \textcolor{comment}{/* Handle the replication of the final EXEC, since whatever a command}
00448 \textcolor{comment}{     * emits is always wrappered around MULTI/EXEC. */}
00449     \textcolor{keywordflow}{if} (ctx->flags & \hyperlink{module_8c_a4b2299e0b7b9fda08895270574120015}{REDISMODULE\_CTX\_MULTI\_EMITTED}) \{
00450         robj *propargv[1];
00451         propargv[0] = createStringObject(\textcolor{stringliteral}{"EXEC"},4);
00452         alsoPropagate(server.execCommand,c->db->id,propargv,1,
00453             \hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF}|\hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL});
00454         decrRefCount(propargv[0]);
00455     \}
00456 \}
00457 
00458 \textcolor{comment}{/* This Redis command binds the normal Redis command invocation with commands}
00459 \textcolor{comment}{ * exported by modules. */}
00460 \textcolor{keywordtype}{void} RedisModuleCommandDispatcher(\hyperlink{structclient}{client} *c) \{
00461     RedisModuleCommandProxy *cp = (\textcolor{keywordtype}{void}*)(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})c->cmd->getkeys\_proc;
00462     RedisModuleCtx ctx = \hyperlink{module_8c_a7a80fb134c35b70c7cfe920ea1033bcd}{REDISMODULE\_CTX\_INIT};
00463 
00464     ctx.module = cp->module;
00465     ctx.client = c;
00466     cp->func(&ctx,(\textcolor{keywordtype}{void}**)c->argv,c->argc);
00467     moduleHandlePropagationAfterCommandCallback(&ctx);
00468     moduleFreeContext(&ctx);
00469 \}
00470 
00471 \textcolor{comment}{/* This function returns the list of keys, with the same interface as the}
00472 \textcolor{comment}{ * 'getkeys' function of the native commands, for module commands that exported}
00473 \textcolor{comment}{ * the "getkeys-api" flag during the registration. This is done when the}
00474 \textcolor{comment}{ * list of keys are not at fixed positions, so that first/last/step cannot}
00475 \textcolor{comment}{ * be used.}
00476 \textcolor{comment}{ *}
00477 \textcolor{comment}{ * In order to accomplish its work, the module command is called, flagging}
00478 \textcolor{comment}{ * the context in a way that the command can recognize this is a special}
00479 \textcolor{comment}{ * "get keys" call by calling RedisModule\_IsKeysPositionRequest(ctx). */}
00480 \textcolor{keywordtype}{int} *moduleGetCommandKeysViaAPI(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} *
      numkeys) \{
00481     RedisModuleCommandProxy *cp = (\textcolor{keywordtype}{void}*)(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})cmd->getkeys\_proc;
00482     RedisModuleCtx ctx = \hyperlink{module_8c_a7a80fb134c35b70c7cfe920ea1033bcd}{REDISMODULE\_CTX\_INIT};
00483 
00484     ctx.module = cp->module;
00485     ctx.client = NULL;
00486     ctx.flags |= \hyperlink{module_8c_a235c576b70301827b2d69fd909b191d9}{REDISMODULE\_CTX\_KEYS\_POS\_REQUEST};
00487     cp->func(&ctx,(\textcolor{keywordtype}{void}**)argv,argc);
00488     \textcolor{keywordtype}{int} *res = ctx.keys\_pos;
00489     \textcolor{keywordflow}{if} (numkeys) *numkeys = ctx.keys\_count;
00490     moduleFreeContext(&ctx);
00491     \textcolor{keywordflow}{return} res;
00492 \}
00493 
00494 \textcolor{comment}{/* Return non-zero if a module command, that was declared with the}
00495 \textcolor{comment}{ * flag "getkeys-api", is called in a special way to get the keys positions}
00496 \textcolor{comment}{ * and not to get executed. Otherwise zero is returned. */}
00497 \textcolor{keywordtype}{int} RM\_IsKeysPositionRequest(RedisModuleCtx *ctx) \{
00498     \textcolor{keywordflow}{return} (ctx->flags & \hyperlink{module_8c_a235c576b70301827b2d69fd909b191d9}{REDISMODULE\_CTX\_KEYS\_POS\_REQUEST}) != 0;
00499 \}
00500 
00501 \textcolor{comment}{/* When a module command is called in order to obtain the position of}
00502 \textcolor{comment}{ * keys, since it was flagged as "getkeys-api" during the registration,}
00503 \textcolor{comment}{ * the command implementation checks for this special call using the}
00504 \textcolor{comment}{ * RedisModule\_IsKeysPositionRequest() API and uses this function in}
00505 \textcolor{comment}{ * order to report keys, like in the following example:}
00506 \textcolor{comment}{ *}
00507 \textcolor{comment}{ *     if (RedisModule\_IsKeysPositionRequest(ctx)) \{}
00508 \textcolor{comment}{ *         RedisModule\_KeyAtPos(ctx,1);}
00509 \textcolor{comment}{ *         RedisModule\_KeyAtPos(ctx,2);}
00510 \textcolor{comment}{ *     \}}
00511 \textcolor{comment}{ *}
00512 \textcolor{comment}{ *  Note: in the example below the get keys API would not be needed since}
00513 \textcolor{comment}{ *  keys are at fixed positions. This interface is only used for commands}
00514 \textcolor{comment}{ *  with a more complex structure. */}
00515 \textcolor{keywordtype}{void} RM\_KeyAtPos(RedisModuleCtx *ctx, \textcolor{keywordtype}{int} pos) \{
00516     \textcolor{keywordflow}{if} (!(ctx->flags & \hyperlink{module_8c_a235c576b70301827b2d69fd909b191d9}{REDISMODULE\_CTX\_KEYS\_POS\_REQUEST})) \textcolor{keywordflow}{return};
00517     \textcolor{keywordflow}{if} (pos <= 0) \textcolor{keywordflow}{return};
00518     ctx->keys\_pos = zrealloc(ctx->keys\_pos,\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int})*(ctx->keys\_count+1));
00519     ctx->keys\_pos[ctx->keys\_count++] = pos;
00520 \}
00521 
00522 \textcolor{comment}{/* Helper for RM\_CreateCommand(). Truns a string representing command}
00523 \textcolor{comment}{ * flags into the command flags used by the Redis core.}
00524 \textcolor{comment}{ *}
00525 \textcolor{comment}{ * It returns the set of flags, or -1 if unknown flags are found. */}
00526 \textcolor{keywordtype}{int} commandFlagsFromString(\textcolor{keywordtype}{char} *s) \{
00527     \textcolor{keywordtype}{int} count, j;
00528     \textcolor{keywordtype}{int} flags = 0;
00529     sds *tokens = sdssplitlen(s,strlen(s),\textcolor{stringliteral}{" "},1,&count);
00530     \textcolor{keywordflow}{for} (j = 0; j < count; j++) \{
00531         \textcolor{keywordtype}{char} *t = tokens[j];
00532         \textcolor{keywordflow}{if} (!strcasecmp(t,\textcolor{stringliteral}{"write"})) flags |= \hyperlink{server_8h_a7391deb9c3a262ded3e186e94eb884e2}{CMD\_WRITE};
00533         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(t,\textcolor{stringliteral}{"readonly"})) flags |= \hyperlink{server_8h_a7e9c728f228e1c82ae1e22173375abcf}{CMD\_READONLY};
00534         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(t,\textcolor{stringliteral}{"admin"})) flags |= \hyperlink{server_8h_a1917805ea3942a4784ec806c33bc6033}{CMD\_ADMIN};
00535         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(t,\textcolor{stringliteral}{"deny-oom"})) flags |= \hyperlink{server_8h_aef97c640ad8dfdaca21eb67d4c37e447}{CMD\_DENYOOM};
00536         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(t,\textcolor{stringliteral}{"deny-script"})) flags |= \hyperlink{server_8h_aaf26ba9b59589bc7701e36fb440a0fbe}{CMD\_NOSCRIPT};
00537         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(t,\textcolor{stringliteral}{"allow-loading"})) flags |= \hyperlink{server_8h_a5327d118cf467e77d8bb0cebdce3c0ce}{CMD\_LOADING};
00538         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(t,\textcolor{stringliteral}{"pubsub"})) flags |= \hyperlink{server_8h_a201d97fc457fe5bd58cb863b4ac7a0cc}{CMD\_PUBSUB};
00539         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(t,\textcolor{stringliteral}{"random"})) flags |= \hyperlink{server_8h_a9f6608fefa355981c2a865ef3d44f196}{CMD\_RANDOM};
00540         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(t,\textcolor{stringliteral}{"allow-stale"})) flags |= \hyperlink{server_8h_acf1f58ff0b6790cd8d0e3edf1a7e599f}{CMD\_STALE};
00541         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(t,\textcolor{stringliteral}{"no-monitor"})) flags |= \hyperlink{server_8h_a43e2aecb49a88a6cd4e56bfa971bdc71}{CMD\_SKIP\_MONITOR};
00542         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(t,\textcolor{stringliteral}{"fast"})) flags |= \hyperlink{server_8h_ae21dc0d9c0dcdefa14ca1054c48f252f}{CMD\_FAST};
00543         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(t,\textcolor{stringliteral}{"getkeys-api"})) flags |= \hyperlink{server_8h_a612a8681d1a25cd86faf4139d161316a}{CMD\_MODULE\_GETKEYS};
00544         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(t,\textcolor{stringliteral}{"no-cluster"})) flags |= 
      \hyperlink{server_8h_abf1e33c6cd6f59383cb155fa0e164fcd}{CMD\_MODULE\_NO\_CLUSTER};
00545         \textcolor{keywordflow}{else} \textcolor{keywordflow}{break};
00546     \}
00547     sdsfreesplitres(tokens,count);
00548     \textcolor{keywordflow}{if} (j != count) \textcolor{keywordflow}{return} -1; \textcolor{comment}{/* Some token not processed correctly. */}
00549     \textcolor{keywordflow}{return} flags;
00550 \}
00551 
00552 \textcolor{comment}{/* Register a new command in the Redis server, that will be handled by}
00553 \textcolor{comment}{ * calling the function pointer 'func' using the RedisModule calling}
00554 \textcolor{comment}{ * convention. The function returns REDISMODULE\_ERR if the specified command}
00555 \textcolor{comment}{ * name is already busy or a set of invalid flags were passed, otherwise}
00556 \textcolor{comment}{ * REDISMODULE\_OK is returned and the new command is registered.}
00557 \textcolor{comment}{ *}
00558 \textcolor{comment}{ * This function must be called during the initialization of the module}
00559 \textcolor{comment}{ * inside the RedisModule\_OnLoad() function. Calling this function outside}
00560 \textcolor{comment}{ * of the initialization function is not defined.}
00561 \textcolor{comment}{ *}
00562 \textcolor{comment}{ * The command function type is the following:}
00563 \textcolor{comment}{ *}
00564 \textcolor{comment}{ *      int MyCommand\_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc);}
00565 \textcolor{comment}{ *}
00566 \textcolor{comment}{ * And is supposed to always return REDISMODULE\_OK.}
00567 \textcolor{comment}{ *}
00568 \textcolor{comment}{ * The set of flags 'strflags' specify the behavior of the command, and should}
00569 \textcolor{comment}{ * be passed as a C string compoesd of space separated words, like for}
00570 \textcolor{comment}{ * example "write deny-oom". The set of flags are:}
00571 \textcolor{comment}{ *}
00572 \textcolor{comment}{ * * **"write"**:     The command may modify the data set (it may also read}
00573 \textcolor{comment}{ *                    from it).}
00574 \textcolor{comment}{ * * **"readonly"**:  The command returns data from keys but never writes.}
00575 \textcolor{comment}{ * * **"admin"**:     The command is an administrative command (may change}
00576 \textcolor{comment}{ *                    replication or perform similar tasks).}
00577 \textcolor{comment}{ * * **"deny-oom"**:  The command may use additional memory and should be}
00578 \textcolor{comment}{ *                    denied during out of memory conditions.}
00579 \textcolor{comment}{ * * **"deny-script"**:   Don't allow this command in Lua scripts.}
00580 \textcolor{comment}{ * * **"allow-loading"**: Allow this command while the server is loading data.}
00581 \textcolor{comment}{ *                        Only commands not interacting with the data set}
00582 \textcolor{comment}{ *                        should be allowed to run in this mode. If not sure}
00583 \textcolor{comment}{ *                        don't use this flag.}
00584 \textcolor{comment}{ * * **"pubsub"**:    The command publishes things on Pub/Sub channels.}
00585 \textcolor{comment}{ * * **"random"**:    The command may have different outputs even starting}
00586 \textcolor{comment}{ *                    from the same input arguments and key values.}
00587 \textcolor{comment}{ * * **"allow-stale"**: The command is allowed to run on slaves that don't}
00588 \textcolor{comment}{ *                      serve stale data. Don't use if you don't know what}
00589 \textcolor{comment}{ *                      this means.}
00590 \textcolor{comment}{ * * **"no-monitor"**: Don't propoagate the command on monitor. Use this if}
00591 \textcolor{comment}{ *                     the command has sensible data among the arguments.}
00592 \textcolor{comment}{ * * **"fast"**:      The command time complexity is not greater}
00593 \textcolor{comment}{ *                    than O(log(N)) where N is the size of the collection or}
00594 \textcolor{comment}{ *                    anything else representing the normal scalability}
00595 \textcolor{comment}{ *                    issue with the command.}
00596 \textcolor{comment}{ * * **"getkeys-api"**: The command implements the interface to return}
00597 \textcolor{comment}{ *                      the arguments that are keys. Used when start/stop/step}
00598 \textcolor{comment}{ *                      is not enough because of the command syntax.}
00599 \textcolor{comment}{ * * **"no-cluster"**: The command should not register in Redis Cluster}
00600 \textcolor{comment}{ *                     since is not designed to work with it because, for}
00601 \textcolor{comment}{ *                     example, is unable to report the position of the}
00602 \textcolor{comment}{ *                     keys, programmatically creates key names, or any}
00603 \textcolor{comment}{ *                     other reason.}
00604 \textcolor{comment}{ */}
00605 \textcolor{keywordtype}{int} RM\_CreateCommand(RedisModuleCtx *ctx, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *name, RedisModuleCmdFunc cmdfunc, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *
      strflags, \textcolor{keywordtype}{int} firstkey, \textcolor{keywordtype}{int} lastkey, \textcolor{keywordtype}{int} keystep) \{
00606     \textcolor{keywordtype}{int} flags = strflags ? commandFlagsFromString((\textcolor{keywordtype}{char}*)strflags) : 0;
00607     \textcolor{keywordflow}{if} (flags == -1) \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
00608     \textcolor{keywordflow}{if} ((flags & \hyperlink{server_8h_abf1e33c6cd6f59383cb155fa0e164fcd}{CMD\_MODULE\_NO\_CLUSTER}) && server.cluster\_enabled)
00609         \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
00610 
00611     \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *rediscmd;
00612     RedisModuleCommandProxy *cp;
00613     sds cmdname = sdsnew(name);
00614 
00615     \textcolor{comment}{/* Check if the command name is busy. */}
00616     \textcolor{keywordflow}{if} (lookupCommand(cmdname) != NULL) \{
00617         sdsfree(cmdname);
00618         \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
00619     \}
00620 
00621     \textcolor{comment}{/* Create a command "proxy", which is a structure that is referenced}
00622 \textcolor{comment}{     * in the command table, so that the generic command that works as}
00623 \textcolor{comment}{     * binding between modules and Redis, can know what function to call}
00624 \textcolor{comment}{     * and what the module is.}
00625 \textcolor{comment}{     *}
00626 \textcolor{comment}{     * Note that we use the Redis command table 'getkeys\_proc' in order to}
00627 \textcolor{comment}{     * pass a reference to the command proxy structure. */}
00628     cp = zmalloc(\textcolor{keyword}{sizeof}(*cp));
00629     cp->module = ctx->module;
00630     cp->func = cmdfunc;
00631     cp->rediscmd = zmalloc(\textcolor{keyword}{sizeof}(*rediscmd));
00632     cp->rediscmd->name = cmdname;
00633     cp->rediscmd->proc = RedisModuleCommandDispatcher;
00634     cp->rediscmd->arity = -1;
00635     cp->rediscmd->flags = flags | \hyperlink{server_8h_accabd32f20281543986166c219124f9e}{CMD\_MODULE};
00636     cp->rediscmd->getkeys\_proc = (redisGetKeysProc*)(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})cp;
00637     cp->rediscmd->firstkey = firstkey;
00638     cp->rediscmd->lastkey = lastkey;
00639     cp->rediscmd->keystep = keystep;
00640     cp->rediscmd->microseconds = 0;
00641     cp->rediscmd->calls = 0;
00642     dictAdd(server.commands,sdsdup(cmdname),cp->rediscmd);
00643     dictAdd(server.orig\_commands,sdsdup(cmdname),cp->rediscmd);
00644     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
00645 \}
00646 
00647 \textcolor{comment}{/* Called by RM\_Init() to setup the `ctx->module` structure.}
00648 \textcolor{comment}{ *}
00649 \textcolor{comment}{ * This is an internal function, Redis modules developers don't need}
00650 \textcolor{comment}{ * to use it. */}
00651 \textcolor{keywordtype}{void} RM\_SetModuleAttribs(RedisModuleCtx *ctx, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *name, \textcolor{keywordtype}{int} ver, \textcolor{keywordtype}{int} apiver) \{
00652     RedisModule *module;
00653 
00654     \textcolor{keywordflow}{if} (ctx->module != NULL) \textcolor{keywordflow}{return};
00655     module = zmalloc(\textcolor{keyword}{sizeof}(*module));
00656     module->name = sdsnew((\textcolor{keywordtype}{char}*)name);
00657     module->ver = ver;
00658     module->apiver = apiver;
00659     module->types = listCreate();
00660     ctx->module = module;
00661 \}
00662 
00663 \textcolor{comment}{/* Return non-zero if the module name is busy.}
00664 \textcolor{comment}{ * Otherwise zero is returned. */}
00665 \textcolor{keywordtype}{int} RM\_IsModuleNameBusy(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *name) \{
00666     sds modulename = sdsnew(name);
00667     dictEntry *de = dictFind(modules,modulename);
00668     sdsfree(modulename);
00669     \textcolor{keywordflow}{return} de != NULL;
00670 \}
00671 
00672 \textcolor{comment}{/* Return the current UNIX time in milliseconds. */}
00673 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} RM\_Milliseconds(\textcolor{keywordtype}{void}) \{
00674     \textcolor{keywordflow}{return} mstime();
00675 \}
00676 
00677 \textcolor{comment}{/* --------------------------------------------------------------------------}
00678 \textcolor{comment}{ * Automatic memory management for modules}
00679 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
00680 
00681 \textcolor{comment}{/* Enable automatic memory management. See API.md for more information.}
00682 \textcolor{comment}{ *}
00683 \textcolor{comment}{ * The function must be called as the first function of a command implementation}
00684 \textcolor{comment}{ * that wants to use automatic memory. */}
00685 \textcolor{keywordtype}{void} RM\_AutoMemory(RedisModuleCtx *ctx) \{
00686     ctx->flags |= \hyperlink{module_8c_a223998b47b49203e12aba298a7a8fd14}{REDISMODULE\_CTX\_AUTO\_MEMORY};
00687 \}
00688 
00689 \textcolor{comment}{/* Add a new object to release automatically when the callback returns. */}
00690 \textcolor{keywordtype}{void} autoMemoryAdd(RedisModuleCtx *ctx, \textcolor{keywordtype}{int} type, \textcolor{keywordtype}{void} *ptr) \{
00691     \textcolor{keywordflow}{if} (!(ctx->flags & \hyperlink{module_8c_a223998b47b49203e12aba298a7a8fd14}{REDISMODULE\_CTX\_AUTO\_MEMORY})) \textcolor{keywordflow}{return};
00692     \textcolor{keywordflow}{if} (ctx->amqueue\_used == ctx->amqueue\_len) \{
00693         ctx->amqueue\_len *= 2;
00694         \textcolor{keywordflow}{if} (ctx->amqueue\_len < 16) ctx->amqueue\_len = 16;
00695         ctx->amqueue = zrealloc(ctx->amqueue,\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} AutoMemEntry)*ctx->amqueue\_len);
00696     \}
00697     ctx->amqueue[ctx->amqueue\_used].type = type;
00698     ctx->amqueue[ctx->amqueue\_used].ptr = ptr;
00699     ctx->amqueue\_used++;
00700 \}
00701 
00702 \textcolor{comment}{/* Mark an object as freed in the auto release queue, so that users can still}
00703 \textcolor{comment}{ * free things manually if they want.}
00704 \textcolor{comment}{ *}
00705 \textcolor{comment}{ * The function returns 1 if the object was actually found in the auto memory}
00706 \textcolor{comment}{ * pool, otherwise 0 is returned. */}
00707 \textcolor{keywordtype}{int} autoMemoryFreed(RedisModuleCtx *ctx, \textcolor{keywordtype}{int} type, \textcolor{keywordtype}{void} *ptr) \{
00708     \textcolor{keywordflow}{if} (!(ctx->flags & \hyperlink{module_8c_a223998b47b49203e12aba298a7a8fd14}{REDISMODULE\_CTX\_AUTO\_MEMORY})) \textcolor{keywordflow}{return} 0;
00709 
00710     \textcolor{keywordtype}{int} count = (ctx->amqueue\_used+1)/2;
00711     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < count; j++) \{
00712         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} side = 0; side < 2; side++) \{
00713             \textcolor{comment}{/* For side = 0 check right side of the array, for}
00714 \textcolor{comment}{             * side = 1 check the left side instead (zig-zag scanning). */}
00715             \textcolor{keywordtype}{int} i = (side == 0) ? (ctx->amqueue\_used - 1 - j) : j;
00716             \textcolor{keywordflow}{if} (ctx->amqueue[i].type == type &&
00717                 ctx->amqueue[i].ptr == ptr)
00718             \{
00719                 ctx->amqueue[i].type = \hyperlink{module_8c_ab136b31f4a0598600f6678d7fd027ee4}{REDISMODULE\_AM\_FREED};
00720 
00721                 \textcolor{comment}{/* Switch the freed element and the last element, to avoid growing}
00722 \textcolor{comment}{                 * the queue unnecessarily if we allocate/free in a loop */}
00723                 \textcolor{keywordflow}{if} (i != ctx->amqueue\_used-1) \{
00724                     ctx->amqueue[i] = ctx->amqueue[ctx->amqueue\_used-1];
00725                 \}
00726 
00727                 \textcolor{comment}{/* Reduce the size of the queue because we either moved the top}
00728 \textcolor{comment}{                 * element elsewhere or freed it */}
00729                 ctx->amqueue\_used--;
00730                 \textcolor{keywordflow}{return} 1;
00731             \}
00732         \}
00733     \}
00734     \textcolor{keywordflow}{return} 0;
00735 \}
00736 
00737 \textcolor{comment}{/* Release all the objects in queue. */}
00738 \textcolor{keywordtype}{void} autoMemoryCollect(RedisModuleCtx *ctx) \{
00739     \textcolor{keywordflow}{if} (!(ctx->flags & \hyperlink{module_8c_a223998b47b49203e12aba298a7a8fd14}{REDISMODULE\_CTX\_AUTO\_MEMORY})) \textcolor{keywordflow}{return};
00740     \textcolor{comment}{/* Clear the AUTO\_MEMORY flag from the context, otherwise the functions}
00741 \textcolor{comment}{     * we call to free the resources, will try to scan the auto release}
00742 \textcolor{comment}{     * queue to mark the entries as freed. */}
00743     ctx->flags &= ~\hyperlink{module_8c_a223998b47b49203e12aba298a7a8fd14}{REDISMODULE\_CTX\_AUTO\_MEMORY};
00744     \textcolor{keywordtype}{int} j;
00745     \textcolor{keywordflow}{for} (j = 0; j < ctx->amqueue\_used; j++) \{
00746         \textcolor{keywordtype}{void} *ptr = ctx->amqueue[j].ptr;
00747         \textcolor{keywordflow}{switch}(ctx->amqueue[j].type) \{
00748         \textcolor{keywordflow}{case} \hyperlink{module_8c_a566ace39ef8d3d16c3f7d9d6c6b8e4ef}{REDISMODULE\_AM\_STRING}: decrRefCount(ptr); \textcolor{keywordflow}{break};
00749         \textcolor{keywordflow}{case} \hyperlink{module_8c_a3a23ca3942d52889333fbd34f6efcffe}{REDISMODULE\_AM\_REPLY}: RM\_FreeCallReply(ptr); \textcolor{keywordflow}{break};
00750         \textcolor{keywordflow}{case} \hyperlink{module_8c_a72f72d8bccf7f1b34e5622b3571c2fe5}{REDISMODULE\_AM\_KEY}: RM\_CloseKey(ptr); \textcolor{keywordflow}{break};
00751         \}
00752     \}
00753     ctx->flags |= \hyperlink{module_8c_a223998b47b49203e12aba298a7a8fd14}{REDISMODULE\_CTX\_AUTO\_MEMORY};
00754     zfree(ctx->amqueue);
00755     ctx->amqueue = NULL;
00756     ctx->amqueue\_len = 0;
00757     ctx->amqueue\_used = 0;
00758 \}
00759 
00760 \textcolor{comment}{/* --------------------------------------------------------------------------}
00761 \textcolor{comment}{ * String objects APIs}
00762 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
00763 
00764 \textcolor{comment}{/* Create a new module string object. The returned string must be freed}
00765 \textcolor{comment}{ * with RedisModule\_FreeString(), unless automatic memory is enabled.}
00766 \textcolor{comment}{ *}
00767 \textcolor{comment}{ * The string is created by copying the `len` bytes starting}
00768 \textcolor{comment}{ * at `ptr`. No reference is retained to the passed buffer. */}
00769 RedisModuleString *RM\_CreateString(RedisModuleCtx *ctx, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *ptr, size\_t len) \{
00770     RedisModuleString *o = createStringObject(ptr,len);
00771     autoMemoryAdd(ctx,\hyperlink{module_8c_a566ace39ef8d3d16c3f7d9d6c6b8e4ef}{REDISMODULE\_AM\_STRING},o);
00772     \textcolor{keywordflow}{return} o;
00773 \}
00774 
00775 
00776 \textcolor{comment}{/* Create a new module string object from a printf format and arguments.}
00777 \textcolor{comment}{ * The returned string must be freed with RedisModule\_FreeString(), unless}
00778 \textcolor{comment}{ * automatic memory is enabled.}
00779 \textcolor{comment}{ *}
00780 \textcolor{comment}{ * The string is created using the sds formatter function sdscatvprintf(). */}
00781 RedisModuleString *RM\_CreateStringPrintf(RedisModuleCtx *ctx, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, ...) \{
00782     sds s = sdsempty();
00783 
00784     va\_list ap;
00785     va\_start(ap, fmt);
00786     s = sdscatvprintf(s, fmt, ap);
00787     va\_end(ap);
00788 
00789     RedisModuleString *o = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING}, s);
00790     autoMemoryAdd(ctx,\hyperlink{module_8c_a566ace39ef8d3d16c3f7d9d6c6b8e4ef}{REDISMODULE\_AM\_STRING},o);
00791 
00792     \textcolor{keywordflow}{return} o;
00793 \}
00794 
00795 
00796 \textcolor{comment}{/* Like RedisModule\_CreatString(), but creates a string starting from a long long}
00797 \textcolor{comment}{ * integer instead of taking a buffer and its length.}
00798 \textcolor{comment}{ *}
00799 \textcolor{comment}{ * The returned string must be released with RedisModule\_FreeString() or by}
00800 \textcolor{comment}{ * enabling automatic memory management. */}
00801 RedisModuleString *RM\_CreateStringFromLongLong(RedisModuleCtx *ctx, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ll) \{
00802     \textcolor{keywordtype}{char} buf[\hyperlink{server_8h_a39ec35278876f65fc1ef70b049856ca3}{LONG\_STR\_SIZE}];
00803     size\_t len = ll2string(buf,\textcolor{keyword}{sizeof}(buf),ll);
00804     \textcolor{keywordflow}{return} RM\_CreateString(ctx,buf,len);
00805 \}
00806 
00807 \textcolor{comment}{/* Like RedisModule\_CreatString(), but creates a string starting from another}
00808 \textcolor{comment}{ * RedisModuleString.}
00809 \textcolor{comment}{ *}
00810 \textcolor{comment}{ * The returned string must be released with RedisModule\_FreeString() or by}
00811 \textcolor{comment}{ * enabling automatic memory management. */}
00812 RedisModuleString *RM\_CreateStringFromString(RedisModuleCtx *ctx, \textcolor{keyword}{const} RedisModuleString *str) \{
00813     RedisModuleString *o = dupStringObject(str);
00814     autoMemoryAdd(ctx,\hyperlink{module_8c_a566ace39ef8d3d16c3f7d9d6c6b8e4ef}{REDISMODULE\_AM\_STRING},o);
00815     \textcolor{keywordflow}{return} o;
00816 \}
00817 
00818 \textcolor{comment}{/* Free a module string object obtained with one of the Redis modules API calls}
00819 \textcolor{comment}{ * that return new string objects.}
00820 \textcolor{comment}{ *}
00821 \textcolor{comment}{ * It is possible to call this function even when automatic memory management}
00822 \textcolor{comment}{ * is enabled. In that case the string will be released ASAP and removed}
00823 \textcolor{comment}{ * from the pool of string to release at the end. */}
00824 \textcolor{keywordtype}{void} RM\_FreeString(RedisModuleCtx *ctx, RedisModuleString *str) \{
00825     decrRefCount(str);
00826     autoMemoryFreed(ctx,\hyperlink{module_8c_a566ace39ef8d3d16c3f7d9d6c6b8e4ef}{REDISMODULE\_AM\_STRING},str);
00827 \}
00828 
00829 \textcolor{comment}{/* Every call to this function, will make the string 'str' requiring}
00830 \textcolor{comment}{ * an additional call to RedisModule\_FreeString() in order to really}
00831 \textcolor{comment}{ * free the string. Note that the automatic freeing of the string obtained}
00832 \textcolor{comment}{ * enabling modules automatic memory management counts for one}
00833 \textcolor{comment}{ * RedisModule\_FreeString() call (it is just executed automatically).}
00834 \textcolor{comment}{ *}
00835 \textcolor{comment}{ * Normally you want to call this function when, at the same time}
00836 \textcolor{comment}{ * the following conditions are true:}
00837 \textcolor{comment}{ *}
00838 \textcolor{comment}{ * 1) You have automatic memory management enabled.}
00839 \textcolor{comment}{ * 2) You want to create string objects.}
00840 \textcolor{comment}{ * 3) Those string objects you create need to live *after* the callback}
00841 \textcolor{comment}{ *    function(for example a command implementation) creating them returns.}
00842 \textcolor{comment}{ *}
00843 \textcolor{comment}{ * Usually you want this in order to store the created string object}
00844 \textcolor{comment}{ * into your own data structure, for example when implementing a new data}
00845 \textcolor{comment}{ * type.}
00846 \textcolor{comment}{ *}
00847 \textcolor{comment}{ * Note that when memory management is turned off, you don't need}
00848 \textcolor{comment}{ * any call to RetainString() since creating a string will always result}
00849 \textcolor{comment}{ * into a string that lives after the callback function returns, if}
00850 \textcolor{comment}{ * no FreeString() call is performed. */}
00851 \textcolor{keywordtype}{void} RM\_RetainString(RedisModuleCtx *ctx, RedisModuleString *str) \{
00852     \textcolor{keywordflow}{if} (!autoMemoryFreed(ctx,\hyperlink{module_8c_a566ace39ef8d3d16c3f7d9d6c6b8e4ef}{REDISMODULE\_AM\_STRING},str)) \{
00853         \textcolor{comment}{/* Increment the string reference counting only if we can't}
00854 \textcolor{comment}{         * just remove the object from the list of objects that should}
00855 \textcolor{comment}{         * be reclaimed. Why we do that, instead of just incrementing}
00856 \textcolor{comment}{         * the refcount in any case, and let the automatic FreeString()}
00857 \textcolor{comment}{         * call at the end to bring the refcount back at the desired}
00858 \textcolor{comment}{         * value? Because this way we ensure that the object refcount}
00859 \textcolor{comment}{         * value is 1 (instead of going to 2 to be dropped later to 1)}
00860 \textcolor{comment}{         * after the call to this function. This is needed for functions}
00861 \textcolor{comment}{         * like RedisModule\_StringAppendBuffer() to work. */}
00862         incrRefCount(str);
00863     \}
00864 \}
00865 
00866 \textcolor{comment}{/* Given a string module object, this function returns the string pointer}
00867 \textcolor{comment}{ * and length of the string. The returned pointer and length should only}
00868 \textcolor{comment}{ * be used for read only accesses and never modified. */}
00869 \textcolor{keyword}{const} \textcolor{keywordtype}{char} *RM\_StringPtrLen(\textcolor{keyword}{const} RedisModuleString *str, size\_t *len) \{
00870     \textcolor{keywordflow}{if} (str == NULL) \{
00871         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *errmsg = \textcolor{stringliteral}{"(NULL string reply referenced in module)"};
00872         \textcolor{keywordflow}{if} (len) *len = strlen(errmsg);
00873         \textcolor{keywordflow}{return} errmsg;
00874     \}
00875     \textcolor{keywordflow}{if} (len) *len = sdslen(str->ptr);
00876     \textcolor{keywordflow}{return} str->ptr;
00877 \}
00878 
00879 \textcolor{comment}{/* --------------------------------------------------------------------------}
00880 \textcolor{comment}{ * Higher level string operations}
00881 \textcolor{comment}{ * ------------------------------------------------------------------------- */}
00882 
00883 \textcolor{comment}{/* Convert the string into a long long integer, storing it at `*ll`.}
00884 \textcolor{comment}{ * Returns REDISMODULE\_OK on success. If the string can't be parsed}
00885 \textcolor{comment}{ * as a valid, strict long long (no spaces before/after), REDISMODULE\_ERR}
00886 \textcolor{comment}{ * is returned. */}
00887 \textcolor{keywordtype}{int} RM\_StringToLongLong(\textcolor{keyword}{const} RedisModuleString *str, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} *ll) \{
00888     \textcolor{keywordflow}{return} string2ll(str->ptr,sdslen(str->ptr),ll) ? \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK} :
00889                                                      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
00890 \}
00891 
00892 \textcolor{comment}{/* Convert the string into a double, storing it at `*d`.}
00893 \textcolor{comment}{ * Returns REDISMODULE\_OK on success or REDISMODULE\_ERR if the string is}
00894 \textcolor{comment}{ * not a valid string representation of a double value. */}
00895 \textcolor{keywordtype}{int} RM\_StringToDouble(\textcolor{keyword}{const} RedisModuleString *str, \textcolor{keywordtype}{double} *d) \{
00896     \textcolor{keywordtype}{int} retval = getDoubleFromObject(str,d);
00897     \textcolor{keywordflow}{return} (retval == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) ? \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK} : 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
00898 \}
00899 
00900 \textcolor{comment}{/* Compare two string objects, returning -1, 0 or 1 respectively if}
00901 \textcolor{comment}{ * a < b, a == b, a > b. Strings are compared byte by byte as two}
00902 \textcolor{comment}{ * binary blobs without any encoding care / collation attempt. */}
00903 \textcolor{keywordtype}{int} RM\_StringCompare(RedisModuleString *a, RedisModuleString *b) \{
00904     \textcolor{keywordflow}{return} compareStringObjects(a,b);
00905 \}
00906 
00907 \textcolor{comment}{/* Return the (possibly modified in encoding) input 'str' object if}
00908 \textcolor{comment}{ * the string is unshared, otherwise NULL is returned. */}
00909 RedisModuleString *moduleAssertUnsharedString(RedisModuleString *str) \{
00910     \textcolor{keywordflow}{if} (str->refcount != 1) \{
00911         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
00912             \textcolor{stringliteral}{"Module attempted to use an in-place string modify operation "}
00913             \textcolor{stringliteral}{"with a string referenced multiple times. Please check the code "}
00914             \textcolor{stringliteral}{"for API usage correctness."});
00915         \textcolor{keywordflow}{return} NULL;
00916     \}
00917     \textcolor{keywordflow}{if} (str->encoding == \hyperlink{server_8h_ac5bb76b546161fd0da4b0ff89b3142ee}{OBJ\_ENCODING\_EMBSTR}) \{
00918         \textcolor{comment}{/* Note: here we "leak" the additional allocation that was}
00919 \textcolor{comment}{         * used in order to store the embedded string in the object. */}
00920         str->ptr = sdsnewlen(str->ptr,sdslen(str->ptr));
00921         str->encoding = \hyperlink{server_8h_a148bc85e3074e324a6dc5eebcad1bcd5}{OBJ\_ENCODING\_RAW};
00922     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (str->encoding == \hyperlink{server_8h_ae934cf008a0be0ef009c92c2d006a816}{OBJ\_ENCODING\_INT}) \{
00923         \textcolor{comment}{/* Convert the string from integer to raw encoding. */}
00924         str->ptr = sdsfromlonglong((\textcolor{keywordtype}{long})str->ptr);
00925         str->encoding = \hyperlink{server_8h_a148bc85e3074e324a6dc5eebcad1bcd5}{OBJ\_ENCODING\_RAW};
00926     \}
00927     \textcolor{keywordflow}{return} str;
00928 \}
00929 
00930 \textcolor{comment}{/* Append the specified buffere to the string 'str'. The string must be a}
00931 \textcolor{comment}{ * string created by the user that is referenced only a single time, otherwise}
00932 \textcolor{comment}{ * REDISMODULE\_ERR is returend and the operation is not performed. */}
00933 \textcolor{keywordtype}{int} RM\_StringAppendBuffer(RedisModuleCtx *ctx, RedisModuleString *str, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *buf, size\_t len) \{
00934     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(ctx);
00935     str = moduleAssertUnsharedString(str);
00936     \textcolor{keywordflow}{if} (str == NULL) \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
00937     str->ptr = sdscatlen(str->ptr,buf,len);
00938     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
00939 \}
00940 
00941 \textcolor{comment}{/* --------------------------------------------------------------------------}
00942 \textcolor{comment}{ * Reply APIs}
00943 \textcolor{comment}{ *}
00944 \textcolor{comment}{ * Most functions always return REDISMODULE\_OK so you can use it with}
00945 \textcolor{comment}{ * 'return' in order to return from the command implementation with:}
00946 \textcolor{comment}{ *}
00947 \textcolor{comment}{ *     if (... some condition ...)}
00948 \textcolor{comment}{ *         return RM\_ReplyWithLongLong(ctx,mycount);}
00949 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
00950 
00951 \textcolor{comment}{/* Send an error about the number of arguments given to the command,}
00952 \textcolor{comment}{ * citing the command name in the error message.}
00953 \textcolor{comment}{ *}
00954 \textcolor{comment}{ * Example:}
00955 \textcolor{comment}{ *}
00956 \textcolor{comment}{ *     if (argc != 3) return RedisModule\_WrongArity(ctx);}
00957 \textcolor{comment}{ */}
00958 \textcolor{keywordtype}{int} RM\_WrongArity(RedisModuleCtx *ctx) \{
00959     addReplyErrorFormat(ctx->client,
00960         \textcolor{stringliteral}{"wrong number of arguments for '%s' command"},
00961         (\textcolor{keywordtype}{char}*)ctx->client->argv[0]->ptr);
00962     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
00963 \}
00964 
00965 \textcolor{comment}{/* Return the client object the `RM\_Reply*` functions should target.}
00966 \textcolor{comment}{ * Normally this is just `ctx->client`, that is the client that called}
00967 \textcolor{comment}{ * the module command, however in the case of thread safe contexts there}
00968 \textcolor{comment}{ * is no directly associated client (since it would not be safe to access}
00969 \textcolor{comment}{ * the client from a thread), so instead the blocked client object referenced}
00970 \textcolor{comment}{ * in the thread safe context, has a fake client that we just use to accumulate}
00971 \textcolor{comment}{ * the replies. Later, when the client is unblocked, the accumulated replies}
00972 \textcolor{comment}{ * are appended to the actual client.}
00973 \textcolor{comment}{ *}
00974 \textcolor{comment}{ * The function returns the client pointer depending on the context, or}
00975 \textcolor{comment}{ * NULL if there is no potential client. This happens when we are in the}
00976 \textcolor{comment}{ * context of a thread safe context that was not initialized with a blocked}
00977 \textcolor{comment}{ * client object. */}
00978 \hyperlink{structclient}{client} *moduleGetReplyClient(RedisModuleCtx *ctx) \{
00979     \textcolor{keywordflow}{if} (!(ctx->flags & \hyperlink{module_8c_a884fbd2b3a1b008f1635afaeb87ca52a}{REDISMODULE\_CTX\_THREAD\_SAFE}) && ctx->client)
00980         \textcolor{keywordflow}{return} ctx->client;
00981     \textcolor{keywordflow}{if} (ctx->blocked\_client)
00982         \textcolor{keywordflow}{return} ctx->blocked\_client->reply\_client;
00983     \textcolor{keywordflow}{return} NULL;
00984 \}
00985 
00986 \textcolor{comment}{/* Send an integer reply to the client, with the specified long long value.}
00987 \textcolor{comment}{ * The function always returns REDISMODULE\_OK. */}
00988 \textcolor{keywordtype}{int} RM\_ReplyWithLongLong(RedisModuleCtx *ctx, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ll) \{
00989     \hyperlink{structclient}{client} *c = moduleGetReplyClient(ctx);
00990     \textcolor{keywordflow}{if} (c == NULL) \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
00991     addReplyLongLong(c,ll);
00992     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
00993 \}
00994 
00995 \textcolor{comment}{/* Reply with an error or simple string (status message). Used to implement}
00996 \textcolor{comment}{ * ReplyWithSimpleString() and ReplyWithError().}
00997 \textcolor{comment}{ * The function always returns REDISMODULE\_OK. */}
00998 \textcolor{keywordtype}{int} replyWithStatus(RedisModuleCtx *ctx, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *msg, \textcolor{keywordtype}{char} *prefix) \{
00999     \hyperlink{structclient}{client} *c = moduleGetReplyClient(ctx);
01000     \textcolor{keywordflow}{if} (c == NULL) \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01001     sds strmsg = sdsnewlen(prefix,1);
01002     strmsg = sdscat(strmsg,msg);
01003     strmsg = sdscatlen(strmsg,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"},2);
01004     addReplySds(c,strmsg);
01005     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01006 \}
01007 
01008 \textcolor{comment}{/* Reply with the error 'err'.}
01009 \textcolor{comment}{ *}
01010 \textcolor{comment}{ * Note that 'err' must contain all the error, including}
01011 \textcolor{comment}{ * the initial error code. The function only provides the initial "-", so}
01012 \textcolor{comment}{ * the usage is, for example:}
01013 \textcolor{comment}{ *}
01014 \textcolor{comment}{ *     RedisModule\_ReplyWithError(ctx,"ERR Wrong Type");}
01015 \textcolor{comment}{ *}
01016 \textcolor{comment}{ * and not just:}
01017 \textcolor{comment}{ *}
01018 \textcolor{comment}{ *     RedisModule\_ReplyWithError(ctx,"Wrong Type");}
01019 \textcolor{comment}{ *}
01020 \textcolor{comment}{ * The function always returns REDISMODULE\_OK.}
01021 \textcolor{comment}{ */}
01022 \textcolor{keywordtype}{int} RM\_ReplyWithError(RedisModuleCtx *ctx, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *err) \{
01023     \textcolor{keywordflow}{return} replyWithStatus(ctx,err,\textcolor{stringliteral}{"-"});
01024 \}
01025 
01026 \textcolor{comment}{/* Reply with a simple string (+... \(\backslash\)r\(\backslash\)n in RESP protocol). This replies}
01027 \textcolor{comment}{ * are suitable only when sending a small non-binary string with small}
01028 \textcolor{comment}{ * overhead, like "OK" or similar replies.}
01029 \textcolor{comment}{ *}
01030 \textcolor{comment}{ * The function always returns REDISMODULE\_OK. */}
01031 \textcolor{keywordtype}{int} RM\_ReplyWithSimpleString(RedisModuleCtx *ctx, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *msg) \{
01032     \textcolor{keywordflow}{return} replyWithStatus(ctx,msg,\textcolor{stringliteral}{"+"});
01033 \}
01034 
01035 \textcolor{comment}{/* Reply with an array type of 'len' elements. However 'len' other calls}
01036 \textcolor{comment}{ * to `ReplyWith*` style functions must follow in order to emit the elements}
01037 \textcolor{comment}{ * of the array.}
01038 \textcolor{comment}{ *}
01039 \textcolor{comment}{ * When producing arrays with a number of element that is not known beforehand}
01040 \textcolor{comment}{ * the function can be called with the special count}
01041 \textcolor{comment}{ * REDISMODULE\_POSTPONED\_ARRAY\_LEN, and the actual number of elements can be}
01042 \textcolor{comment}{ * later set with RedisModule\_ReplySetArrayLength() (which will set the}
01043 \textcolor{comment}{ * latest "open" count if there are multiple ones).}
01044 \textcolor{comment}{ *}
01045 \textcolor{comment}{ * The function always returns REDISMODULE\_OK. */}
01046 \textcolor{keywordtype}{int} RM\_ReplyWithArray(RedisModuleCtx *ctx, \textcolor{keywordtype}{long} len) \{
01047     \hyperlink{structclient}{client} *c = moduleGetReplyClient(ctx);
01048     \textcolor{keywordflow}{if} (c == NULL) \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01049     \textcolor{keywordflow}{if} (len == \hyperlink{redismodule_8h_af07005134cbf107aad1c8e0ded8fcf2b}{REDISMODULE\_POSTPONED\_ARRAY\_LEN}) \{
01050         ctx->postponed\_arrays = zrealloc(ctx->postponed\_arrays,\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*)*
01051                 (ctx->postponed\_arrays\_count+1));
01052         ctx->postponed\_arrays[ctx->postponed\_arrays\_count] =
01053             addDeferredMultiBulkLength(c);
01054         ctx->postponed\_arrays\_count++;
01055     \} \textcolor{keywordflow}{else} \{
01056         addReplyMultiBulkLen(c,len);
01057     \}
01058     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01059 \}
01060 
01061 \textcolor{comment}{/* When RedisModule\_ReplyWithArray() is used with the argument}
01062 \textcolor{comment}{ * REDISMODULE\_POSTPONED\_ARRAY\_LEN, because we don't know beforehand the number}
01063 \textcolor{comment}{ * of items we are going to output as elements of the array, this function}
01064 \textcolor{comment}{ * will take care to set the array length.}
01065 \textcolor{comment}{ *}
01066 \textcolor{comment}{ * Since it is possible to have multiple array replies pending with unknown}
01067 \textcolor{comment}{ * length, this function guarantees to always set the latest array length}
01068 \textcolor{comment}{ * that was created in a postponed way.}
01069 \textcolor{comment}{ *}
01070 \textcolor{comment}{ * For example in order to output an array like [1,[10,20,30]] we}
01071 \textcolor{comment}{ * could write:}
01072 \textcolor{comment}{ *}
01073 \textcolor{comment}{ *      RedisModule\_ReplyWithArray(ctx,REDISMODULE\_POSTPONED\_ARRAY\_LEN);}
01074 \textcolor{comment}{ *      RedisModule\_ReplyWithLongLong(ctx,1);}
01075 \textcolor{comment}{ *      RedisModule\_ReplyWithArray(ctx,REDISMODULE\_POSTPONED\_ARRAY\_LEN);}
01076 \textcolor{comment}{ *      RedisModule\_ReplyWithLongLong(ctx,10);}
01077 \textcolor{comment}{ *      RedisModule\_ReplyWithLongLong(ctx,20);}
01078 \textcolor{comment}{ *      RedisModule\_ReplyWithLongLong(ctx,30);}
01079 \textcolor{comment}{ *      RedisModule\_ReplySetArrayLength(ctx,3); // Set len of 10,20,30 array.}
01080 \textcolor{comment}{ *      RedisModule\_ReplySetArrayLength(ctx,2); // Set len of top array}
01081 \textcolor{comment}{ *}
01082 \textcolor{comment}{ * Note that in the above example there is no reason to postpone the array}
01083 \textcolor{comment}{ * length, since we produce a fixed number of elements, but in the practice}
01084 \textcolor{comment}{ * the code may use an interator or other ways of creating the output so}
01085 \textcolor{comment}{ * that is not easy to calculate in advance the number of elements.}
01086 \textcolor{comment}{ */}
01087 \textcolor{keywordtype}{void} RM\_ReplySetArrayLength(RedisModuleCtx *ctx, \textcolor{keywordtype}{long} len) \{
01088     \hyperlink{structclient}{client} *c = moduleGetReplyClient(ctx);
01089     \textcolor{keywordflow}{if} (c == NULL) \textcolor{keywordflow}{return};
01090     \textcolor{keywordflow}{if} (ctx->postponed\_arrays\_count == 0) \{
01091         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01092             \textcolor{stringliteral}{"API misuse detected in module %s: "}
01093             \textcolor{stringliteral}{"RedisModule\_ReplySetArrayLength() called without previous "}
01094             \textcolor{stringliteral}{"RedisModule\_ReplyWithArray(ctx,REDISMODULE\_POSTPONED\_ARRAY\_LEN) "}
01095             \textcolor{stringliteral}{"call."}, ctx->module->name);
01096             \textcolor{keywordflow}{return};
01097     \}
01098     ctx->postponed\_arrays\_count--;
01099     setDeferredMultiBulkLength(c,
01100             ctx->postponed\_arrays[ctx->postponed\_arrays\_count],
01101             len);
01102     \textcolor{keywordflow}{if} (ctx->postponed\_arrays\_count == 0) \{
01103         zfree(ctx->postponed\_arrays);
01104         ctx->postponed\_arrays = NULL;
01105     \}
01106 \}
01107 
01108 \textcolor{comment}{/* Reply with a bulk string, taking in input a C buffer pointer and length.}
01109 \textcolor{comment}{ *}
01110 \textcolor{comment}{ * The function always returns REDISMODULE\_OK. */}
01111 \textcolor{keywordtype}{int} RM\_ReplyWithStringBuffer(RedisModuleCtx *ctx, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *buf, size\_t len) \{
01112     \hyperlink{structclient}{client} *c = moduleGetReplyClient(ctx);
01113     \textcolor{keywordflow}{if} (c == NULL) \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01114     addReplyBulkCBuffer(c,(\textcolor{keywordtype}{char}*)buf,len);
01115     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01116 \}
01117 
01118 \textcolor{comment}{/* Reply with a bulk string, taking in input a RedisModuleString object.}
01119 \textcolor{comment}{ *}
01120 \textcolor{comment}{ * The function always returns REDISMODULE\_OK. */}
01121 \textcolor{keywordtype}{int} RM\_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str) \{
01122     \hyperlink{structclient}{client} *c = moduleGetReplyClient(ctx);
01123     \textcolor{keywordflow}{if} (c == NULL) \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01124     addReplyBulk(c,str);
01125     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01126 \}
01127 
01128 \textcolor{comment}{/* Reply to the client with a NULL. In the RESP protocol a NULL is encoded}
01129 \textcolor{comment}{ * as the string "$-1\(\backslash\)r\(\backslash\)n".}
01130 \textcolor{comment}{ *}
01131 \textcolor{comment}{ * The function always returns REDISMODULE\_OK. */}
01132 \textcolor{keywordtype}{int} RM\_ReplyWithNull(RedisModuleCtx *ctx) \{
01133     \hyperlink{structclient}{client} *c = moduleGetReplyClient(ctx);
01134     \textcolor{keywordflow}{if} (c == NULL) \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01135     addReply(c,shared.nullbulk);
01136     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01137 \}
01138 
01139 \textcolor{comment}{/* Reply exactly what a Redis command returned us with RedisModule\_Call().}
01140 \textcolor{comment}{ * This function is useful when we use RedisModule\_Call() in order to}
01141 \textcolor{comment}{ * execute some command, as we want to reply to the client exactly the}
01142 \textcolor{comment}{ * same reply we obtained by the command.}
01143 \textcolor{comment}{ *}
01144 \textcolor{comment}{ * The function always returns REDISMODULE\_OK. */}
01145 \textcolor{keywordtype}{int} RM\_ReplyWithCallReply(RedisModuleCtx *ctx, \hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply) \{
01146     \hyperlink{structclient}{client} *c = moduleGetReplyClient(ctx);
01147     \textcolor{keywordflow}{if} (c == NULL) \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01148     sds proto = sdsnewlen(reply->proto, reply->protolen);
01149     addReplySds(c,proto);
01150     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01151 \}
01152 
01153 \textcolor{comment}{/* Send a string reply obtained converting the double 'd' into a bulk string.}
01154 \textcolor{comment}{ * This function is basically equivalent to converting a double into}
01155 \textcolor{comment}{ * a string into a C buffer, and then calling the function}
01156 \textcolor{comment}{ * RedisModule\_ReplyWithStringBuffer() with the buffer and length.}
01157 \textcolor{comment}{ *}
01158 \textcolor{comment}{ * The function always returns REDISMODULE\_OK. */}
01159 \textcolor{keywordtype}{int} RM\_ReplyWithDouble(RedisModuleCtx *ctx, \textcolor{keywordtype}{double} d) \{
01160     \hyperlink{structclient}{client} *c = moduleGetReplyClient(ctx);
01161     \textcolor{keywordflow}{if} (c == NULL) \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01162     addReplyDouble(c,d);
01163     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01164 \}
01165 
01166 \textcolor{comment}{/* --------------------------------------------------------------------------}
01167 \textcolor{comment}{ * Commands replication API}
01168 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
01169 
01170 \textcolor{comment}{/* Helper function to replicate MULTI the first time we replicate something}
01171 \textcolor{comment}{ * in the context of a command execution. EXEC will be handled by the}
01172 \textcolor{comment}{ * RedisModuleCommandDispatcher() function. */}
01173 \textcolor{keywordtype}{void} moduleReplicateMultiIfNeeded(RedisModuleCtx *ctx) \{
01174     \textcolor{comment}{/* Skip this if client explicitly wrap the command with MULTI, or if}
01175 \textcolor{comment}{     * the module command was called by a script. */}
01176     \textcolor{keywordflow}{if} (ctx->client->flags & (\hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI}|\hyperlink{server_8h_af9d0b0f45ef2c1fd29ac714a300de706}{CLIENT\_LUA})) \textcolor{keywordflow}{return};
01177     \textcolor{comment}{/* If we already emitted MULTI return ASAP. */}
01178     \textcolor{keywordflow}{if} (ctx->flags & \hyperlink{module_8c_a4b2299e0b7b9fda08895270574120015}{REDISMODULE\_CTX\_MULTI\_EMITTED}) \textcolor{keywordflow}{return};
01179     \textcolor{comment}{/* If this is a thread safe context, we do not want to wrap commands}
01180 \textcolor{comment}{     * executed into MUTLI/EXEC, they are executed as single commands}
01181 \textcolor{comment}{     * from an external client in essence. */}
01182     \textcolor{keywordflow}{if} (ctx->flags & \hyperlink{module_8c_a884fbd2b3a1b008f1635afaeb87ca52a}{REDISMODULE\_CTX\_THREAD\_SAFE}) \textcolor{keywordflow}{return};
01183     execCommandPropagateMulti(ctx->client);
01184     ctx->flags |= \hyperlink{module_8c_a4b2299e0b7b9fda08895270574120015}{REDISMODULE\_CTX\_MULTI\_EMITTED};
01185 \}
01186 
01187 \textcolor{comment}{/* Replicate the specified command and arguments to slaves and AOF, as effect}
01188 \textcolor{comment}{ * of execution of the calling command implementation.}
01189 \textcolor{comment}{ *}
01190 \textcolor{comment}{ * The replicated commands are always wrapped into the MULTI/EXEC that}
01191 \textcolor{comment}{ * contains all the commands replicated in a given module command}
01192 \textcolor{comment}{ * execution. However the commands replicated with RedisModule\_Call()}
01193 \textcolor{comment}{ * are the first items, the ones replicated with RedisModule\_Replicate()}
01194 \textcolor{comment}{ * will all follow before the EXEC.}
01195 \textcolor{comment}{ *}
01196 \textcolor{comment}{ * Modules should try to use one interface or the other.}
01197 \textcolor{comment}{ *}
01198 \textcolor{comment}{ * This command follows exactly the same interface of RedisModule\_Call(),}
01199 \textcolor{comment}{ * so a set of format specifiers must be passed, followed by arguments}
01200 \textcolor{comment}{ * matching the provided format specifiers.}
01201 \textcolor{comment}{ *}
01202 \textcolor{comment}{ * Please refer to RedisModule\_Call() for more information.}
01203 \textcolor{comment}{ *}
01204 \textcolor{comment}{ * The command returns REDISMODULE\_ERR if the format specifiers are invalid}
01205 \textcolor{comment}{ * or the command name does not belong to a known command. */}
01206 \textcolor{keywordtype}{int} RM\_Replicate(RedisModuleCtx *ctx, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *cmdname, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, ...) \{
01207     \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd;
01208     robj **argv = NULL;
01209     \textcolor{keywordtype}{int} argc = 0, flags = 0, j;
01210     va\_list ap;
01211 
01212     cmd = lookupCommandByCString((\textcolor{keywordtype}{char}*)cmdname);
01213     \textcolor{keywordflow}{if} (!cmd) \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01214 
01215     \textcolor{comment}{/* Create the client and dispatch the command. */}
01216     va\_start(ap, fmt);
01217     argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);
01218     va\_end(ap);
01219     \textcolor{keywordflow}{if} (argv == NULL) \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01220 
01221     \textcolor{comment}{/* Replicate! */}
01222     moduleReplicateMultiIfNeeded(ctx);
01223     alsoPropagate(cmd,ctx->client->db->id,argv,argc,
01224         \hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF}|\hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL});
01225 
01226     \textcolor{comment}{/* Release the argv. */}
01227     \textcolor{keywordflow}{for} (j = 0; j < argc; j++) decrRefCount(argv[j]);
01228     zfree(argv);
01229     server.dirty++;
01230     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01231 \}
01232 
01233 \textcolor{comment}{/* This function will replicate the command exactly as it was invoked}
01234 \textcolor{comment}{ * by the client. Note that this function will not wrap the command into}
01235 \textcolor{comment}{ * a MULTI/EXEC stanza, so it should not be mixed with other replication}
01236 \textcolor{comment}{ * commands.}
01237 \textcolor{comment}{ *}
01238 \textcolor{comment}{ * Basically this form of replication is useful when you want to propagate}
01239 \textcolor{comment}{ * the command to the slaves and AOF file exactly as it was called, since}
01240 \textcolor{comment}{ * the command can just be re-executed to deterministically re-create the}
01241 \textcolor{comment}{ * new state starting from the old one.}
01242 \textcolor{comment}{ *}
01243 \textcolor{comment}{ * The function always returns REDISMODULE\_OK. */}
01244 \textcolor{keywordtype}{int} RM\_ReplicateVerbatim(RedisModuleCtx *ctx) \{
01245     alsoPropagate(ctx->client->cmd,ctx->client->db->id,
01246         ctx->client->argv,ctx->client->argc,
01247         \hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF}|\hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL});
01248     server.dirty++;
01249     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01250 \}
01251 
01252 \textcolor{comment}{/* --------------------------------------------------------------------------}
01253 \textcolor{comment}{ * DB and Key APIs -- Generic API}
01254 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
01255 
01256 \textcolor{comment}{/* Return the ID of the current client calling the currently active module}
01257 \textcolor{comment}{ * command. The returned ID has a few guarantees:}
01258 \textcolor{comment}{ *}
01259 \textcolor{comment}{ * 1. The ID is different for each different client, so if the same client}
01260 \textcolor{comment}{ *    executes a module command multiple times, it can be recognized as}
01261 \textcolor{comment}{ *    having the same ID, otherwise the ID will be different.}
01262 \textcolor{comment}{ * 2. The ID increases monotonically. Clients connecting to the server later}
01263 \textcolor{comment}{ *    are guaranteed to get IDs greater than any past ID previously seen.}
01264 \textcolor{comment}{ *}
01265 \textcolor{comment}{ * Valid IDs are from 1 to 2^64-1. If 0 is returned it means there is no way}
01266 \textcolor{comment}{ * to fetch the ID in the context the function was currently called. */}
01267 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} RM\_GetClientId(RedisModuleCtx *ctx) \{
01268     \textcolor{keywordflow}{if} (ctx->client == NULL) \textcolor{keywordflow}{return} 0;
01269     \textcolor{keywordflow}{return} ctx->client->id;
01270 \}
01271 
01272 \textcolor{comment}{/* Return the currently selected DB. */}
01273 \textcolor{keywordtype}{int} RM\_GetSelectedDb(RedisModuleCtx *ctx) \{
01274     \textcolor{keywordflow}{return} ctx->client->db->id;
01275 \}
01276 
01277 
01278 \textcolor{comment}{/* Return the current context's flags. The flags provide information on the }
01279 \textcolor{comment}{ * current request context (whether the client is a Lua script or in a MULTI),}
01280 \textcolor{comment}{ * and about the Redis instance in general, i.e replication and persistence. }
01281 \textcolor{comment}{ * }
01282 \textcolor{comment}{ * The available flags are:}
01283 \textcolor{comment}{ * }
01284 \textcolor{comment}{ *  * REDISMODULE\_CTX\_FLAGS\_LUA: The command is running in a Lua script}
01285 \textcolor{comment}{ * }
01286 \textcolor{comment}{ *  * REDISMODULE\_CTX\_FLAGS\_MULTI: The command is running inside a transaction}
01287 \textcolor{comment}{ * }
01288 \textcolor{comment}{ *  * REDISMODULE\_CTX\_FLAGS\_MASTER: The Redis instance is a master}
01289 \textcolor{comment}{ * }
01290 \textcolor{comment}{ *  * REDISMODULE\_CTX\_FLAGS\_SLAVE: The Redis instance is a slave}
01291 \textcolor{comment}{ * }
01292 \textcolor{comment}{ *  * REDISMODULE\_CTX\_FLAGS\_READONLY: The Redis instance is read-only}
01293 \textcolor{comment}{ * }
01294 \textcolor{comment}{ *  * REDISMODULE\_CTX\_FLAGS\_CLUSTER: The Redis instance is in cluster mode}
01295 \textcolor{comment}{ * }
01296 \textcolor{comment}{ *  * REDISMODULE\_CTX\_FLAGS\_AOF: The Redis instance has AOF enabled}
01297 \textcolor{comment}{ * }
01298 \textcolor{comment}{ *  * REDISMODULE\_CTX\_FLAGS\_RDB: The instance has RDB enabled}
01299 \textcolor{comment}{ * }
01300 \textcolor{comment}{ *  * REDISMODULE\_CTX\_FLAGS\_MAXMEMORY:  The instance has Maxmemory set}
01301 \textcolor{comment}{ * }
01302 \textcolor{comment}{ *  * REDISMODULE\_CTX\_FLAGS\_EVICT:  Maxmemory is set and has an eviction}
01303 \textcolor{comment}{ *    policy that may delete keys}
01304 \textcolor{comment}{ */}
01305 \textcolor{keywordtype}{int} RM\_GetContextFlags(RedisModuleCtx *ctx) \{
01306 
01307     \textcolor{keywordtype}{int} flags = 0;
01308     \textcolor{comment}{/* Client specific flags */}
01309     \textcolor{keywordflow}{if} (ctx->client) \{
01310         \textcolor{keywordflow}{if} (ctx->client->flags & \hyperlink{server_8h_af9d0b0f45ef2c1fd29ac714a300de706}{CLIENT\_LUA})
01311          flags |= \hyperlink{redismodule_8h_ae1eac2a152ac7acd3ac8c7eb84d3bc45}{REDISMODULE\_CTX\_FLAGS\_LUA};
01312         \textcolor{keywordflow}{if} (ctx->client->flags & \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI})
01313          flags |= \hyperlink{redismodule_8h_a2498b6bcdcdc1733a2913a23d23c2b56}{REDISMODULE\_CTX\_FLAGS\_MULTI};
01314     \}
01315 
01316     \textcolor{keywordflow}{if} (server.cluster\_enabled)
01317         flags |= \hyperlink{redismodule_8h_a5c34f8b64241bbbd00bc3df9c3c08844}{REDISMODULE\_CTX\_FLAGS\_CLUSTER};
01318 
01319     \textcolor{comment}{/* Maxmemory and eviction policy */}
01320     \textcolor{keywordflow}{if} (server.maxmemory > 0) \{
01321         flags |= \hyperlink{redismodule_8h_a8c676eb00ac368cca7c8515aa115213d}{REDISMODULE\_CTX\_FLAGS\_MAXMEMORY};
01322 
01323         \textcolor{keywordflow}{if} (server.maxmemory\_policy != \hyperlink{server_8h_a418e5a222cf659c003df77830f1ae343}{MAXMEMORY\_NO\_EVICTION})
01324             flags |= \hyperlink{redismodule_8h_acc6e7822ea410be48f1006b39cf8c487}{REDISMODULE\_CTX\_FLAGS\_EVICT};
01325     \}
01326 
01327     \textcolor{comment}{/* Persistence flags */}
01328     \textcolor{keywordflow}{if} (server.aof\_state != \hyperlink{server_8h_a5226306fbcebcb6d5d02e0fef3c213c2}{AOF\_OFF})
01329         flags |= \hyperlink{redismodule_8h_a33ce10fefe981f7c6f3676b8d6ed6195}{REDISMODULE\_CTX\_FLAGS\_AOF};
01330     \textcolor{keywordflow}{if} (server.saveparamslen > 0)
01331         flags |= \hyperlink{redismodule_8h_a27a5c58d9cbaba98c06c532d09dc7a41}{REDISMODULE\_CTX\_FLAGS\_RDB};
01332 
01333     \textcolor{comment}{/* Replication flags */}
01334     \textcolor{keywordflow}{if} (server.masterhost == NULL) \{
01335         flags |= \hyperlink{redismodule_8h_a4ada8d595eeaaea1d343cafaab7be85a}{REDISMODULE\_CTX\_FLAGS\_MASTER};
01336     \} \textcolor{keywordflow}{else} \{
01337         flags |= \hyperlink{redismodule_8h_ae6c2d2900511d92be4f9ecab6a330459}{REDISMODULE\_CTX\_FLAGS\_SLAVE};
01338         \textcolor{keywordflow}{if} (server.repl\_slave\_ro)
01339             flags |= \hyperlink{redismodule_8h_a58e4767512e8e1491f048cb77ac9371f}{REDISMODULE\_CTX\_FLAGS\_READONLY};
01340     \}
01341 
01342     \textcolor{keywordflow}{return} flags;
01343 \}
01344 
01345 \textcolor{comment}{/* Change the currently selected DB. Returns an error if the id}
01346 \textcolor{comment}{ * is out of range.}
01347 \textcolor{comment}{ *}
01348 \textcolor{comment}{ * Note that the client will retain the currently selected DB even after}
01349 \textcolor{comment}{ * the Redis command implemented by the module calling this function}
01350 \textcolor{comment}{ * returns.}
01351 \textcolor{comment}{ *}
01352 \textcolor{comment}{ * If the module command wishes to change something in a different DB and}
01353 \textcolor{comment}{ * returns back to the original one, it should call RedisModule\_GetSelectedDb()}
01354 \textcolor{comment}{ * before in order to restore the old DB number before returning. */}
01355 \textcolor{keywordtype}{int} RM\_SelectDb(RedisModuleCtx *ctx, \textcolor{keywordtype}{int} newid) \{
01356     \textcolor{keywordtype}{int} retval = selectDb(ctx->client,newid);
01357     \textcolor{keywordflow}{return} (retval == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) ? \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK} : 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01358 \}
01359 
01360 \textcolor{comment}{/* Return an handle representing a Redis key, so that it is possible}
01361 \textcolor{comment}{ * to call other APIs with the key handle as argument to perform}
01362 \textcolor{comment}{ * operations on the key.}
01363 \textcolor{comment}{ *}
01364 \textcolor{comment}{ * The return value is the handle repesenting the key, that must be}
01365 \textcolor{comment}{ * closed with RM\_CloseKey().}
01366 \textcolor{comment}{ *}
01367 \textcolor{comment}{ * If the key does not exist and WRITE mode is requested, the handle}
01368 \textcolor{comment}{ * is still returned, since it is possible to perform operations on}
01369 \textcolor{comment}{ * a yet not existing key (that will be created, for example, after}
01370 \textcolor{comment}{ * a list push operation). If the mode is just READ instead, and the}
01371 \textcolor{comment}{ * key does not exist, NULL is returned. However it is still safe to}
01372 \textcolor{comment}{ * call RedisModule\_CloseKey() and RedisModule\_KeyType() on a NULL}
01373 \textcolor{comment}{ * value. */}
01374 \textcolor{keywordtype}{void} *RM\_OpenKey(RedisModuleCtx *ctx, robj *keyname, \textcolor{keywordtype}{int} mode) \{
01375     RedisModuleKey *kp;
01376     robj *value;
01377 
01378     \textcolor{keywordflow}{if} (mode & \hyperlink{redismodule_8h_a73b37117ef94cb4a904361afcc51b6b4}{REDISMODULE\_WRITE}) \{
01379         value = lookupKeyWrite(ctx->client->db,keyname);
01380     \} \textcolor{keywordflow}{else} \{
01381         value = lookupKeyRead(ctx->client->db,keyname);
01382         \textcolor{keywordflow}{if} (value == NULL) \{
01383             \textcolor{keywordflow}{return} NULL;
01384         \}
01385     \}
01386 
01387     \textcolor{comment}{/* Setup the key handle. */}
01388     kp = zmalloc(\textcolor{keyword}{sizeof}(*kp));
01389     kp->ctx = ctx;
01390     kp->db = ctx->client->db;
01391     kp->key = keyname;
01392     incrRefCount(keyname);
01393     kp->value = value;
01394     kp->iter = NULL;
01395     kp->mode = mode;
01396     zsetKeyReset(kp);
01397     autoMemoryAdd(ctx,\hyperlink{module_8c_a72f72d8bccf7f1b34e5622b3571c2fe5}{REDISMODULE\_AM\_KEY},kp);
01398     \textcolor{keywordflow}{return} (\textcolor{keywordtype}{void}*)kp;
01399 \}
01400 
01401 \textcolor{comment}{/* Close a key handle. */}
01402 \textcolor{keywordtype}{void} RM\_CloseKey(RedisModuleKey *key) \{
01403     \textcolor{keywordflow}{if} (key == NULL) \textcolor{keywordflow}{return};
01404     \textcolor{keywordflow}{if} (key->mode & \hyperlink{redismodule_8h_a73b37117ef94cb4a904361afcc51b6b4}{REDISMODULE\_WRITE}) signalModifiedKey(key->db,key->key);
01405     \textcolor{comment}{/* TODO: if (key->iter) RM\_KeyIteratorStop(kp); */}
01406     RM\_ZsetRangeStop(key);
01407     decrRefCount(key->key);
01408     autoMemoryFreed(key->ctx,\hyperlink{module_8c_a72f72d8bccf7f1b34e5622b3571c2fe5}{REDISMODULE\_AM\_KEY},key);
01409     zfree(key);
01410 \}
01411 
01412 \textcolor{comment}{/* Return the type of the key. If the key pointer is NULL then}
01413 \textcolor{comment}{ * REDISMODULE\_KEYTYPE\_EMPTY is returned. */}
01414 \textcolor{keywordtype}{int} RM\_KeyType(RedisModuleKey *key) \{
01415     \textcolor{keywordflow}{if} (key == NULL || key->value ==  NULL) \textcolor{keywordflow}{return} 
      \hyperlink{redismodule_8h_adf2819748eb5e89c621d2c9c65c0b5f7}{REDISMODULE\_KEYTYPE\_EMPTY};
01416     \textcolor{comment}{/* We map between defines so that we are free to change the internal}
01417 \textcolor{comment}{     * defines as desired. */}
01418     \textcolor{keywordflow}{switch}(key->value->type) \{
01419     \textcolor{keywordflow}{case} \hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING}: \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_aa95428eed7110a77736ddbe0584aebbf}{REDISMODULE\_KEYTYPE\_STRING};
01420     \textcolor{keywordflow}{case} \hyperlink{server_8h_a4a5f22a280949c97a0cb0d4213275126}{OBJ\_LIST}: \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a4c01058971d9d8fe1cfa02071fa87fa6}{REDISMODULE\_KEYTYPE\_LIST};
01421     \textcolor{keywordflow}{case} \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET}: \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a9dbd714eeaaf496a9b45e151a387b41a}{REDISMODULE\_KEYTYPE\_SET};
01422     \textcolor{keywordflow}{case} \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}: \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a93d1514d4c11cc65551b36cfd9a72cc2}{REDISMODULE\_KEYTYPE\_ZSET};
01423     \textcolor{keywordflow}{case} \hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH}: \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_ac019575ac57520c325597e2fb54c5b71}{REDISMODULE\_KEYTYPE\_HASH};
01424     \textcolor{keywordflow}{case} \hyperlink{server_8h_a92c1fed85f709180fda0ff10d37d649b}{OBJ\_MODULE}: \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a7beeb7b9c1c8e419591b3affb5b01f93}{REDISMODULE\_KEYTYPE\_MODULE};
01425     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} 0;
01426     \}
01427 \}
01428 
01429 \textcolor{comment}{/* Return the length of the value associated with the key.}
01430 \textcolor{comment}{ * For strings this is the length of the string. For all the other types}
01431 \textcolor{comment}{ * is the number of elements (just counting keys for hashes).}
01432 \textcolor{comment}{ *}
01433 \textcolor{comment}{ * If the key pointer is NULL or the key is empty, zero is returned. */}
01434 size\_t RM\_ValueLength(RedisModuleKey *key) \{
01435     \textcolor{keywordflow}{if} (key == NULL || key->value == NULL) \textcolor{keywordflow}{return} 0;
01436     \textcolor{keywordflow}{switch}(key->value->type) \{
01437     \textcolor{keywordflow}{case} \hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING}: \textcolor{keywordflow}{return} stringObjectLen(key->value);
01438     \textcolor{keywordflow}{case} \hyperlink{server_8h_a4a5f22a280949c97a0cb0d4213275126}{OBJ\_LIST}: \textcolor{keywordflow}{return} listTypeLength(key->value);
01439     \textcolor{keywordflow}{case} \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET}: \textcolor{keywordflow}{return} setTypeSize(key->value);
01440     \textcolor{keywordflow}{case} \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}: \textcolor{keywordflow}{return} zsetLength(key->value);
01441     \textcolor{keywordflow}{case} \hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH}: \textcolor{keywordflow}{return} hashTypeLength(key->value);
01442     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} 0;
01443     \}
01444 \}
01445 
01446 \textcolor{comment}{/* If the key is open for writing, remove it, and setup the key to}
01447 \textcolor{comment}{ * accept new writes as an empty key (that will be created on demand).}
01448 \textcolor{comment}{ * On success REDISMODULE\_OK is returned. If the key is not open for}
01449 \textcolor{comment}{ * writing REDISMODULE\_ERR is returned. */}
01450 \textcolor{keywordtype}{int} RM\_DeleteKey(RedisModuleKey *key) \{
01451     \textcolor{keywordflow}{if} (!(key->mode & \hyperlink{redismodule_8h_a73b37117ef94cb4a904361afcc51b6b4}{REDISMODULE\_WRITE})) \textcolor{keywordflow}{return} 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01452     \textcolor{keywordflow}{if} (key->value) \{
01453         dbDelete(key->db,key->key);
01454         key->value = NULL;
01455     \}
01456     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01457 \}
01458 
01459 \textcolor{comment}{/* Return the key expire value, as milliseconds of remaining TTL.}
01460 \textcolor{comment}{ * If no TTL is associated with the key or if the key is empty,}
01461 \textcolor{comment}{ * REDISMODULE\_NO\_EXPIRE is returned. */}
01462 mstime\_t RM\_GetExpire(RedisModuleKey *key) \{
01463     mstime\_t expire = getExpire(key->db,key->key);
01464     \textcolor{keywordflow}{if} (expire == -1 || key->value == NULL) \textcolor{keywordflow}{return} -1;
01465     expire -= mstime();
01466     \textcolor{keywordflow}{return} expire >= 0 ? expire : 0;
01467 \}
01468 
01469 \textcolor{comment}{/* Set a new expire for the key. If the special expire}
01470 \textcolor{comment}{ * REDISMODULE\_NO\_EXPIRE is set, the expire is cancelled if there was}
01471 \textcolor{comment}{ * one (the same as the PERSIST command).}
01472 \textcolor{comment}{ *}
01473 \textcolor{comment}{ * Note that the expire must be provided as a positive integer representing}
01474 \textcolor{comment}{ * the number of milliseconds of TTL the key should have.}
01475 \textcolor{comment}{ *}
01476 \textcolor{comment}{ * The function returns REDISMODULE\_OK on success or REDISMODULE\_ERR if}
01477 \textcolor{comment}{ * the key was not open for writing or is an empty key. */}
01478 \textcolor{keywordtype}{int} RM\_SetExpire(RedisModuleKey *key, mstime\_t expire) \{
01479     \textcolor{keywordflow}{if} (!(key->mode & \hyperlink{redismodule_8h_a73b37117ef94cb4a904361afcc51b6b4}{REDISMODULE\_WRITE}) || key->value == NULL)
01480         \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01481     \textcolor{keywordflow}{if} (expire != \hyperlink{redismodule_8h_aa3f706d438eca2eca600845f5ee2e9b3}{REDISMODULE\_NO\_EXPIRE}) \{
01482         expire += mstime();
01483         setExpire(key->ctx->client,key->db,key->key,expire);
01484     \} \textcolor{keywordflow}{else} \{
01485         removeExpire(key->db,key->key);
01486     \}
01487     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01488 \}
01489 
01490 \textcolor{comment}{/* --------------------------------------------------------------------------}
01491 \textcolor{comment}{ * Key API for String type}
01492 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
01493 
01494 \textcolor{comment}{/* If the key is open for writing, set the specified string 'str' as the}
01495 \textcolor{comment}{ * value of the key, deleting the old value if any.}
01496 \textcolor{comment}{ * On success REDISMODULE\_OK is returned. If the key is not open for}
01497 \textcolor{comment}{ * writing or there is an active iterator, REDISMODULE\_ERR is returned. */}
01498 \textcolor{keywordtype}{int} RM\_StringSet(RedisModuleKey *key, RedisModuleString *str) \{
01499     \textcolor{keywordflow}{if} (!(key->mode & \hyperlink{redismodule_8h_a73b37117ef94cb4a904361afcc51b6b4}{REDISMODULE\_WRITE}) || key->iter) \textcolor{keywordflow}{return} 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01500     RM\_DeleteKey(key);
01501     setKey(key->db,key->key,str);
01502     key->value = str;
01503     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01504 \}
01505 
01506 \textcolor{comment}{/* Prepare the key associated string value for DMA access, and returns}
01507 \textcolor{comment}{ * a pointer and size (by reference), that the user can use to read or}
01508 \textcolor{comment}{ * modify the string in-place accessing it directly via pointer.}
01509 \textcolor{comment}{ *}
01510 \textcolor{comment}{ * The 'mode' is composed by bitwise OR-ing the following flags:}
01511 \textcolor{comment}{ *}
01512 \textcolor{comment}{ *     REDISMODULE\_READ -- Read access}
01513 \textcolor{comment}{ *     REDISMODULE\_WRITE -- Write access}
01514 \textcolor{comment}{ *}
01515 \textcolor{comment}{ * If the DMA is not requested for writing, the pointer returned should}
01516 \textcolor{comment}{ * only be accessed in a read-only fashion.}
01517 \textcolor{comment}{ *}
01518 \textcolor{comment}{ * On error (wrong type) NULL is returned.}
01519 \textcolor{comment}{ *}
01520 \textcolor{comment}{ * DMA access rules:}
01521 \textcolor{comment}{ *}
01522 \textcolor{comment}{ * 1. No other key writing function should be called since the moment}
01523 \textcolor{comment}{ * the pointer is obtained, for all the time we want to use DMA access}
01524 \textcolor{comment}{ * to read or modify the string.}
01525 \textcolor{comment}{ *}
01526 \textcolor{comment}{ * 2. Each time RM\_StringTruncate() is called, to continue with the DMA}
01527 \textcolor{comment}{ * access, RM\_StringDMA() should be called again to re-obtain}
01528 \textcolor{comment}{ * a new pointer and length.}
01529 \textcolor{comment}{ *}
01530 \textcolor{comment}{ * 3. If the returned pointer is not NULL, but the length is zero, no}
01531 \textcolor{comment}{ * byte can be touched (the string is empty, or the key itself is empty)}
01532 \textcolor{comment}{ * so a RM\_StringTruncate() call should be used if there is to enlarge}
01533 \textcolor{comment}{ * the string, and later call StringDMA() again to get the pointer.}
01534 \textcolor{comment}{ */}
01535 \textcolor{keywordtype}{char} *RM\_StringDMA(RedisModuleKey *key, size\_t *len, \textcolor{keywordtype}{int} mode) \{
01536     \textcolor{comment}{/* We need to return *some* pointer for empty keys, we just return}
01537 \textcolor{comment}{     * a string literal pointer, that is the advantage to be mapped into}
01538 \textcolor{comment}{     * a read only memory page, so the module will segfault if a write}
01539 \textcolor{comment}{     * attempt is performed. */}
01540     \textcolor{keywordtype}{char} *emptystring = \textcolor{stringliteral}{"<dma-empty-string>"};
01541     \textcolor{keywordflow}{if} (key->value == NULL) \{
01542         *len = 0;
01543         \textcolor{keywordflow}{return} emptystring;
01544     \}
01545 
01546     \textcolor{keywordflow}{if} (key->value->type != \hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING}) \textcolor{keywordflow}{return} NULL;
01547 
01548     \textcolor{comment}{/* For write access, and even for read access if the object is encoded,}
01549 \textcolor{comment}{     * we unshare the string (that has the side effect of decoding it). */}
01550     \textcolor{keywordflow}{if} ((mode & \hyperlink{redismodule_8h_a73b37117ef94cb4a904361afcc51b6b4}{REDISMODULE\_WRITE}) || key->value->encoding != 
      \hyperlink{server_8h_a148bc85e3074e324a6dc5eebcad1bcd5}{OBJ\_ENCODING\_RAW})
01551         key->value = dbUnshareStringValue(key->db, key->key, key->value);
01552 
01553     *len = sdslen(key->value->ptr);
01554     \textcolor{keywordflow}{return} key->value->ptr;
01555 \}
01556 
01557 \textcolor{comment}{/* If the string is open for writing and is of string type, resize it, padding}
01558 \textcolor{comment}{ * with zero bytes if the new length is greater than the old one.}
01559 \textcolor{comment}{ *}
01560 \textcolor{comment}{ * After this call, RM\_StringDMA() must be called again to continue}
01561 \textcolor{comment}{ * DMA access with the new pointer.}
01562 \textcolor{comment}{ *}
01563 \textcolor{comment}{ * The function returns REDISMODULE\_OK on success, and REDISMODULE\_ERR on}
01564 \textcolor{comment}{ * error, that is, the key is not open for writing, is not a string}
01565 \textcolor{comment}{ * or resizing for more than 512 MB is requested.}
01566 \textcolor{comment}{ *}
01567 \textcolor{comment}{ * If the key is empty, a string key is created with the new string value}
01568 \textcolor{comment}{ * unless the new length value requested is zero. */}
01569 \textcolor{keywordtype}{int} RM\_StringTruncate(RedisModuleKey *key, size\_t newlen) \{
01570     \textcolor{keywordflow}{if} (!(key->mode & \hyperlink{redismodule_8h_a73b37117ef94cb4a904361afcc51b6b4}{REDISMODULE\_WRITE})) \textcolor{keywordflow}{return} 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01571     \textcolor{keywordflow}{if} (key->value && key->value->type != \hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING}) \textcolor{keywordflow}{return} 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01572     \textcolor{keywordflow}{if} (newlen > 512*1024*1024) \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01573 
01574     \textcolor{comment}{/* Empty key and new len set to 0. Just return REDISMODULE\_OK without}
01575 \textcolor{comment}{     * doing anything. */}
01576     \textcolor{keywordflow}{if} (key->value == NULL && newlen == 0) \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01577 
01578     \textcolor{keywordflow}{if} (key->value == NULL) \{
01579         \textcolor{comment}{/* Empty key: create it with the new size. */}
01580         robj *o = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnewlen(NULL, newlen));
01581         setKey(key->db,key->key,o);
01582         key->value = o;
01583         decrRefCount(o);
01584     \} \textcolor{keywordflow}{else} \{
01585         \textcolor{comment}{/* Unshare and resize. */}
01586         key->value = dbUnshareStringValue(key->db, key->key, key->value);
01587         size\_t curlen = sdslen(key->value->ptr);
01588         \textcolor{keywordflow}{if} (newlen > curlen) \{
01589             key->value->ptr = sdsgrowzero(key->value->ptr,newlen);
01590         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (newlen < curlen) \{
01591             sdsrange(key->value->ptr,0,newlen-1);
01592             \textcolor{comment}{/* If the string is too wasteful, reallocate it. */}
01593             \textcolor{keywordflow}{if} (sdslen(key->value->ptr) < sdsavail(key->value->ptr))
01594                 key->value->ptr = sdsRemoveFreeSpace(key->value->ptr);
01595         \}
01596     \}
01597     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01598 \}
01599 
01600 \textcolor{comment}{/* --------------------------------------------------------------------------}
01601 \textcolor{comment}{ * Key API for List type}
01602 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
01603 
01604 \textcolor{comment}{/* Push an element into a list, on head or tail depending on 'where' argumnet.}
01605 \textcolor{comment}{ * If the key pointer is about an empty key opened for writing, the key}
01606 \textcolor{comment}{ * is created. On error (key opened for read-only operations or of the wrong}
01607 \textcolor{comment}{ * type) REDISMODULE\_ERR is returned, otherwise REDISMODULE\_OK is returned. */}
01608 \textcolor{keywordtype}{int} RM\_ListPush(RedisModuleKey *key, \textcolor{keywordtype}{int} where, RedisModuleString *ele) \{
01609     \textcolor{keywordflow}{if} (!(key->mode & \hyperlink{redismodule_8h_a73b37117ef94cb4a904361afcc51b6b4}{REDISMODULE\_WRITE})) \textcolor{keywordflow}{return} 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01610     \textcolor{keywordflow}{if} (key->value && key->value->type != \hyperlink{server_8h_a4a5f22a280949c97a0cb0d4213275126}{OBJ\_LIST}) \textcolor{keywordflow}{return} 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01611     \textcolor{keywordflow}{if} (key->value == NULL) moduleCreateEmptyKey(key,
      \hyperlink{redismodule_8h_a4c01058971d9d8fe1cfa02071fa87fa6}{REDISMODULE\_KEYTYPE\_LIST});
01612     listTypePush(key->value, ele,
01613         (where == \hyperlink{redismodule_8h_a6ca6298fda4f019c7585d34b870fd5f1}{REDISMODULE\_LIST\_HEAD}) ? 
      \hyperlink{quicklist_8h_a4cbe05838d62e8d1c8bfa46c9f1b083a}{QUICKLIST\_HEAD} : \hyperlink{quicklist_8h_a602bad1be3a6abb2a66ef87387cb7698}{QUICKLIST\_TAIL});
01614     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01615 \}
01616 
01617 \textcolor{comment}{/* Pop an element from the list, and returns it as a module string object}
01618 \textcolor{comment}{ * that the user should be free with RM\_FreeString() or by enabling}
01619 \textcolor{comment}{ * automatic memory. 'where' specifies if the element should be popped from}
01620 \textcolor{comment}{ * head or tail. The command returns NULL if:}
01621 \textcolor{comment}{ * 1) The list is empty.}
01622 \textcolor{comment}{ * 2) The key was not open for writing.}
01623 \textcolor{comment}{ * 3) The key is not a list. */}
01624 RedisModuleString *RM\_ListPop(RedisModuleKey *key, \textcolor{keywordtype}{int} where) \{
01625     \textcolor{keywordflow}{if} (!(key->mode & \hyperlink{redismodule_8h_a73b37117ef94cb4a904361afcc51b6b4}{REDISMODULE\_WRITE}) ||
01626         key->value == NULL ||
01627         key->value->type != \hyperlink{server_8h_a4a5f22a280949c97a0cb0d4213275126}{OBJ\_LIST}) \textcolor{keywordflow}{return} NULL;
01628     robj *ele = listTypePop(key->value,
01629         (where == \hyperlink{redismodule_8h_a6ca6298fda4f019c7585d34b870fd5f1}{REDISMODULE\_LIST\_HEAD}) ? 
      \hyperlink{quicklist_8h_a4cbe05838d62e8d1c8bfa46c9f1b083a}{QUICKLIST\_HEAD} : \hyperlink{quicklist_8h_a602bad1be3a6abb2a66ef87387cb7698}{QUICKLIST\_TAIL});
01630     robj *decoded = getDecodedObject(ele);
01631     decrRefCount(ele);
01632     moduleDelKeyIfEmpty(key);
01633     autoMemoryAdd(key->ctx,\hyperlink{module_8c_a566ace39ef8d3d16c3f7d9d6c6b8e4ef}{REDISMODULE\_AM\_STRING},decoded);
01634     \textcolor{keywordflow}{return} decoded;
01635 \}
01636 
01637 \textcolor{comment}{/* --------------------------------------------------------------------------}
01638 \textcolor{comment}{ * Key API for Sorted Set type}
01639 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
01640 
01641 \textcolor{comment}{/* Conversion from/to public flags of the Modules API and our private flags,}
01642 \textcolor{comment}{ * so that we have everything decoupled. */}
01643 \textcolor{keywordtype}{int} RM\_ZsetAddFlagsToCoreFlags(\textcolor{keywordtype}{int} flags) \{
01644     \textcolor{keywordtype}{int} retflags = 0;
01645     \textcolor{keywordflow}{if} (flags & \hyperlink{redismodule_8h_a90fbeee986d1f2d7288399c8304e5b06}{REDISMODULE\_ZADD\_XX}) retflags |= \hyperlink{server_8h_a4bc45df3143a1110ca9b8a67d25f47eb}{ZADD\_XX};
01646     \textcolor{keywordflow}{if} (flags & \hyperlink{redismodule_8h_a8de0369fb71791fe42d5ec6d8959bd0d}{REDISMODULE\_ZADD\_NX}) retflags |= \hyperlink{server_8h_a708539c0c5926d4c12c4bb2bb45513b2}{ZADD\_NX};
01647     \textcolor{keywordflow}{return} retflags;
01648 \}
01649 
01650 \textcolor{comment}{/* See previous function comment. */}
01651 \textcolor{keywordtype}{int} RM\_ZsetAddFlagsFromCoreFlags(\textcolor{keywordtype}{int} flags) \{
01652     \textcolor{keywordtype}{int} retflags = 0;
01653     \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_a2c0f3e2c3a5c73496b732648c69eda18}{ZADD\_ADDED}) retflags |= \hyperlink{redismodule_8h_a5c69099d5d3846f1634c335998a88086}{REDISMODULE\_ZADD\_ADDED};
01654     \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_aabb6bb7a2a2e73ab9fcda97cf704761b}{ZADD\_UPDATED}) retflags |= 
      \hyperlink{redismodule_8h_a616a231cd3922fde9daac0ff29c8bfdc}{REDISMODULE\_ZADD\_UPDATED};
01655     \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_afd0096ac4bedddb9b0b7f27396839c06}{ZADD\_NOP}) retflags |= \hyperlink{redismodule_8h_ad63e6e9dea8d9b3d736241007f039268}{REDISMODULE\_ZADD\_NOP};
01656     \textcolor{keywordflow}{return} retflags;
01657 \}
01658 
01659 \textcolor{comment}{/* Add a new element into a sorted set, with the specified 'score'.}
01660 \textcolor{comment}{ * If the element already exists, the score is updated.}
01661 \textcolor{comment}{ *}
01662 \textcolor{comment}{ * A new sorted set is created at value if the key is an empty open key}
01663 \textcolor{comment}{ * setup for writing.}
01664 \textcolor{comment}{ *}
01665 \textcolor{comment}{ * Additional flags can be passed to the function via a pointer, the flags}
01666 \textcolor{comment}{ * are both used to receive input and to communicate state when the function}
01667 \textcolor{comment}{ * returns. 'flagsptr' can be NULL if no special flags are used.}
01668 \textcolor{comment}{ *}
01669 \textcolor{comment}{ * The input flags are:}
01670 \textcolor{comment}{ *}
01671 \textcolor{comment}{ *     REDISMODULE\_ZADD\_XX: Element must already exist. Do nothing otherwise.}
01672 \textcolor{comment}{ *     REDISMODULE\_ZADD\_NX: Element must not exist. Do nothing otherwise.}
01673 \textcolor{comment}{ *}
01674 \textcolor{comment}{ * The output flags are:}
01675 \textcolor{comment}{ *}
01676 \textcolor{comment}{ *     REDISMODULE\_ZADD\_ADDED: The new element was added to the sorted set.}
01677 \textcolor{comment}{ *     REDISMODULE\_ZADD\_UPDATED: The score of the element was updated.}
01678 \textcolor{comment}{ *     REDISMODULE\_ZADD\_NOP: No operation was performed because XX or NX flags.}
01679 \textcolor{comment}{ *}
01680 \textcolor{comment}{ * On success the function returns REDISMODULE\_OK. On the following errors}
01681 \textcolor{comment}{ * REDISMODULE\_ERR is returned:}
01682 \textcolor{comment}{ *}
01683 \textcolor{comment}{ * * The key was not opened for writing.}
01684 \textcolor{comment}{ * * The key is of the wrong type.}
01685 \textcolor{comment}{ * * 'score' double value is not a number (NaN).}
01686 \textcolor{comment}{ */}
01687 \textcolor{keywordtype}{int} RM\_ZsetAdd(RedisModuleKey *key, \textcolor{keywordtype}{double} score, RedisModuleString *ele, \textcolor{keywordtype}{int} *flagsptr) \{
01688     \textcolor{keywordtype}{int} flags = 0;
01689     \textcolor{keywordflow}{if} (!(key->mode & \hyperlink{redismodule_8h_a73b37117ef94cb4a904361afcc51b6b4}{REDISMODULE\_WRITE})) \textcolor{keywordflow}{return} 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01690     \textcolor{keywordflow}{if} (key->value && key->value->type != \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}) \textcolor{keywordflow}{return} 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01691     \textcolor{keywordflow}{if} (key->value == NULL) moduleCreateEmptyKey(key,
      \hyperlink{redismodule_8h_a93d1514d4c11cc65551b36cfd9a72cc2}{REDISMODULE\_KEYTYPE\_ZSET});
01692     \textcolor{keywordflow}{if} (flagsptr) flags = RM\_ZsetAddFlagsToCoreFlags(*flagsptr);
01693     \textcolor{keywordflow}{if} (zsetAdd(key->value,score,ele->ptr,&flags,NULL) == 0) \{
01694         \textcolor{keywordflow}{if} (flagsptr) *flagsptr = 0;
01695         \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01696     \}
01697     \textcolor{keywordflow}{if} (flagsptr) *flagsptr = RM\_ZsetAddFlagsFromCoreFlags(flags);
01698     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01699 \}
01700 
01701 \textcolor{comment}{/* This function works exactly like RM\_ZsetAdd(), but instead of setting}
01702 \textcolor{comment}{ * a new score, the score of the existing element is incremented, or if the}
01703 \textcolor{comment}{ * element does not already exist, it is added assuming the old score was}
01704 \textcolor{comment}{ * zero.}
01705 \textcolor{comment}{ *}
01706 \textcolor{comment}{ * The input and output flags, and the return value, have the same exact}
01707 \textcolor{comment}{ * meaning, with the only difference that this function will return}
01708 \textcolor{comment}{ * REDISMODULE\_ERR even when 'score' is a valid double number, but adding it}
01709 \textcolor{comment}{ * to the existing score resuts into a NaN (not a number) condition.}
01710 \textcolor{comment}{ *}
01711 \textcolor{comment}{ * This function has an additional field 'newscore', if not NULL is filled}
01712 \textcolor{comment}{ * with the new score of the element after the increment, if no error}
01713 \textcolor{comment}{ * is returned. */}
01714 \textcolor{keywordtype}{int} RM\_ZsetIncrby(RedisModuleKey *key, \textcolor{keywordtype}{double} score, RedisModuleString *ele, \textcolor{keywordtype}{int} *flagsptr, \textcolor{keywordtype}{double} *
      newscore) \{
01715     \textcolor{keywordtype}{int} flags = 0;
01716     \textcolor{keywordflow}{if} (!(key->mode & \hyperlink{redismodule_8h_a73b37117ef94cb4a904361afcc51b6b4}{REDISMODULE\_WRITE})) \textcolor{keywordflow}{return} 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01717     \textcolor{keywordflow}{if} (key->value && key->value->type != \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}) \textcolor{keywordflow}{return} 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01718     \textcolor{keywordflow}{if} (key->value == NULL) moduleCreateEmptyKey(key,
      \hyperlink{redismodule_8h_a93d1514d4c11cc65551b36cfd9a72cc2}{REDISMODULE\_KEYTYPE\_ZSET});
01719     \textcolor{keywordflow}{if} (flagsptr) flags = RM\_ZsetAddFlagsToCoreFlags(*flagsptr);
01720     flags |= \hyperlink{server_8h_aa31f5564c57b55123a4e2d6a5eb599cf}{ZADD\_INCR};
01721     \textcolor{keywordflow}{if} (zsetAdd(key->value,score,ele->ptr,&flags,newscore) == 0) \{
01722         \textcolor{keywordflow}{if} (flagsptr) *flagsptr = 0;
01723         \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01724     \}
01725     \textcolor{comment}{/* zsetAdd() may signal back that the resulting score is not a number. */}
01726     \textcolor{keywordflow}{if} (flagsptr && (*flagsptr & \hyperlink{server_8h_ae46720414ddb69ab95bbade04b15194c}{ZADD\_NAN})) \{
01727         *flagsptr = 0;
01728         \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01729     \}
01730     \textcolor{keywordflow}{if} (flagsptr) *flagsptr = RM\_ZsetAddFlagsFromCoreFlags(flags);
01731     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01732 \}
01733 
01734 \textcolor{comment}{/* Remove the specified element from the sorted set.}
01735 \textcolor{comment}{ * The function returns REDISMODULE\_OK on success, and REDISMODULE\_ERR}
01736 \textcolor{comment}{ * on one of the following conditions:}
01737 \textcolor{comment}{ *}
01738 \textcolor{comment}{ * * The key was not opened for writing.}
01739 \textcolor{comment}{ * * The key is of the wrong type.}
01740 \textcolor{comment}{ *}
01741 \textcolor{comment}{ * The return value does NOT indicate the fact the element was really}
01742 \textcolor{comment}{ * removed (since it existed) or not, just if the function was executed}
01743 \textcolor{comment}{ * with success.}
01744 \textcolor{comment}{ *}
01745 \textcolor{comment}{ * In order to know if the element was removed, the additional argument}
01746 \textcolor{comment}{ * 'deleted' must be passed, that populates the integer by reference}
01747 \textcolor{comment}{ * setting it to 1 or 0 depending on the outcome of the operation.}
01748 \textcolor{comment}{ * The 'deleted' argument can be NULL if the caller is not interested}
01749 \textcolor{comment}{ * to know if the element was really removed.}
01750 \textcolor{comment}{ *}
01751 \textcolor{comment}{ * Empty keys will be handled correctly by doing nothing. */}
01752 \textcolor{keywordtype}{int} RM\_ZsetRem(RedisModuleKey *key, RedisModuleString *ele, \textcolor{keywordtype}{int} *deleted) \{
01753     \textcolor{keywordflow}{if} (!(key->mode & \hyperlink{redismodule_8h_a73b37117ef94cb4a904361afcc51b6b4}{REDISMODULE\_WRITE})) \textcolor{keywordflow}{return} 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01754     \textcolor{keywordflow}{if} (key->value && key->value->type != \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}) \textcolor{keywordflow}{return} 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01755     \textcolor{keywordflow}{if} (key->value != NULL && zsetDel(key->value,ele->ptr)) \{
01756         \textcolor{keywordflow}{if} (deleted) *deleted = 1;
01757     \} \textcolor{keywordflow}{else} \{
01758         \textcolor{keywordflow}{if} (deleted) *deleted = 0;
01759     \}
01760     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01761 \}
01762 
01763 \textcolor{comment}{/* On success retrieve the double score associated at the sorted set element}
01764 \textcolor{comment}{ * 'ele' and returns REDISMODULE\_OK. Otherwise REDISMODULE\_ERR is returned}
01765 \textcolor{comment}{ * to signal one of the following conditions:}
01766 \textcolor{comment}{ *}
01767 \textcolor{comment}{ * * There is no such element 'ele' in the sorted set.}
01768 \textcolor{comment}{ * * The key is not a sorted set.}
01769 \textcolor{comment}{ * * The key is an open empty key.}
01770 \textcolor{comment}{ */}
01771 \textcolor{keywordtype}{int} RM\_ZsetScore(RedisModuleKey *key, RedisModuleString *ele, \textcolor{keywordtype}{double} *score) \{
01772     \textcolor{keywordflow}{if} (key->value == NULL) \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01773     \textcolor{keywordflow}{if} (key->value->type != \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}) \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01774     \textcolor{keywordflow}{if} (zsetScore(key->value,ele->ptr,score) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \textcolor{keywordflow}{return} 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01775     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01776 \}
01777 
01778 \textcolor{comment}{/* --------------------------------------------------------------------------}
01779 \textcolor{comment}{ * Key API for Sorted Set iterator}
01780 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
01781 
01782 \textcolor{keywordtype}{void} zsetKeyReset(RedisModuleKey *key) \{
01783     key->ztype = \hyperlink{module_8c_aa51c11fc138f0fbbc6d8dc1e86bf320a}{REDISMODULE\_ZSET\_RANGE\_NONE};
01784     key->zcurrent = NULL;
01785     key->zer = 1;
01786 \}
01787 
01788 \textcolor{comment}{/* Stop a sorted set iteration. */}
01789 \textcolor{keywordtype}{void} RM\_ZsetRangeStop(RedisModuleKey *key) \{
01790     \textcolor{comment}{/* Free resources if needed. */}
01791     \textcolor{keywordflow}{if} (key->ztype == \hyperlink{module_8c_a36d7bac3b2781ba9b076ee6feee141a1}{REDISMODULE\_ZSET\_RANGE\_LEX})
01792         zslFreeLexRange(&key->zlrs);
01793     \textcolor{comment}{/* Setup sensible values so that misused iteration API calls when an}
01794 \textcolor{comment}{     * iterator is not active will result into something more sensible}
01795 \textcolor{comment}{     * than crashing. */}
01796     zsetKeyReset(key);
01797 \}
01798 
01799 \textcolor{comment}{/* Return the "End of range" flag value to signal the end of the iteration. */}
01800 \textcolor{keywordtype}{int} RM\_ZsetRangeEndReached(RedisModuleKey *key) \{
01801     \textcolor{keywordflow}{return} key->zer;
01802 \}
01803 
01804 \textcolor{comment}{/* Helper function for RM\_ZsetFirstInScoreRange() and RM\_ZsetLastInScoreRange().}
01805 \textcolor{comment}{ * Setup the sorted set iteration according to the specified score range}
01806 \textcolor{comment}{ * (see the functions calling it for more info). If 'first' is true the}
01807 \textcolor{comment}{ * first element in the range is used as a starting point for the iterator}
01808 \textcolor{comment}{ * otherwise the last. Return REDISMODULE\_OK on success otherwise}
01809 \textcolor{comment}{ * REDISMODULE\_ERR. */}
01810 \textcolor{keywordtype}{int} zsetInitScoreRange(RedisModuleKey *key, \textcolor{keywordtype}{double} min, \textcolor{keywordtype}{double} max, \textcolor{keywordtype}{int} minex, \textcolor{keywordtype}{int} maxex, \textcolor{keywordtype}{int} first) \{
01811     \textcolor{keywordflow}{if} (!key->value || key->value->type != \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}) \textcolor{keywordflow}{return} 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01812 
01813     RM\_ZsetRangeStop(key);
01814     key->ztype = \hyperlink{module_8c_a103d0f18dc1536298a03324d5ba545be}{REDISMODULE\_ZSET\_RANGE\_SCORE};
01815     key->zer = 0;
01816 
01817     \textcolor{comment}{/* Setup the range structure used by the sorted set core implementation}
01818 \textcolor{comment}{     * in order to seek at the specified element. */}
01819     zrangespec *zrs = &key->zrs;
01820     zrs->min = min;
01821     zrs->max = max;
01822     zrs->minex = minex;
01823     zrs->maxex = maxex;
01824 
01825     \textcolor{keywordflow}{if} (key->value->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
01826         key->zcurrent = first ? zzlFirstInRange(key->value->ptr,zrs) :
01827                                 zzlLastInRange(key->value->ptr,zrs);
01828     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key->value->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
01829         zset *zs = key->value->ptr;
01830         zskiplist *zsl = zs->zsl;
01831         key->zcurrent = first ? zslFirstInRange(zsl,zrs) :
01832                                 zslLastInRange(zsl,zrs);
01833     \} \textcolor{keywordflow}{else} \{
01834         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unsupported zset encoding"});
01835     \}
01836     \textcolor{keywordflow}{if} (key->zcurrent == NULL) key->zer = 1;
01837     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01838 \}
01839 
01840 \textcolor{comment}{/* Setup a sorted set iterator seeking the first element in the specified}
01841 \textcolor{comment}{ * range. Returns REDISMODULE\_OK if the iterator was correctly initialized}
01842 \textcolor{comment}{ * otherwise REDISMODULE\_ERR is returned in the following conditions:}
01843 \textcolor{comment}{ *}
01844 \textcolor{comment}{ * 1. The value stored at key is not a sorted set or the key is empty.}
01845 \textcolor{comment}{ *}
01846 \textcolor{comment}{ * The range is specified according to the two double values 'min' and 'max'.}
01847 \textcolor{comment}{ * Both can be infinite using the following two macros:}
01848 \textcolor{comment}{ *}
01849 \textcolor{comment}{ * REDISMODULE\_POSITIVE\_INFINITE for positive infinite value}
01850 \textcolor{comment}{ * REDISMODULE\_NEGATIVE\_INFINITE for negative infinite value}
01851 \textcolor{comment}{ *}
01852 \textcolor{comment}{ * 'minex' and 'maxex' parameters, if true, respectively setup a range}
01853 \textcolor{comment}{ * where the min and max value are exclusive (not included) instead of}
01854 \textcolor{comment}{ * inclusive. */}
01855 \textcolor{keywordtype}{int} RM\_ZsetFirstInScoreRange(RedisModuleKey *key, \textcolor{keywordtype}{double} min, \textcolor{keywordtype}{double} max, \textcolor{keywordtype}{int} minex, \textcolor{keywordtype}{int} maxex) \{
01856     \textcolor{keywordflow}{return} zsetInitScoreRange(key,min,max,minex,maxex,1);
01857 \}
01858 
01859 \textcolor{comment}{/* Exactly like RedisModule\_ZsetFirstInScoreRange() but the last element of}
01860 \textcolor{comment}{ * the range is selected for the start of the iteration instead. */}
01861 \textcolor{keywordtype}{int} RM\_ZsetLastInScoreRange(RedisModuleKey *key, \textcolor{keywordtype}{double} min, \textcolor{keywordtype}{double} max, \textcolor{keywordtype}{int} minex, \textcolor{keywordtype}{int} maxex) \{
01862     \textcolor{keywordflow}{return} zsetInitScoreRange(key,min,max,minex,maxex,0);
01863 \}
01864 
01865 \textcolor{comment}{/* Helper function for RM\_ZsetFirstInLexRange() and RM\_ZsetLastInLexRange().}
01866 \textcolor{comment}{ * Setup the sorted set iteration according to the specified lexicographical}
01867 \textcolor{comment}{ * range (see the functions calling it for more info). If 'first' is true the}
01868 \textcolor{comment}{ * first element in the range is used as a starting point for the iterator}
01869 \textcolor{comment}{ * otherwise the last. Return REDISMODULE\_OK on success otherwise}
01870 \textcolor{comment}{ * REDISMODULE\_ERR.}
01871 \textcolor{comment}{ *}
01872 \textcolor{comment}{ * Note that this function takes 'min' and 'max' in the same form of the}
01873 \textcolor{comment}{ * Redis ZRANGEBYLEX command. */}
01874 \textcolor{keywordtype}{int} zsetInitLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max, \textcolor{keywordtype}{int} first) \{
01875     \textcolor{keywordflow}{if} (!key->value || key->value->type != \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}) \textcolor{keywordflow}{return} 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01876 
01877     RM\_ZsetRangeStop(key);
01878     key->zer = 0;
01879 
01880     \textcolor{comment}{/* Setup the range structure used by the sorted set core implementation}
01881 \textcolor{comment}{     * in order to seek at the specified element. */}
01882     zlexrangespec *zlrs = &key->zlrs;
01883     \textcolor{keywordflow}{if} (zslParseLexRange(min, max, zlrs) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \textcolor{keywordflow}{return} 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
01884 
01885     \textcolor{comment}{/* Set the range type to lex only after successfully parsing the range,}
01886 \textcolor{comment}{     * otherwise we don't want the zlexrangespec to be freed. */}
01887     key->ztype = \hyperlink{module_8c_a36d7bac3b2781ba9b076ee6feee141a1}{REDISMODULE\_ZSET\_RANGE\_LEX};
01888 
01889     \textcolor{keywordflow}{if} (key->value->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
01890         key->zcurrent = first ? zzlFirstInLexRange(key->value->ptr,zlrs) :
01891                                 zzlLastInLexRange(key->value->ptr,zlrs);
01892     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key->value->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
01893         zset *zs = key->value->ptr;
01894         zskiplist *zsl = zs->zsl;
01895         key->zcurrent = first ? zslFirstInLexRange(zsl,zlrs) :
01896                                 zslLastInLexRange(zsl,zlrs);
01897     \} \textcolor{keywordflow}{else} \{
01898         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unsupported zset encoding"});
01899     \}
01900     \textcolor{keywordflow}{if} (key->zcurrent == NULL) key->zer = 1;
01901 
01902     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
01903 \}
01904 
01905 \textcolor{comment}{/* Setup a sorted set iterator seeking the first element in the specified}
01906 \textcolor{comment}{ * lexicographical range. Returns REDISMODULE\_OK if the iterator was correctly}
01907 \textcolor{comment}{ * initialized otherwise REDISMODULE\_ERR is returned in the}
01908 \textcolor{comment}{ * following conditions:}
01909 \textcolor{comment}{ *}
01910 \textcolor{comment}{ * 1. The value stored at key is not a sorted set or the key is empty.}
01911 \textcolor{comment}{ * 2. The lexicographical range 'min' and 'max' format is invalid.}
01912 \textcolor{comment}{ *}
01913 \textcolor{comment}{ * 'min' and 'max' should be provided as two RedisModuleString objects}
01914 \textcolor{comment}{ * in the same format as the parameters passed to the ZRANGEBYLEX command.}
01915 \textcolor{comment}{ * The function does not take ownership of the objects, so they can be released}
01916 \textcolor{comment}{ * ASAP after the iterator is setup. */}
01917 \textcolor{keywordtype}{int} RM\_ZsetFirstInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) \{
01918     \textcolor{keywordflow}{return} zsetInitLexRange(key,min,max,1);
01919 \}
01920 
01921 \textcolor{comment}{/* Exactly like RedisModule\_ZsetFirstInLexRange() but the last element of}
01922 \textcolor{comment}{ * the range is selected for the start of the iteration instead. */}
01923 \textcolor{keywordtype}{int} RM\_ZsetLastInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) \{
01924     \textcolor{keywordflow}{return} zsetInitLexRange(key,min,max,0);
01925 \}
01926 
01927 \textcolor{comment}{/* Return the current sorted set element of an active sorted set iterator}
01928 \textcolor{comment}{ * or NULL if the range specified in the iterator does not include any}
01929 \textcolor{comment}{ * element. */}
01930 RedisModuleString *RM\_ZsetRangeCurrentElement(RedisModuleKey *key, \textcolor{keywordtype}{double} *score) \{
01931     RedisModuleString *str;
01932 
01933     \textcolor{keywordflow}{if} (key->zcurrent == NULL) \textcolor{keywordflow}{return} NULL;
01934     \textcolor{keywordflow}{if} (key->value->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
01935         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr, *sptr;
01936         eptr = key->zcurrent;
01937         sds ele = ziplistGetObject(eptr);
01938         \textcolor{keywordflow}{if} (score) \{
01939             sptr = ziplistNext(key->value->ptr,eptr);
01940             *score = zzlGetScore(sptr);
01941         \}
01942         str = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},ele);
01943     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key->value->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
01944         zskiplistNode *ln = key->zcurrent;
01945         \textcolor{keywordflow}{if} (score) *score = ln->score;
01946         str = createStringObject(ln->ele,sdslen(ln->ele));
01947     \} \textcolor{keywordflow}{else} \{
01948         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unsupported zset encoding"});
01949     \}
01950     autoMemoryAdd(key->ctx,\hyperlink{module_8c_a566ace39ef8d3d16c3f7d9d6c6b8e4ef}{REDISMODULE\_AM\_STRING},str);
01951     \textcolor{keywordflow}{return} str;
01952 \}
01953 
01954 \textcolor{comment}{/* Go to the next element of the sorted set iterator. Returns 1 if there was}
01955 \textcolor{comment}{ * a next element, 0 if we are already at the latest element or the range}
01956 \textcolor{comment}{ * does not include any item at all. */}
01957 \textcolor{keywordtype}{int} RM\_ZsetRangeNext(RedisModuleKey *key) \{
01958     \textcolor{keywordflow}{if} (!key->ztype || !key->zcurrent) \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* No active iterator. */}
01959 
01960     \textcolor{keywordflow}{if} (key->value->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
01961         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl = key->value->ptr;
01962         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr = key->zcurrent;
01963         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *next;
01964         next = ziplistNext(zl,eptr); \textcolor{comment}{/* Skip element. */}
01965         \textcolor{keywordflow}{if} (next) next = ziplistNext(zl,next); \textcolor{comment}{/* Skip score. */}
01966         \textcolor{keywordflow}{if} (next == NULL) \{
01967             key->zer = 1;
01968             \textcolor{keywordflow}{return} 0;
01969         \} \textcolor{keywordflow}{else} \{
01970             \textcolor{comment}{/* Are we still within the range? */}
01971             \textcolor{keywordflow}{if} (key->ztype == \hyperlink{module_8c_a103d0f18dc1536298a03324d5ba545be}{REDISMODULE\_ZSET\_RANGE\_SCORE}) \{
01972                 \textcolor{comment}{/* Fetch the next element score for the}
01973 \textcolor{comment}{                 * range check. */}
01974                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *saved\_next = next;
01975                 next = ziplistNext(zl,next); \textcolor{comment}{/* Skip next element. */}
01976                 \textcolor{keywordtype}{double} score = zzlGetScore(next); \textcolor{comment}{/* Obtain the next score. */}
01977                 \textcolor{keywordflow}{if} (!zslValueLteMax(score,&key->zrs)) \{
01978                     key->zer = 1;
01979                     \textcolor{keywordflow}{return} 0;
01980                 \}
01981                 next = saved\_next;
01982             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key->ztype == \hyperlink{module_8c_a36d7bac3b2781ba9b076ee6feee141a1}{REDISMODULE\_ZSET\_RANGE\_LEX}) \{
01983                 \textcolor{keywordflow}{if} (!zzlLexValueLteMax(next,&key->zlrs)) \{
01984                     key->zer = 1;
01985                     \textcolor{keywordflow}{return} 0;
01986                 \}
01987             \}
01988             key->zcurrent = next;
01989             \textcolor{keywordflow}{return} 1;
01990         \}
01991     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key->value->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
01992         zskiplistNode *ln = key->zcurrent, *next = ln->level[0].forward;
01993         \textcolor{keywordflow}{if} (next == NULL) \{
01994             key->zer = 1;
01995             \textcolor{keywordflow}{return} 0;
01996         \} \textcolor{keywordflow}{else} \{
01997             \textcolor{comment}{/* Are we still within the range? */}
01998             \textcolor{keywordflow}{if} (key->ztype == \hyperlink{module_8c_a103d0f18dc1536298a03324d5ba545be}{REDISMODULE\_ZSET\_RANGE\_SCORE} &&
01999                 !zslValueLteMax(next->score,&key->zrs))
02000             \{
02001                 key->zer = 1;
02002                 \textcolor{keywordflow}{return} 0;
02003             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key->ztype == \hyperlink{module_8c_a36d7bac3b2781ba9b076ee6feee141a1}{REDISMODULE\_ZSET\_RANGE\_LEX}) \{
02004                 \textcolor{keywordflow}{if} (!zslLexValueLteMax(next->ele,&key->zlrs)) \{
02005                     key->zer = 1;
02006                     \textcolor{keywordflow}{return} 0;
02007                 \}
02008             \}
02009             key->zcurrent = next;
02010             \textcolor{keywordflow}{return} 1;
02011         \}
02012     \} \textcolor{keywordflow}{else} \{
02013         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unsupported zset encoding"});
02014     \}
02015 \}
02016 
02017 \textcolor{comment}{/* Go to the previous element of the sorted set iterator. Returns 1 if there was}
02018 \textcolor{comment}{ * a previous element, 0 if we are already at the first element or the range}
02019 \textcolor{comment}{ * does not include any item at all. */}
02020 \textcolor{keywordtype}{int} RM\_ZsetRangePrev(RedisModuleKey *key) \{
02021     \textcolor{keywordflow}{if} (!key->ztype || !key->zcurrent) \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* No active iterator. */}
02022 
02023     \textcolor{keywordflow}{if} (key->value->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
02024         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl = key->value->ptr;
02025         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *eptr = key->zcurrent;
02026         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *prev;
02027         prev = ziplistPrev(zl,eptr); \textcolor{comment}{/* Go back to previous score. */}
02028         \textcolor{keywordflow}{if} (prev) prev = ziplistPrev(zl,prev); \textcolor{comment}{/* Back to previous ele. */}
02029         \textcolor{keywordflow}{if} (prev == NULL) \{
02030             key->zer = 1;
02031             \textcolor{keywordflow}{return} 0;
02032         \} \textcolor{keywordflow}{else} \{
02033             \textcolor{comment}{/* Are we still within the range? */}
02034             \textcolor{keywordflow}{if} (key->ztype == \hyperlink{module_8c_a103d0f18dc1536298a03324d5ba545be}{REDISMODULE\_ZSET\_RANGE\_SCORE}) \{
02035                 \textcolor{comment}{/* Fetch the previous element score for the}
02036 \textcolor{comment}{                 * range check. */}
02037                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *saved\_prev = prev;
02038                 prev = ziplistNext(zl,prev); \textcolor{comment}{/* Skip element to get the score.*/}
02039                 \textcolor{keywordtype}{double} score = zzlGetScore(prev); \textcolor{comment}{/* Obtain the prev score. */}
02040                 \textcolor{keywordflow}{if} (!zslValueGteMin(score,&key->zrs)) \{
02041                     key->zer = 1;
02042                     \textcolor{keywordflow}{return} 0;
02043                 \}
02044                 prev = saved\_prev;
02045             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key->ztype == \hyperlink{module_8c_a36d7bac3b2781ba9b076ee6feee141a1}{REDISMODULE\_ZSET\_RANGE\_LEX}) \{
02046                 \textcolor{keywordflow}{if} (!zzlLexValueGteMin(prev,&key->zlrs)) \{
02047                     key->zer = 1;
02048                     \textcolor{keywordflow}{return} 0;
02049                 \}
02050             \}
02051             key->zcurrent = prev;
02052             \textcolor{keywordflow}{return} 1;
02053         \}
02054     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key->value->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
02055         zskiplistNode *ln = key->zcurrent, *prev = ln->backward;
02056         \textcolor{keywordflow}{if} (prev == NULL) \{
02057             key->zer = 1;
02058             \textcolor{keywordflow}{return} 0;
02059         \} \textcolor{keywordflow}{else} \{
02060             \textcolor{comment}{/* Are we still within the range? */}
02061             \textcolor{keywordflow}{if} (key->ztype == \hyperlink{module_8c_a103d0f18dc1536298a03324d5ba545be}{REDISMODULE\_ZSET\_RANGE\_SCORE} &&
02062                 !zslValueGteMin(prev->score,&key->zrs))
02063             \{
02064                 key->zer = 1;
02065                 \textcolor{keywordflow}{return} 0;
02066             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (key->ztype == \hyperlink{module_8c_a36d7bac3b2781ba9b076ee6feee141a1}{REDISMODULE\_ZSET\_RANGE\_LEX}) \{
02067                 \textcolor{keywordflow}{if} (!zslLexValueGteMin(prev->ele,&key->zlrs)) \{
02068                     key->zer = 1;
02069                     \textcolor{keywordflow}{return} 0;
02070                 \}
02071             \}
02072             key->zcurrent = prev;
02073             \textcolor{keywordflow}{return} 1;
02074         \}
02075     \} \textcolor{keywordflow}{else} \{
02076         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unsupported zset encoding"});
02077     \}
02078 \}
02079 
02080 \textcolor{comment}{/* --------------------------------------------------------------------------}
02081 \textcolor{comment}{ * Key API for Hash type}
02082 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
02083 
02084 \textcolor{comment}{/* Set the field of the specified hash field to the specified value.}
02085 \textcolor{comment}{ * If the key is an empty key open for writing, it is created with an empty}
02086 \textcolor{comment}{ * hash value, in order to set the specified field.}
02087 \textcolor{comment}{ *}
02088 \textcolor{comment}{ * The function is variadic and the user must specify pairs of field}
02089 \textcolor{comment}{ * names and values, both as RedisModuleString pointers (unless the}
02090 \textcolor{comment}{ * CFIELD option is set, see later).}
02091 \textcolor{comment}{ *}
02092 \textcolor{comment}{ * Example to set the hash argv[1] to the value argv[2]:}
02093 \textcolor{comment}{ *}
02094 \textcolor{comment}{ *      RedisModule\_HashSet(key,REDISMODULE\_HASH\_NONE,argv[1],argv[2],NULL);}
02095 \textcolor{comment}{ *}
02096 \textcolor{comment}{ * The function can also be used in order to delete fields (if they exist)}
02097 \textcolor{comment}{ * by setting them to the specified value of REDISMODULE\_HASH\_DELETE:}
02098 \textcolor{comment}{ *}
02099 \textcolor{comment}{ *      RedisModule\_HashSet(key,REDISMODULE\_HASH\_NONE,argv[1],}
02100 \textcolor{comment}{ *                          REDISMODULE\_HASH\_DELETE,NULL);}
02101 \textcolor{comment}{ *}
02102 \textcolor{comment}{ * The behavior of the command changes with the specified flags, that can be}
02103 \textcolor{comment}{ * set to REDISMODULE\_HASH\_NONE if no special behavior is needed.}
02104 \textcolor{comment}{ *}
02105 \textcolor{comment}{ *     REDISMODULE\_HASH\_NX: The operation is performed only if the field was not}
02106 \textcolor{comment}{ *                          already existing in the hash.}
02107 \textcolor{comment}{ *     REDISMODULE\_HASH\_XX: The operation is performed only if the field was}
02108 \textcolor{comment}{ *                          already existing, so that a new value could be}
02109 \textcolor{comment}{ *                          associated to an existing filed, but no new fields}
02110 \textcolor{comment}{ *                          are created.}
02111 \textcolor{comment}{ *     REDISMODULE\_HASH\_CFIELDS: The field names passed are null terminated C}
02112 \textcolor{comment}{ *                               strings instead of RedisModuleString objects.}
02113 \textcolor{comment}{ *}
02114 \textcolor{comment}{ * Unless NX is specified, the command overwrites the old field value with}
02115 \textcolor{comment}{ * the new one.}
02116 \textcolor{comment}{ *}
02117 \textcolor{comment}{ * When using REDISMODULE\_HASH\_CFIELDS, field names are reported using}
02118 \textcolor{comment}{ * normal C strings, so for example to delete the field "foo" the following}
02119 \textcolor{comment}{ * code can be used:}
02120 \textcolor{comment}{ *}
02121 \textcolor{comment}{ *      RedisModule\_HashSet(key,REDISMODULE\_HASH\_CFIELDS,"foo",}
02122 \textcolor{comment}{ *                          REDISMODULE\_HASH\_DELETE,NULL);}
02123 \textcolor{comment}{ *}
02124 \textcolor{comment}{ * Return value:}
02125 \textcolor{comment}{ *}
02126 \textcolor{comment}{ * The number of fields updated (that may be less than the number of fields}
02127 \textcolor{comment}{ * specified because of the XX or NX options).}
02128 \textcolor{comment}{ *}
02129 \textcolor{comment}{ * In the following case the return value is always zero:}
02130 \textcolor{comment}{ *}
02131 \textcolor{comment}{ * * The key was not open for writing.}
02132 \textcolor{comment}{ * * The key was associated with a non Hash value.}
02133 \textcolor{comment}{ */}
02134 \textcolor{keywordtype}{int} RM\_HashSet(RedisModuleKey *key, \textcolor{keywordtype}{int} flags, ...) \{
02135     va\_list ap;
02136     \textcolor{keywordflow}{if} (!(key->mode & \hyperlink{redismodule_8h_a73b37117ef94cb4a904361afcc51b6b4}{REDISMODULE\_WRITE})) \textcolor{keywordflow}{return} 0;
02137     \textcolor{keywordflow}{if} (key->value && key->value->type != \hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH}) \textcolor{keywordflow}{return} 0;
02138     \textcolor{keywordflow}{if} (key->value == NULL) moduleCreateEmptyKey(key,
      \hyperlink{redismodule_8h_ac019575ac57520c325597e2fb54c5b71}{REDISMODULE\_KEYTYPE\_HASH});
02139 
02140     \textcolor{keywordtype}{int} updated = 0;
02141     va\_start(ap, flags);
02142     \textcolor{keywordflow}{while}(1) \{
02143         RedisModuleString *field, *value;
02144         \textcolor{comment}{/* Get the field and value objects. */}
02145         \textcolor{keywordflow}{if} (flags & \hyperlink{redismodule_8h_a0b45cc86dbd926d0af5d59a5f4c0e0da}{REDISMODULE\_HASH\_CFIELDS}) \{
02146             \textcolor{keywordtype}{char} *cfield = va\_arg(ap,\textcolor{keywordtype}{char}*);
02147             \textcolor{keywordflow}{if} (cfield == NULL) \textcolor{keywordflow}{break};
02148             field = createRawStringObject(cfield,strlen(cfield));
02149         \} \textcolor{keywordflow}{else} \{
02150             field = va\_arg(ap,RedisModuleString*);
02151             \textcolor{keywordflow}{if} (field == NULL) \textcolor{keywordflow}{break};
02152         \}
02153         value = va\_arg(ap,RedisModuleString*);
02154 
02155         \textcolor{comment}{/* Handle XX and NX */}
02156         \textcolor{keywordflow}{if} (flags & (\hyperlink{redismodule_8h_a004820ba3dee8c209e6d19267b5c6fb9}{REDISMODULE\_HASH\_XX}|
      \hyperlink{redismodule_8h_a11aa350d4db460e8416beaf263ee2e42}{REDISMODULE\_HASH\_NX})) \{
02157             \textcolor{keywordtype}{int} exists = hashTypeExists(key->value, field->ptr);
02158             \textcolor{keywordflow}{if} (((flags & \hyperlink{redismodule_8h_a004820ba3dee8c209e6d19267b5c6fb9}{REDISMODULE\_HASH\_XX}) && !exists) ||
02159                 ((flags & \hyperlink{redismodule_8h_a11aa350d4db460e8416beaf263ee2e42}{REDISMODULE\_HASH\_NX}) && exists))
02160             \{
02161                 \textcolor{keywordflow}{if} (flags & \hyperlink{redismodule_8h_a0b45cc86dbd926d0af5d59a5f4c0e0da}{REDISMODULE\_HASH\_CFIELDS}) decrRefCount(field);
02162                 \textcolor{keywordflow}{continue};
02163             \}
02164         \}
02165 
02166         \textcolor{comment}{/* Handle deletion if value is REDISMODULE\_HASH\_DELETE. */}
02167         \textcolor{keywordflow}{if} (value == \hyperlink{redismodule_8h_ab4a99f96be3384e33942c82817bde501}{REDISMODULE\_HASH\_DELETE}) \{
02168             updated += hashTypeDelete(key->value, field->ptr);
02169             \textcolor{keywordflow}{if} (flags & \hyperlink{redismodule_8h_a0b45cc86dbd926d0af5d59a5f4c0e0da}{REDISMODULE\_HASH\_CFIELDS}) decrRefCount(field);
02170             \textcolor{keywordflow}{continue};
02171         \}
02172 
02173         \textcolor{keywordtype}{int} low\_flags = \hyperlink{server_8h_ad182dd9d0a3945ad3fb4045e559b612e}{HASH\_SET\_COPY};
02174         \textcolor{comment}{/* If CFIELDS is active, we can pass the ownership of the}
02175 \textcolor{comment}{         * SDS object to the low level function that sets the field}
02176 \textcolor{comment}{         * to avoid a useless copy. */}
02177         \textcolor{keywordflow}{if} (flags & \hyperlink{redismodule_8h_a0b45cc86dbd926d0af5d59a5f4c0e0da}{REDISMODULE\_HASH\_CFIELDS})
02178             low\_flags |= \hyperlink{server_8h_a9c13f8e0e439bfde94687cb01ab81b4b}{HASH\_SET\_TAKE\_FIELD};
02179         updated += hashTypeSet(key->value, field->ptr, value->ptr, low\_flags);
02180 
02181         \textcolor{comment}{/* If CFIELDS is active, SDS string ownership is now of hashTypeSet(),}
02182 \textcolor{comment}{         * however we still have to release the 'field' object shell. */}
02183         \textcolor{keywordflow}{if} (flags & \hyperlink{redismodule_8h_a0b45cc86dbd926d0af5d59a5f4c0e0da}{REDISMODULE\_HASH\_CFIELDS}) \{
02184            field->ptr = NULL; \textcolor{comment}{/* Prevent the SDS string from being freed. */}
02185            decrRefCount(field);
02186         \}
02187     \}
02188     va\_end(ap);
02189     moduleDelKeyIfEmpty(key);
02190     \textcolor{keywordflow}{return} updated;
02191 \}
02192 
02193 \textcolor{comment}{/* Get fields from an hash value. This function is called using a variable}
02194 \textcolor{comment}{ * number of arguments, alternating a field name (as a StringRedisModule}
02195 \textcolor{comment}{ * pointer) with a pointer to a StringRedisModule pointer, that is set to the}
02196 \textcolor{comment}{ * value of the field if the field exist, or NULL if the field did not exist.}
02197 \textcolor{comment}{ * At the end of the field/value-ptr pairs, NULL must be specified as last}
02198 \textcolor{comment}{ * argument to signal the end of the arguments in the variadic function.}
02199 \textcolor{comment}{ *}
02200 \textcolor{comment}{ * This is an example usage:}
02201 \textcolor{comment}{ *}
02202 \textcolor{comment}{ *      RedisModuleString *first, *second;}
02203 \textcolor{comment}{ *      RedisModule\_HashGet(mykey,REDISMODULE\_HASH\_NONE,argv[1],&first,}
02204 \textcolor{comment}{ *                      argv[2],&second,NULL);}
02205 \textcolor{comment}{ *}
02206 \textcolor{comment}{ * As with RedisModule\_HashSet() the behavior of the command can be specified}
02207 \textcolor{comment}{ * passing flags different than REDISMODULE\_HASH\_NONE:}
02208 \textcolor{comment}{ *}
02209 \textcolor{comment}{ * REDISMODULE\_HASH\_CFIELD: field names as null terminated C strings.}
02210 \textcolor{comment}{ *}
02211 \textcolor{comment}{ * REDISMODULE\_HASH\_EXISTS: instead of setting the value of the field}
02212 \textcolor{comment}{ * expecting a RedisModuleString pointer to pointer, the function just}
02213 \textcolor{comment}{ * reports if the field esists or not and expects an integer pointer}
02214 \textcolor{comment}{ * as the second element of each pair.}
02215 \textcolor{comment}{ *}
02216 \textcolor{comment}{ * Example of REDISMODULE\_HASH\_CFIELD:}
02217 \textcolor{comment}{ *}
02218 \textcolor{comment}{ *      RedisModuleString *username, *hashedpass;}
02219 \textcolor{comment}{ *      RedisModule\_HashGet(mykey,"username",&username,"hp",&hashedpass, NULL);}
02220 \textcolor{comment}{ *}
02221 \textcolor{comment}{ * Example of REDISMODULE\_HASH\_EXISTS:}
02222 \textcolor{comment}{ *}
02223 \textcolor{comment}{ *      int exists;}
02224 \textcolor{comment}{ *      RedisModule\_HashGet(mykey,argv[1],&exists,NULL);}
02225 \textcolor{comment}{ *}
02226 \textcolor{comment}{ * The function returns REDISMODULE\_OK on success and REDISMODULE\_ERR if}
02227 \textcolor{comment}{ * the key is not an hash value.}
02228 \textcolor{comment}{ *}
02229 \textcolor{comment}{ * Memory management:}
02230 \textcolor{comment}{ *}
02231 \textcolor{comment}{ * The returned RedisModuleString objects should be released with}
02232 \textcolor{comment}{ * RedisModule\_FreeString(), or by enabling automatic memory management.}
02233 \textcolor{comment}{ */}
02234 \textcolor{keywordtype}{int} RM\_HashGet(RedisModuleKey *key, \textcolor{keywordtype}{int} flags, ...) \{
02235     va\_list ap;
02236     \textcolor{keywordflow}{if} (key->value && key->value->type != \hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH}) \textcolor{keywordflow}{return} 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
02237 
02238     va\_start(ap, flags);
02239     \textcolor{keywordflow}{while}(1) \{
02240         RedisModuleString *field, **valueptr;
02241         \textcolor{keywordtype}{int} *existsptr;
02242         \textcolor{comment}{/* Get the field object and the value pointer to pointer. */}
02243         \textcolor{keywordflow}{if} (flags & \hyperlink{redismodule_8h_a0b45cc86dbd926d0af5d59a5f4c0e0da}{REDISMODULE\_HASH\_CFIELDS}) \{
02244             \textcolor{keywordtype}{char} *cfield = va\_arg(ap,\textcolor{keywordtype}{char}*);
02245             \textcolor{keywordflow}{if} (cfield == NULL) \textcolor{keywordflow}{break};
02246             field = createRawStringObject(cfield,strlen(cfield));
02247         \} \textcolor{keywordflow}{else} \{
02248             field = va\_arg(ap,RedisModuleString*);
02249             \textcolor{keywordflow}{if} (field == NULL) \textcolor{keywordflow}{break};
02250         \}
02251 
02252         \textcolor{comment}{/* Query the hash for existence or value object. */}
02253         \textcolor{keywordflow}{if} (flags & \hyperlink{redismodule_8h_af30d67dd15a4c35bfb57e20b645d65c4}{REDISMODULE\_HASH\_EXISTS}) \{
02254             existsptr = va\_arg(ap,\textcolor{keywordtype}{int}*);
02255             \textcolor{keywordflow}{if} (key->value)
02256                 *existsptr = hashTypeExists(key->value,field->ptr);
02257             \textcolor{keywordflow}{else}
02258                 *existsptr = 0;
02259         \} \textcolor{keywordflow}{else} \{
02260             valueptr = va\_arg(ap,RedisModuleString**);
02261             \textcolor{keywordflow}{if} (key->value) \{
02262                 *valueptr = hashTypeGetValueObject(key->value,field->ptr);
02263                 \textcolor{keywordflow}{if} (*valueptr) \{
02264                     robj *decoded = getDecodedObject(*valueptr);
02265                     decrRefCount(*valueptr);
02266                     *valueptr = decoded;
02267                 \}
02268                 \textcolor{keywordflow}{if} (*valueptr)
02269                     autoMemoryAdd(key->ctx,\hyperlink{module_8c_a566ace39ef8d3d16c3f7d9d6c6b8e4ef}{REDISMODULE\_AM\_STRING},*valueptr);
02270             \} \textcolor{keywordflow}{else} \{
02271                 *valueptr = NULL;
02272             \}
02273         \}
02274 
02275         \textcolor{comment}{/* Cleanup */}
02276         \textcolor{keywordflow}{if} (flags & \hyperlink{redismodule_8h_a0b45cc86dbd926d0af5d59a5f4c0e0da}{REDISMODULE\_HASH\_CFIELDS}) decrRefCount(field);
02277     \}
02278     va\_end(ap);
02279     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
02280 \}
02281 
02282 \textcolor{comment}{/* --------------------------------------------------------------------------}
02283 \textcolor{comment}{ * Redis <-> Modules generic Call() API}
02284 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
02285 
02286 \textcolor{comment}{/* Create a new RedisModuleCallReply object. The processing of the reply}
02287 \textcolor{comment}{ * is lazy, the object is just populated with the raw protocol and later}
02288 \textcolor{comment}{ * is processed as needed. Initially we just make sure to set the right}
02289 \textcolor{comment}{ * reply type, which is extremely cheap to do. */}
02290 \hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *moduleCreateCallReplyFromProto(RedisModuleCtx *ctx, sds 
      proto) \{
02291     \hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply = zmalloc(\textcolor{keyword}{sizeof}(*reply));
02292     reply->ctx = ctx;
02293     reply->proto = proto;
02294     reply->protolen = sdslen(proto);
02295     reply->flags = \hyperlink{module_8c_a86d2a6b1f34cb5c7d5b69e4646ae0a7a}{REDISMODULE\_REPLYFLAG\_TOPARSE}; \textcolor{comment}{/* Lazy parsing. */}
02296     \textcolor{keywordflow}{switch}(proto[0]) \{
02297     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'$'}:
02298     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'+'}: reply->type = \hyperlink{redismodule_8h_abc8a4584f9085b55692994244a26012b}{REDISMODULE\_REPLY\_STRING}; \textcolor{keywordflow}{break};
02299     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'-'}: reply->type = \hyperlink{redismodule_8h_ae70c78e91f22b2ff98795babccac44c9}{REDISMODULE\_REPLY\_ERROR}; \textcolor{keywordflow}{break};
02300     \textcolor{keywordflow}{case} \textcolor{stringliteral}{':'}: reply->type = \hyperlink{redismodule_8h_a9cff1d7e4fdc52b273949ed0d83e916b}{REDISMODULE\_REPLY\_INTEGER}; \textcolor{keywordflow}{break};
02301     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'*'}: reply->type = \hyperlink{redismodule_8h_a2adb9d56c9d950784c3397cbe3f5d6af}{REDISMODULE\_REPLY\_ARRAY}; \textcolor{keywordflow}{break};
02302     \textcolor{keywordflow}{default}: reply->type = \hyperlink{redismodule_8h_a60cb302d85b881ad4a0c27db04688f94}{REDISMODULE\_REPLY\_UNKNOWN}; \textcolor{keywordflow}{break};
02303     \}
02304     \textcolor{keywordflow}{if} ((proto[0] == \textcolor{stringliteral}{'*'} || proto[0] == \textcolor{stringliteral}{'$'}) && proto[1] == \textcolor{stringliteral}{'-'})
02305         reply->type = \hyperlink{redismodule_8h_a5f14ab4822e5911f669c942f0fb95f7f}{REDISMODULE\_REPLY\_NULL};
02306     \textcolor{keywordflow}{return} reply;
02307 \}
02308 
02309 \textcolor{keywordtype}{void} moduleParseCallReply\_Int(\hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply);
02310 \textcolor{keywordtype}{void} moduleParseCallReply\_BulkString(\hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply);
02311 \textcolor{keywordtype}{void} moduleParseCallReply\_SimpleString(\hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply);
02312 \textcolor{keywordtype}{void} moduleParseCallReply\_Array(\hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply);
02313 
02314 \textcolor{comment}{/* Do nothing if REDISMODULE\_REPLYFLAG\_TOPARSE is false, otherwise}
02315 \textcolor{comment}{ * use the protcol of the reply in reply->proto in order to fill the}
02316 \textcolor{comment}{ * reply with parsed data according to the reply type. */}
02317 \textcolor{keywordtype}{void} moduleParseCallReply(\hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply) \{
02318     \textcolor{keywordflow}{if} (!(reply->flags & \hyperlink{module_8c_a86d2a6b1f34cb5c7d5b69e4646ae0a7a}{REDISMODULE\_REPLYFLAG\_TOPARSE})) \textcolor{keywordflow}{return};
02319     reply->flags &= ~\hyperlink{module_8c_a86d2a6b1f34cb5c7d5b69e4646ae0a7a}{REDISMODULE\_REPLYFLAG\_TOPARSE};
02320 
02321     \textcolor{keywordflow}{switch}(reply->proto[0]) \{
02322     \textcolor{keywordflow}{case} \textcolor{stringliteral}{':'}: moduleParseCallReply\_Int(reply); \textcolor{keywordflow}{break};
02323     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'$'}: moduleParseCallReply\_BulkString(reply); \textcolor{keywordflow}{break};
02324     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'-'}: \textcolor{comment}{/* handled by next item. */}
02325     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'+'}: moduleParseCallReply\_SimpleString(reply); \textcolor{keywordflow}{break};
02326     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'*'}: moduleParseCallReply\_Array(reply); \textcolor{keywordflow}{break};
02327     \}
02328 \}
02329 
02330 \textcolor{keywordtype}{void} moduleParseCallReply\_Int(\hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply) \{
02331     \textcolor{keywordtype}{char} *proto = reply->proto;
02332     \textcolor{keywordtype}{char} *p = strchr(proto+1,\textcolor{stringliteral}{'\(\backslash\)r'});
02333 
02334     string2ll(proto+1,p-proto-1,&reply->val.ll);
02335     reply->protolen = p-proto+2;
02336     reply->type = \hyperlink{redismodule_8h_a9cff1d7e4fdc52b273949ed0d83e916b}{REDISMODULE\_REPLY\_INTEGER};
02337 \}
02338 
02339 \textcolor{keywordtype}{void} moduleParseCallReply\_BulkString(\hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply) \{
02340     \textcolor{keywordtype}{char} *proto = reply->proto;
02341     \textcolor{keywordtype}{char} *p = strchr(proto+1,\textcolor{stringliteral}{'\(\backslash\)r'});
02342     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} bulklen;
02343 
02344     string2ll(proto+1,p-proto-1,&bulklen);
02345     \textcolor{keywordflow}{if} (bulklen == -1) \{
02346         reply->protolen = p-proto+2;
02347         reply->type = \hyperlink{redismodule_8h_a5f14ab4822e5911f669c942f0fb95f7f}{REDISMODULE\_REPLY\_NULL};
02348     \} \textcolor{keywordflow}{else} \{
02349         reply->val.str = p+2;
02350         reply->len = bulklen;
02351         reply->protolen = p-proto+2+bulklen+2;
02352         reply->type = \hyperlink{redismodule_8h_abc8a4584f9085b55692994244a26012b}{REDISMODULE\_REPLY\_STRING};
02353     \}
02354 \}
02355 
02356 \textcolor{keywordtype}{void} moduleParseCallReply\_SimpleString(\hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply) \{
02357     \textcolor{keywordtype}{char} *proto = reply->proto;
02358     \textcolor{keywordtype}{char} *p = strchr(proto+1,\textcolor{stringliteral}{'\(\backslash\)r'});
02359 
02360     reply->val.str = proto+1;
02361     reply->len = p-proto-1;
02362     reply->protolen = p-proto+2;
02363     reply->type = proto[0] == \textcolor{stringliteral}{'+'} ? \hyperlink{redismodule_8h_abc8a4584f9085b55692994244a26012b}{REDISMODULE\_REPLY\_STRING} :
02364                                     \hyperlink{redismodule_8h_ae70c78e91f22b2ff98795babccac44c9}{REDISMODULE\_REPLY\_ERROR};
02365 \}
02366 
02367 \textcolor{keywordtype}{void} moduleParseCallReply\_Array(\hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply) \{
02368     \textcolor{keywordtype}{char} *proto = reply->proto;
02369     \textcolor{keywordtype}{char} *p = strchr(proto+1,\textcolor{stringliteral}{'\(\backslash\)r'});
02370     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} arraylen, j;
02371 
02372     string2ll(proto+1,p-proto-1,&arraylen);
02373     p += 2;
02374 
02375     \textcolor{keywordflow}{if} (arraylen == -1) \{
02376         reply->protolen = p-proto;
02377         reply->type = \hyperlink{redismodule_8h_a5f14ab4822e5911f669c942f0fb95f7f}{REDISMODULE\_REPLY\_NULL};
02378         \textcolor{keywordflow}{return};
02379     \}
02380 
02381     reply->val.array = zmalloc(\textcolor{keyword}{sizeof}(RedisModuleCallReply)*arraylen);
02382     reply->len = arraylen;
02383     \textcolor{keywordflow}{for} (j = 0; j < arraylen; j++) \{
02384         \hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *ele = reply->val.array+j;
02385         ele->flags = \hyperlink{module_8c_a1605682f825f95f3de0c5bd149ecdff5}{REDISMODULE\_REPLYFLAG\_NESTED} |
02386                      \hyperlink{module_8c_a86d2a6b1f34cb5c7d5b69e4646ae0a7a}{REDISMODULE\_REPLYFLAG\_TOPARSE};
02387         ele->proto = p;
02388         ele->ctx = reply->ctx;
02389         moduleParseCallReply(ele);
02390         p += ele->protolen;
02391     \}
02392     reply->protolen = p-proto;
02393     reply->type = \hyperlink{redismodule_8h_a2adb9d56c9d950784c3397cbe3f5d6af}{REDISMODULE\_REPLY\_ARRAY};
02394 \}
02395 
02396 \textcolor{comment}{/* Free a Call reply and all the nested replies it contains if it's an}
02397 \textcolor{comment}{ * array. */}
02398 \textcolor{keywordtype}{void} RM\_FreeCallReply\_Rec(\hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply, \textcolor{keywordtype}{int} freenested)\{
02399     \textcolor{comment}{/* Don't free nested replies by default: the user must always free the}
02400 \textcolor{comment}{     * toplevel reply. However be gentle and don't crash if the module}
02401 \textcolor{comment}{     * misuses the API. */}
02402     \textcolor{keywordflow}{if} (!freenested && reply->flags & \hyperlink{module_8c_a1605682f825f95f3de0c5bd149ecdff5}{REDISMODULE\_REPLYFLAG\_NESTED}) \textcolor{keywordflow}{return}
      ;
02403 
02404     \textcolor{keywordflow}{if} (!(reply->flags & \hyperlink{module_8c_a86d2a6b1f34cb5c7d5b69e4646ae0a7a}{REDISMODULE\_REPLYFLAG\_TOPARSE})) \{
02405         \textcolor{keywordflow}{if} (reply->type == \hyperlink{redismodule_8h_a2adb9d56c9d950784c3397cbe3f5d6af}{REDISMODULE\_REPLY\_ARRAY}) \{
02406             size\_t j;
02407             \textcolor{keywordflow}{for} (j = 0; j < reply->len; j++)
02408                 RM\_FreeCallReply\_Rec(reply->val.array+j,1);
02409             zfree(reply->val.array);
02410         \}
02411     \}
02412 
02413     \textcolor{comment}{/* For nested replies, we don't free reply->proto (which if not NULL}
02414 \textcolor{comment}{     * references the parent reply->proto buffer), nor the structure}
02415 \textcolor{comment}{     * itself which is allocated as an array of structures, and is freed}
02416 \textcolor{comment}{     * when the array value is released. */}
02417     \textcolor{keywordflow}{if} (!(reply->flags & \hyperlink{module_8c_a1605682f825f95f3de0c5bd149ecdff5}{REDISMODULE\_REPLYFLAG\_NESTED})) \{
02418         \textcolor{keywordflow}{if} (reply->proto) sdsfree(reply->proto);
02419         zfree(reply);
02420     \}
02421 \}
02422 
02423 \textcolor{comment}{/* Wrapper for the recursive free reply function. This is needed in order}
02424 \textcolor{comment}{ * to have the first level function to return on nested replies, but only}
02425 \textcolor{comment}{ * if called by the module API. */}
02426 \textcolor{keywordtype}{void} RM\_FreeCallReply(\hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply) \{
02427 
02428     RedisModuleCtx *ctx = reply->ctx;
02429     RM\_FreeCallReply\_Rec(reply,0);
02430     autoMemoryFreed(ctx,\hyperlink{module_8c_a3a23ca3942d52889333fbd34f6efcffe}{REDISMODULE\_AM\_REPLY},reply);
02431 \}
02432 
02433 \textcolor{comment}{/* Return the reply type. */}
02434 \textcolor{keywordtype}{int} RM\_CallReplyType(\hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply) \{
02435     \textcolor{keywordflow}{if} (!reply) \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a60cb302d85b881ad4a0c27db04688f94}{REDISMODULE\_REPLY\_UNKNOWN};
02436     \textcolor{keywordflow}{return} reply->type;
02437 \}
02438 
02439 \textcolor{comment}{/* Return the reply type length, where applicable. */}
02440 size\_t RM\_CallReplyLength(RedisModuleCallReply *reply) \{
02441     moduleParseCallReply(reply);
02442     \textcolor{keywordflow}{switch}(reply->type) \{
02443     \textcolor{keywordflow}{case} \hyperlink{redismodule_8h_abc8a4584f9085b55692994244a26012b}{REDISMODULE\_REPLY\_STRING}:
02444     \textcolor{keywordflow}{case} \hyperlink{redismodule_8h_ae70c78e91f22b2ff98795babccac44c9}{REDISMODULE\_REPLY\_ERROR}:
02445     \textcolor{keywordflow}{case} \hyperlink{redismodule_8h_a2adb9d56c9d950784c3397cbe3f5d6af}{REDISMODULE\_REPLY\_ARRAY}:
02446         \textcolor{keywordflow}{return} reply->len;
02447     \textcolor{keywordflow}{default}:
02448         \textcolor{keywordflow}{return} 0;
02449     \}
02450 \}
02451 
02452 \textcolor{comment}{/* Return the 'idx'-th nested call reply element of an array reply, or NULL}
02453 \textcolor{comment}{ * if the reply type is wrong or the index is out of range. */}
02454 \hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *RM\_CallReplyArrayElement(
      \hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply, size\_t idx) \{
02455     moduleParseCallReply(reply);
02456     \textcolor{keywordflow}{if} (reply->type != \hyperlink{redismodule_8h_a2adb9d56c9d950784c3397cbe3f5d6af}{REDISMODULE\_REPLY\_ARRAY}) \textcolor{keywordflow}{return} NULL;
02457     \textcolor{keywordflow}{if} (idx >= reply->len) \textcolor{keywordflow}{return} NULL;
02458     \textcolor{keywordflow}{return} reply->val.array+idx;
02459 \}
02460 
02461 \textcolor{comment}{/* Return the long long of an integer reply. */}
02462 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} RM\_CallReplyInteger(\hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply) \{
02463     moduleParseCallReply(reply);
02464     \textcolor{keywordflow}{if} (reply->type != \hyperlink{redismodule_8h_a9cff1d7e4fdc52b273949ed0d83e916b}{REDISMODULE\_REPLY\_INTEGER}) \textcolor{keywordflow}{return} LLONG\_MIN;
02465     \textcolor{keywordflow}{return} reply->val.ll;
02466 \}
02467 
02468 \textcolor{comment}{/* Return the pointer and length of a string or error reply. */}
02469 \textcolor{keyword}{const} \textcolor{keywordtype}{char} *RM\_CallReplyStringPtr(\hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply, size\_t *len) \{
02470     moduleParseCallReply(reply);
02471     \textcolor{keywordflow}{if} (reply->type != \hyperlink{redismodule_8h_abc8a4584f9085b55692994244a26012b}{REDISMODULE\_REPLY\_STRING} &&
02472         reply->type != \hyperlink{redismodule_8h_ae70c78e91f22b2ff98795babccac44c9}{REDISMODULE\_REPLY\_ERROR}) \textcolor{keywordflow}{return} NULL;
02473     \textcolor{keywordflow}{if} (len) *len = reply->len;
02474     \textcolor{keywordflow}{return} reply->val.str;
02475 \}
02476 
02477 \textcolor{comment}{/* Return a new string object from a call reply of type string, error or}
02478 \textcolor{comment}{ * integer. Otherwise (wrong reply type) return NULL. */}
02479 RedisModuleString *RM\_CreateStringFromCallReply(\hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply) \{
02480     moduleParseCallReply(reply);
02481     \textcolor{keywordflow}{switch}(reply->type) \{
02482     \textcolor{keywordflow}{case} \hyperlink{redismodule_8h_abc8a4584f9085b55692994244a26012b}{REDISMODULE\_REPLY\_STRING}:
02483     \textcolor{keywordflow}{case} \hyperlink{redismodule_8h_ae70c78e91f22b2ff98795babccac44c9}{REDISMODULE\_REPLY\_ERROR}:
02484         \textcolor{keywordflow}{return} RM\_CreateString(reply->ctx,reply->val.str,reply->len);
02485     \textcolor{keywordflow}{case} \hyperlink{redismodule_8h_a9cff1d7e4fdc52b273949ed0d83e916b}{REDISMODULE\_REPLY\_INTEGER}: \{
02486         \textcolor{keywordtype}{char} buf[64];
02487         \textcolor{keywordtype}{int} len = ll2string(buf,\textcolor{keyword}{sizeof}(buf),reply->val.ll);
02488         \textcolor{keywordflow}{return} RM\_CreateString(reply->ctx,buf,len);
02489         \}
02490     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} NULL;
02491     \}
02492 \}
02493 
02494 \textcolor{comment}{/* Returns an array of robj pointers, and populates *argc with the number}
02495 \textcolor{comment}{ * of items, by parsing the format specifier "fmt" as described for}
02496 \textcolor{comment}{ * the RM\_Call(), RM\_Replicate() and other module APIs.}
02497 \textcolor{comment}{ *}
02498 \textcolor{comment}{ * The integer pointed by 'flags' is populated with flags according}
02499 \textcolor{comment}{ * to special modifiers in "fmt". For now only one exists:}
02500 \textcolor{comment}{ *}
02501 \textcolor{comment}{ *     "!" -> REDISMODULE\_ARGV\_REPLICATE}
02502 \textcolor{comment}{ *}
02503 \textcolor{comment}{ * On error (format specifier error) NULL is returned and nothing is}
02504 \textcolor{comment}{ * allocated. On success the argument vector is returned. */}
02505 
02506 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_ARGV\_REPLICATE} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)}
02507 
02508 robj **moduleCreateArgvFromUserFormat(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *cmdname, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, \textcolor{keywordtype}{int} *argcp, \textcolor{keywordtype}{int} *flags, 
      va\_list ap) \{
02509     \textcolor{keywordtype}{int} argc = 0, argv\_size, j;
02510     robj **argv = NULL;
02511 
02512     \textcolor{comment}{/* As a first guess to avoid useless reallocations, size argv to}
02513 \textcolor{comment}{     * hold one argument for each char specifier in 'fmt'. */}
02514     argv\_size = strlen(fmt)+1; \textcolor{comment}{/* +1 because of the command name. */}
02515     argv = zrealloc(argv,\textcolor{keyword}{sizeof}(robj*)*argv\_size);
02516 
02517     \textcolor{comment}{/* Build the arguments vector based on the format specifier. */}
02518     argv[0] = createStringObject(cmdname,strlen(cmdname));
02519     argc++;
02520 
02521     \textcolor{comment}{/* Create the client and dispatch the command. */}
02522     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *p = fmt;
02523     \textcolor{keywordflow}{while}(*p) \{
02524         \textcolor{keywordflow}{if} (*p == \textcolor{stringliteral}{'c'}) \{
02525             \textcolor{keywordtype}{char} *cstr = va\_arg(ap,\textcolor{keywordtype}{char}*);
02526             argv[argc++] = createStringObject(cstr,strlen(cstr));
02527         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*p == \textcolor{stringliteral}{'s'}) \{
02528             robj *obj = va\_arg(ap,\textcolor{keywordtype}{void}*);
02529             argv[argc++] = obj;
02530             incrRefCount(obj);
02531         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*p == \textcolor{stringliteral}{'b'}) \{
02532             \textcolor{keywordtype}{char} *buf = va\_arg(ap,\textcolor{keywordtype}{char}*);
02533             size\_t len = va\_arg(ap,size\_t);
02534             argv[argc++] = createStringObject(buf,len);
02535         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*p == \textcolor{stringliteral}{'l'}) \{
02536             \textcolor{keywordtype}{long} ll = va\_arg(ap,\textcolor{keywordtype}{long} \textcolor{keywordtype}{long});
02537             argv[argc++] = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsfromlonglong(ll));
02538         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*p == \textcolor{stringliteral}{'v'}) \{
02539              \textcolor{comment}{/* A vector of strings */}
02540              robj **v = va\_arg(ap, \textcolor{keywordtype}{void}*);
02541              size\_t vlen = va\_arg(ap, size\_t);
02542 
02543              \textcolor{comment}{/* We need to grow argv to hold the vector's elements.}
02544 \textcolor{comment}{              * We resize by vector\_len-1 elements, because we held}
02545 \textcolor{comment}{              * one element in argv for the vector already */}
02546              argv\_size += vlen-1;
02547              argv = zrealloc(argv,\textcolor{keyword}{sizeof}(robj*)*argv\_size);
02548 
02549              size\_t i = 0;
02550              \textcolor{keywordflow}{for} (i = 0; i < vlen; i++) \{
02551                  incrRefCount(v[i]);
02552                  argv[argc++] = v[i];
02553              \}
02554         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*p == \textcolor{stringliteral}{'!'}) \{
02555             \textcolor{keywordflow}{if} (flags) (*flags) |= \hyperlink{module_8c_a53bcac3a263b30f4600dec73c4b3d0ef}{REDISMODULE\_ARGV\_REPLICATE};
02556         \} \textcolor{keywordflow}{else} \{
02557             \textcolor{keywordflow}{goto} fmterr;
02558         \}
02559         p++;
02560     \}
02561     *argcp = argc;
02562     \textcolor{keywordflow}{return} argv;
02563 
02564 fmterr:
02565     \textcolor{keywordflow}{for} (j = 0; j < argc; j++)
02566         decrRefCount(argv[j]);
02567     zfree(argv);
02568     \textcolor{keywordflow}{return} NULL;
02569 \}
02570 
02571 \textcolor{comment}{/* Exported API to call any Redis command from modules.}
02572 \textcolor{comment}{ * On success a RedisModuleCallReply object is returned, otherwise}
02573 \textcolor{comment}{ * NULL is returned and errno is set to the following values:}
02574 \textcolor{comment}{ *}
02575 \textcolor{comment}{ * EINVAL: command non existing, wrong arity, wrong format specifier.}
02576 \textcolor{comment}{ * EPERM:  operation in Cluster instance with key in non local slot. */}
02577 \hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *RM\_Call(RedisModuleCtx *ctx, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *cmdname, \textcolor{keyword}{const} \textcolor{keywordtype}{char}
       *fmt, ...) \{
02578     \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd;
02579     \hyperlink{structclient}{client} *c = NULL;
02580     robj **argv = NULL;
02581     \textcolor{keywordtype}{int} argc = 0, flags = 0;
02582     va\_list ap;
02583     \hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply = NULL;
02584     \textcolor{keywordtype}{int} replicate = 0; \textcolor{comment}{/* Replicate this command? */}
02585 
02586     cmd = lookupCommandByCString((\textcolor{keywordtype}{char}*)cmdname);
02587     \textcolor{keywordflow}{if} (!cmd) \{
02588         errno = EINVAL;
02589         \textcolor{keywordflow}{return} NULL;
02590     \}
02591 
02592     \textcolor{comment}{/* Create the client and dispatch the command. */}
02593     va\_start(ap, fmt);
02594     c = createClient(-1);
02595     argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);
02596     replicate = flags & \hyperlink{module_8c_a53bcac3a263b30f4600dec73c4b3d0ef}{REDISMODULE\_ARGV\_REPLICATE};
02597     va\_end(ap);
02598 
02599     \textcolor{comment}{/* Setup our fake client for command execution. */}
02600     c->flags |= \hyperlink{server_8h_a633251b1c4bbfe09c54a5c88920d8eda}{CLIENT\_MODULE};
02601     c->db = ctx->client->db;
02602     c->argv = argv;
02603     c->argc = argc;
02604     c->cmd = c->lastcmd = cmd;
02605     \textcolor{comment}{/* We handle the above format error only when the client is setup so that}
02606 \textcolor{comment}{     * we can free it normally. */}
02607     \textcolor{keywordflow}{if} (argv == NULL) \textcolor{keywordflow}{goto} cleanup;
02608 
02609     \textcolor{comment}{/* Basic arity checks. */}
02610     \textcolor{keywordflow}{if} ((cmd->arity > 0 && cmd->arity != argc) || (argc < -cmd->arity)) \{
02611         errno = EINVAL;
02612         \textcolor{keywordflow}{goto} cleanup;
02613     \}
02614 
02615     \textcolor{comment}{/* If this is a Redis Cluster node, we need to make sure the module is not}
02616 \textcolor{comment}{     * trying to access non-local keys, with the exception of commands}
02617 \textcolor{comment}{     * received from our master. */}
02618     \textcolor{keywordflow}{if} (server.cluster\_enabled && !(ctx->client->flags & \hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER})) \{
02619         \textcolor{comment}{/* Duplicate relevant flags in the module client. */}
02620         c->flags &= ~(\hyperlink{server_8h_a84ba0494755e2f4f0faf6017175b5e0a}{CLIENT\_READONLY}|\hyperlink{server_8h_a108ac316dfd847430daf3c97f28557d3}{CLIENT\_ASKING});
02621         c->flags |= ctx->client->flags & (\hyperlink{server_8h_a84ba0494755e2f4f0faf6017175b5e0a}{CLIENT\_READONLY}|
      \hyperlink{server_8h_a108ac316dfd847430daf3c97f28557d3}{CLIENT\_ASKING});
02622         \textcolor{keywordflow}{if} (getNodeByQuery(c,c->cmd,c->argv,c->argc,NULL,NULL) !=
02623                            server.cluster->myself)
02624         \{
02625             errno = EPERM;
02626             \textcolor{keywordflow}{goto} cleanup;
02627         \}
02628     \}
02629 
02630     \textcolor{comment}{/* If we are using single commands replication, we need to wrap what}
02631 \textcolor{comment}{     * we propagate into a MULTI/EXEC block, so that it will be atomic like}
02632 \textcolor{comment}{     * a Lua script in the context of AOF and slaves. */}
02633     \textcolor{keywordflow}{if} (replicate) moduleReplicateMultiIfNeeded(ctx);
02634 
02635     \textcolor{comment}{/* Run the command */}
02636     \textcolor{keywordtype}{int} call\_flags = \hyperlink{server_8h_a934cea7b13db05a29264146cd5b14064}{CMD\_CALL\_SLOWLOG} | \hyperlink{server_8h_a7b1d9cf5be21e4808da0c16f03155973}{CMD\_CALL\_STATS};
02637     \textcolor{keywordflow}{if} (replicate) \{
02638         call\_flags |= \hyperlink{server_8h_a3ca848c94df18641ac372c58fca0e236}{CMD\_CALL\_PROPAGATE\_AOF};
02639         call\_flags |= \hyperlink{server_8h_a69e4a8fdb26588e1028deb20fd51424a}{CMD\_CALL\_PROPAGATE\_REPL};
02640     \}
02641     call(c,call\_flags);
02642 
02643     \textcolor{comment}{/* Convert the result of the Redis command into a suitable Lua type.}
02644 \textcolor{comment}{     * The first thing we need is to create a single string from the client}
02645 \textcolor{comment}{     * output buffers. */}
02646     sds proto = sdsnewlen(c->buf,c->bufpos);
02647     c->bufpos = 0;
02648     \textcolor{keywordflow}{while}(\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(c->reply)) \{
02649         sds o = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(\hyperlink{adlist_8h_aa8dc514bbe217bb2e87c1c77cfa84690}{listFirst}(c->reply));
02650 
02651         proto = sdscatsds(proto,o);
02652         listDelNode(c->reply,\hyperlink{adlist_8h_aa8dc514bbe217bb2e87c1c77cfa84690}{listFirst}(c->reply));
02653     \}
02654     reply = moduleCreateCallReplyFromProto(ctx,proto);
02655     autoMemoryAdd(ctx,\hyperlink{module_8c_a3a23ca3942d52889333fbd34f6efcffe}{REDISMODULE\_AM\_REPLY},reply);
02656 
02657 cleanup:
02658     freeClient(c);
02659     \textcolor{keywordflow}{return} reply;
02660 \}
02661 
02662 \textcolor{comment}{/* Return a pointer, and a length, to the protocol returned by the command}
02663 \textcolor{comment}{ * that returned the reply object. */}
02664 \textcolor{keyword}{const} \textcolor{keywordtype}{char} *RM\_CallReplyProto(\hyperlink{structRedisModuleCallReply}{RedisModuleCallReply} *reply, size\_t *len) \{
02665     \textcolor{keywordflow}{if} (reply->proto) *len = sdslen(reply->proto);
02666     \textcolor{keywordflow}{return} reply->proto;
02667 \}
02668 
02669 \textcolor{comment}{/* --------------------------------------------------------------------------}
02670 \textcolor{comment}{ * Modules data types}
02671 \textcolor{comment}{ *}
02672 \textcolor{comment}{ * When String DMA or using existing data structures is not enough, it is}
02673 \textcolor{comment}{ * possible to create new data types from scratch and export them to}
02674 \textcolor{comment}{ * Redis. The module must provide a set of callbacks for handling the}
02675 \textcolor{comment}{ * new values exported (for example in order to provide RDB saving/loading,}
02676 \textcolor{comment}{ * AOF rewrite, and so forth). In this section we define this API.}
02677 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
02678 
02679 \textcolor{comment}{/* Turn a 9 chars name in the specified charset and a 10 bit encver into}
02680 \textcolor{comment}{ * a single 64 bit unsigned integer that represents this exact module name}
02681 \textcolor{comment}{ * and version. This final number is called a "type ID" and is used when}
02682 \textcolor{comment}{ * writing module exported values to RDB files, in order to re-associate the}
02683 \textcolor{comment}{ * value to the right module to load them during RDB loading.}
02684 \textcolor{comment}{ *}
02685 \textcolor{comment}{ * If the string is not of the right length or the charset is wrong, or}
02686 \textcolor{comment}{ * if encver is outside the unsigned 10 bit integer range, 0 is returned,}
02687 \textcolor{comment}{ * otherwise the function returns the right type ID.}
02688 \textcolor{comment}{ *}
02689 \textcolor{comment}{ * The resulting 64 bit integer is composed as follows:}
02690 \textcolor{comment}{ *}
02691 \textcolor{comment}{ *     (high order bits) 6|6|6|6|6|6|6|6|6|10 (low order bits)}
02692 \textcolor{comment}{ *}
02693 \textcolor{comment}{ * The first 6 bits value is the first character, name[0], while the last}
02694 \textcolor{comment}{ * 6 bits value, immediately before the 10 bits integer, is name[8].}
02695 \textcolor{comment}{ * The last 10 bits are the encoding version.}
02696 \textcolor{comment}{ *}
02697 \textcolor{comment}{ * Note that a name and encver combo of "AAAAAAAAA" and 0, will produce}
02698 \textcolor{comment}{ * zero as return value, that is the same we use to signal errors, thus}
02699 \textcolor{comment}{ * this combination is invalid, and also useless since type names should}
02700 \textcolor{comment}{ * try to be vary to avoid collisions. */}
02701 
02702 \textcolor{keyword}{const} \textcolor{keywordtype}{char} *ModuleTypeNameCharSet =
02703              \textcolor{stringliteral}{"ABCDEFGHIJKLMNOPQRSTUVWXYZ"}
02704              \textcolor{stringliteral}{"abcdefghijklmnopqrstuvwxyz"}
02705              \textcolor{stringliteral}{"0123456789-\_"};
02706 
02707 uint64\_t moduleTypeEncodeId(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *name, \textcolor{keywordtype}{int} encver) \{
02708     \textcolor{comment}{/* We use 64 symbols so that we can map each character into 6 bits}
02709 \textcolor{comment}{     * of the final output. */}
02710     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *cset = ModuleTypeNameCharSet;
02711     \textcolor{keywordflow}{if} (strlen(name) != 9) \textcolor{keywordflow}{return} 0;
02712     \textcolor{keywordflow}{if} (encver < 0 || encver > 1023) \textcolor{keywordflow}{return} 0;
02713 
02714     uint64\_t id = 0;
02715     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 9; j++) \{
02716         \textcolor{keywordtype}{char} *p = strchr(cset,name[j]);
02717         \textcolor{keywordflow}{if} (!p) \textcolor{keywordflow}{return} 0;
02718         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} pos = p-cset;
02719         id = (id << 6) | pos;
02720     \}
02721     id = (id << 10) | encver;
02722     \textcolor{keywordflow}{return} id;
02723 \}
02724 
02725 \textcolor{comment}{/* Search, in the list of exported data types of all the modules registered,}
02726 \textcolor{comment}{ * a type with the same name as the one given. Returns the moduleType}
02727 \textcolor{comment}{ * structure pointer if such a module is found, or NULL otherwise. */}
02728 moduleType *moduleTypeLookupModuleByName(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *name) \{
02729     dictIterator *di = dictGetIterator(modules);
02730     dictEntry *de;
02731 
02732     \textcolor{keywordflow}{while} ((de = dictNext(di)) != NULL) \{
02733         \textcolor{keyword}{struct} \hyperlink{structRedisModule}{RedisModule} *module = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
02734         listIter li;
02735         listNode *ln;
02736 
02737         listRewind(module->types,&li);
02738         \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
02739             moduleType *mt = ln->value;
02740             \textcolor{keywordflow}{if} (memcmp(name,mt->name,\textcolor{keyword}{sizeof}(mt->name)) == 0) \{
02741                 dictReleaseIterator(di);
02742                 \textcolor{keywordflow}{return} mt;
02743             \}
02744         \}
02745     \}
02746     dictReleaseIterator(di);
02747     \textcolor{keywordflow}{return} NULL;
02748 \}
02749 
02750 \textcolor{comment}{/* Lookup a module by ID, with caching. This function is used during RDB}
02751 \textcolor{comment}{ * loading. Modules exporting data types should never be able to unload, so}
02752 \textcolor{comment}{ * our cache does not need to expire. */}
02753 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{MODULE\_LOOKUP\_CACHE\_SIZE} 3
02754 
02755 moduleType *moduleTypeLookupModuleByID(uint64\_t id) \{
02756     \textcolor{keyword}{static} \textcolor{keyword}{struct} \{
02757         uint64\_t id;
02758         moduleType *mt;
02759     \} cache[\hyperlink{module_8c_a7eaacbbffb61183eeb647383f95d8cf4}{MODULE\_LOOKUP\_CACHE\_SIZE}];
02760 
02761     \textcolor{comment}{/* Search in cache to start. */}
02762     \textcolor{keywordtype}{int} j;
02763     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{module_8c_a7eaacbbffb61183eeb647383f95d8cf4}{MODULE\_LOOKUP\_CACHE\_SIZE} && cache[j].mt != NULL; j++)
02764         \textcolor{keywordflow}{if} (cache[j].id == id) \textcolor{keywordflow}{return} cache[j].mt;
02765 
02766     \textcolor{comment}{/* Slow module by module lookup. */}
02767     moduleType *mt = NULL;
02768     dictIterator *di = dictGetIterator(modules);
02769     dictEntry *de;
02770 
02771     \textcolor{keywordflow}{while} ((de = dictNext(di)) != NULL && mt == NULL) \{
02772         \textcolor{keyword}{struct} \hyperlink{structRedisModule}{RedisModule} *module = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
02773         listIter li;
02774         listNode *ln;
02775 
02776         listRewind(module->types,&li);
02777         \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
02778             moduleType *this\_mt = ln->value;
02779             \textcolor{comment}{/* Compare only the 54 bit module identifier and not the}
02780 \textcolor{comment}{             * encoding version. */}
02781             \textcolor{keywordflow}{if} (this\_mt->id >> 10 == id >> 10) \{
02782                 mt = this\_mt;
02783                 \textcolor{keywordflow}{break};
02784             \}
02785         \}
02786     \}
02787     dictReleaseIterator(di);
02788 
02789     \textcolor{comment}{/* Add to cache if possible. */}
02790     \textcolor{keywordflow}{if} (mt && j < \hyperlink{module_8c_a7eaacbbffb61183eeb647383f95d8cf4}{MODULE\_LOOKUP\_CACHE\_SIZE}) \{
02791         cache[j].id = id;
02792         cache[j].mt = mt;
02793     \}
02794     \textcolor{keywordflow}{return} mt;
02795 \}
02796 
02797 \textcolor{comment}{/* Turn an (unresolved) module ID into a type name, to show the user an}
02798 \textcolor{comment}{ * error when RDB files contain module data we can't load.}
02799 \textcolor{comment}{ * The buffer pointed by 'name' must be 10 bytes at least. The function will}
02800 \textcolor{comment}{ * fill it with a null terminated module name. */}
02801 \textcolor{keywordtype}{void} moduleTypeNameByID(\textcolor{keywordtype}{char} *name, uint64\_t moduleid) \{
02802     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *cset = ModuleTypeNameCharSet;
02803 
02804     name[9] = \textcolor{stringliteral}{'\(\backslash\)0'};
02805     \textcolor{keywordtype}{char} *p = name+8;
02806     moduleid >>= 10;
02807     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 9; j++) \{
02808         *p-- = cset[moduleid & 63];
02809         moduleid >>= 6;
02810     \}
02811 \}
02812 
02813 \textcolor{comment}{/* Register a new data type exported by the module. The parameters are the}
02814 \textcolor{comment}{ * following. Please for in depth documentation check the modules API}
02815 \textcolor{comment}{ * documentation, especially the TYPES.md file.}
02816 \textcolor{comment}{ *}
02817 \textcolor{comment}{ * * **name**: A 9 characters data type name that MUST be unique in the Redis}
02818 \textcolor{comment}{ *   Modules ecosystem. Be creative... and there will be no collisions. Use}
02819 \textcolor{comment}{ *   the charset A-Z a-z 9-0, plus the two "-\_" characters. A good}
02820 \textcolor{comment}{ *   idea is to use, for example `<typename>-<vendor>`. For example}
02821 \textcolor{comment}{ *   "tree-AntZ" may mean "Tree data structure by @antirez". To use both}
02822 \textcolor{comment}{ *   lower case and upper case letters helps in order to prevent collisions.}
02823 \textcolor{comment}{ * * **encver**: Encoding version, which is, the version of the serialization}
02824 \textcolor{comment}{ *   that a module used in order to persist data. As long as the "name"}
02825 \textcolor{comment}{ *   matches, the RDB loading will be dispatched to the type callbacks}
02826 \textcolor{comment}{ *   whatever 'encver' is used, however the module can understand if}
02827 \textcolor{comment}{ *   the encoding it must load are of an older version of the module.}
02828 \textcolor{comment}{ *   For example the module "tree-AntZ" initially used encver=0. Later}
02829 \textcolor{comment}{ *   after an upgrade, it started to serialize data in a different format}
02830 \textcolor{comment}{ *   and to register the type with encver=1. However this module may}
02831 \textcolor{comment}{ *   still load old data produced by an older version if the rdb\_load}
02832 \textcolor{comment}{ *   callback is able to check the encver value and act accordingly.}
02833 \textcolor{comment}{ *   The encver must be a positive value between 0 and 1023.}
02834 \textcolor{comment}{ * * **typemethods\_ptr** is a pointer to a RedisModuleTypeMethods structure}
02835 \textcolor{comment}{ *   that should be populated with the methods callbacks and structure}
02836 \textcolor{comment}{ *   version, like in the following example:}
02837 \textcolor{comment}{ *}
02838 \textcolor{comment}{ *      RedisModuleTypeMethods tm = \{}
02839 \textcolor{comment}{ *          .version = REDISMODULE\_TYPE\_METHOD\_VERSION,}
02840 \textcolor{comment}{ *          .rdb\_load = myType\_RDBLoadCallBack,}
02841 \textcolor{comment}{ *          .rdb\_save = myType\_RDBSaveCallBack,}
02842 \textcolor{comment}{ *          .aof\_rewrite = myType\_AOFRewriteCallBack,}
02843 \textcolor{comment}{ *          .free = myType\_FreeCallBack,}
02844 \textcolor{comment}{ *}
02845 \textcolor{comment}{ *          // Optional fields}
02846 \textcolor{comment}{ *          .digest = myType\_DigestCallBack,}
02847 \textcolor{comment}{ *          .mem\_usage = myType\_MemUsageCallBack,}
02848 \textcolor{comment}{ *      \}}
02849 \textcolor{comment}{ *}
02850 \textcolor{comment}{ * * **rdb\_load**: A callback function pointer that loads data from RDB files.}
02851 \textcolor{comment}{ * * **rdb\_save**: A callback function pointer that saves data to RDB files.}
02852 \textcolor{comment}{ * * **aof\_rewrite**: A callback function pointer that rewrites data as commands.}
02853 \textcolor{comment}{ * * **digest**: A callback function pointer that is used for `DEBUG DIGEST`.}
02854 \textcolor{comment}{ * * **free**: A callback function pointer that can free a type value.}
02855 \textcolor{comment}{ *}
02856 \textcolor{comment}{ * The **digest* and **mem\_usage** methods should currently be omitted since}
02857 \textcolor{comment}{ * they are not yet implemented inside the Redis modules core.}
02858 \textcolor{comment}{ *}
02859 \textcolor{comment}{ * Note: the module name "AAAAAAAAA" is reserved and produces an error, it}
02860 \textcolor{comment}{ * happens to be pretty lame as well.}
02861 \textcolor{comment}{ *}
02862 \textcolor{comment}{ * If there is already a module registering a type with the same name,}
02863 \textcolor{comment}{ * and if the module name or encver is invalid, NULL is returned.}
02864 \textcolor{comment}{ * Otherwise the new type is registered into Redis, and a reference of}
02865 \textcolor{comment}{ * type RedisModuleType is returned: the caller of the function should store}
02866 \textcolor{comment}{ * this reference into a gobal variable to make future use of it in the}
02867 \textcolor{comment}{ * modules type API, since a single module may register multiple types.}
02868 \textcolor{comment}{ * Example code fragment:}
02869 \textcolor{comment}{ *}
02870 \textcolor{comment}{ *      static RedisModuleType *BalancedTreeType;}
02871 \textcolor{comment}{ *}
02872 \textcolor{comment}{ *      int RedisModule\_OnLoad(RedisModuleCtx *ctx) \{}
02873 \textcolor{comment}{ *          // some code here ...}
02874 \textcolor{comment}{ *          BalancedTreeType = RM\_CreateDataType(...);}
02875 \textcolor{comment}{ *      \}}
02876 \textcolor{comment}{ */}
02877 moduleType *RM\_CreateDataType(RedisModuleCtx *ctx, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *name, \textcolor{keywordtype}{int} encver, \textcolor{keywordtype}{void} *typemethods\_ptr
      ) \{
02878     uint64\_t id = moduleTypeEncodeId(name,encver);
02879     \textcolor{keywordflow}{if} (id == 0) \textcolor{keywordflow}{return} NULL;
02880     \textcolor{keywordflow}{if} (moduleTypeLookupModuleByName(name) != NULL) \textcolor{keywordflow}{return} NULL;
02881 
02882     \textcolor{keywordtype}{long} typemethods\_version = ((\textcolor{keywordtype}{long}*)typemethods\_ptr)[0];
02883     \textcolor{keywordflow}{if} (typemethods\_version == 0) \textcolor{keywordflow}{return} NULL;
02884 
02885     \textcolor{keyword}{struct} typemethods \{
02886         uint64\_t version;
02887         moduleTypeLoadFunc rdb\_load;
02888         moduleTypeSaveFunc rdb\_save;
02889         moduleTypeRewriteFunc aof\_rewrite;
02890         moduleTypeMemUsageFunc mem\_usage;
02891         moduleTypeDigestFunc digest;
02892         moduleTypeFreeFunc free;
02893     \} *tms = (\textcolor{keyword}{struct} typemethods*) typemethods\_ptr;
02894 
02895     moduleType *mt = zcalloc(\textcolor{keyword}{sizeof}(*mt));
02896     mt->id = id;
02897     mt->module = ctx->module;
02898     mt->rdb\_load = tms->rdb\_load;
02899     mt->rdb\_save = tms->rdb\_save;
02900     mt->aof\_rewrite = tms->aof\_rewrite;
02901     mt->mem\_usage = tms->mem\_usage;
02902     mt->digest = tms->digest;
02903     mt->free = tms->free;
02904     memcpy(mt->name,name,\textcolor{keyword}{sizeof}(mt->name));
02905     listAddNodeTail(ctx->module->types,mt);
02906     \textcolor{keywordflow}{return} mt;
02907 \}
02908 
02909 \textcolor{comment}{/* If the key is open for writing, set the specified module type object}
02910 \textcolor{comment}{ * as the value of the key, deleting the old value if any.}
02911 \textcolor{comment}{ * On success REDISMODULE\_OK is returned. If the key is not open for}
02912 \textcolor{comment}{ * writing or there is an active iterator, REDISMODULE\_ERR is returned. */}
02913 \textcolor{keywordtype}{int} RM\_ModuleTypeSetValue(RedisModuleKey *key, moduleType *mt, \textcolor{keywordtype}{void} *value) \{
02914     \textcolor{keywordflow}{if} (!(key->mode & \hyperlink{redismodule_8h_a73b37117ef94cb4a904361afcc51b6b4}{REDISMODULE\_WRITE}) || key->iter) \textcolor{keywordflow}{return} 
      \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
02915     RM\_DeleteKey(key);
02916     robj *o = createModuleObject(mt,value);
02917     setKey(key->db,key->key,o);
02918     decrRefCount(o);
02919     key->value = o;
02920     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
02921 \}
02922 
02923 \textcolor{comment}{/* Assuming RedisModule\_KeyType() returned REDISMODULE\_KEYTYPE\_MODULE on}
02924 \textcolor{comment}{ * the key, returns the moduel type pointer of the value stored at key.}
02925 \textcolor{comment}{ *}
02926 \textcolor{comment}{ * If the key is NULL, is not associated with a module type, or is empty,}
02927 \textcolor{comment}{ * then NULL is returned instead. */}
02928 moduleType *RM\_ModuleTypeGetType(RedisModuleKey *key) \{
02929     \textcolor{keywordflow}{if} (key == NULL ||
02930         key->value == NULL ||
02931         RM\_KeyType(key) != \hyperlink{redismodule_8h_a7beeb7b9c1c8e419591b3affb5b01f93}{REDISMODULE\_KEYTYPE\_MODULE}) \textcolor{keywordflow}{return} NULL;
02932     moduleValue *mv = key->value->ptr;
02933     \textcolor{keywordflow}{return} mv->type;
02934 \}
02935 
02936 \textcolor{comment}{/* Assuming RedisModule\_KeyType() returned REDISMODULE\_KEYTYPE\_MODULE on}
02937 \textcolor{comment}{ * the key, returns the module type low-level value stored at key, as}
02938 \textcolor{comment}{ * it was set by the user via RedisModule\_ModuleTypeSet().}
02939 \textcolor{comment}{ *}
02940 \textcolor{comment}{ * If the key is NULL, is not associated with a module type, or is empty,}
02941 \textcolor{comment}{ * then NULL is returned instead. */}
02942 \textcolor{keywordtype}{void} *RM\_ModuleTypeGetValue(RedisModuleKey *key) \{
02943     \textcolor{keywordflow}{if} (key == NULL ||
02944         key->value == NULL ||
02945         RM\_KeyType(key) != \hyperlink{redismodule_8h_a7beeb7b9c1c8e419591b3affb5b01f93}{REDISMODULE\_KEYTYPE\_MODULE}) \textcolor{keywordflow}{return} NULL;
02946     moduleValue *mv = key->value->ptr;
02947     \textcolor{keywordflow}{return} mv->value;
02948 \}
02949 
02950 \textcolor{comment}{/* --------------------------------------------------------------------------}
02951 \textcolor{comment}{ * RDB loading and saving functions}
02952 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
02953 
02954 \textcolor{comment}{/* Called when there is a load error in the context of a module. This cannot}
02955 \textcolor{comment}{ * be recovered like for the built-in types. */}
02956 \textcolor{keywordtype}{void} moduleRDBLoadError(\hyperlink{structRedisModuleIO}{RedisModuleIO} *io) \{
02957     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
02958         \textcolor{stringliteral}{"Error loading data from RDB (short read or EOF). "}
02959         \textcolor{stringliteral}{"Read performed by module '%s' about type '%s' "}
02960         \textcolor{stringliteral}{"after reading '%llu' bytes of a value."},
02961         io->type->module->name,
02962         io->type->name,
02963         (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long})io->bytes);
02964     exit(1);
02965 \}
02966 
02967 \textcolor{comment}{/* Save an unsigned 64 bit value into the RDB file. This function should only}
02968 \textcolor{comment}{ * be called in the context of the rdb\_save method of modules implementing new}
02969 \textcolor{comment}{ * data types. */}
02970 \textcolor{keywordtype}{void} RM\_SaveUnsigned(\hyperlink{structRedisModuleIO}{RedisModuleIO} *io, uint64\_t value) \{
02971     \textcolor{keywordflow}{if} (io->error) \textcolor{keywordflow}{return};
02972     \textcolor{comment}{/* Save opcode. */}
02973     \textcolor{keywordtype}{int} retval = rdbSaveLen(io->rio, \hyperlink{rdb_8h_a51400e437b171bb1d6206058b48e9938}{RDB\_MODULE\_OPCODE\_UINT});
02974     \textcolor{keywordflow}{if} (retval == -1) \textcolor{keywordflow}{goto} saveerr;
02975     io->bytes += retval;
02976     \textcolor{comment}{/* Save value. */}
02977     retval = rdbSaveLen(io->rio, value);
02978     \textcolor{keywordflow}{if} (retval == -1) \textcolor{keywordflow}{goto} saveerr;
02979     io->bytes += retval;
02980     \textcolor{keywordflow}{return};
02981 
02982 saveerr:
02983     io->error = 1;
02984 \}
02985 
02986 \textcolor{comment}{/* Load an unsigned 64 bit value from the RDB file. This function should only}
02987 \textcolor{comment}{ * be called in the context of the rdb\_load method of modules implementing}
02988 \textcolor{comment}{ * new data types. */}
02989 uint64\_t RM\_LoadUnsigned(\hyperlink{structRedisModuleIO}{RedisModuleIO} *io) \{
02990     \textcolor{keywordflow}{if} (io->ver == 2) \{
02991         uint64\_t opcode = rdbLoadLen(io->rio,NULL);
02992         \textcolor{keywordflow}{if} (opcode != \hyperlink{rdb_8h_a51400e437b171bb1d6206058b48e9938}{RDB\_MODULE\_OPCODE\_UINT}) \textcolor{keywordflow}{goto} loaderr;
02993     \}
02994     uint64\_t value;
02995     \textcolor{keywordtype}{int} retval = rdbLoadLenByRef(io->rio, NULL, &value);
02996     \textcolor{keywordflow}{if} (retval == -1) \textcolor{keywordflow}{goto} loaderr;
02997     \textcolor{keywordflow}{return} value;
02998 
02999 loaderr:
03000     moduleRDBLoadError(io);
03001     \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* Never reached. */}
03002 \}
03003 
03004 \textcolor{comment}{/* Like RedisModule\_SaveUnsigned() but for signed 64 bit values. */}
03005 \textcolor{keywordtype}{void} RM\_SaveSigned(\hyperlink{structRedisModuleIO}{RedisModuleIO} *io, int64\_t value) \{
03006     \textcolor{keyword}{union} \{uint64\_t u; int64\_t i;\} conv;
03007     conv.i = value;
03008     RM\_SaveUnsigned(io,conv.u);
03009 \}
03010 
03011 \textcolor{comment}{/* Like RedisModule\_LoadUnsigned() but for signed 64 bit values. */}
03012 int64\_t RM\_LoadSigned(\hyperlink{structRedisModuleIO}{RedisModuleIO} *io) \{
03013     \textcolor{keyword}{union} \{uint64\_t u; int64\_t i;\} conv;
03014     conv.u = RM\_LoadUnsigned(io);
03015     \textcolor{keywordflow}{return} conv.i;
03016 \}
03017 
03018 \textcolor{comment}{/* In the context of the rdb\_save method of a module type, saves a}
03019 \textcolor{comment}{ * string into the RDB file taking as input a RedisModuleString.}
03020 \textcolor{comment}{ *}
03021 \textcolor{comment}{ * The string can be later loaded with RedisModule\_LoadString() or}
03022 \textcolor{comment}{ * other Load family functions expecting a serialized string inside}
03023 \textcolor{comment}{ * the RDB file. */}
03024 \textcolor{keywordtype}{void} RM\_SaveString(\hyperlink{structRedisModuleIO}{RedisModuleIO} *io, RedisModuleString *s) \{
03025     \textcolor{keywordflow}{if} (io->error) \textcolor{keywordflow}{return};
03026     \textcolor{comment}{/* Save opcode. */}
03027     \textcolor{keywordtype}{int} retval = rdbSaveLen(io->rio, \hyperlink{rdb_8h_aba61dd3092856fb28a71a7e0032d82f1}{RDB\_MODULE\_OPCODE\_STRING});
03028     \textcolor{keywordflow}{if} (retval == -1) \textcolor{keywordflow}{goto} saveerr;
03029     io->bytes += retval;
03030     \textcolor{comment}{/* Save value. */}
03031     retval = rdbSaveStringObject(io->rio, s);
03032     \textcolor{keywordflow}{if} (retval == -1) \textcolor{keywordflow}{goto} saveerr;
03033     io->bytes += retval;
03034     \textcolor{keywordflow}{return};
03035 
03036 saveerr:
03037     io->error = 1;
03038 \}
03039 
03040 \textcolor{comment}{/* Like RedisModule\_SaveString() but takes a raw C pointer and length}
03041 \textcolor{comment}{ * as input. */}
03042 \textcolor{keywordtype}{void} RM\_SaveStringBuffer(\hyperlink{structRedisModuleIO}{RedisModuleIO} *io, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *str, size\_t len) \{
03043     \textcolor{keywordflow}{if} (io->error) \textcolor{keywordflow}{return};
03044     \textcolor{comment}{/* Save opcode. */}
03045     \textcolor{keywordtype}{int} retval = rdbSaveLen(io->rio, \hyperlink{rdb_8h_aba61dd3092856fb28a71a7e0032d82f1}{RDB\_MODULE\_OPCODE\_STRING});
03046     \textcolor{keywordflow}{if} (retval == -1) \textcolor{keywordflow}{goto} saveerr;
03047     io->bytes += retval;
03048     \textcolor{comment}{/* Save value. */}
03049     retval = rdbSaveRawString(io->rio, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)str,len);
03050     \textcolor{keywordflow}{if} (retval == -1) \textcolor{keywordflow}{goto} saveerr;
03051     io->bytes += retval;
03052     \textcolor{keywordflow}{return};
03053 
03054 saveerr:
03055     io->error = 1;
03056 \}
03057 
03058 \textcolor{comment}{/* Implements RM\_LoadString() and RM\_LoadStringBuffer() */}
03059 \textcolor{keywordtype}{void} *moduleLoadString(\hyperlink{structRedisModuleIO}{RedisModuleIO} *io, \textcolor{keywordtype}{int} plain, size\_t *lenptr) \{
03060     \textcolor{keywordflow}{if} (io->ver == 2) \{
03061         uint64\_t opcode = rdbLoadLen(io->rio,NULL);
03062         \textcolor{keywordflow}{if} (opcode != \hyperlink{rdb_8h_aba61dd3092856fb28a71a7e0032d82f1}{RDB\_MODULE\_OPCODE\_STRING}) \textcolor{keywordflow}{goto} loaderr;
03063     \}
03064     \textcolor{keywordtype}{void} *s = rdbGenericLoadStringObject(io->rio,
03065               plain ? \hyperlink{rdb_8h_a5579c0ff24afa891ad41006def040a25}{RDB\_LOAD\_PLAIN} : \hyperlink{rdb_8h_aa6539176570d3833856d0b6c71077c67}{RDB\_LOAD\_NONE}, lenptr);
03066     \textcolor{keywordflow}{if} (s == NULL) \textcolor{keywordflow}{goto} loaderr;
03067     \textcolor{keywordflow}{return} s;
03068 
03069 loaderr:
03070     moduleRDBLoadError(io);
03071     \textcolor{keywordflow}{return} NULL; \textcolor{comment}{/* Never reached. */}
03072 \}
03073 
03074 \textcolor{comment}{/* In the context of the rdb\_load method of a module data type, loads a string}
03075 \textcolor{comment}{ * from the RDB file, that was previously saved with RedisModule\_SaveString()}
03076 \textcolor{comment}{ * functions family.}
03077 \textcolor{comment}{ *}
03078 \textcolor{comment}{ * The returned string is a newly allocated RedisModuleString object, and}
03079 \textcolor{comment}{ * the user should at some point free it with a call to RedisModule\_FreeString().}
03080 \textcolor{comment}{ *}
03081 \textcolor{comment}{ * If the data structure does not store strings as RedisModuleString objects,}
03082 \textcolor{comment}{ * the similar function RedisModule\_LoadStringBuffer() could be used instead. */}
03083 RedisModuleString *RM\_LoadString(\hyperlink{structRedisModuleIO}{RedisModuleIO} *io) \{
03084     \textcolor{keywordflow}{return} moduleLoadString(io,0,NULL);
03085 \}
03086 
03087 \textcolor{comment}{/* Like RedisModule\_LoadString() but returns an heap allocated string that}
03088 \textcolor{comment}{ * was allocated with RedisModule\_Alloc(), and can be resized or freed with}
03089 \textcolor{comment}{ * RedisModule\_Realloc() or RedisModule\_Free().}
03090 \textcolor{comment}{ *}
03091 \textcolor{comment}{ * The size of the string is stored at '*lenptr' if not NULL.}
03092 \textcolor{comment}{ * The returned string is not automatically NULL termianted, it is loaded}
03093 \textcolor{comment}{ * exactly as it was stored inisde the RDB file. */}
03094 \textcolor{keywordtype}{char} *RM\_LoadStringBuffer(\hyperlink{structRedisModuleIO}{RedisModuleIO} *io, size\_t *lenptr) \{
03095     \textcolor{keywordflow}{return} moduleLoadString(io,1,lenptr);
03096 \}
03097 
03098 \textcolor{comment}{/* In the context of the rdb\_save method of a module data type, saves a double}
03099 \textcolor{comment}{ * value to the RDB file. The double can be a valid number, a NaN or infinity.}
03100 \textcolor{comment}{ * It is possible to load back the value with RedisModule\_LoadDouble(). */}
03101 \textcolor{keywordtype}{void} RM\_SaveDouble(\hyperlink{structRedisModuleIO}{RedisModuleIO} *io, \textcolor{keywordtype}{double} value) \{
03102     \textcolor{keywordflow}{if} (io->error) \textcolor{keywordflow}{return};
03103     \textcolor{comment}{/* Save opcode. */}
03104     \textcolor{keywordtype}{int} retval = rdbSaveLen(io->rio, \hyperlink{rdb_8h_a657fe8be09e7e9b7b4e071da54d2a5f7}{RDB\_MODULE\_OPCODE\_DOUBLE});
03105     \textcolor{keywordflow}{if} (retval == -1) \textcolor{keywordflow}{goto} saveerr;
03106     io->bytes += retval;
03107     \textcolor{comment}{/* Save value. */}
03108     retval = rdbSaveBinaryDoubleValue(io->rio, value);
03109     \textcolor{keywordflow}{if} (retval == -1) \textcolor{keywordflow}{goto} saveerr;
03110     io->bytes += retval;
03111     \textcolor{keywordflow}{return};
03112 
03113 saveerr:
03114     io->error = 1;
03115 \}
03116 
03117 \textcolor{comment}{/* In the context of the rdb\_save method of a module data type, loads back the}
03118 \textcolor{comment}{ * double value saved by RedisModule\_SaveDouble(). */}
03119 \textcolor{keywordtype}{double} RM\_LoadDouble(\hyperlink{structRedisModuleIO}{RedisModuleIO} *io) \{
03120     \textcolor{keywordflow}{if} (io->ver == 2) \{
03121         uint64\_t opcode = rdbLoadLen(io->rio,NULL);
03122         \textcolor{keywordflow}{if} (opcode != \hyperlink{rdb_8h_a657fe8be09e7e9b7b4e071da54d2a5f7}{RDB\_MODULE\_OPCODE\_DOUBLE}) \textcolor{keywordflow}{goto} loaderr;
03123     \}
03124     \textcolor{keywordtype}{double} value;
03125     \textcolor{keywordtype}{int} retval = rdbLoadBinaryDoubleValue(io->rio, &value);
03126     \textcolor{keywordflow}{if} (retval == -1) \textcolor{keywordflow}{goto} loaderr;
03127     \textcolor{keywordflow}{return} value;
03128 
03129 loaderr:
03130     moduleRDBLoadError(io);
03131     \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* Never reached. */}
03132 \}
03133 
03134 \textcolor{comment}{/* In the context of the rdb\_save method of a module data type, saves a float}
03135 \textcolor{comment}{ * value to the RDB file. The float can be a valid number, a NaN or infinity.}
03136 \textcolor{comment}{ * It is possible to load back the value with RedisModule\_LoadFloat(). */}
03137 \textcolor{keywordtype}{void} RM\_SaveFloat(\hyperlink{structRedisModuleIO}{RedisModuleIO} *io, \textcolor{keywordtype}{float} value) \{
03138     \textcolor{keywordflow}{if} (io->error) \textcolor{keywordflow}{return};
03139     \textcolor{comment}{/* Save opcode. */}
03140     \textcolor{keywordtype}{int} retval = rdbSaveLen(io->rio, \hyperlink{rdb_8h_ac6c932476609f11914ab1172688f247e}{RDB\_MODULE\_OPCODE\_FLOAT});
03141     \textcolor{keywordflow}{if} (retval == -1) \textcolor{keywordflow}{goto} saveerr;
03142     io->bytes += retval;
03143     \textcolor{comment}{/* Save value. */}
03144     retval = rdbSaveBinaryFloatValue(io->rio, value);
03145     \textcolor{keywordflow}{if} (retval == -1) \textcolor{keywordflow}{goto} saveerr;
03146     io->bytes += retval;
03147     \textcolor{keywordflow}{return};
03148 
03149 saveerr:
03150     io->error = 1;
03151 \}
03152 
03153 \textcolor{comment}{/* In the context of the rdb\_save method of a module data type, loads back the}
03154 \textcolor{comment}{ * float value saved by RedisModule\_SaveFloat(). */}
03155 \textcolor{keywordtype}{float} RM\_LoadFloat(\hyperlink{structRedisModuleIO}{RedisModuleIO} *io) \{
03156     \textcolor{keywordflow}{if} (io->ver == 2) \{
03157         uint64\_t opcode = rdbLoadLen(io->rio,NULL);
03158         \textcolor{keywordflow}{if} (opcode != \hyperlink{rdb_8h_ac6c932476609f11914ab1172688f247e}{RDB\_MODULE\_OPCODE\_FLOAT}) \textcolor{keywordflow}{goto} loaderr;
03159     \}
03160     \textcolor{keywordtype}{float} value;
03161     \textcolor{keywordtype}{int} retval = rdbLoadBinaryFloatValue(io->rio, &value);
03162     \textcolor{keywordflow}{if} (retval == -1) \textcolor{keywordflow}{goto} loaderr;
03163     \textcolor{keywordflow}{return} value;
03164 
03165 loaderr:
03166     moduleRDBLoadError(io);
03167     \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* Never reached. */}
03168 \}
03169 
03170 \textcolor{comment}{/* --------------------------------------------------------------------------}
03171 \textcolor{comment}{ * Key digest API (DEBUG DIGEST interface for modules types)}
03172 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
03173 
03174 \textcolor{comment}{/* Add a new element to the digest. This function can be called multiple times}
03175 \textcolor{comment}{ * one element after the other, for all the elements that constitute a given}
03176 \textcolor{comment}{ * data structure. The function call must be followed by the call to}
03177 \textcolor{comment}{ * `RedisModule\_DigestEndSequence` eventually, when all the elements that are}
03178 \textcolor{comment}{ * always in a given order are added. See the Redis Modules data types}
03179 \textcolor{comment}{ * documentation for more info. However this is a quick example that uses Redis}
03180 \textcolor{comment}{ * data types as an example.}
03181 \textcolor{comment}{ *}
03182 \textcolor{comment}{ * To add a sequence of unordered elements (for example in the case of a Redis}
03183 \textcolor{comment}{ * Set), the pattern to use is:}
03184 \textcolor{comment}{ *}
03185 \textcolor{comment}{ *     foreach element \{}
03186 \textcolor{comment}{ *         AddElement(element);}
03187 \textcolor{comment}{ *         EndSequence();}
03188 \textcolor{comment}{ *     \}}
03189 \textcolor{comment}{ *}
03190 \textcolor{comment}{ * Because Sets are not ordered, so every element added has a position that}
03191 \textcolor{comment}{ * does not depend from the other. However if instead our elements are}
03192 \textcolor{comment}{ * ordered in pairs, like field-value pairs of an Hash, then one should}
03193 \textcolor{comment}{ * use:}
03194 \textcolor{comment}{ *}
03195 \textcolor{comment}{ *     foreach key,value \{}
03196 \textcolor{comment}{ *         AddElement(key);}
03197 \textcolor{comment}{ *         AddElement(value);}
03198 \textcolor{comment}{ *         EndSquence();}
03199 \textcolor{comment}{ *     \}}
03200 \textcolor{comment}{ *}
03201 \textcolor{comment}{ * Because the key and value will be always in the above order, while instead}
03202 \textcolor{comment}{ * the single key-value pairs, can appear in any position into a Redis hash.}
03203 \textcolor{comment}{ *}
03204 \textcolor{comment}{ * A list of ordered elements would be implemented with:}
03205 \textcolor{comment}{ *}
03206 \textcolor{comment}{ *     foreach element \{}
03207 \textcolor{comment}{ *         AddElement(element);}
03208 \textcolor{comment}{ *     \}}
03209 \textcolor{comment}{ *     EndSequence();}
03210 \textcolor{comment}{ *}
03211 \textcolor{comment}{ */}
03212 \textcolor{keywordtype}{void} RM\_DigestAddStringBuffer(RedisModuleDigest *md, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ele, size\_t len) \{
03213     mixDigest(md->o,ele,len);
03214 \}
03215 
03216 \textcolor{comment}{/* Like `RedisModule\_DigestAddStringBuffer()` but takes a long long as input}
03217 \textcolor{comment}{ * that gets converted into a string before adding it to the digest. */}
03218 \textcolor{keywordtype}{void} RM\_DigestAddLongLong(RedisModuleDigest *md, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ll) \{
03219     \textcolor{keywordtype}{char} buf[\hyperlink{server_8h_a39ec35278876f65fc1ef70b049856ca3}{LONG\_STR\_SIZE}];
03220     size\_t len = ll2string(buf,\textcolor{keyword}{sizeof}(buf),ll);
03221     mixDigest(md->o,buf,len);
03222 \}
03223 
03224 \textcolor{comment}{/* See the doucmnetation for `RedisModule\_DigestAddElement()`. */}
03225 \textcolor{keywordtype}{void} RM\_DigestEndSequence(RedisModuleDigest *md) \{
03226     xorDigest(md->x,md->o,\textcolor{keyword}{sizeof}(md->o));
03227     memset(md->o,0,\textcolor{keyword}{sizeof}(md->o));
03228 \}
03229 
03230 \textcolor{comment}{/* --------------------------------------------------------------------------}
03231 \textcolor{comment}{ * AOF API for modules data types}
03232 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
03233 
03234 \textcolor{comment}{/* Emits a command into the AOF during the AOF rewriting process. This function}
03235 \textcolor{comment}{ * is only called in the context of the aof\_rewrite method of data types exported}
03236 \textcolor{comment}{ * by a module. The command works exactly like RedisModule\_Call() in the way}
03237 \textcolor{comment}{ * the parameters are passed, but it does not return anything as the error}
03238 \textcolor{comment}{ * handling is performed by Redis itself. */}
03239 \textcolor{keywordtype}{void} RM\_EmitAOF(\hyperlink{structRedisModuleIO}{RedisModuleIO} *io, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *cmdname, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, ...) \{
03240     \textcolor{keywordflow}{if} (io->error) \textcolor{keywordflow}{return};
03241     \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd;
03242     robj **argv = NULL;
03243     \textcolor{keywordtype}{int} argc = 0, flags = 0, j;
03244     va\_list ap;
03245 
03246     cmd = lookupCommandByCString((\textcolor{keywordtype}{char}*)cmdname);
03247     \textcolor{keywordflow}{if} (!cmd) \{
03248         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
03249             \textcolor{stringliteral}{"Fatal: AOF method for module data type '%s' tried to "}
03250             \textcolor{stringliteral}{"emit unknown command '%s'"},
03251             io->type->name, cmdname);
03252         io->error = 1;
03253         errno = EINVAL;
03254         \textcolor{keywordflow}{return};
03255     \}
03256 
03257     \textcolor{comment}{/* Emit the arguments into the AOF in Redis protocol format. */}
03258     va\_start(ap, fmt);
03259     argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);
03260     va\_end(ap);
03261     \textcolor{keywordflow}{if} (argv == NULL) \{
03262         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
03263             \textcolor{stringliteral}{"Fatal: AOF method for module data type '%s' tried to "}
03264             \textcolor{stringliteral}{"call RedisModule\_EmitAOF() with wrong format specifiers '%s'"},
03265             io->type->name, fmt);
03266         io->error = 1;
03267         errno = EINVAL;
03268         \textcolor{keywordflow}{return};
03269     \}
03270 
03271     \textcolor{comment}{/* Bulk count. */}
03272     \textcolor{keywordflow}{if} (!io->error && rioWriteBulkCount(io->rio,\textcolor{stringliteral}{'*'},argc) == 0)
03273         io->error = 1;
03274 
03275     \textcolor{comment}{/* Arguments. */}
03276     \textcolor{keywordflow}{for} (j = 0; j < argc; j++) \{
03277         \textcolor{keywordflow}{if} (!io->error && rioWriteBulkObject(io->rio,argv[j]) == 0)
03278             io->error = 1;
03279         decrRefCount(argv[j]);
03280     \}
03281     zfree(argv);
03282     \textcolor{keywordflow}{return};
03283 \}
03284 
03285 \textcolor{comment}{/* --------------------------------------------------------------------------}
03286 \textcolor{comment}{ * IO context handling}
03287 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
03288 
03289 RedisModuleCtx *RM\_GetContextFromIO(\hyperlink{structRedisModuleIO}{RedisModuleIO} *io) \{
03290     \textcolor{keywordflow}{if} (io->ctx) \textcolor{keywordflow}{return} io->ctx; \textcolor{comment}{/* Can't have more than one... */}
03291     RedisModuleCtx ctxtemplate = \hyperlink{module_8c_a7a80fb134c35b70c7cfe920ea1033bcd}{REDISMODULE\_CTX\_INIT};
03292     io->ctx = zmalloc(\textcolor{keyword}{sizeof}(RedisModuleCtx));
03293     *(io->ctx) = ctxtemplate;
03294     io->ctx->module = io->type->module;
03295     io->ctx->client = NULL;
03296     \textcolor{keywordflow}{return} io->ctx;
03297 \}
03298 
03299 \textcolor{comment}{/* --------------------------------------------------------------------------}
03300 \textcolor{comment}{ * Logging}
03301 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
03302 
03303 \textcolor{comment}{/* This is the low level function implementing both:}
03304 \textcolor{comment}{ *}
03305 \textcolor{comment}{ *      RM\_Log()}
03306 \textcolor{comment}{ *      RM\_LogIOError()}
03307 \textcolor{comment}{ *}
03308 \textcolor{comment}{ */}
03309 \textcolor{keywordtype}{void} RM\_LogRaw(RedisModule *module, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *levelstr, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, va\_list ap) \{
03310     \textcolor{keywordtype}{char} msg[\hyperlink{server_8h_a37cd05cbfd7fb52ad21d3a822cff2ee6}{LOG\_MAX\_LEN}];
03311     size\_t name\_len;
03312     \textcolor{keywordtype}{int} level;
03313 
03314     \textcolor{keywordflow}{if} (!strcasecmp(levelstr,\textcolor{stringliteral}{"debug"})) level = \hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG};
03315     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(levelstr,\textcolor{stringliteral}{"verbose"})) level = \hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE};
03316     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(levelstr,\textcolor{stringliteral}{"notice"})) level = \hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE};
03317     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(levelstr,\textcolor{stringliteral}{"warning"})) level = \hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING};
03318     \textcolor{keywordflow}{else} level = \hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE}; \textcolor{comment}{/* Default. */}
03319 
03320     name\_len = snprintf(msg, \textcolor{keyword}{sizeof}(msg),\textcolor{stringliteral}{"<%s> "}, module->name);
03321     vsnprintf(msg + name\_len, \textcolor{keyword}{sizeof}(msg) - name\_len, fmt, ap);
03322     serverLogRaw(level,msg);
03323 \}
03324 
03325 \textcolor{comment}{/* Produces a log message to the standard Redis log, the format accepts}
03326 \textcolor{comment}{ * printf-alike specifiers, while level is a string describing the log}
03327 \textcolor{comment}{ * level to use when emitting the log, and must be one of the following:}
03328 \textcolor{comment}{ *}
03329 \textcolor{comment}{ * * "debug"}
03330 \textcolor{comment}{ * * "verbose"}
03331 \textcolor{comment}{ * * "notice"}
03332 \textcolor{comment}{ * * "warning"}
03333 \textcolor{comment}{ *}
03334 \textcolor{comment}{ * If the specified log level is invalid, verbose is used by default.}
03335 \textcolor{comment}{ * There is a fixed limit to the length of the log line this function is able}
03336 \textcolor{comment}{ * to emit, this limti is not specified but is guaranteed to be more than}
03337 \textcolor{comment}{ * a few lines of text.}
03338 \textcolor{comment}{ */}
03339 \textcolor{keywordtype}{void} RM\_Log(RedisModuleCtx *ctx, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *levelstr, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, ...) \{
03340     \textcolor{keywordflow}{if} (!ctx->module) \textcolor{keywordflow}{return};   \textcolor{comment}{/* Can only log if module is initialized */}
03341 
03342     va\_list ap;
03343     va\_start(ap, fmt);
03344     RM\_LogRaw(ctx->module,levelstr,fmt,ap);
03345     va\_end(ap);
03346 \}
03347 
03348 \textcolor{comment}{/* Log errors from RDB / AOF serialization callbacks.}
03349 \textcolor{comment}{ *}
03350 \textcolor{comment}{ * This function should be used when a callback is returning a critical}
03351 \textcolor{comment}{ * error to the caller since cannot load or save the data for some}
03352 \textcolor{comment}{ * critical reason. */}
03353 \textcolor{keywordtype}{void} RM\_LogIOError(\hyperlink{structRedisModuleIO}{RedisModuleIO} *io, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *levelstr, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, ...) \{
03354     va\_list ap;
03355     va\_start(ap, fmt);
03356     RM\_LogRaw(io->type->module,levelstr,fmt,ap);
03357     va\_end(ap);
03358 \}
03359 
03360 \textcolor{comment}{/* --------------------------------------------------------------------------}
03361 \textcolor{comment}{ * Blocking clients from modules}
03362 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
03363 
03364 \textcolor{comment}{/* Readable handler for the awake pipe. We do nothing here, the awake bytes}
03365 \textcolor{comment}{ * will be actually read in a more appropriate place in the}
03366 \textcolor{comment}{ * moduleHandleBlockedClients() function that is where clients are actually}
03367 \textcolor{comment}{ * served. */}
03368 \textcolor{keywordtype}{void} moduleBlockedClientPipeReadable(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask) \{
03369     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(el);
03370     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(fd);
03371     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(mask);
03372     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(privdata);
03373 \}
03374 
03375 \textcolor{comment}{/* This is called from blocked.c in order to unblock a client: may be called}
03376 \textcolor{comment}{ * for multiple reasons while the client is in the middle of being blocked}
03377 \textcolor{comment}{ * because the client is terminated, but is also called for cleanup when a}
03378 \textcolor{comment}{ * client is unblocked in a clean way after replaying.}
03379 \textcolor{comment}{ *}
03380 \textcolor{comment}{ * What we do here is just to set the client to NULL in the redis module}
03381 \textcolor{comment}{ * blocked client handle. This way if the client is terminated while there}
03382 \textcolor{comment}{ * is a pending threaded operation involving the blocked client, we'll know}
03383 \textcolor{comment}{ * that the client no longer exists and no reply callback should be called.}
03384 \textcolor{comment}{ *}
03385 \textcolor{comment}{ * The structure RedisModuleBlockedClient will be always deallocated when}
03386 \textcolor{comment}{ * running the list of clients blocked by a module that need to be unblocked. */}
03387 \textcolor{keywordtype}{void} unblockClientFromModule(\hyperlink{structclient}{client} *c) \{
03388     RedisModuleBlockedClient *bc = c->bpop.module\_blocked\_handle;
03389     bc->client = NULL;
03390     \textcolor{comment}{/* Reset the client for a new query since, for blocking commands implemented}
03391 \textcolor{comment}{     * into modules, we do not it immediately after the command returns (and}
03392 \textcolor{comment}{     * the client blocks) in order to be still able to access the argument}
03393 \textcolor{comment}{     * vector from callbacks. */}
03394     resetClient(c);
03395 \}
03396 
03397 \textcolor{comment}{/* Block a client in the context of a blocking command, returning an handle}
03398 \textcolor{comment}{ * which will be used, later, in order to unblock the client with a call to}
03399 \textcolor{comment}{ * RedisModule\_UnblockClient(). The arguments specify callback functions}
03400 \textcolor{comment}{ * and a timeout after which the client is unblocked.}
03401 \textcolor{comment}{ *}
03402 \textcolor{comment}{ * The callbacks are called in the following contexts:}
03403 \textcolor{comment}{ *}
03404 \textcolor{comment}{ *     reply\_callback:  called after a successful RedisModule\_UnblockClient()}
03405 \textcolor{comment}{ *                      call in order to reply to the client and unblock it.}
03406 \textcolor{comment}{ *}
03407 \textcolor{comment}{ *     reply\_timeout:   called when the timeout is reached in order to send an}
03408 \textcolor{comment}{ *                      error to the client.}
03409 \textcolor{comment}{ *}
03410 \textcolor{comment}{ *     free\_privdata:   called in order to free the privata data that is passed}
03411 \textcolor{comment}{ *                      by RedisModule\_UnblockClient() call.}
03412 \textcolor{comment}{ */}
03413 RedisModuleBlockedClient *RM\_BlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply\_callback, 
      RedisModuleCmdFunc timeout\_callback, \textcolor{keywordtype}{void} (*free\_privdata)(\textcolor{keywordtype}{void}*), \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} timeout\_ms) \{
03414     \hyperlink{structclient}{client} *c = ctx->client;
03415     \textcolor{keywordtype}{int} islua = c->flags & \hyperlink{server_8h_af9d0b0f45ef2c1fd29ac714a300de706}{CLIENT\_LUA};
03416     \textcolor{keywordtype}{int} ismulti = c->flags & \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI};
03417 
03418     c->bpop.module\_blocked\_handle = zmalloc(\textcolor{keyword}{sizeof}(RedisModuleBlockedClient));
03419     RedisModuleBlockedClient *bc = c->bpop.module\_blocked\_handle;
03420 
03421     \textcolor{comment}{/* We need to handle the invalid operation of calling modules blocking}
03422 \textcolor{comment}{     * commands from Lua or MULTI. We actually create an already aborted}
03423 \textcolor{comment}{     * (client set to NULL) blocked client handle, and actually reply with}
03424 \textcolor{comment}{     * an error. */}
03425     bc->client = (islua || ismulti) ? NULL : c;
03426     bc->module = ctx->module;
03427     bc->reply\_callback = reply\_callback;
03428     bc->timeout\_callback = timeout\_callback;
03429     bc->free\_privdata = free\_privdata;
03430     bc->privdata = NULL;
03431     bc->reply\_client = createClient(-1);
03432     bc->reply\_client->flags |= \hyperlink{server_8h_a633251b1c4bbfe09c54a5c88920d8eda}{CLIENT\_MODULE};
03433     bc->dbid = c->db->id;
03434     c->bpop.timeout = timeout\_ms ? (mstime()+timeout\_ms) : 0;
03435 
03436     \textcolor{keywordflow}{if} (islua || ismulti) \{
03437         c->bpop.module\_blocked\_handle = NULL;
03438         addReplyError(c, islua ?
03439             \textcolor{stringliteral}{"Blocking module command called from Lua script"} :
03440             \textcolor{stringliteral}{"Blocking module command called from transaction"});
03441     \} \textcolor{keywordflow}{else} \{
03442         blockClient(c,\hyperlink{server_8h_a6bdaa78b1c4c376ebf666afb891ace42}{BLOCKED\_MODULE});
03443     \}
03444     \textcolor{keywordflow}{return} bc;
03445 \}
03446 
03447 \textcolor{comment}{/* Unblock a client blocked by `RedisModule\_BlockedClient`. This will trigger}
03448 \textcolor{comment}{ * the reply callbacks to be called in order to reply to the client.}
03449 \textcolor{comment}{ * The 'privdata' argument will be accessible by the reply callback, so}
03450 \textcolor{comment}{ * the caller of this function can pass any value that is needed in order to}
03451 \textcolor{comment}{ * actually reply to the client.}
03452 \textcolor{comment}{ *}
03453 \textcolor{comment}{ * A common usage for 'privdata' is a thread that computes something that}
03454 \textcolor{comment}{ * needs to be passed to the client, included but not limited some slow}
03455 \textcolor{comment}{ * to compute reply or some reply obtained via networking.}
03456 \textcolor{comment}{ *}
03457 \textcolor{comment}{ * Note: this function can be called from threads spawned by the module. */}
03458 \textcolor{keywordtype}{int} RM\_UnblockClient(RedisModuleBlockedClient *bc, \textcolor{keywordtype}{void} *privdata) \{
03459     pthread\_mutex\_lock(&moduleUnblockedClientsMutex);
03460     bc->privdata = privdata;
03461     listAddNodeTail(moduleUnblockedClients,bc);
03462     \textcolor{keywordflow}{if} (write(server.module\_blocked\_pipe[1],\textcolor{stringliteral}{"A"},1) != 1) \{
03463         \textcolor{comment}{/* Ignore the error, this is best-effort. */}
03464     \}
03465     pthread\_mutex\_unlock(&moduleUnblockedClientsMutex);
03466     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
03467 \}
03468 
03469 \textcolor{comment}{/* Abort a blocked client blocking operation: the client will be unblocked}
03470 \textcolor{comment}{ * without firing the reply callback. */}
03471 \textcolor{keywordtype}{int} RM\_AbortBlock(RedisModuleBlockedClient *bc) \{
03472     bc->reply\_callback = NULL;
03473     \textcolor{keywordflow}{return} RM\_UnblockClient(bc,NULL);
03474 \}
03475 
03476 \textcolor{comment}{/* This function will check the moduleUnblockedClients queue in order to}
03477 \textcolor{comment}{ * call the reply callback and really unblock the client.}
03478 \textcolor{comment}{ *}
03479 \textcolor{comment}{ * Clients end into this list because of calls to RM\_UnblockClient(),}
03480 \textcolor{comment}{ * however it is possible that while the module was doing work for the}
03481 \textcolor{comment}{ * blocked client, it was terminated by Redis (for timeout or other reasons).}
03482 \textcolor{comment}{ * When this happens the RedisModuleBlockedClient structure in the queue}
03483 \textcolor{comment}{ * will have the 'client' field set to NULL. */}
03484 \textcolor{keywordtype}{void} moduleHandleBlockedClients(\textcolor{keywordtype}{void}) \{
03485     listNode *ln;
03486     RedisModuleBlockedClient *bc;
03487 
03488     pthread\_mutex\_lock(&moduleUnblockedClientsMutex);
03489     \textcolor{comment}{/* Here we unblock all the pending clients blocked in modules operations}
03490 \textcolor{comment}{     * so we can read every pending "awake byte" in the pipe. */}
03491     \textcolor{keywordtype}{char} buf[1];
03492     \textcolor{keywordflow}{while} (read(server.module\_blocked\_pipe[0],buf,1) == 1);
03493     \textcolor{keywordflow}{while} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(moduleUnblockedClients)) \{
03494         ln = \hyperlink{adlist_8h_aa8dc514bbe217bb2e87c1c77cfa84690}{listFirst}(moduleUnblockedClients);
03495         bc = ln->value;
03496         \hyperlink{structclient}{client} *c = bc->client;
03497         listDelNode(moduleUnblockedClients,ln);
03498         pthread\_mutex\_unlock(&moduleUnblockedClientsMutex);
03499 
03500         \textcolor{comment}{/* Release the lock during the loop, as long as we don't}
03501 \textcolor{comment}{         * touch the shared list. */}
03502 
03503         \textcolor{comment}{/* Call the reply callback if the client is valid and we have}
03504 \textcolor{comment}{         * any callback. */}
03505         \textcolor{keywordflow}{if} (c && bc->reply\_callback) \{
03506             RedisModuleCtx ctx = \hyperlink{module_8c_a7a80fb134c35b70c7cfe920ea1033bcd}{REDISMODULE\_CTX\_INIT};
03507             ctx.flags |= \hyperlink{module_8c_a06323cb111581e0b8848943a08639a87}{REDISMODULE\_CTX\_BLOCKED\_REPLY};
03508             ctx.blocked\_privdata = bc->privdata;
03509             ctx.module = bc->module;
03510             ctx.client = bc->client;
03511             bc->reply\_callback(&ctx,(\textcolor{keywordtype}{void}**)c->argv,c->argc);
03512             moduleHandlePropagationAfterCommandCallback(&ctx);
03513             moduleFreeContext(&ctx);
03514         \}
03515 
03516         \textcolor{comment}{/* Free privdata if any. */}
03517         \textcolor{keywordflow}{if} (bc->privdata && bc->free\_privdata)
03518             bc->free\_privdata(bc->privdata);
03519 
03520         \textcolor{comment}{/* It is possible that this blocked client object accumulated}
03521 \textcolor{comment}{         * replies to send to the client in a thread safe context.}
03522 \textcolor{comment}{         * We need to glue such replies to the client output buffer and}
03523 \textcolor{comment}{         * free the temporary client we just used for the replies. */}
03524         \textcolor{keywordflow}{if} (c) \{
03525             \textcolor{keywordflow}{if} (bc->reply\_client->bufpos)
03526                 addReplyString(c,bc->reply\_client->buf,
03527                                  bc->reply\_client->bufpos);
03528             \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(bc->reply\_client->reply))
03529                 listJoin(c->reply,bc->reply\_client->reply);
03530             c->reply\_bytes += bc->reply\_client->reply\_bytes;
03531         \}
03532         freeClient(bc->reply\_client);
03533 
03534         \textcolor{keywordflow}{if} (c != NULL) \{
03535             unblockClient(c);
03536             \textcolor{comment}{/* Put the client in the list of clients that need to write}
03537 \textcolor{comment}{             * if there are pending replies here. This is needed since}
03538 \textcolor{comment}{             * during a non blocking command the client may receive output. */}
03539             \textcolor{keywordflow}{if} (clientHasPendingReplies(c) &&
03540                 !(c->flags & \hyperlink{server_8h_addd2e991874faef411339e9ae9619023}{CLIENT\_PENDING\_WRITE}))
03541             \{
03542                 c->flags |= \hyperlink{server_8h_addd2e991874faef411339e9ae9619023}{CLIENT\_PENDING\_WRITE};
03543                 listAddNodeHead(server.clients\_pending\_write,c);
03544             \}
03545         \}
03546 
03547         \textcolor{comment}{/* Free 'bc' only after unblocking the client, since it is}
03548 \textcolor{comment}{         * referenced in the client blocking context, and must be valid}
03549 \textcolor{comment}{         * when calling unblockClient(). */}
03550         zfree(bc);
03551 
03552         \textcolor{comment}{/* Lock again before to iterate the loop. */}
03553         pthread\_mutex\_lock(&moduleUnblockedClientsMutex);
03554     \}
03555     pthread\_mutex\_unlock(&moduleUnblockedClientsMutex);
03556 \}
03557 
03558 \textcolor{comment}{/* Called when our client timed out. After this function unblockClient()}
03559 \textcolor{comment}{ * is called, and it will invalidate the blocked client. So this function}
03560 \textcolor{comment}{ * does not need to do any cleanup. Eventually the module will call the}
03561 \textcolor{comment}{ * API to unblock the client and the memory will be released. */}
03562 \textcolor{keywordtype}{void} moduleBlockedClientTimedOut(\hyperlink{structclient}{client} *c) \{
03563     RedisModuleBlockedClient *bc = c->bpop.module\_blocked\_handle;
03564     RedisModuleCtx ctx = \hyperlink{module_8c_a7a80fb134c35b70c7cfe920ea1033bcd}{REDISMODULE\_CTX\_INIT};
03565     ctx.flags |= \hyperlink{module_8c_a28ea3db0137452d6b6cc025eefe28be7}{REDISMODULE\_CTX\_BLOCKED\_TIMEOUT};
03566     ctx.module = bc->module;
03567     ctx.client = bc->client;
03568     bc->timeout\_callback(&ctx,(\textcolor{keywordtype}{void}**)c->argv,c->argc);
03569     moduleFreeContext(&ctx);
03570 \}
03571 
03572 \textcolor{comment}{/* Return non-zero if a module command was called in order to fill the}
03573 \textcolor{comment}{ * reply for a blocked client. */}
03574 \textcolor{keywordtype}{int} RM\_IsBlockedReplyRequest(RedisModuleCtx *ctx) \{
03575     \textcolor{keywordflow}{return} (ctx->flags & \hyperlink{module_8c_a06323cb111581e0b8848943a08639a87}{REDISMODULE\_CTX\_BLOCKED\_REPLY}) != 0;
03576 \}
03577 
03578 \textcolor{comment}{/* Return non-zero if a module command was called in order to fill the}
03579 \textcolor{comment}{ * reply for a blocked client that timed out. */}
03580 \textcolor{keywordtype}{int} RM\_IsBlockedTimeoutRequest(RedisModuleCtx *ctx) \{
03581     \textcolor{keywordflow}{return} (ctx->flags & \hyperlink{module_8c_a28ea3db0137452d6b6cc025eefe28be7}{REDISMODULE\_CTX\_BLOCKED\_TIMEOUT}) != 0;
03582 \}
03583 
03584 \textcolor{comment}{/* Get the privata data set by RedisModule\_UnblockClient() */}
03585 \textcolor{keywordtype}{void} *RM\_GetBlockedClientPrivateData(RedisModuleCtx *ctx) \{
03586     \textcolor{keywordflow}{return} ctx->blocked\_privdata;
03587 \}
03588 
03589 \textcolor{comment}{/* --------------------------------------------------------------------------}
03590 \textcolor{comment}{ * Thread Safe Contexts}
03591 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
03592 
03593 \textcolor{comment}{/* Return a context which can be used inside threads to make Redis context}
03594 \textcolor{comment}{ * calls with certain modules APIs. If 'bc' is not NULL then the module will}
03595 \textcolor{comment}{ * be bound to a blocked client, and it will be possible to use the}
03596 \textcolor{comment}{ * `RedisModule\_Reply*` family of functions to accumulate a reply for when the}
03597 \textcolor{comment}{ * client will be unblocked. Otherwise the thread safe context will be}
03598 \textcolor{comment}{ * detached by a specific client.}
03599 \textcolor{comment}{ *}
03600 \textcolor{comment}{ * To call non-reply APIs, the thread safe context must be prepared with:}
03601 \textcolor{comment}{ *}
03602 \textcolor{comment}{ *     RedisModule\_ThreadSafeCallStart(ctx);}
03603 \textcolor{comment}{ *     ... make your call here ...}
03604 \textcolor{comment}{ *     RedisModule\_ThreadSafeCallStop(ctx);}
03605 \textcolor{comment}{ *}
03606 \textcolor{comment}{ * This is not needed when using `RedisModule\_Reply*` functions, assuming}
03607 \textcolor{comment}{ * that a blocked client was used when the context was created, otherwise}
03608 \textcolor{comment}{ * no RedisModule\_Reply* call should be made at all.}
03609 \textcolor{comment}{ *}
03610 \textcolor{comment}{ * TODO: thread safe contexts do not inherit the blocked client}
03611 \textcolor{comment}{ * selected database. */}
03612 RedisModuleCtx *RM\_GetThreadSafeContext(RedisModuleBlockedClient *bc) \{
03613     RedisModuleCtx *ctx = zmalloc(\textcolor{keyword}{sizeof}(*ctx));
03614     RedisModuleCtx empty = \hyperlink{module_8c_a7a80fb134c35b70c7cfe920ea1033bcd}{REDISMODULE\_CTX\_INIT};
03615     memcpy(ctx,&empty,\textcolor{keyword}{sizeof}(empty));
03616     \textcolor{keywordflow}{if} (bc) \{
03617         ctx->blocked\_client = bc;
03618         ctx->module = bc->module;
03619     \}
03620     ctx->flags |= \hyperlink{module_8c_a884fbd2b3a1b008f1635afaeb87ca52a}{REDISMODULE\_CTX\_THREAD\_SAFE};
03621     \textcolor{comment}{/* Even when the context is associated with a blocked client, we can't}
03622 \textcolor{comment}{     * access it safely from another thread, so we create a fake client here}
03623 \textcolor{comment}{     * in order to keep things like the currently selected database and similar}
03624 \textcolor{comment}{     * things. */}
03625     ctx->client = createClient(-1);
03626     \textcolor{keywordflow}{if} (bc) selectDb(ctx->client,bc->dbid);
03627     \textcolor{keywordflow}{return} ctx;
03628 \}
03629 
03630 \textcolor{comment}{/* Release a thread safe context. */}
03631 \textcolor{keywordtype}{void} RM\_FreeThreadSafeContext(RedisModuleCtx *ctx) \{
03632     moduleFreeContext(ctx);
03633     zfree(ctx);
03634 \}
03635 
03636 \textcolor{comment}{/* Acquire the server lock before executing a thread safe API call.}
03637 \textcolor{comment}{ * This is not needed for `RedisModule\_Reply*` calls when there is}
03638 \textcolor{comment}{ * a blocked client connected to the thread safe context. */}
03639 \textcolor{keywordtype}{void} RM\_ThreadSafeContextLock(RedisModuleCtx *ctx) \{
03640     \hyperlink{dict_8h_aa077e877a37a7dc65056290a2c9760da}{DICT\_NOTUSED}(ctx);
03641     moduleAcquireGIL();
03642 \}
03643 
03644 \textcolor{comment}{/* Release the server lock after a thread safe API call was executed. */}
03645 \textcolor{keywordtype}{void} RM\_ThreadSafeContextUnlock(RedisModuleCtx *ctx) \{
03646     \hyperlink{dict_8h_aa077e877a37a7dc65056290a2c9760da}{DICT\_NOTUSED}(ctx);
03647     moduleReleaseGIL();
03648 \}
03649 
03650 \textcolor{keywordtype}{void} moduleAcquireGIL(\textcolor{keywordtype}{void}) \{
03651     pthread\_mutex\_lock(&moduleGIL);
03652 \}
03653 
03654 \textcolor{keywordtype}{void} moduleReleaseGIL(\textcolor{keywordtype}{void}) \{
03655     pthread\_mutex\_unlock(&moduleGIL);
03656 \}
03657 
03658 \textcolor{comment}{/* --------------------------------------------------------------------------}
03659 \textcolor{comment}{ * Modules API internals}
03660 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
03661 
03662 \textcolor{comment}{/* server.moduleapi dictionary type. Only uses plain C strings since}
03663 \textcolor{comment}{ * this gets queries from modules. */}
03664 
03665 uint64\_t dictCStringKeyHash(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *key) \{
03666     \textcolor{keywordflow}{return} dictGenHashFunction((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)key, strlen((\textcolor{keywordtype}{char}*)key));
03667 \}
03668 
03669 \textcolor{keywordtype}{int} dictCStringKeyCompare(\textcolor{keywordtype}{void} *privdata, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key1, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key2) \{
03670     \hyperlink{dict_8h_aa077e877a37a7dc65056290a2c9760da}{DICT\_NOTUSED}(privdata);
03671     \textcolor{keywordflow}{return} strcmp(key1,key2) == 0;
03672 \}
03673 
03674 dictType moduleAPIDictType = \{
03675     dictCStringKeyHash,        \textcolor{comment}{/* hash function */}
03676     NULL,                      \textcolor{comment}{/* key dup */}
03677     NULL,                      \textcolor{comment}{/* val dup */}
03678     dictCStringKeyCompare,     \textcolor{comment}{/* key compare */}
03679     NULL,                      \textcolor{comment}{/* key destructor */}
03680     NULL                       \textcolor{comment}{/* val destructor */}
03681 \};
03682 
03683 \textcolor{keywordtype}{int} moduleRegisterApi(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *funcname, \textcolor{keywordtype}{void} *funcptr) \{
03684     \textcolor{keywordflow}{return} dictAdd(server.moduleapi, (\textcolor{keywordtype}{char}*)funcname, funcptr);
03685 \}
03686 
03687 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REGISTER\_API}\textcolor{preprocessor}{(}\textcolor{preprocessor}{name}\textcolor{preprocessor}{)}
03688     \textcolor{preprocessor}{moduleRegisterApi}\textcolor{preprocessor}{(}\textcolor{stringliteral}{"RedisModule\_"} \textcolor{preprocessor}{#}\textcolor{preprocessor}{name}\textcolor{preprocessor}{,} \textcolor{preprocessor}{(}\textcolor{keywordtype}{void} \textcolor{preprocessor}{*}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}\textcolor{preprocessor}{)}\textcolor{preprocessor}{RM\_} \textcolor{preprocessor}{##} \textcolor{preprocessor}{name}\textcolor{preprocessor}{)}
03689 
03690 \textcolor{comment}{/* Global initialization at Redis startup. */}
03691 \textcolor{keywordtype}{void} moduleRegisterCoreAPI(\textcolor{keywordtype}{void});
03692 
03693 \textcolor{keywordtype}{void} moduleInitModulesSystem(\textcolor{keywordtype}{void}) \{
03694     moduleUnblockedClients = listCreate();
03695 
03696     server.loadmodule\_queue = listCreate();
03697     modules = dictCreate(&modulesDictType,NULL);
03698     moduleRegisterCoreAPI();
03699     \textcolor{keywordflow}{if} (pipe(server.module\_blocked\_pipe) == -1) \{
03700         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
03701             \textcolor{stringliteral}{"Can't create the pipe for module blocking commands: %s"},
03702             strerror(errno));
03703         exit(1);
03704     \}
03705     \textcolor{comment}{/* Make the pipe non blocking. This is just a best effort aware mechanism}
03706 \textcolor{comment}{     * and we do not want to block not in the read nor in the write half. */}
03707     anetNonBlock(NULL,server.module\_blocked\_pipe[0]);
03708     anetNonBlock(NULL,server.module\_blocked\_pipe[1]);
03709 
03710     \textcolor{comment}{/* Our thread-safe contexts GIL must start with already locked:}
03711 \textcolor{comment}{     * it is just unlocked when it's safe. */}
03712     pthread\_mutex\_lock(&moduleGIL);
03713 \}
03714 
03715 \textcolor{comment}{/* Load all the modules in the server.loadmodule\_queue list, which is}
03716 \textcolor{comment}{ * populated by `loadmodule` directives in the configuration file.}
03717 \textcolor{comment}{ * We can't load modules directly when processing the configuration file}
03718 \textcolor{comment}{ * because the server must be fully initialized before loading modules.}
03719 \textcolor{comment}{ *}
03720 \textcolor{comment}{ * The function aborts the server on errors, since to start with missing}
03721 \textcolor{comment}{ * modules is not considered sane: clients may rely on the existance of}
03722 \textcolor{comment}{ * given commands, loading AOF also may need some modules to exist, and}
03723 \textcolor{comment}{ * if this instance is a slave, it must understand commands from master. */}
03724 \textcolor{keywordtype}{void} moduleLoadFromQueue(\textcolor{keywordtype}{void}) \{
03725     listIter li;
03726     listNode *ln;
03727 
03728     listRewind(server.loadmodule\_queue,&li);
03729     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
03730         \textcolor{keyword}{struct} \hyperlink{structmoduleLoadQueueEntry}{moduleLoadQueueEntry} *loadmod = ln->value;
03731         \textcolor{keywordflow}{if} (moduleLoad(loadmod->path,(\textcolor{keywordtype}{void} **)loadmod->argv,loadmod->argc)
03732             == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR})
03733         \{
03734             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
03735                 \textcolor{stringliteral}{"Can't load module from %s: server aborting"},
03736                 loadmod->path);
03737             exit(1);
03738         \}
03739     \}
03740 \}
03741 
03742 \textcolor{keywordtype}{void} moduleFreeModuleStructure(\textcolor{keyword}{struct} \hyperlink{structRedisModule}{RedisModule} *module) \{
03743     listRelease(module->types);
03744     sdsfree(module->name);
03745     zfree(module);
03746 \}
03747 
03748 \textcolor{keywordtype}{void} moduleUnregisterCommands(\textcolor{keyword}{struct} \hyperlink{structRedisModule}{RedisModule} *module) \{
03749     \textcolor{comment}{/* Unregister all the commands registered by this module. */}
03750     dictIterator *di = dictGetSafeIterator(server.commands);
03751     dictEntry *de;
03752     \textcolor{keywordflow}{while} ((de = dictNext(di)) != NULL) \{
03753         \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
03754         \textcolor{keywordflow}{if} (cmd->proc == RedisModuleCommandDispatcher) \{
03755             RedisModuleCommandProxy *cp =
03756                 (\textcolor{keywordtype}{void}*)(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})cmd->getkeys\_proc;
03757             sds cmdname = cp->rediscmd->name;
03758             \textcolor{keywordflow}{if} (cp->module == module) \{
03759                 dictDelete(server.commands,cmdname);
03760                 dictDelete(server.orig\_commands,cmdname);
03761                 sdsfree(cmdname);
03762                 zfree(cp->rediscmd);
03763                 zfree(cp);
03764             \}
03765         \}
03766     \}
03767     dictReleaseIterator(di);
03768 \}
03769 
03770 \textcolor{comment}{/* Load a module and initialize it. On success C\_OK is returned, otherwise}
03771 \textcolor{comment}{ * C\_ERR is returned. */}
03772 \textcolor{keywordtype}{int} moduleLoad(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *path, \textcolor{keywordtype}{void} **module\_argv, \textcolor{keywordtype}{int} module\_argc) \{
03773     \textcolor{keywordtype}{int} (*onload)(\textcolor{keywordtype}{void} *, \textcolor{keywordtype}{void} **, \textcolor{keywordtype}{int});
03774     \textcolor{keywordtype}{void} *handle;
03775     RedisModuleCtx ctx = \hyperlink{module_8c_a7a80fb134c35b70c7cfe920ea1033bcd}{REDISMODULE\_CTX\_INIT};
03776 
03777     handle = dlopen(path,RTLD\_NOW|RTLD\_LOCAL);
03778     \textcolor{keywordflow}{if} (handle == NULL) \{
03779         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"Module %s failed to load: %s"}, path, dlerror());
03780         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
03781     \}
03782     onload = (\textcolor{keywordtype}{int} (*)(\textcolor{keywordtype}{void} *, \textcolor{keywordtype}{void} **, \textcolor{keywordtype}{int}))(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}) dlsym(handle,\textcolor{stringliteral}{"RedisModule\_OnLoad"});
03783     \textcolor{keywordflow}{if} (onload == NULL) \{
03784         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
03785             \textcolor{stringliteral}{"Module %s does not export RedisModule\_OnLoad() "}
03786             \textcolor{stringliteral}{"symbol. Module not loaded."},path);
03787         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
03788     \}
03789     \textcolor{keywordflow}{if} (onload((\textcolor{keywordtype}{void}*)&ctx,module\_argv,module\_argc) == \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR}) \{
03790         \textcolor{keywordflow}{if} (ctx.module) \{
03791             moduleUnregisterCommands(ctx.module);
03792             moduleFreeModuleStructure(ctx.module);
03793         \}
03794         dlclose(handle);
03795         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
03796             \textcolor{stringliteral}{"Module %s initialization failed. Module not loaded"},path);
03797         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
03798     \}
03799 
03800     \textcolor{comment}{/* Redis module loaded! Register it. */}
03801     dictAdd(modules,ctx.module->name,ctx.module);
03802     ctx.module->handle = handle;
03803     serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Module '%s' loaded from %s"},ctx.module->name,path);
03804     moduleFreeContext(&ctx);
03805     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
03806 \}
03807 
03808 \textcolor{comment}{/* Unload the module registered with the specified name. On success}
03809 \textcolor{comment}{ * C\_OK is returned, otherwise C\_ERR is returned and errno is set}
03810 \textcolor{comment}{ * to the following values depending on the type of error:}
03811 \textcolor{comment}{ *}
03812 \textcolor{comment}{ * * ENONET: No such module having the specified name.}
03813 \textcolor{comment}{ * * EBUSY: The module exports a new data type and can only be reloaded. */}
03814 \textcolor{keywordtype}{int} moduleUnload(sds name) \{
03815     \textcolor{keyword}{struct} \hyperlink{structRedisModule}{RedisModule} *module = dictFetchValue(modules,name);
03816 
03817     \textcolor{keywordflow}{if} (module == NULL) \{
03818         errno = ENOENT;
03819         \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
03820     \}
03821 
03822     \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(module->types)) \{
03823         errno = EBUSY;
03824         \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a3df6f5bd5247289e66f44437a7cddd49}{REDISMODULE\_ERR};
03825     \}
03826 
03827     moduleUnregisterCommands(module);
03828 
03829     \textcolor{comment}{/* Unregister all the hooks. TODO: Yet no hooks support here. */}
03830 
03831     \textcolor{comment}{/* Unload the dynamic library. */}
03832     \textcolor{keywordflow}{if} (dlclose(module->handle) == -1) \{
03833         \textcolor{keywordtype}{char} *error = dlerror();
03834         \textcolor{keywordflow}{if} (error == NULL) error = \textcolor{stringliteral}{"Unknown error"};
03835         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Error when trying to close the %s module: %s"},
03836             module->name, error);
03837     \}
03838 
03839     \textcolor{comment}{/* Remove from list of modules. */}
03840     serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Module %s unloaded"},module->name);
03841     dictDelete(modules,module->name);
03842     module->name = NULL; \textcolor{comment}{/* The name was already freed by dictDelete(). */}
03843     moduleFreeModuleStructure(module);
03844 
03845     \textcolor{keywordflow}{return} \hyperlink{redismodule_8h_a1bc5bfd69abcd378ff52c640adc5418d}{REDISMODULE\_OK};
03846 \}
03847 
03848 \textcolor{comment}{/* Redis MODULE command.}
03849 \textcolor{comment}{ *}
03850 \textcolor{comment}{ * MODULE LOAD <path> [args...] */}
03851 \textcolor{keywordtype}{void} moduleCommand(\hyperlink{structclient}{client} *c) \{
03852     \textcolor{keywordtype}{char} *subcmd = c->argv[1]->ptr;
03853 
03854     \textcolor{keywordflow}{if} (!strcasecmp(subcmd,\textcolor{stringliteral}{"load"}) && c->argc >= 3) \{
03855         robj **argv = NULL;
03856         \textcolor{keywordtype}{int} argc = 0;
03857 
03858         \textcolor{keywordflow}{if} (c->argc > 3) \{
03859             argc = c->argc - 3;
03860             argv = &c->argv[3];
03861         \}
03862 
03863         \textcolor{keywordflow}{if} (moduleLoad(c->argv[2]->ptr,(\textcolor{keywordtype}{void} **)argv,argc) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
03864             addReply(c,shared.ok);
03865         \textcolor{keywordflow}{else}
03866             addReplyError(c,
03867                 \textcolor{stringliteral}{"Error loading the extension. Please check the server logs."});
03868     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(subcmd,\textcolor{stringliteral}{"unload"}) && c->argc == 3) \{
03869         \textcolor{keywordflow}{if} (moduleUnload(c->argv[2]->ptr) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
03870             addReply(c,shared.ok);
03871         \textcolor{keywordflow}{else} \{
03872             \textcolor{keywordtype}{char} *errmsg;
03873             \textcolor{keywordflow}{switch}(errno) \{
03874             \textcolor{keywordflow}{case} ENOENT:
03875                 errmsg = \textcolor{stringliteral}{"no such module with that name"};
03876                 \textcolor{keywordflow}{break};
03877             \textcolor{keywordflow}{case} EBUSY:
03878                 errmsg = \textcolor{stringliteral}{"the module exports one or more module-side data types, can't unload"};
03879                 \textcolor{keywordflow}{break};
03880             \textcolor{keywordflow}{default}:
03881                 errmsg = \textcolor{stringliteral}{"operation not possible."};
03882                 \textcolor{keywordflow}{break};
03883             \}
03884             addReplyErrorFormat(c,\textcolor{stringliteral}{"Error unloading module: %s"},errmsg);
03885         \}
03886     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(subcmd,\textcolor{stringliteral}{"list"}) && c->argc == 2) \{
03887         dictIterator *di = dictGetIterator(modules);
03888         dictEntry *de;
03889 
03890         addReplyMultiBulkLen(c,\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(modules));
03891         \textcolor{keywordflow}{while} ((de = dictNext(di)) != NULL) \{
03892             sds name = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
03893             \textcolor{keyword}{struct} \hyperlink{structRedisModule}{RedisModule} *module = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
03894             addReplyMultiBulkLen(c,4);
03895             addReplyBulkCString(c,\textcolor{stringliteral}{"name"});
03896             addReplyBulkCBuffer(c,name,sdslen(name));
03897             addReplyBulkCString(c,\textcolor{stringliteral}{"ver"});
03898             addReplyLongLong(c,module->ver);
03899         \}
03900         dictReleaseIterator(di);
03901     \} \textcolor{keywordflow}{else} \{
03902         addReply(c,shared.syntaxerr);
03903     \}
03904 \}
03905 
03906 \textcolor{comment}{/* Return the number of registered modules. */}
03907 size\_t moduleCount(\textcolor{keywordtype}{void}) \{
03908     \textcolor{keywordflow}{return} \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(modules);
03909 \}
03910 
03911 \textcolor{comment}{/* Register all the APIs we export. Keep this function at the end of the}
03912 \textcolor{comment}{ * file so that's easy to seek it to add new entries. */}
03913 \textcolor{keywordtype}{void} moduleRegisterCoreAPI(\textcolor{keywordtype}{void}) \{
03914     server.moduleapi = dictCreate(&moduleAPIDictType,NULL);
03915     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(Alloc);
03916     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(Calloc);
03917     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(Realloc);
03918     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(Free);
03919     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(Strdup);
03920     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(CreateCommand);
03921     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(SetModuleAttribs);
03922     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(IsModuleNameBusy);
03923     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(WrongArity);
03924     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ReplyWithLongLong);
03925     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ReplyWithError);
03926     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ReplyWithSimpleString);
03927     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ReplyWithArray);
03928     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ReplySetArrayLength);
03929     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ReplyWithString);
03930     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ReplyWithStringBuffer);
03931     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ReplyWithNull);
03932     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ReplyWithCallReply);
03933     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ReplyWithDouble);
03934     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(GetSelectedDb);
03935     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(SelectDb);
03936     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(OpenKey);
03937     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(CloseKey);
03938     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(KeyType);
03939     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ValueLength);
03940     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ListPush);
03941     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ListPop);
03942     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(StringToLongLong);
03943     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(StringToDouble);
03944     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(Call);
03945     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(CallReplyProto);
03946     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(FreeCallReply);
03947     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(CallReplyInteger);
03948     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(CallReplyType);
03949     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(CallReplyLength);
03950     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(CallReplyArrayElement);
03951     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(CallReplyStringPtr);
03952     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(CreateStringFromCallReply);
03953     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(CreateString);
03954     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(CreateStringFromLongLong);
03955     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(CreateStringFromString);
03956     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(CreateStringPrintf);
03957     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(FreeString);
03958     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(StringPtrLen);
03959     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(AutoMemory);
03960     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(Replicate);
03961     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ReplicateVerbatim);
03962     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(DeleteKey);
03963     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(StringSet);
03964     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(StringDMA);
03965     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(StringTruncate);
03966     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(SetExpire);
03967     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(GetExpire);
03968     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ZsetAdd);
03969     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ZsetIncrby);
03970     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ZsetScore);
03971     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ZsetRem);
03972     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ZsetRangeStop);
03973     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ZsetFirstInScoreRange);
03974     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ZsetLastInScoreRange);
03975     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ZsetFirstInLexRange);
03976     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ZsetLastInLexRange);
03977     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ZsetRangeCurrentElement);
03978     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ZsetRangeNext);
03979     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ZsetRangePrev);
03980     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ZsetRangeEndReached);
03981     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(HashSet);
03982     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(HashGet);
03983     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(IsKeysPositionRequest);
03984     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(KeyAtPos);
03985     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(GetClientId);
03986     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(GetContextFlags);
03987     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(PoolAlloc);
03988     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(CreateDataType);
03989     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ModuleTypeSetValue);
03990     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ModuleTypeGetType);
03991     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ModuleTypeGetValue);
03992     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(SaveUnsigned);
03993     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(LoadUnsigned);
03994     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(SaveSigned);
03995     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(LoadSigned);
03996     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(SaveString);
03997     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(SaveStringBuffer);
03998     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(LoadString);
03999     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(LoadStringBuffer);
04000     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(SaveDouble);
04001     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(LoadDouble);
04002     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(SaveFloat);
04003     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(LoadFloat);
04004     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(EmitAOF);
04005     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(Log);
04006     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(LogIOError);
04007     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(StringAppendBuffer);
04008     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(RetainString);
04009     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(StringCompare);
04010     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(GetContextFromIO);
04011     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(BlockClient);
04012     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(UnblockClient);
04013     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(IsBlockedReplyRequest);
04014     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(IsBlockedTimeoutRequest);
04015     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(GetBlockedClientPrivateData);
04016     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(AbortBlock);
04017     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(Milliseconds);
04018     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(GetThreadSafeContext);
04019     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(FreeThreadSafeContext);
04020     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ThreadSafeContextLock);
04021     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(ThreadSafeContextUnlock);
04022     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(DigestAddStringBuffer);
04023     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(DigestAddLongLong);
04024     \hyperlink{module_8c_a38783dad7766982759c7d417a8ab9211}{REGISTER\_API}(DigestEndSequence);
04025 \}
\end{DoxyCode}
