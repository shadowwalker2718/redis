\hypertarget{t__hash_8c_source}{}\section{t\+\_\+hash.\+c}
\label{t__hash_8c_source}\index{src/t\+\_\+hash.\+c@{src/t\+\_\+hash.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>}
00003 \textcolor{comment}{ * All rights reserved.}
00004 \textcolor{comment}{ *}
00005 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00006 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00007 \textcolor{comment}{ *}
00008 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00009 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00010 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00011 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00012 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00013 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00014 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00015 \textcolor{comment}{ *     specific prior written permission.}
00016 \textcolor{comment}{ *}
00017 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00018 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00019 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00020 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00021 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00022 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00023 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00024 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00025 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00026 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00027 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00028 \textcolor{comment}{ */}
00029 
00030 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{server_8h}{"server.h"}
00031 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{math}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00032 
00033 \textcolor{comment}{/*-----------------------------------------------------------------------------}
00034 \textcolor{comment}{ * Hash type API}
00035 \textcolor{comment}{ *----------------------------------------------------------------------------*/}
00036 
00037 \textcolor{comment}{/* Check the length of a number of objects to see if we need to convert a}
00038 \textcolor{comment}{ * ziplist to a real hash. Note that we only check string encoded objects}
00039 \textcolor{comment}{ * as their string length can be queried in constant time. */}
00040 \textcolor{keywordtype}{void} hashTypeTryConversion(robj *o, robj **argv, \textcolor{keywordtype}{int} start, \textcolor{keywordtype}{int} end) \{
00041     \textcolor{keywordtype}{int} i;
00042 
00043     \textcolor{keywordflow}{if} (o->encoding != \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \textcolor{keywordflow}{return};
00044 
00045     \textcolor{keywordflow}{for} (i = start; i <= end; i++) \{
00046         \textcolor{keywordflow}{if} (\hyperlink{server_8h_afcfb5bd97af52d1dbce331745cae030c}{sdsEncodedObject}(argv[i]) &&
00047             sdslen(argv[i]->ptr) > server.hash\_max\_ziplist\_value)
00048         \{
00049             hashTypeConvert(o, \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT});
00050             \textcolor{keywordflow}{break};
00051         \}
00052     \}
00053 \}
00054 
00055 \textcolor{comment}{/* Get the value from a ziplist encoded hash, identified by field.}
00056 \textcolor{comment}{ * Returns -1 when the field cannot be found. */}
00057 \textcolor{keywordtype}{int} hashTypeGetFromZiplist(robj *o, sds field,
00058                            \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **vstr,
00059                            \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *vlen,
00060                            \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} *vll)
00061 \{
00062     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, *fptr = NULL, *vptr = NULL;
00063     \textcolor{keywordtype}{int} ret;
00064 
00065     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(o->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST});
00066 
00067     zl = o->ptr;
00068     fptr = ziplistIndex(zl, \hyperlink{ziplist_8h_a88d32e547c509220e1c50cd9306186ba}{ZIPLIST\_HEAD});
00069     \textcolor{keywordflow}{if} (fptr != NULL) \{
00070         fptr = ziplistFind(fptr, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)field, sdslen(field), 1);
00071         \textcolor{keywordflow}{if} (fptr != NULL) \{
00072             \textcolor{comment}{/* Grab pointer to the value (fptr points to the field) */}
00073             vptr = ziplistNext(zl, fptr);
00074             \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(vptr != NULL);
00075         \}
00076     \}
00077 
00078     \textcolor{keywordflow}{if} (vptr != NULL) \{
00079         ret = ziplistGet(vptr, vstr, vlen, vll);
00080         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(ret);
00081         \textcolor{keywordflow}{return} 0;
00082     \}
00083 
00084     \textcolor{keywordflow}{return} -1;
00085 \}
00086 
00087 \textcolor{comment}{/* Get the value from a hash table encoded hash, identified by field.}
00088 \textcolor{comment}{ * Returns NULL when the field cannot be found, otherwise the SDS value}
00089 \textcolor{comment}{ * is returned. */}
00090 sds hashTypeGetFromHashTable(robj *o, sds field) \{
00091     dictEntry *de;
00092 
00093     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(o->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT});
00094 
00095     de = dictFind(o->ptr, field);
00096     \textcolor{keywordflow}{if} (de == NULL) \textcolor{keywordflow}{return} NULL;
00097     \textcolor{keywordflow}{return} \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
00098 \}
00099 
00100 \textcolor{comment}{/* Higher level function of hashTypeGet*() that returns the hash value}
00101 \textcolor{comment}{ * associated with the specified field. If the field is found C\_OK}
00102 \textcolor{comment}{ * is returned, otherwise C\_ERR. The returned object is returned by}
00103 \textcolor{comment}{ * reference in either *vstr and *vlen if it's returned in string form,}
00104 \textcolor{comment}{ * or stored in *vll if it's returned as a number.}
00105 \textcolor{comment}{ *}
00106 \textcolor{comment}{ * If *vll is populated *vstr is set to NULL, so the caller}
00107 \textcolor{comment}{ * can always check the function return by checking the return value}
00108 \textcolor{comment}{ * for C\_OK and checking if vll (or vstr) is NULL. */}
00109 \textcolor{keywordtype}{int} hashTypeGetValue(robj *o, sds field, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **vstr, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *vlen, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} *vll) \{
00110     \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
00111         *vstr = NULL;
00112         \textcolor{keywordflow}{if} (hashTypeGetFromZiplist(o, field, vstr, vlen, vll) == 0)
00113             \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00114     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00115         sds value;
00116         \textcolor{keywordflow}{if} ((value = hashTypeGetFromHashTable(o, field)) != NULL) \{
00117             *vstr = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) value;
00118             *vlen = sdslen(value);
00119             \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00120         \}
00121     \} \textcolor{keywordflow}{else} \{
00122         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown hash encoding"});
00123     \}
00124     \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00125 \}
00126 
00127 \textcolor{comment}{/* Like hashTypeGetValue() but returns a Redis object, which is useful for}
00128 \textcolor{comment}{ * interaction with the hash type outside t\_hash.c.}
00129 \textcolor{comment}{ * The function returns NULL if the field is not found in the hash. Otherwise}
00130 \textcolor{comment}{ * a newly allocated string object with the value is returned. */}
00131 robj *hashTypeGetValueObject(robj *o, sds field) \{
00132     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr;
00133     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen;
00134     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} vll;
00135 
00136     \textcolor{keywordflow}{if} (hashTypeGetValue(o,field,&vstr,&vlen,&vll) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \textcolor{keywordflow}{return} NULL;
00137     \textcolor{keywordflow}{if} (vstr) \textcolor{keywordflow}{return} createStringObject((\textcolor{keywordtype}{char}*)vstr,vlen);
00138     \textcolor{keywordflow}{else} \textcolor{keywordflow}{return} createStringObjectFromLongLong(vll);
00139 \}
00140 
00141 \textcolor{comment}{/* Higher level function using hashTypeGet*() to return the length of the}
00142 \textcolor{comment}{ * object associated with the requested field, or 0 if the field does not}
00143 \textcolor{comment}{ * exist. */}
00144 size\_t hashTypeGetValueLength(robj *o, sds field) \{
00145     size\_t len = 0;
00146     \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
00147         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr = NULL;
00148         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen = UINT\_MAX;
00149         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} vll = LLONG\_MAX;
00150 
00151         \textcolor{keywordflow}{if} (hashTypeGetFromZiplist(o, field, &vstr, &vlen, &vll) == 0)
00152             len = vstr ? vlen : sdigits10(vll);
00153     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00154         sds aux;
00155 
00156         \textcolor{keywordflow}{if} ((aux = hashTypeGetFromHashTable(o, field)) != NULL)
00157             len = sdslen(aux);
00158     \} \textcolor{keywordflow}{else} \{
00159         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown hash encoding"});
00160     \}
00161     \textcolor{keywordflow}{return} len;
00162 \}
00163 
00164 \textcolor{comment}{/* Test if the specified field exists in the given hash. Returns 1 if the field}
00165 \textcolor{comment}{ * exists, and 0 when it doesn't. */}
00166 \textcolor{keywordtype}{int} hashTypeExists(robj *o, sds field) \{
00167     \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
00168         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr = NULL;
00169         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen = UINT\_MAX;
00170         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} vll = LLONG\_MAX;
00171 
00172         \textcolor{keywordflow}{if} (hashTypeGetFromZiplist(o, field, &vstr, &vlen, &vll) == 0) \textcolor{keywordflow}{return} 1;
00173     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00174         \textcolor{keywordflow}{if} (hashTypeGetFromHashTable(o, field) != NULL) \textcolor{keywordflow}{return} 1;
00175     \} \textcolor{keywordflow}{else} \{
00176         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown hash encoding"});
00177     \}
00178     \textcolor{keywordflow}{return} 0;
00179 \}
00180 
00181 \textcolor{comment}{/* Add a new field, overwrite the old with the new value if it already exists.}
00182 \textcolor{comment}{ * Return 0 on insert and 1 on update.}
00183 \textcolor{comment}{ *}
00184 \textcolor{comment}{ * By default, the key and value SDS strings are copied if needed, so the}
00185 \textcolor{comment}{ * caller retains ownership of the strings passed. However this behavior}
00186 \textcolor{comment}{ * can be effected by passing appropriate flags (possibly bitwise OR-ed):}
00187 \textcolor{comment}{ *}
00188 \textcolor{comment}{ * HASH\_SET\_TAKE\_FIELD -- The SDS field ownership passes to the function.}
00189 \textcolor{comment}{ * HASH\_SET\_TAKE\_VALUE -- The SDS value ownership passes to the function.}
00190 \textcolor{comment}{ *}
00191 \textcolor{comment}{ * When the flags are used the caller does not need to release the passed}
00192 \textcolor{comment}{ * SDS string(s). It's up to the function to use the string to create a new}
00193 \textcolor{comment}{ * entry or to free the SDS string before returning to the caller.}
00194 \textcolor{comment}{ *}
00195 \textcolor{comment}{ * HASH\_SET\_COPY corresponds to no flags passed, and means the default}
00196 \textcolor{comment}{ * semantics of copying the values if needed.}
00197 \textcolor{comment}{ *}
00198 \textcolor{comment}{ */}
00199 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{HASH\_SET\_TAKE\_FIELD} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)}
00200 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{HASH\_SET\_TAKE\_VALUE} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}1\textcolor{preprocessor}{)}
00201 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{HASH\_SET\_COPY} 0
00202 \textcolor{keywordtype}{int} hashTypeSet(robj *o, sds field, sds value, \textcolor{keywordtype}{int} flags) \{
00203     \textcolor{keywordtype}{int} update = 0;
00204 
00205     \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
00206         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, *fptr, *vptr;
00207 
00208         zl = o->ptr;
00209         fptr = ziplistIndex(zl, \hyperlink{ziplist_8h_a88d32e547c509220e1c50cd9306186ba}{ZIPLIST\_HEAD});
00210         \textcolor{keywordflow}{if} (fptr != NULL) \{
00211             fptr = ziplistFind(fptr, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)field, sdslen(field), 1);
00212             \textcolor{keywordflow}{if} (fptr != NULL) \{
00213                 \textcolor{comment}{/* Grab pointer to the value (fptr points to the field) */}
00214                 vptr = ziplistNext(zl, fptr);
00215                 \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(vptr != NULL);
00216                 update = 1;
00217 
00218                 \textcolor{comment}{/* Delete value */}
00219                 zl = ziplistDelete(zl, &vptr);
00220 
00221                 \textcolor{comment}{/* Insert new value */}
00222                 zl = ziplistInsert(zl, vptr, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)value,
00223                         sdslen(value));
00224             \}
00225         \}
00226 
00227         \textcolor{keywordflow}{if} (!update) \{
00228             \textcolor{comment}{/* Push new field/value pair onto the tail of the ziplist */}
00229             zl = ziplistPush(zl, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)field, sdslen(field),
00230                     \hyperlink{ziplist_8h_a25d058a2c2c0db0f131f84d23ede6ba2}{ZIPLIST\_TAIL});
00231             zl = ziplistPush(zl, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)value, sdslen(value),
00232                     \hyperlink{ziplist_8h_a25d058a2c2c0db0f131f84d23ede6ba2}{ZIPLIST\_TAIL});
00233         \}
00234         o->ptr = zl;
00235 
00236         \textcolor{comment}{/* Check if the ziplist needs to be converted to a hash table */}
00237         \textcolor{keywordflow}{if} (hashTypeLength(o) > server.hash\_max\_ziplist\_entries)
00238             hashTypeConvert(o, \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT});
00239     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00240         dictEntry *de = dictFind(o->ptr,field);
00241         \textcolor{keywordflow}{if} (de) \{
00242             sdsfree(\hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de));
00243             \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_a6835ddf42816b819b74a677170d6f304}{HASH\_SET\_TAKE\_VALUE}) \{
00244                 \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de) = value;
00245                 value = NULL;
00246             \} \textcolor{keywordflow}{else} \{
00247                 \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de) = sdsdup(value);
00248             \}
00249             update = 1;
00250         \} \textcolor{keywordflow}{else} \{
00251             sds f,v;
00252             \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_a9c13f8e0e439bfde94687cb01ab81b4b}{HASH\_SET\_TAKE\_FIELD}) \{
00253                 f = field;
00254                 field = NULL;
00255             \} \textcolor{keywordflow}{else} \{
00256                 f = sdsdup(field);
00257             \}
00258             \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_a6835ddf42816b819b74a677170d6f304}{HASH\_SET\_TAKE\_VALUE}) \{
00259                 v = value;
00260                 value = NULL;
00261             \} \textcolor{keywordflow}{else} \{
00262                 v = sdsdup(value);
00263             \}
00264             dictAdd(o->ptr,f,v);
00265         \}
00266     \} \textcolor{keywordflow}{else} \{
00267         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown hash encoding"});
00268     \}
00269 
00270     \textcolor{comment}{/* Free SDS strings we did not referenced elsewhere if the flags}
00271 \textcolor{comment}{     * want this function to be responsible. */}
00272     \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_a9c13f8e0e439bfde94687cb01ab81b4b}{HASH\_SET\_TAKE\_FIELD} && field) sdsfree(field);
00273     \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_a6835ddf42816b819b74a677170d6f304}{HASH\_SET\_TAKE\_VALUE} && value) sdsfree(value);
00274     \textcolor{keywordflow}{return} update;
00275 \}
00276 
00277 \textcolor{comment}{/* Delete an element from a hash.}
00278 \textcolor{comment}{ * Return 1 on deleted and 0 on not found. */}
00279 \textcolor{keywordtype}{int} hashTypeDelete(robj *o, sds field) \{
00280     \textcolor{keywordtype}{int} deleted = 0;
00281 
00282     \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
00283         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, *fptr;
00284 
00285         zl = o->ptr;
00286         fptr = ziplistIndex(zl, \hyperlink{ziplist_8h_a88d32e547c509220e1c50cd9306186ba}{ZIPLIST\_HEAD});
00287         \textcolor{keywordflow}{if} (fptr != NULL) \{
00288             fptr = ziplistFind(fptr, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)field, sdslen(field), 1);
00289             \textcolor{keywordflow}{if} (fptr != NULL) \{
00290                 zl = ziplistDelete(zl,&fptr); \textcolor{comment}{/* Delete the key. */}
00291                 zl = ziplistDelete(zl,&fptr); \textcolor{comment}{/* Delete the value. */}
00292                 o->ptr = zl;
00293                 deleted = 1;
00294             \}
00295         \}
00296     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00297         \textcolor{keywordflow}{if} (dictDelete((dict*)o->ptr, field) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
00298             deleted = 1;
00299 
00300             \textcolor{comment}{/* Always check if the dictionary needs a resize after a delete. */}
00301             \textcolor{keywordflow}{if} (htNeedsResize(o->ptr)) dictResize(o->ptr);
00302         \}
00303 
00304     \} \textcolor{keywordflow}{else} \{
00305         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown hash encoding"});
00306     \}
00307     \textcolor{keywordflow}{return} deleted;
00308 \}
00309 
00310 \textcolor{comment}{/* Return the number of elements in a hash. */}
00311 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} hashTypeLength(\textcolor{keyword}{const} robj *o) \{
00312     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} length = ULONG\_MAX;
00313 
00314     \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
00315         length = ziplistLen(o->ptr) / 2;
00316     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00317         length = \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}((\textcolor{keyword}{const} dict*)o->ptr);
00318     \} \textcolor{keywordflow}{else} \{
00319         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown hash encoding"});
00320     \}
00321     \textcolor{keywordflow}{return} length;
00322 \}
00323 
00324 hashTypeIterator *hashTypeInitIterator(robj *subject) \{
00325     hashTypeIterator *hi = zmalloc(\textcolor{keyword}{sizeof}(hashTypeIterator));
00326     hi->subject = subject;
00327     hi->encoding = subject->encoding;
00328 
00329     \textcolor{keywordflow}{if} (hi->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
00330         hi->fptr = NULL;
00331         hi->vptr = NULL;
00332     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (hi->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00333         hi->di = dictGetIterator(subject->ptr);
00334     \} \textcolor{keywordflow}{else} \{
00335         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown hash encoding"});
00336     \}
00337     \textcolor{keywordflow}{return} hi;
00338 \}
00339 
00340 \textcolor{keywordtype}{void} hashTypeReleaseIterator(hashTypeIterator *hi) \{
00341     \textcolor{keywordflow}{if} (hi->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT})
00342         dictReleaseIterator(hi->di);
00343     zfree(hi);
00344 \}
00345 
00346 \textcolor{comment}{/* Move to the next entry in the hash. Return C\_OK when the next entry}
00347 \textcolor{comment}{ * could be found and C\_ERR when the iterator reaches the end. */}
00348 \textcolor{keywordtype}{int} hashTypeNext(hashTypeIterator *hi) \{
00349     \textcolor{keywordflow}{if} (hi->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
00350         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl;
00351         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *fptr, *vptr;
00352 
00353         zl = hi->subject->ptr;
00354         fptr = hi->fptr;
00355         vptr = hi->vptr;
00356 
00357         \textcolor{keywordflow}{if} (fptr == NULL) \{
00358             \textcolor{comment}{/* Initialize cursor */}
00359             \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(vptr == NULL);
00360             fptr = ziplistIndex(zl, 0);
00361         \} \textcolor{keywordflow}{else} \{
00362             \textcolor{comment}{/* Advance cursor */}
00363             \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(vptr != NULL);
00364             fptr = ziplistNext(zl, vptr);
00365         \}
00366         \textcolor{keywordflow}{if} (fptr == NULL) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00367 
00368         \textcolor{comment}{/* Grab pointer to the value (fptr points to the field) */}
00369         vptr = ziplistNext(zl, fptr);
00370         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(vptr != NULL);
00371 
00372         \textcolor{comment}{/* fptr, vptr now point to the first or next pair */}
00373         hi->fptr = fptr;
00374         hi->vptr = vptr;
00375     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (hi->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00376         \textcolor{keywordflow}{if} ((hi->de = dictNext(hi->di)) == NULL) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00377     \} \textcolor{keywordflow}{else} \{
00378         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown hash encoding"});
00379     \}
00380     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00381 \}
00382 
00383 \textcolor{comment}{/* Get the field or value at iterator cursor, for an iterator on a hash value}
00384 \textcolor{comment}{ * encoded as a ziplist. Prototype is similar to `hashTypeGetFromZiplist`. */}
00385 \textcolor{keywordtype}{void} hashTypeCurrentFromZiplist(hashTypeIterator *hi, \textcolor{keywordtype}{int} what,
00386                                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **vstr,
00387                                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *vlen,
00388                                 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} *vll)
00389 \{
00390     \textcolor{keywordtype}{int} ret;
00391 
00392     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(hi->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST});
00393 
00394     \textcolor{keywordflow}{if} (what & \hyperlink{server_8h_aede46b2a96d6f19aff38ccdac76598ac}{OBJ\_HASH\_KEY}) \{
00395         ret = ziplistGet(hi->fptr, vstr, vlen, vll);
00396         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(ret);
00397     \} \textcolor{keywordflow}{else} \{
00398         ret = ziplistGet(hi->vptr, vstr, vlen, vll);
00399         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(ret);
00400     \}
00401 \}
00402 
00403 \textcolor{comment}{/* Get the field or value at iterator cursor, for an iterator on a hash value}
00404 \textcolor{comment}{ * encoded as a hash table. Prototype is similar to}
00405 \textcolor{comment}{ * `hashTypeGetFromHashTable`. */}
00406 sds hashTypeCurrentFromHashTable(hashTypeIterator *hi, \textcolor{keywordtype}{int} what) \{
00407     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(hi->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT});
00408 
00409     \textcolor{keywordflow}{if} (what & \hyperlink{server_8h_aede46b2a96d6f19aff38ccdac76598ac}{OBJ\_HASH\_KEY}) \{
00410         \textcolor{keywordflow}{return} \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(hi->de);
00411     \} \textcolor{keywordflow}{else} \{
00412         \textcolor{keywordflow}{return} \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(hi->de);
00413     \}
00414 \}
00415 
00416 \textcolor{comment}{/* Higher level function of hashTypeCurrent*() that returns the hash value}
00417 \textcolor{comment}{ * at current iterator position.}
00418 \textcolor{comment}{ *}
00419 \textcolor{comment}{ * The returned element is returned by reference in either *vstr and *vlen if}
00420 \textcolor{comment}{ * it's returned in string form, or stored in *vll if it's returned as}
00421 \textcolor{comment}{ * a number.}
00422 \textcolor{comment}{ *}
00423 \textcolor{comment}{ * If *vll is populated *vstr is set to NULL, so the caller}
00424 \textcolor{comment}{ * can always check the function return by checking the return value}
00425 \textcolor{comment}{ * type checking if vstr == NULL. */}
00426 \textcolor{keywordtype}{void} hashTypeCurrentObject(hashTypeIterator *hi, \textcolor{keywordtype}{int} what, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **vstr, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *vlen, \textcolor{keywordtype}{
      long} \textcolor{keywordtype}{long} *vll) \{
00427     \textcolor{keywordflow}{if} (hi->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
00428         *vstr = NULL;
00429         hashTypeCurrentFromZiplist(hi, what, vstr, vlen, vll);
00430     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (hi->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00431         sds ele = hashTypeCurrentFromHashTable(hi, what);
00432         *vstr = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*) ele;
00433         *vlen = sdslen(ele);
00434     \} \textcolor{keywordflow}{else} \{
00435         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown hash encoding"});
00436     \}
00437 \}
00438 
00439 \textcolor{comment}{/* Return the key or value at the current iterator position as a new}
00440 \textcolor{comment}{ * SDS string. */}
00441 sds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, \textcolor{keywordtype}{int} what) \{
00442     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr;
00443     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen;
00444     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} vll;
00445 
00446     hashTypeCurrentObject(hi,what,&vstr,&vlen,&vll);
00447     \textcolor{keywordflow}{if} (vstr) \textcolor{keywordflow}{return} sdsnewlen(vstr,vlen);
00448     \textcolor{keywordflow}{return} sdsfromlonglong(vll);
00449 \}
00450 
00451 robj *hashTypeLookupWriteOrCreate(\hyperlink{structclient}{client} *c, robj *key) \{
00452     robj *o = lookupKeyWrite(c->db,key);
00453     \textcolor{keywordflow}{if} (o == NULL) \{
00454         o = createHashObject();
00455         dbAdd(c->db,key,o);
00456     \} \textcolor{keywordflow}{else} \{
00457         \textcolor{keywordflow}{if} (o->type != \hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH}) \{
00458             addReply(c,shared.wrongtypeerr);
00459             \textcolor{keywordflow}{return} NULL;
00460         \}
00461     \}
00462     \textcolor{keywordflow}{return} o;
00463 \}
00464 
00465 \textcolor{keywordtype}{void} hashTypeConvertZiplist(robj *o, \textcolor{keywordtype}{int} enc) \{
00466     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(o->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST});
00467 
00468     \textcolor{keywordflow}{if} (enc == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
00469         \textcolor{comment}{/* Nothing to do... */}
00470 
00471     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (enc == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00472         hashTypeIterator *hi;
00473         dict *dict;
00474         \textcolor{keywordtype}{int} ret;
00475 
00476         hi = hashTypeInitIterator(o);
00477         dict = dictCreate(&hashDictType, NULL);
00478 
00479         \textcolor{keywordflow}{while} (hashTypeNext(hi) != \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
00480             sds key, value;
00481 
00482             key = hashTypeCurrentObjectNewSds(hi,\hyperlink{server_8h_aede46b2a96d6f19aff38ccdac76598ac}{OBJ\_HASH\_KEY});
00483             value = hashTypeCurrentObjectNewSds(hi,\hyperlink{server_8h_a1f87a280688b29cd45aa3aa0dceac7c7}{OBJ\_HASH\_VALUE});
00484             ret = dictAdd(dict, key, value);
00485             \textcolor{keywordflow}{if} (ret != \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK}) \{
00486                 serverLogHexDump(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"ziplist with dup elements dump"},
00487                     o->ptr,ziplistBlobLen(o->ptr));
00488                 \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Ziplist corruption detected"});
00489             \}
00490         \}
00491         hashTypeReleaseIterator(hi);
00492         zfree(o->ptr);
00493         o->encoding = \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT};
00494         o->ptr = dict;
00495     \} \textcolor{keywordflow}{else} \{
00496         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown hash encoding"});
00497     \}
00498 \}
00499 
00500 \textcolor{keywordtype}{void} hashTypeConvert(robj *o, \textcolor{keywordtype}{int} enc) \{
00501     \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
00502         hashTypeConvertZiplist(o, enc);
00503     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00504         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Not implemented"});
00505     \} \textcolor{keywordflow}{else} \{
00506         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown hash encoding"});
00507     \}
00508 \}
00509 
00510 \textcolor{comment}{/*-----------------------------------------------------------------------------}
00511 \textcolor{comment}{ * Hash type commands}
00512 \textcolor{comment}{ *----------------------------------------------------------------------------*/}
00513 
00514 \textcolor{keywordtype}{void} hsetnxCommand(\hyperlink{structclient}{client} *c) \{
00515     robj *o;
00516     \textcolor{keywordflow}{if} ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) \textcolor{keywordflow}{return};
00517     hashTypeTryConversion(o,c->argv,2,3);
00518 
00519     \textcolor{keywordflow}{if} (hashTypeExists(o, c->argv[2]->ptr)) \{
00520         addReply(c, shared.czero);
00521     \} \textcolor{keywordflow}{else} \{
00522         hashTypeSet(o,c->argv[2]->ptr,c->argv[3]->ptr,\hyperlink{server_8h_ad182dd9d0a3945ad3fb4045e559b612e}{HASH\_SET\_COPY});
00523         addReply(c, shared.cone);
00524         signalModifiedKey(c->db,c->argv[1]);
00525         notifyKeyspaceEvent(\hyperlink{server_8h_afe25ae13417e6fa5011e7efc69a34bc0}{NOTIFY\_HASH},\textcolor{stringliteral}{"hset"},c->argv[1],c->db->id);
00526         server.dirty++;
00527     \}
00528 \}
00529 
00530 \textcolor{keywordtype}{void} hsetCommand(\hyperlink{structclient}{client} *c) \{
00531     \textcolor{keywordtype}{int} i, created = 0;
00532     robj *o;
00533 
00534     \textcolor{keywordflow}{if} ((c->argc % 2) == 1) \{
00535         addReplyError(c,\textcolor{stringliteral}{"wrong number of arguments for HMSET"});
00536         \textcolor{keywordflow}{return};
00537     \}
00538 
00539     \textcolor{keywordflow}{if} ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) \textcolor{keywordflow}{return};
00540     hashTypeTryConversion(o,c->argv,2,c->argc-1);
00541 
00542     \textcolor{keywordflow}{for} (i = 2; i < c->argc; i += 2)
00543         created += !hashTypeSet(o,c->argv[i]->ptr,c->argv[i+1]->ptr,
      \hyperlink{server_8h_ad182dd9d0a3945ad3fb4045e559b612e}{HASH\_SET\_COPY});
00544 
00545     \textcolor{comment}{/* HMSET (deprecated) and HSET return value is different. */}
00546     \textcolor{keywordtype}{char} *cmdname = c->argv[0]->ptr;
00547     \textcolor{keywordflow}{if} (cmdname[1] == \textcolor{stringliteral}{'s'} || cmdname[1] == \textcolor{stringliteral}{'S'}) \{
00548         \textcolor{comment}{/* HSET */}
00549         addReplyLongLong(c, created);
00550     \} \textcolor{keywordflow}{else} \{
00551         \textcolor{comment}{/* HMSET */}
00552         addReply(c, shared.ok);
00553     \}
00554     signalModifiedKey(c->db,c->argv[1]);
00555     notifyKeyspaceEvent(\hyperlink{server_8h_afe25ae13417e6fa5011e7efc69a34bc0}{NOTIFY\_HASH},\textcolor{stringliteral}{"hset"},c->argv[1],c->db->id);
00556     server.dirty++;
00557 \}
00558 
00559 \textcolor{keywordtype}{void} hincrbyCommand(\hyperlink{structclient}{client} *c) \{
00560     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value, incr, oldvalue;
00561     robj *o;
00562     sds \textcolor{keyword}{new};
00563     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr;
00564     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen;
00565 
00566     \textcolor{keywordflow}{if} (getLongLongFromObjectOrReply(c,c->argv[3],&incr,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \textcolor{keywordflow}{return};
00567     \textcolor{keywordflow}{if} ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) \textcolor{keywordflow}{return};
00568     \textcolor{keywordflow}{if} (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&value) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
00569         \textcolor{keywordflow}{if} (vstr) \{
00570             \textcolor{keywordflow}{if} (string2ll((\textcolor{keywordtype}{char}*)vstr,vlen,&value) == 0) \{
00571                 addReplyError(c,\textcolor{stringliteral}{"hash value is not an integer"});
00572                 \textcolor{keywordflow}{return};
00573             \}
00574         \} \textcolor{comment}{/* Else hashTypeGetValue() already stored it into &value */}
00575     \} \textcolor{keywordflow}{else} \{
00576         value = 0;
00577     \}
00578 
00579     oldvalue = value;
00580     \textcolor{keywordflow}{if} ((incr < 0 && oldvalue < 0 && incr < (LLONG\_MIN-oldvalue)) ||
00581         (incr > 0 && oldvalue > 0 && incr > (LLONG\_MAX-oldvalue))) \{
00582         addReplyError(c,\textcolor{stringliteral}{"increment or decrement would overflow"});
00583         \textcolor{keywordflow}{return};
00584     \}
00585     value += incr;
00586     \textcolor{keyword}{new} = sdsfromlonglong(value);
00587     hashTypeSet(o,c->argv[2]->ptr,\textcolor{keyword}{new},\hyperlink{server_8h_a6835ddf42816b819b74a677170d6f304}{HASH\_SET\_TAKE\_VALUE});
00588     addReplyLongLong(c,value);
00589     signalModifiedKey(c->db,c->argv[1]);
00590     notifyKeyspaceEvent(\hyperlink{server_8h_afe25ae13417e6fa5011e7efc69a34bc0}{NOTIFY\_HASH},\textcolor{stringliteral}{"hincrby"},c->argv[1],c->db->id);
00591     server.dirty++;
00592 \}
00593 
00594 \textcolor{keywordtype}{void} hincrbyfloatCommand(\hyperlink{structclient}{client} *c) \{
00595     \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} value, incr;
00596     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ll;
00597     robj *o;
00598     sds \textcolor{keyword}{new};
00599     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr;
00600     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen;
00601 
00602     \textcolor{keywordflow}{if} (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \textcolor{keywordflow}{return};
00603     \textcolor{keywordflow}{if} ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) \textcolor{keywordflow}{return};
00604     \textcolor{keywordflow}{if} (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
00605         \textcolor{keywordflow}{if} (vstr) \{
00606             \textcolor{keywordflow}{if} (string2ld((\textcolor{keywordtype}{char}*)vstr,vlen,&value) == 0) \{
00607                 addReplyError(c,\textcolor{stringliteral}{"hash value is not a float"});
00608                 \textcolor{keywordflow}{return};
00609             \}
00610         \} \textcolor{keywordflow}{else} \{
00611             value = (\textcolor{keywordtype}{long} \textcolor{keywordtype}{double})ll;
00612         \}
00613     \} \textcolor{keywordflow}{else} \{
00614         value = 0;
00615     \}
00616 
00617     value += incr;
00618 
00619     \textcolor{keywordtype}{char} buf[256];
00620     \textcolor{keywordtype}{int} len = ld2string(buf,\textcolor{keyword}{sizeof}(buf),value,1);
00621     \textcolor{keyword}{new} = sdsnewlen(buf,len);
00622     hashTypeSet(o,c->argv[2]->ptr,\textcolor{keyword}{new},\hyperlink{server_8h_a6835ddf42816b819b74a677170d6f304}{HASH\_SET\_TAKE\_VALUE});
00623     addReplyBulkCBuffer(c,buf,len);
00624     signalModifiedKey(c->db,c->argv[1]);
00625     notifyKeyspaceEvent(\hyperlink{server_8h_afe25ae13417e6fa5011e7efc69a34bc0}{NOTIFY\_HASH},\textcolor{stringliteral}{"hincrbyfloat"},c->argv[1],c->db->id);
00626     server.dirty++;
00627 
00628     \textcolor{comment}{/* Always replicate HINCRBYFLOAT as an HSET command with the final value}
00629 \textcolor{comment}{     * in order to make sure that differences in float pricision or formatting}
00630 \textcolor{comment}{     * will not create differences in replicas or after an AOF restart. */}
00631     robj *aux, *newobj;
00632     aux = createStringObject(\textcolor{stringliteral}{"HSET"},4);
00633     newobj = createRawStringObject(buf,len);
00634     rewriteClientCommandArgument(c,0,aux);
00635     decrRefCount(aux);
00636     rewriteClientCommandArgument(c,3,newobj);
00637     decrRefCount(newobj);
00638 \}
00639 
00640 \textcolor{keyword}{static} \textcolor{keywordtype}{void} addHashFieldToReply(\hyperlink{structclient}{client} *c, robj *o, sds field) \{
00641     \textcolor{keywordtype}{int} ret;
00642 
00643     \textcolor{keywordflow}{if} (o == NULL) \{
00644         addReply(c, shared.nullbulk);
00645         \textcolor{keywordflow}{return};
00646     \}
00647 
00648     \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
00649         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr = NULL;
00650         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen = UINT\_MAX;
00651         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} vll = LLONG\_MAX;
00652 
00653         ret = hashTypeGetFromZiplist(o, field, &vstr, &vlen, &vll);
00654         \textcolor{keywordflow}{if} (ret < 0) \{
00655             addReply(c, shared.nullbulk);
00656         \} \textcolor{keywordflow}{else} \{
00657             \textcolor{keywordflow}{if} (vstr) \{
00658                 addReplyBulkCBuffer(c, vstr, vlen);
00659             \} \textcolor{keywordflow}{else} \{
00660                 addReplyBulkLongLong(c, vll);
00661             \}
00662         \}
00663 
00664     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00665         sds value = hashTypeGetFromHashTable(o, field);
00666         \textcolor{keywordflow}{if} (value == NULL)
00667             addReply(c, shared.nullbulk);
00668         \textcolor{keywordflow}{else}
00669             addReplyBulkCBuffer(c, value, sdslen(value));
00670     \} \textcolor{keywordflow}{else} \{
00671         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown hash encoding"});
00672     \}
00673 \}
00674 
00675 \textcolor{keywordtype}{void} hgetCommand(\hyperlink{structclient}{client} *c) \{
00676     robj *o;
00677 
00678     \textcolor{keywordflow}{if} ((o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
00679         checkType(c,o,\hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH})) \textcolor{keywordflow}{return};
00680 
00681     addHashFieldToReply(c, o, c->argv[2]->ptr);
00682 \}
00683 
00684 \textcolor{keywordtype}{void} hmgetCommand(\hyperlink{structclient}{client} *c) \{
00685     robj *o;
00686     \textcolor{keywordtype}{int} i;
00687 
00688     \textcolor{comment}{/* Don't abort when the key cannot be found. Non-existing keys are empty}
00689 \textcolor{comment}{     * hashes, where HMGET should respond with a series of null bulks. */}
00690     o = lookupKeyRead(c->db, c->argv[1]);
00691     \textcolor{keywordflow}{if} (o != NULL && o->type != \hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH}) \{
00692         addReply(c, shared.wrongtypeerr);
00693         \textcolor{keywordflow}{return};
00694     \}
00695 
00696     addReplyMultiBulkLen(c, c->argc-2);
00697     \textcolor{keywordflow}{for} (i = 2; i < c->argc; i++) \{
00698         addHashFieldToReply(c, o, c->argv[i]->ptr);
00699     \}
00700 \}
00701 
00702 \textcolor{keywordtype}{void} hdelCommand(\hyperlink{structclient}{client} *c) \{
00703     robj *o;
00704     \textcolor{keywordtype}{int} j, deleted = 0, keyremoved = 0;
00705 
00706     \textcolor{keywordflow}{if} ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
00707         checkType(c,o,\hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH})) \textcolor{keywordflow}{return};
00708 
00709     \textcolor{keywordflow}{for} (j = 2; j < c->argc; j++) \{
00710         \textcolor{keywordflow}{if} (hashTypeDelete(o,c->argv[j]->ptr)) \{
00711             deleted++;
00712             \textcolor{keywordflow}{if} (hashTypeLength(o) == 0) \{
00713                 dbDelete(c->db,c->argv[1]);
00714                 keyremoved = 1;
00715                 \textcolor{keywordflow}{break};
00716             \}
00717         \}
00718     \}
00719     \textcolor{keywordflow}{if} (deleted) \{
00720         signalModifiedKey(c->db,c->argv[1]);
00721         notifyKeyspaceEvent(\hyperlink{server_8h_afe25ae13417e6fa5011e7efc69a34bc0}{NOTIFY\_HASH},\textcolor{stringliteral}{"hdel"},c->argv[1],c->db->id);
00722         \textcolor{keywordflow}{if} (keyremoved)
00723             notifyKeyspaceEvent(\hyperlink{server_8h_a9fa53dd1068e62365f3964ad3479eec2}{NOTIFY\_GENERIC},\textcolor{stringliteral}{"del"},c->argv[1],
00724                                 c->db->id);
00725         server.dirty += deleted;
00726     \}
00727     addReplyLongLong(c,deleted);
00728 \}
00729 
00730 \textcolor{keywordtype}{void} hlenCommand(\hyperlink{structclient}{client} *c) \{
00731     robj *o;
00732 
00733     \textcolor{keywordflow}{if} ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
00734         checkType(c,o,\hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH})) \textcolor{keywordflow}{return};
00735 
00736     addReplyLongLong(c,hashTypeLength(o));
00737 \}
00738 
00739 \textcolor{keywordtype}{void} hstrlenCommand(\hyperlink{structclient}{client} *c) \{
00740     robj *o;
00741 
00742     \textcolor{keywordflow}{if} ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
00743         checkType(c,o,\hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH})) \textcolor{keywordflow}{return};
00744     addReplyLongLong(c,hashTypeGetValueLength(o,c->argv[2]->ptr));
00745 \}
00746 
00747 \textcolor{keyword}{static} \textcolor{keywordtype}{void} addHashIteratorCursorToReply(\hyperlink{structclient}{client} *c, hashTypeIterator *hi, \textcolor{keywordtype}{int} what) \{
00748     \textcolor{keywordflow}{if} (hi->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
00749         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr = NULL;
00750         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen = UINT\_MAX;
00751         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} vll = LLONG\_MAX;
00752 
00753         hashTypeCurrentFromZiplist(hi, what, &vstr, &vlen, &vll);
00754         \textcolor{keywordflow}{if} (vstr)
00755             addReplyBulkCBuffer(c, vstr, vlen);
00756         \textcolor{keywordflow}{else}
00757             addReplyBulkLongLong(c, vll);
00758     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (hi->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00759         sds value = hashTypeCurrentFromHashTable(hi, what);
00760         addReplyBulkCBuffer(c, value, sdslen(value));
00761     \} \textcolor{keywordflow}{else} \{
00762         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown hash encoding"});
00763     \}
00764 \}
00765 
00766 \textcolor{keywordtype}{void} genericHgetallCommand(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} flags) \{
00767     robj *o;
00768     hashTypeIterator *hi;
00769     \textcolor{keywordtype}{int} multiplier = 0;
00770     \textcolor{keywordtype}{int} length, count = 0;
00771 
00772     \textcolor{keywordflow}{if} ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk)) == NULL
00773         || checkType(c,o,\hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH})) \textcolor{keywordflow}{return};
00774 
00775     \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_aede46b2a96d6f19aff38ccdac76598ac}{OBJ\_HASH\_KEY}) multiplier++;
00776     \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_a1f87a280688b29cd45aa3aa0dceac7c7}{OBJ\_HASH\_VALUE}) multiplier++;
00777 
00778     length = hashTypeLength(o) * multiplier;
00779     addReplyMultiBulkLen(c, length);
00780 
00781     hi = hashTypeInitIterator(o);
00782     \textcolor{keywordflow}{while} (hashTypeNext(hi) != \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
00783         \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_aede46b2a96d6f19aff38ccdac76598ac}{OBJ\_HASH\_KEY}) \{
00784             addHashIteratorCursorToReply(c, hi, \hyperlink{server_8h_aede46b2a96d6f19aff38ccdac76598ac}{OBJ\_HASH\_KEY});
00785             count++;
00786         \}
00787         \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_a1f87a280688b29cd45aa3aa0dceac7c7}{OBJ\_HASH\_VALUE}) \{
00788             addHashIteratorCursorToReply(c, hi, \hyperlink{server_8h_a1f87a280688b29cd45aa3aa0dceac7c7}{OBJ\_HASH\_VALUE});
00789             count++;
00790         \}
00791     \}
00792 
00793     hashTypeReleaseIterator(hi);
00794     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(count == length);
00795 \}
00796 
00797 \textcolor{keywordtype}{void} hkeysCommand(\hyperlink{structclient}{client} *c) \{
00798     genericHgetallCommand(c,\hyperlink{server_8h_aede46b2a96d6f19aff38ccdac76598ac}{OBJ\_HASH\_KEY});
00799 \}
00800 
00801 \textcolor{keywordtype}{void} hvalsCommand(\hyperlink{structclient}{client} *c) \{
00802     genericHgetallCommand(c,\hyperlink{server_8h_a1f87a280688b29cd45aa3aa0dceac7c7}{OBJ\_HASH\_VALUE});
00803 \}
00804 
00805 \textcolor{keywordtype}{void} hgetallCommand(\hyperlink{structclient}{client} *c) \{
00806     genericHgetallCommand(c,\hyperlink{server_8h_aede46b2a96d6f19aff38ccdac76598ac}{OBJ\_HASH\_KEY}|\hyperlink{server_8h_a1f87a280688b29cd45aa3aa0dceac7c7}{OBJ\_HASH\_VALUE});
00807 \}
00808 
00809 \textcolor{keywordtype}{void} hexistsCommand(\hyperlink{structclient}{client} *c) \{
00810     robj *o;
00811     \textcolor{keywordflow}{if} ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
00812         checkType(c,o,\hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH})) \textcolor{keywordflow}{return};
00813 
00814     addReply(c, hashTypeExists(o,c->argv[2]->ptr) ? shared.cone : shared.czero);
00815 \}
00816 
00817 \textcolor{keywordtype}{void} hscanCommand(\hyperlink{structclient}{client} *c) \{
00818     robj *o;
00819     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} cursor;
00820 
00821     \textcolor{keywordflow}{if} (parseScanCursorOrReply(c,c->argv[2],&cursor) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \textcolor{keywordflow}{return};
00822     \textcolor{keywordflow}{if} ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
00823         checkType(c,o,\hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH})) \textcolor{keywordflow}{return};
00824     scanGenericCommand(c,o,cursor);
00825 \}
\end{DoxyCode}
