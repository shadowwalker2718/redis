\hypertarget{latency_8c_source}{}\section{latency.\+c}
\label{latency_8c_source}\index{src/latency.\+c@{src/latency.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* The latency monitor allows to easily observe the sources of latency}
00002 \textcolor{comment}{ * in a Redis instance using the LATENCY command. Different latency}
00003 \textcolor{comment}{ * sources are monitored, like disk I/O, execution of commands, fork}
00004 \textcolor{comment}{ * system call, and so forth.}
00005 \textcolor{comment}{ *}
00006 \textcolor{comment}{ * ----------------------------------------------------------------------------}
00007 \textcolor{comment}{ *}
00008 \textcolor{comment}{ * Copyright (c) 2014, Salvatore Sanfilippo <antirez at gmail dot com>}
00009 \textcolor{comment}{ * All rights reserved.}
00010 \textcolor{comment}{ *}
00011 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00012 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00013 \textcolor{comment}{ *}
00014 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00015 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00016 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00017 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00018 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00019 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00020 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00021 \textcolor{comment}{ *     specific prior written permission.}
00022 \textcolor{comment}{ *}
00023 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00024 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00025 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00026 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00027 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00028 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00029 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00030 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00031 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00032 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00033 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00034 \textcolor{comment}{ */}
00035 
00036 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{server_8h}{"server.h"}
00037 
00038 \textcolor{comment}{/* Dictionary type for latency events. */}
00039 \textcolor{keywordtype}{int} dictStringKeyCompare(\textcolor{keywordtype}{void} *privdata, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key1, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key2) \{
00040     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(privdata);
00041     \textcolor{keywordflow}{return} strcmp(key1,key2) == 0;
00042 \}
00043 
00044 uint64\_t dictStringHash(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *key) \{
00045     \textcolor{keywordflow}{return} dictGenHashFunction(key, strlen(key));
00046 \}
00047 
00048 \textcolor{keywordtype}{void} dictVanillaFree(\textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{void} *val);
00049 
00050 dictType latencyTimeSeriesDictType = \{
00051     dictStringHash,             \textcolor{comment}{/* hash function */}
00052     NULL,                       \textcolor{comment}{/* key dup */}
00053     NULL,                       \textcolor{comment}{/* val dup */}
00054     dictStringKeyCompare,       \textcolor{comment}{/* key compare */}
00055     dictVanillaFree,            \textcolor{comment}{/* key destructor */}
00056     dictVanillaFree             \textcolor{comment}{/* val destructor */}
00057 \};
00058 
00059 \textcolor{comment}{/* ------------------------- Utility functions ------------------------------ */}
00060 
00061 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \_\_linux\_\_
00062 \textcolor{comment}{/* Returns 1 if Transparent Huge Pages support is enabled in the kernel.}
00063 \textcolor{comment}{ * Otherwise (or if we are unable to check) 0 is returned. */}
00064 \textcolor{keywordtype}{int} THPIsEnabled(\textcolor{keywordtype}{void}) \{
00065     \textcolor{keywordtype}{char} buf[1024];
00066 
00067     FILE *fp = fopen(\textcolor{stringliteral}{"/sys/kernel/mm/transparent\_hugepage/enabled"},\textcolor{stringliteral}{"r"});
00068     \textcolor{keywordflow}{if} (!fp) \textcolor{keywordflow}{return} 0;
00069     \textcolor{keywordflow}{if} (fgets(buf,\textcolor{keyword}{sizeof}(buf),fp) == NULL) \{
00070         fclose(fp);
00071         \textcolor{keywordflow}{return} 0;
00072     \}
00073     fclose(fp);
00074     \textcolor{keywordflow}{return} (strstr(buf,\textcolor{stringliteral}{"[never]"}) == NULL) ? 1 : 0;
00075 \}
00076 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
00077 
00078 \textcolor{comment}{/* Report the amount of AnonHugePages in smap, in bytes. If the return}
00079 \textcolor{comment}{ * value of the function is non-zero, the process is being targeted by}
00080 \textcolor{comment}{ * THP support, and is likely to have memory usage / latency issues. */}
00081 \textcolor{keywordtype}{int} THPGetAnonHugePagesSize(\textcolor{keywordtype}{void}) \{
00082     \textcolor{keywordflow}{return} zmalloc\_get\_smap\_bytes\_by\_field(\textcolor{stringliteral}{"AnonHugePages:"},-1);
00083 \}
00084 
00085 \textcolor{comment}{/* ---------------------------- Latency API --------------------------------- */}
00086 
00087 \textcolor{comment}{/* Latency monitor initialization. We just need to create the dictionary}
00088 \textcolor{comment}{ * of time series, each time serie is craeted on demand in order to avoid}
00089 \textcolor{comment}{ * having a fixed list to maintain. */}
00090 \textcolor{keywordtype}{void} latencyMonitorInit(\textcolor{keywordtype}{void}) \{
00091     server.latency\_events = dictCreate(&latencyTimeSeriesDictType,NULL);
00092 \}
00093 
00094 \textcolor{comment}{/* Add the specified sample to the specified time series "event".}
00095 \textcolor{comment}{ * This function is usually called via latencyAddSampleIfNeeded(), that}
00096 \textcolor{comment}{ * is a macro that only adds the sample if the latency is higher than}
00097 \textcolor{comment}{ * server.latency\_monitor\_threshold. */}
00098 \textcolor{keywordtype}{void} latencyAddSample(\textcolor{keywordtype}{char} *event, mstime\_t latency) \{
00099     \textcolor{keyword}{struct} \hyperlink{structlatencyTimeSeries}{latencyTimeSeries} *ts = dictFetchValue(server.latency\_events,event);
00100     time\_t now = time(NULL);
00101     \textcolor{keywordtype}{int} prev;
00102 
00103     \textcolor{comment}{/* Create the time series if it does not exist. */}
00104     \textcolor{keywordflow}{if} (ts == NULL) \{
00105         ts = zmalloc(\textcolor{keyword}{sizeof}(*ts));
00106         ts->idx = 0;
00107         ts->max = 0;
00108         memset(ts->samples,0,\textcolor{keyword}{sizeof}(ts->samples));
00109         dictAdd(server.latency\_events,zstrdup(event),ts);
00110     \}
00111 
00112     \textcolor{comment}{/* If the previous sample is in the same second, we update our old sample}
00113 \textcolor{comment}{     * if this latency is > of the old one, or just return. */}
00114     prev = (ts->idx + \hyperlink{latency_8h_a7e3ba352d9d7bb4c88c2c42c16e6674b}{LATENCY\_TS\_LEN} - 1) % \hyperlink{latency_8h_a7e3ba352d9d7bb4c88c2c42c16e6674b}{LATENCY\_TS\_LEN};
00115     \textcolor{keywordflow}{if} (ts->samples[prev].time == now) \{
00116         \textcolor{keywordflow}{if} (latency > ts->samples[prev].latency)
00117             ts->samples[prev].latency = latency;
00118         \textcolor{keywordflow}{return};
00119     \}
00120 
00121     ts->samples[ts->idx].time = time(NULL);
00122     ts->samples[ts->idx].latency = latency;
00123     \textcolor{keywordflow}{if} (latency > ts->max) ts->max = latency;
00124 
00125     ts->idx++;
00126     \textcolor{keywordflow}{if} (ts->idx == \hyperlink{latency_8h_a7e3ba352d9d7bb4c88c2c42c16e6674b}{LATENCY\_TS\_LEN}) ts->idx = 0;
00127 \}
00128 
00129 \textcolor{comment}{/* Reset data for the specified event, or all the events data if 'event' is}
00130 \textcolor{comment}{ * NULL.}
00131 \textcolor{comment}{ *}
00132 \textcolor{comment}{ * Note: this is O(N) even when event\_to\_reset is not NULL because makes}
00133 \textcolor{comment}{ * the code simpler and we have a small fixed max number of events. */}
00134 \textcolor{keywordtype}{int} latencyResetEvent(\textcolor{keywordtype}{char} *event\_to\_reset) \{
00135     dictIterator *di;
00136     dictEntry *de;
00137     \textcolor{keywordtype}{int} resets = 0;
00138 
00139     di = dictGetSafeIterator(server.latency\_events);
00140     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
00141         \textcolor{keywordtype}{char} *event = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
00142 
00143         \textcolor{keywordflow}{if} (event\_to\_reset == NULL || strcasecmp(event,event\_to\_reset) == 0) \{
00144             dictDelete(server.latency\_events, event);
00145             resets++;
00146         \}
00147     \}
00148     dictReleaseIterator(di);
00149     \textcolor{keywordflow}{return} resets;
00150 \}
00151 
00152 \textcolor{comment}{/* ------------------------ Latency reporting (doctor) ---------------------- */}
00153 
00154 \textcolor{comment}{/* Analyze the samples avaialble for a given event and return a structure}
00155 \textcolor{comment}{ * populate with different metrics, average, MAD, min, max, and so forth.}
00156 \textcolor{comment}{ * Check latency.h definition of struct latenctStat for more info.}
00157 \textcolor{comment}{ * If the specified event has no elements the structure is populate with}
00158 \textcolor{comment}{ * zero values. */}
00159 \textcolor{keywordtype}{void} analyzeLatencyForEvent(\textcolor{keywordtype}{char} *event, \textcolor{keyword}{struct} \hyperlink{structlatencyStats}{latencyStats} *ls) \{
00160     \textcolor{keyword}{struct} \hyperlink{structlatencyTimeSeries}{latencyTimeSeries} *ts = dictFetchValue(server.latency\_events,event);
00161     \textcolor{keywordtype}{int} j;
00162     uint64\_t sum;
00163 
00164     ls->all\_time\_high = ts ? ts->max : 0;
00165     ls->avg = 0;
00166     ls->min = 0;
00167     ls->max = 0;
00168     ls->mad = 0;
00169     ls->samples = 0;
00170     ls->period = 0;
00171     \textcolor{keywordflow}{if} (!ts) \textcolor{keywordflow}{return};
00172 
00173     \textcolor{comment}{/* First pass, populate everything but the MAD. */}
00174     sum = 0;
00175     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{latency_8h_a7e3ba352d9d7bb4c88c2c42c16e6674b}{LATENCY\_TS\_LEN}; j++) \{
00176         \textcolor{keywordflow}{if} (ts->samples[j].time == 0) \textcolor{keywordflow}{continue};
00177         ls->samples++;
00178         \textcolor{keywordflow}{if} (ls->samples == 1) \{
00179             ls->min = ls->max = ts->samples[j].latency;
00180         \} \textcolor{keywordflow}{else} \{
00181             \textcolor{keywordflow}{if} (ls->min > ts->samples[j].latency)
00182                 ls->min = ts->samples[j].latency;
00183             \textcolor{keywordflow}{if} (ls->max < ts->samples[j].latency)
00184                 ls->max = ts->samples[j].latency;
00185         \}
00186         sum += ts->samples[j].latency;
00187 
00188         \textcolor{comment}{/* Track the oldest event time in ls->period. */}
00189         \textcolor{keywordflow}{if} (ls->period == 0 || ts->samples[j].time < ls->period)
00190             ls->period = ts->samples[j].time;
00191     \}
00192 
00193     \textcolor{comment}{/* So far avg is actually the sum of the latencies, and period is}
00194 \textcolor{comment}{     * the oldest event time. We need to make the first an average and}
00195 \textcolor{comment}{     * the second a range of seconds. */}
00196     \textcolor{keywordflow}{if} (ls->samples) \{
00197         ls->avg = sum / ls->samples;
00198         ls->period = time(NULL) - ls->period;
00199         \textcolor{keywordflow}{if} (ls->period == 0) ls->period = 1;
00200     \}
00201 
00202     \textcolor{comment}{/* Second pass, compute MAD. */}
00203     sum = 0;
00204     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{latency_8h_a7e3ba352d9d7bb4c88c2c42c16e6674b}{LATENCY\_TS\_LEN}; j++) \{
00205         int64\_t delta;
00206 
00207         \textcolor{keywordflow}{if} (ts->samples[j].time == 0) \textcolor{keywordflow}{continue};
00208         delta = (int64\_t)ls->avg - ts->samples[j].latency;
00209         \textcolor{keywordflow}{if} (delta < 0) delta = -delta;
00210         sum += delta;
00211     \}
00212     \textcolor{keywordflow}{if} (ls->samples) ls->mad = sum / ls->samples;
00213 \}
00214 
00215 \textcolor{comment}{/* Create a human readable report of latency events for this Redis instance. */}
00216 sds createLatencyReport(\textcolor{keywordtype}{void}) \{
00217     sds report = sdsempty();
00218     \textcolor{keywordtype}{int} advise\_better\_vm = 0;       \textcolor{comment}{/* Better virtual machines. */}
00219     \textcolor{keywordtype}{int} advise\_slowlog\_enabled = 0; \textcolor{comment}{/* Enable slowlog. */}
00220     \textcolor{keywordtype}{int} advise\_slowlog\_tuning = 0;  \textcolor{comment}{/* Reconfigure slowlog. */}
00221     \textcolor{keywordtype}{int} advise\_slowlog\_inspect = 0; \textcolor{comment}{/* Check your slowlog. */}
00222     \textcolor{keywordtype}{int} advise\_disk\_contention = 0; \textcolor{comment}{/* Try to lower disk contention. */}
00223     \textcolor{keywordtype}{int} advise\_scheduler = 0;       \textcolor{comment}{/* Intrinsic latency. */}
00224     \textcolor{keywordtype}{int} advise\_data\_writeback = 0;  \textcolor{comment}{/* data=writeback. */}
00225     \textcolor{keywordtype}{int} advise\_no\_appendfsync = 0;  \textcolor{comment}{/* don't fsync during rewrites. */}
00226     \textcolor{keywordtype}{int} advise\_local\_disk = 0;      \textcolor{comment}{/* Avoid remote disks. */}
00227     \textcolor{keywordtype}{int} advise\_ssd = 0;             \textcolor{comment}{/* Use an SSD drive. */}
00228     \textcolor{keywordtype}{int} advise\_write\_load\_info = 0; \textcolor{comment}{/* Print info about AOF and write load. */}
00229     \textcolor{keywordtype}{int} advise\_hz = 0;              \textcolor{comment}{/* Use higher HZ. */}
00230     \textcolor{keywordtype}{int} advise\_large\_objects = 0;   \textcolor{comment}{/* Deletion of large objects. */}
00231     \textcolor{keywordtype}{int} advise\_mass\_eviction = 0;   \textcolor{comment}{/* Avoid mass eviction of keys. */}
00232     \textcolor{keywordtype}{int} advise\_relax\_fsync\_policy = 0; \textcolor{comment}{/* appendfsync always is slow. */}
00233     \textcolor{keywordtype}{int} advise\_disable\_thp = 0;     \textcolor{comment}{/* AnonHugePages detected. */}
00234     \textcolor{keywordtype}{int} advices = 0;
00235 
00236     \textcolor{comment}{/* Return ASAP if the latency engine is disabled and it looks like it}
00237 \textcolor{comment}{     * was never enabled so far. */}
00238     \textcolor{keywordflow}{if} (\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.latency\_events) == 0 &&
00239         server.latency\_monitor\_threshold == 0)
00240     \{
00241         report = sdscat(report,\textcolor{stringliteral}{"I'm sorry, Dave, I can't do that. Latency monitoring is disabled in
       this Redis instance. You may use \(\backslash\)"CONFIG SET latency-monitor-threshold <milliseconds>.\(\backslash\)" in order to enable
       it. If we weren't in a deep space mission I'd suggest to take a look at
       http://redis.io/topics/latency-monitor.\(\backslash\)n"});
00242         \textcolor{keywordflow}{return} report;
00243     \}
00244 
00245     \textcolor{comment}{/* Show all the events stats and add for each event some event-related}
00246 \textcolor{comment}{     * comment depending on the values. */}
00247     dictIterator *di;
00248     dictEntry *de;
00249     \textcolor{keywordtype}{int} eventnum = 0;
00250 
00251     di = dictGetSafeIterator(server.latency\_events);
00252     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
00253         \textcolor{keywordtype}{char} *event = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
00254         \textcolor{keyword}{struct} \hyperlink{structlatencyTimeSeries}{latencyTimeSeries} *ts = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
00255         \textcolor{keyword}{struct} \hyperlink{structlatencyStats}{latencyStats} ls;
00256 
00257         \textcolor{keywordflow}{if} (ts == NULL) \textcolor{keywordflow}{continue};
00258         eventnum++;
00259         \textcolor{keywordflow}{if} (eventnum == 1) \{
00260             report = sdscat(report,\textcolor{stringliteral}{"Dave, I have observed latency spikes in this Redis instance. You
       don't mind talking about it, do you Dave?\(\backslash\)n\(\backslash\)n"});
00261         \}
00262         analyzeLatencyForEvent(event,&ls);
00263 
00264         report = sdscatprintf(report,
00265             \textcolor{stringliteral}{"%d. %s: %d latency spikes (average %lums, mean deviation %lums, period %.2f sec). Worst
       all time event %lums."},
00266             eventnum, event,
00267             ls.samples,
00268             (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}) ls.avg,
00269             (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}) ls.mad,
00270             (\textcolor{keywordtype}{double}) ls.period/ls.samples,
00271             (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}) ts->max);
00272 
00273         \textcolor{comment}{/* Fork */}
00274         \textcolor{keywordflow}{if} (!strcasecmp(event,\textcolor{stringliteral}{"fork"})) \{
00275             \textcolor{keywordtype}{char} *fork\_quality;
00276             \textcolor{keywordflow}{if} (server.stat\_fork\_rate < 10) \{
00277                 fork\_quality = \textcolor{stringliteral}{"terrible"};
00278                 advise\_better\_vm = 1;
00279                 advices++;
00280             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.stat\_fork\_rate < 25) \{
00281                 fork\_quality = \textcolor{stringliteral}{"poor"};
00282                 advise\_better\_vm = 1;
00283                 advices++;
00284             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.stat\_fork\_rate < 100) \{
00285                 fork\_quality = \textcolor{stringliteral}{"good"};
00286             \} \textcolor{keywordflow}{else} \{
00287                 fork\_quality = \textcolor{stringliteral}{"excellent"};
00288             \}
00289             report = sdscatprintf(report,
00290                 \textcolor{stringliteral}{" Fork rate is %.2f GB/sec (%s)."}, server.stat\_fork\_rate,
00291                 fork\_quality);
00292         \}
00293 
00294         \textcolor{comment}{/* Potentially commands. */}
00295         \textcolor{keywordflow}{if} (!strcasecmp(event,\textcolor{stringliteral}{"command"})) \{
00296             \textcolor{keywordflow}{if} (server.slowlog\_log\_slower\_than == 0) \{
00297                 advise\_slowlog\_enabled = 1;
00298                 advices++;
00299             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.slowlog\_log\_slower\_than/1000 >
00300                        server.latency\_monitor\_threshold)
00301             \{
00302                 advise\_slowlog\_tuning = 1;
00303                 advices++;
00304             \}
00305             advise\_slowlog\_inspect = 1;
00306             advise\_large\_objects = 1;
00307             advices += 2;
00308         \}
00309 
00310         \textcolor{comment}{/* fast-command. */}
00311         \textcolor{keywordflow}{if} (!strcasecmp(event,\textcolor{stringliteral}{"fast-command"})) \{
00312             advise\_scheduler = 1;
00313             advices++;
00314         \}
00315 
00316         \textcolor{comment}{/* AOF and I/O. */}
00317         \textcolor{keywordflow}{if} (!strcasecmp(event,\textcolor{stringliteral}{"aof-write-pending-fsync"})) \{
00318             advise\_local\_disk = 1;
00319             advise\_disk\_contention = 1;
00320             advise\_ssd = 1;
00321             advise\_data\_writeback = 1;
00322             advices += 4;
00323         \}
00324 
00325         \textcolor{keywordflow}{if} (!strcasecmp(event,\textcolor{stringliteral}{"aof-write-active-child"})) \{
00326             advise\_no\_appendfsync = 1;
00327             advise\_data\_writeback = 1;
00328             advise\_ssd = 1;
00329             advices += 3;
00330         \}
00331 
00332         \textcolor{keywordflow}{if} (!strcasecmp(event,\textcolor{stringliteral}{"aof-write-alone"})) \{
00333             advise\_local\_disk = 1;
00334             advise\_data\_writeback = 1;
00335             advise\_ssd = 1;
00336             advices += 3;
00337         \}
00338 
00339         \textcolor{keywordflow}{if} (!strcasecmp(event,\textcolor{stringliteral}{"aof-fsync-always"})) \{
00340             advise\_relax\_fsync\_policy = 1;
00341             advices++;
00342         \}
00343 
00344         \textcolor{keywordflow}{if} (!strcasecmp(event,\textcolor{stringliteral}{"aof-fstat"}) ||
00345             !strcasecmp(event,\textcolor{stringliteral}{"rdb-unlik-temp-file"})) \{
00346             advise\_disk\_contention = 1;
00347             advise\_local\_disk = 1;
00348             advices += 2;
00349         \}
00350 
00351         \textcolor{keywordflow}{if} (!strcasecmp(event,\textcolor{stringliteral}{"aof-rewrite-diff-write"}) ||
00352             !strcasecmp(event,\textcolor{stringliteral}{"aof-rename"})) \{
00353             advise\_write\_load\_info = 1;
00354             advise\_data\_writeback = 1;
00355             advise\_ssd = 1;
00356             advise\_local\_disk = 1;
00357             advices += 4;
00358         \}
00359 
00360         \textcolor{comment}{/* Expire cycle. */}
00361         \textcolor{keywordflow}{if} (!strcasecmp(event,\textcolor{stringliteral}{"expire-cycle"})) \{
00362             advise\_hz = 1;
00363             advise\_large\_objects = 1;
00364             advices += 2;
00365         \}
00366 
00367         \textcolor{comment}{/* Eviction cycle. */}
00368         \textcolor{keywordflow}{if} (!strcasecmp(event,\textcolor{stringliteral}{"eviction-del"})) \{
00369             advise\_large\_objects = 1;
00370             advices++;
00371         \}
00372 
00373         \textcolor{keywordflow}{if} (!strcasecmp(event,\textcolor{stringliteral}{"eviction-cycle"})) \{
00374             advise\_mass\_eviction = 1;
00375             advices++;
00376         \}
00377 
00378         report = sdscatlen(report,\textcolor{stringliteral}{"\(\backslash\)n"},1);
00379     \}
00380     dictReleaseIterator(di);
00381 
00382     \textcolor{comment}{/* Add non event based advices. */}
00383     \textcolor{keywordflow}{if} (THPGetAnonHugePagesSize() > 0) \{
00384         advise\_disable\_thp = 1;
00385         advices++;
00386     \}
00387 
00388     \textcolor{keywordflow}{if} (eventnum == 0 && advices == 0) \{
00389         report = sdscat(report,\textcolor{stringliteral}{"Dave, no latency spike was observed during the lifetime of this Redis
       instance, not in the slightest bit. I honestly think you ought to sit down calmly, take a stress pill, and
       think things over.\(\backslash\)n"});
00390     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (eventnum > 0 && advices == 0) \{
00391         report = sdscat(report,\textcolor{stringliteral}{"\(\backslash\)nWhile there are latency events logged, I'm not able to suggest any
       easy fix. Please use the Redis community to get some help, providing this report in your help request.\(\backslash\)n"});
00392     \} \textcolor{keywordflow}{else} \{
00393         \textcolor{comment}{/* Add all the suggestions accumulated so far. */}
00394 
00395         \textcolor{comment}{/* Better VM. */}
00396         report = sdscat(report,\textcolor{stringliteral}{"\(\backslash\)nI have a few advices for you:\(\backslash\)n\(\backslash\)n"});
00397         \textcolor{keywordflow}{if} (advise\_better\_vm) \{
00398             report = sdscat(report,\textcolor{stringliteral}{"- If you are using a virtual machine, consider upgrading it with a
       faster one using an hypervisior that provides less latency during fork() calls. Xen is known to have poor
       fork() performance. Even in the context of the same VM provider, certain kinds of instances can execute fork
       faster than others.\(\backslash\)n"});
00399         \}
00400 
00401         \textcolor{comment}{/* Slow log. */}
00402         \textcolor{keywordflow}{if} (advise\_slowlog\_enabled) \{
00403             report = sdscatprintf(report,\textcolor{stringliteral}{"- There are latency issues with potentially slow commands
       you are using. Try to enable the Slow Log Redis feature using the command 'CONFIG SET slowlog-log-slower-than
       %llu'. If the Slow log is disabled Redis is not able to log slow commands execution for you.\(\backslash\)n"}, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{
      long} \textcolor{keywordtype}{long})server.latency\_monitor\_threshold*1000);
00404         \}
00405 
00406         \textcolor{keywordflow}{if} (advise\_slowlog\_tuning) \{
00407             report = sdscatprintf(report,\textcolor{stringliteral}{"- Your current Slow Log configuration only logs events that
       are slower than your configured latency monitor threshold. Please use 'CONFIG SET slowlog-log-slower-than
       %llu'.\(\backslash\)n"}, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long})server.latency\_monitor\_threshold*1000);
00408         \}
00409 
00410         \textcolor{keywordflow}{if} (advise\_slowlog\_inspect) \{
00411             report = sdscat(report,\textcolor{stringliteral}{"- Check your Slow Log to understand what are the commands you are
       running which are too slow to execute. Please check http://redis.io/commands/slowlog for more
       information.\(\backslash\)n"});
00412         \}
00413 
00414         \textcolor{comment}{/* Intrinsic latency. */}
00415         \textcolor{keywordflow}{if} (advise\_scheduler) \{
00416             report = sdscat(report,\textcolor{stringliteral}{"- The system is slow to execute Redis code paths not containing
       system calls. This usually means the system does not provide Redis CPU time to run for long periods. You
       should try to:\(\backslash\)n"}
00417             \textcolor{stringliteral}{"  1) Lower the system load.\(\backslash\)n"}
00418             \textcolor{stringliteral}{"  2) Use a computer / VM just for Redis if you are running other softawre in the same
       system.\(\backslash\)n"}
00419             \textcolor{stringliteral}{"  3) Check if you have a \(\backslash\)"noisy neighbour\(\backslash\)" problem.\(\backslash\)n"}
00420             \textcolor{stringliteral}{"  4) Check with 'redis-cli --intrinsic-latency 100' what is the intrinsic latency in your
       system.\(\backslash\)n"}
00421             \textcolor{stringliteral}{"  5) Check if the problem is allocator-related by recompiling Redis with MALLOC=libc, if
       you are using Jemalloc. However this may create fragmentation problems.\(\backslash\)n"});
00422         \}
00423 
00424         \textcolor{comment}{/* AOF / Disk latency. */}
00425         \textcolor{keywordflow}{if} (advise\_local\_disk) \{
00426             report = sdscat(report,\textcolor{stringliteral}{"- It is strongly advised to use local disks for persistence,
       especially if you are using AOF. Remote disks provided by platform-as-a-service providers are known to be
       slow.\(\backslash\)n"});
00427         \}
00428 
00429         \textcolor{keywordflow}{if} (advise\_ssd) \{
00430             report = sdscat(report,\textcolor{stringliteral}{"- SSD disks are able to reduce fsync latency, and total time
       needed for snapshotting and AOF log rewriting (resulting in smaller memory usage and smaller final AOF rewrite
       buffer flushes). With extremely high write load SSD disks can be a good option. However Redis should perform
       reasonably with high load using normal disks. Use this advice as a last resort.\(\backslash\)n"});
00431         \}
00432 
00433         \textcolor{keywordflow}{if} (advise\_data\_writeback) \{
00434             report = sdscat(report,\textcolor{stringliteral}{"- Mounting ext3/4 filesystems with data=writeback can provide a
       performance boost compared to data=ordered, however this mode of operation provides less guarantees, and
       sometimes it can happen that after a hard crash the AOF file will have an half-written command at the end and
       will require to be repaired before Redis restarts.\(\backslash\)n"});
00435         \}
00436 
00437         \textcolor{keywordflow}{if} (advise\_disk\_contention) \{
00438             report = sdscat(report,\textcolor{stringliteral}{"- Try to lower the disk contention. This is often caused by other
       disk intensive processes running in the same computer (including other Redis instances).\(\backslash\)n"});
00439         \}
00440 
00441         \textcolor{keywordflow}{if} (advise\_no\_appendfsync) \{
00442             report = sdscat(report,\textcolor{stringliteral}{"- Assuming from the point of view of data safety this is viable in
       your environment, you could try to enable the 'no-appendfsync-on-rewrite' option, so that fsync will not be
       performed while there is a child rewriting the AOF file or producing an RDB file (the moment where there is
       high disk contention).\(\backslash\)n"});
00443         \}
00444 
00445         \textcolor{keywordflow}{if} (advise\_relax\_fsync\_policy && server.\hyperlink{config_8h_af5994c643c434574580bb7816af82cad}{aof\_fsync} == 
      \hyperlink{server_8h_a83bfec10b7b4be60ec6d5868cadc73bb}{AOF\_FSYNC\_ALWAYS}) \{
00446             report = sdscat(report,\textcolor{stringliteral}{"- Your fsync policy is set to 'always'. It is very hard to get
       good performances with such a setup, if possible try to relax the fsync policy to 'onesec'.\(\backslash\)n"});
00447         \}
00448 
00449         \textcolor{keywordflow}{if} (advise\_write\_load\_info) \{
00450             report = sdscat(report,\textcolor{stringliteral}{"- Latency during the AOF atomic rename operation or when the final
       difference is flushed to the AOF file at the end of the rewrite, sometimes is caused by very high write
       load, causing the AOF buffer to get very large. If possible try to send less commands to accomplish the same
       work, or use Lua scripts to group multiple operations into a single EVALSHA call.\(\backslash\)n"});
00451         \}
00452 
00453         \textcolor{keywordflow}{if} (advise\_hz && server.hz < 100) \{
00454             report = sdscat(report,\textcolor{stringliteral}{"- In order to make the Redis keys expiring process more
       incremental, try to set the 'hz' configuration parameter to 100 using 'CONFIG SET hz 100'.\(\backslash\)n"});
00455         \}
00456 
00457         \textcolor{keywordflow}{if} (advise\_large\_objects) \{
00458             report = sdscat(report,\textcolor{stringliteral}{"- Deleting, expiring or evicting (because of maxmemory policy)
       large objects is a blocking operation. If you have very large objects that are often deleted, expired, or
       evicted, try to fragment those objects into multiple smaller objects.\(\backslash\)n"});
00459         \}
00460 
00461         \textcolor{keywordflow}{if} (advise\_mass\_eviction) \{
00462             report = sdscat(report,\textcolor{stringliteral}{"- Sudden changes to the 'maxmemory' setting via 'CONFIG SET', or
       allocation of large objects via sets or sorted sets intersections, STORE option of SORT, Redis Cluster large
       keys migrations (RESTORE command), may create sudden memory pressure forcing the server to block trying to
       evict keys. \(\backslash\)n"});
00463         \}
00464 
00465         \textcolor{keywordflow}{if} (advise\_disable\_thp) \{
00466             report = sdscat(report,\textcolor{stringliteral}{"- I detected a non zero amount of anonymous huge pages used by
       your process. This creates very serious latency events in different conditions, especially when Redis is
       persisting on disk. To disable THP support use the command 'echo never >
       /sys/kernel/mm/transparent\_hugepage/enabled', make sure to also add it into /etc/rc.local so that the command will be executed again after a reboot.
       Note that even if you have already disabled THP, you still need to restart the Redis process to get rid of
       the huge pages already created.\(\backslash\)n"});
00467         \}
00468     \}
00469 
00470     \textcolor{keywordflow}{return} report;
00471 \}
00472 
00473 \textcolor{comment}{/* ---------------------- Latency command implementation -------------------- */}
00474 
00475 \textcolor{comment}{/* latencyCommand() helper to produce a time-delay reply for all the samples}
00476 \textcolor{comment}{ * in memory for the specified time series. */}
00477 \textcolor{keywordtype}{void} latencyCommandReplyWithSamples(\hyperlink{structclient}{client} *c, \textcolor{keyword}{struct} 
      \hyperlink{structlatencyTimeSeries}{latencyTimeSeries} *ts) \{
00478     \textcolor{keywordtype}{void} *replylen = addDeferredMultiBulkLength(c);
00479     \textcolor{keywordtype}{int} samples = 0, j;
00480 
00481     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{latency_8h_a7e3ba352d9d7bb4c88c2c42c16e6674b}{LATENCY\_TS\_LEN}; j++) \{
00482         \textcolor{keywordtype}{int} i = (ts->idx + j) % \hyperlink{latency_8h_a7e3ba352d9d7bb4c88c2c42c16e6674b}{LATENCY\_TS\_LEN};
00483 
00484         \textcolor{keywordflow}{if} (ts->samples[i].time == 0) \textcolor{keywordflow}{continue};
00485         addReplyMultiBulkLen(c,2);
00486         addReplyLongLong(c,ts->samples[i].time);
00487         addReplyLongLong(c,ts->samples[i].latency);
00488         samples++;
00489     \}
00490     setDeferredMultiBulkLength(c,replylen,samples);
00491 \}
00492 
00493 \textcolor{comment}{/* latencyCommand() helper to produce the reply for the LATEST subcommand,}
00494 \textcolor{comment}{ * listing the last latency sample for every event type registered so far. */}
00495 \textcolor{keywordtype}{void} latencyCommandReplyWithLatestEvents(\hyperlink{structclient}{client} *c) \{
00496     dictIterator *di;
00497     dictEntry *de;
00498 
00499     addReplyMultiBulkLen(c,\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.latency\_events));
00500     di = dictGetIterator(server.latency\_events);
00501     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
00502         \textcolor{keywordtype}{char} *event = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
00503         \textcolor{keyword}{struct} \hyperlink{structlatencyTimeSeries}{latencyTimeSeries} *ts = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
00504         \textcolor{keywordtype}{int} last = (ts->idx + \hyperlink{latency_8h_a7e3ba352d9d7bb4c88c2c42c16e6674b}{LATENCY\_TS\_LEN} - 1) % 
      \hyperlink{latency_8h_a7e3ba352d9d7bb4c88c2c42c16e6674b}{LATENCY\_TS\_LEN};
00505 
00506         addReplyMultiBulkLen(c,4);
00507         addReplyBulkCString(c,event);
00508         addReplyLongLong(c,ts->samples[last].time);
00509         addReplyLongLong(c,ts->samples[last].latency);
00510         addReplyLongLong(c,ts->max);
00511     \}
00512     dictReleaseIterator(di);
00513 \}
00514 
00515 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LATENCY\_GRAPH\_COLS} 80
00516 sds latencyCommandGenSparkeline(\textcolor{keywordtype}{char} *event, \textcolor{keyword}{struct} \hyperlink{structlatencyTimeSeries}{latencyTimeSeries} *ts) \{
00517     \textcolor{keywordtype}{int} j;
00518     \textcolor{keyword}{struct} \hyperlink{structsequence}{sequence} *seq = createSparklineSequence();
00519     sds graph = sdsempty();
00520     uint32\_t min = 0, max = 0;
00521 
00522     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{latency_8h_a7e3ba352d9d7bb4c88c2c42c16e6674b}{LATENCY\_TS\_LEN}; j++) \{
00523         \textcolor{keywordtype}{int} i = (ts->idx + j) % \hyperlink{latency_8h_a7e3ba352d9d7bb4c88c2c42c16e6674b}{LATENCY\_TS\_LEN};
00524         \textcolor{keywordtype}{int} elapsed;
00525         \textcolor{keywordtype}{char} buf[64];
00526 
00527         \textcolor{keywordflow}{if} (ts->samples[i].time == 0) \textcolor{keywordflow}{continue};
00528         \textcolor{comment}{/* Update min and max. */}
00529         \textcolor{keywordflow}{if} (seq->length == 0) \{
00530             min = max = ts->samples[i].latency;
00531         \} \textcolor{keywordflow}{else} \{
00532             \textcolor{keywordflow}{if} (ts->samples[i].latency > max) max = ts->samples[i].latency;
00533             \textcolor{keywordflow}{if} (ts->samples[i].latency < min) min = ts->samples[i].latency;
00534         \}
00535         \textcolor{comment}{/* Use as label the number of seconds / minutes / hours / days}
00536 \textcolor{comment}{         * ago the event happened. */}
00537         elapsed = time(NULL) - ts->samples[i].time;
00538         \textcolor{keywordflow}{if} (elapsed < 60)
00539             snprintf(buf,\textcolor{keyword}{sizeof}(buf),\textcolor{stringliteral}{"%ds"},elapsed);
00540         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (elapsed < 3600)
00541             snprintf(buf,\textcolor{keyword}{sizeof}(buf),\textcolor{stringliteral}{"%dm"},elapsed/60);
00542         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (elapsed < 3600*24)
00543             snprintf(buf,\textcolor{keyword}{sizeof}(buf),\textcolor{stringliteral}{"%dh"},elapsed/3600);
00544         \textcolor{keywordflow}{else}
00545             snprintf(buf,\textcolor{keyword}{sizeof}(buf),\textcolor{stringliteral}{"%dd"},elapsed/(3600*24));
00546         sparklineSequenceAddSample(seq,ts->samples[i].latency,buf);
00547     \}
00548 
00549     graph = sdscatprintf(graph,
00550         \textcolor{stringliteral}{"%s - high %lu ms, low %lu ms (all time high %lu ms)\(\backslash\)n"}, event,
00551         (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}) max, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}) min, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}) ts->max);
00552     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{latency_8c_a3acc869332e75f8b926c821d6cc97c8e}{LATENCY\_GRAPH\_COLS}; j++)
00553         graph = sdscatlen(graph,\textcolor{stringliteral}{"-"},1);
00554     graph = sdscatlen(graph,\textcolor{stringliteral}{"\(\backslash\)n"},1);
00555     graph = sparklineRender(graph,seq,\hyperlink{latency_8c_a3acc869332e75f8b926c821d6cc97c8e}{LATENCY\_GRAPH\_COLS},4,
      \hyperlink{sparkline_8h_af6a091d13a723f2ac2a848be4235a6cd}{SPARKLINE\_FILL});
00556     freeSparklineSequence(seq);
00557     \textcolor{keywordflow}{return} graph;
00558 \}
00559 
00560 \textcolor{comment}{/* LATENCY command implementations.}
00561 \textcolor{comment}{ *}
00562 \textcolor{comment}{ * LATENCY SAMPLES: return time-latency samples for the specified event.}
00563 \textcolor{comment}{ * LATENCY LATEST: return the latest latency for all the events classes.}
00564 \textcolor{comment}{ * LATENCY DOCTOR: returns an human readable analysis of instance latency.}
00565 \textcolor{comment}{ * LATENCY GRAPH: provide an ASCII graph of the latency of the specified event.}
00566 \textcolor{comment}{ */}
00567 \textcolor{keywordtype}{void} latencyCommand(\hyperlink{structclient}{client} *c) \{
00568     \textcolor{keyword}{struct} \hyperlink{structlatencyTimeSeries}{latencyTimeSeries} *ts;
00569 
00570     \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"history"}) && c->argc == 3) \{
00571         \textcolor{comment}{/* LATENCY HISTORY <event> */}
00572         ts = dictFetchValue(server.latency\_events,c->argv[2]->ptr);
00573         \textcolor{keywordflow}{if} (ts == NULL) \{
00574             addReplyMultiBulkLen(c,0);
00575         \} \textcolor{keywordflow}{else} \{
00576             latencyCommandReplyWithSamples(c,ts);
00577         \}
00578     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"graph"}) && c->argc == 3) \{
00579         \textcolor{comment}{/* LATENCY GRAPH <event> */}
00580         sds graph;
00581         dictEntry *de;
00582         \textcolor{keywordtype}{char} *event;
00583 
00584         de = dictFind(server.latency\_events,c->argv[2]->ptr);
00585         \textcolor{keywordflow}{if} (de == NULL) \textcolor{keywordflow}{goto} nodataerr;
00586         ts = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
00587         event = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
00588 
00589         graph = latencyCommandGenSparkeline(event,ts);
00590         addReplyBulkCString(c,graph);
00591         sdsfree(graph);
00592     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"latest"}) && c->argc == 2) \{
00593         \textcolor{comment}{/* LATENCY LATEST */}
00594         latencyCommandReplyWithLatestEvents(c);
00595     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"doctor"}) && c->argc == 2) \{
00596         \textcolor{comment}{/* LATENCY DOCTOR */}
00597         sds report = createLatencyReport();
00598 
00599         addReplyBulkCBuffer(c,report,sdslen(report));
00600         sdsfree(report);
00601     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"reset"}) && c->argc >= 2) \{
00602         \textcolor{comment}{/* LATENCY RESET */}
00603         \textcolor{keywordflow}{if} (c->argc == 2) \{
00604             addReplyLongLong(c,latencyResetEvent(NULL));
00605         \} \textcolor{keywordflow}{else} \{
00606             \textcolor{keywordtype}{int} j, resets = 0;
00607 
00608             \textcolor{keywordflow}{for} (j = 2; j < c->argc; j++)
00609                 resets += latencyResetEvent(c->argv[j]->ptr);
00610             addReplyLongLong(c,resets);
00611         \}
00612     \} \textcolor{keywordflow}{else} \{
00613         addReply(c,shared.syntaxerr);
00614     \}
00615     \textcolor{keywordflow}{return};
00616 
00617 nodataerr:
00618     \textcolor{comment}{/* Common error when the user asks for an event we have no latency}
00619 \textcolor{comment}{     * information about. */}
00620     addReplyErrorFormat(c,
00621         \textcolor{stringliteral}{"No samples available for event '%s'"}, (\textcolor{keywordtype}{char}*) c->argv[2]->ptr);
00622 \}
\end{DoxyCode}
