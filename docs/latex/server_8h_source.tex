\hypertarget{server_8h_source}{}\section{server.\+h}
\label{server_8h_source}\index{src/server.\+h@{src/server.\+h}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>}
00003 \textcolor{comment}{ * All rights reserved.}
00004 \textcolor{comment}{ *}
00005 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00006 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00007 \textcolor{comment}{ *}
00008 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00009 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00010 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00011 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00012 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00013 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00014 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00015 \textcolor{comment}{ *     specific prior written permission.}
00016 \textcolor{comment}{ *}
00017 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00018 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00019 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00020 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00021 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00022 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00023 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00024 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00025 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00026 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00027 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00028 \textcolor{comment}{ */}
00029 
00030 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifndef} \textcolor{preprocessor}{\_\_REDIS\_H}
00031 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{\_\_REDIS\_H}
00032 
00033 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{fmacros_8h}{"fmacros.h"}
00034 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{config_8h}{"config.h"}
00035 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{solarisfixes_8h}{"solarisfixes.h"}
00036 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{rio_8h}{"rio.h"}
00037 
00038 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdio}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00039 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdlib}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00040 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{string}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00041 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{time}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00042 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{limits}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00043 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{unistd}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00044 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{errno}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00045 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{inttypes}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00046 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{pthread}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00047 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{syslog}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00048 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{netinet}\textcolor{preprocessor}{/}\textcolor{preprocessor}{in}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00049 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{lua}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00050 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{signal}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00051 
00052 \textcolor{keyword}{typedef} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} mstime\_t; \textcolor{comment}{/* millisecond time type. */}
00053 
00054 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{ae_8h}{"ae.h"}            \textcolor{comment}{/* Event driven programming library */}
00055 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{sds_8h}{"sds.h"}            \textcolor{comment}{/* Dynamic safe strings */}
00056 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{dict_8h}{"dict.h"}            \textcolor{comment}{/* Hash tables */}
00057 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{adlist_8h}{"adlist.h"}            \textcolor{comment}{/* Linked lists */}
00058 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{zmalloc_8h}{"zmalloc.h"}            \textcolor{comment}{/* total memory usage aware version of malloc/free */}
00059 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{anet_8h}{"anet.h"}            \textcolor{comment}{/* Networking the easy way */}
00060 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{ziplist_8h}{"ziplist.h"}            \textcolor{comment}{/* Compact list data structure */}
00061 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{intset_8h}{"intset.h"}            \textcolor{comment}{/* Compact integer set structure */}
00062 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{stream_8h}{"stream.h"}            \textcolor{comment}{/* Stream data type header file. */}
00063 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{version_8h}{"version.h"}            \textcolor{comment}{/* Version macro */}
00064 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{util_8h}{"util.h"}            \textcolor{comment}{/* Misc functions useful in many places */}
00065 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{latency_8h}{"latency.h"}            \textcolor{comment}{/* Latency monitor API */}
00066 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{sparkline_8h}{"sparkline.h"}              \textcolor{comment}{/* ASCII graphs API */}
00067 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{quicklist_8h}{"quicklist.h"}               \textcolor{comment}{/* Lists are encoded as linked lists of}
00068 \textcolor{comment}{                           N-elements flat arrays */}
00069 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{rax_8h}{"rax.h"}            \textcolor{comment}{/* Radix tree */}
00070 
00071 \textcolor{comment}{/* Following includes allow test functions to be called from Redis main() */}
00072 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{zipmap_8h}{"zipmap.h"}
00073 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{sha1_8h}{"sha1.h"}
00074 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{endianconv_8h}{"endianconv.h"}
00075 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{crc64_8h}{"crc64.h"}
00076 
00077 \textcolor{comment}{/* Error codes */}
00078 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{C\_OK}                    0
00079 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{C\_ERR}                   \textcolor{preprocessor}{-}1
00080 
00081 \textcolor{comment}{/* Static server configuration */}
00082 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_HZ}        10      \textcolor{comment}{/* Time interrupt calls/sec. */}
00083 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_MIN\_HZ}            1
00084 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_MAX\_HZ}            500
00085 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_SERVER\_PORT}        6379    \textcolor{comment}{/* TCP port */}
00086 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_TCP\_BACKLOG}       511     \textcolor{comment}{/* TCP listen backlog */}
00087 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_CLIENT\_TIMEOUT}       0       \textcolor{comment}{/* default client timeout: infinite */}
00088 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_DBNUM}     16
00089 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_MAX\_LINE}    1024
00090 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CRON\_DBS\_PER\_CALL} 16
00091 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{NET\_MAX\_WRITES\_PER\_EVENT} \textcolor{preprocessor}{(}1024\textcolor{preprocessor}{*}64\textcolor{preprocessor}{)}
00092 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{PROTO\_SHARED\_SELECT\_CMDS} 10
00093 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_SHARED\_INTEGERS} 10000
00094 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_SHARED\_BULKHDR\_LEN} 32
00095 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LOG\_MAX\_LEN}    1024 \textcolor{comment}{/* Default maximum length of syslog messages */}
00096 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{AOF\_REWRITE\_PERC}  100
00097 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{AOF\_REWRITE\_MIN\_SIZE} \textcolor{preprocessor}{(}64\textcolor{preprocessor}{*}1024\textcolor{preprocessor}{*}1024\textcolor{preprocessor}{)}
00098 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{AOF\_REWRITE\_ITEMS\_PER\_CMD} 64
00099 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{AOF\_READ\_DIFF\_INTERVAL\_BYTES} \textcolor{preprocessor}{(}1024\textcolor{preprocessor}{*}10\textcolor{preprocessor}{)}
00100 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_SLOWLOG\_LOG\_SLOWER\_THAN} 10000
00101 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_SLOWLOG\_MAX\_LEN} 128
00102 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_MAX\_CLIENTS} 10000
00103 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_AUTHPASS\_MAX\_LEN} 512
00104 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_SLAVE\_PRIORITY} 100
00105 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_REPL\_TIMEOUT} 60
00106 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_REPL\_PING\_SLAVE\_PERIOD} 10
00107 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_RUN\_ID\_SIZE} 40
00108 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{RDB\_EOF\_MARK\_SIZE} 40
00109 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_REPL\_BACKLOG\_SIZE} \textcolor{preprocessor}{(}1024\textcolor{preprocessor}{*}1024\textcolor{preprocessor}{)}    \textcolor{comment}{/* 1mb */}
00110 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_REPL\_BACKLOG\_TIME\_LIMIT} \textcolor{preprocessor}{(}60\textcolor{preprocessor}{*}60\textcolor{preprocessor}{)}  \textcolor{comment}{/* 1 hour */}
00111 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_REPL\_BACKLOG\_MIN\_SIZE} \textcolor{preprocessor}{(}1024\textcolor{preprocessor}{*}16\textcolor{preprocessor}{)}          \textcolor{comment}{/* 16k */}
00112 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_BGSAVE\_RETRY\_DELAY} 5 \textcolor{comment}{/* Wait a few secs before trying again. */}
00113 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_PID\_FILE} \textcolor{stringliteral}{"/var/run/redis.pid"}
00114 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_SYSLOG\_IDENT} \textcolor{stringliteral}{"redis"}
00115 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_CLUSTER\_CONFIG\_FILE} \textcolor{stringliteral}{"nodes.conf"}
00116 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_CLUSTER\_ANNOUNCE\_IP} NULL         \textcolor{comment}{/* Auto detect. */}
00117 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_CLUSTER\_ANNOUNCE\_PORT} 0          \textcolor{comment}{/* Use server.port */}
00118 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_CLUSTER\_ANNOUNCE\_BUS\_PORT} 0      \textcolor{comment}{/* Use +10000 offset. */}
00119 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_DAEMONIZE} 0
00120 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_UNIX\_SOCKET\_PERM} 0
00121 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_TCP\_KEEPALIVE} 300
00122 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_PROTECTED\_MODE} 1
00123 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_LOGFILE} \textcolor{stringliteral}{""}
00124 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_SYSLOG\_ENABLED} 0
00125 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_STOP\_WRITES\_ON\_BGSAVE\_ERROR} 1
00126 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_RDB\_COMPRESSION} 1
00127 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_RDB\_CHECKSUM} 1
00128 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_RDB\_FILENAME} \textcolor{stringliteral}{"dump.rdb"}
00129 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_REPL\_DISKLESS\_SYNC} 0
00130 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_REPL\_DISKLESS\_SYNC\_DELAY} 5
00131 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_SLAVE\_SERVE\_STALE\_DATA} 1
00132 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_SLAVE\_READ\_ONLY} 1
00133 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_SLAVE\_ANNOUNCE\_IP} NULL
00134 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_SLAVE\_ANNOUNCE\_PORT} 0
00135 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_REPL\_DISABLE\_TCP\_NODELAY} 0
00136 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_MAXMEMORY} 0
00137 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_MAXMEMORY\_SAMPLES} 5
00138 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_LFU\_LOG\_FACTOR} 10
00139 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_LFU\_DECAY\_TIME} 1
00140 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_AOF\_FILENAME} \textcolor{stringliteral}{"appendonly.aof"}
00141 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_AOF\_NO\_FSYNC\_ON\_REWRITE} 0
00142 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_AOF\_LOAD\_TRUNCATED} 1
00143 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_AOF\_USE\_RDB\_PREAMBLE} 0
00144 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_ACTIVE\_REHASHING} 1
00145 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_AOF\_REWRITE\_INCREMENTAL\_FSYNC} 1
00146 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_MIN\_SLAVES\_TO\_WRITE} 0
00147 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_MIN\_SLAVES\_MAX\_LAG} 10
00148 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{NET\_IP\_STR\_LEN} 46 \textcolor{comment}{/* INET6\_ADDRSTRLEN is 46, but we need to be sure */}
00149 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{NET\_PEER\_ID\_LEN} \textcolor{preprocessor}{(}\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN}\textcolor{preprocessor}{+}32\textcolor{preprocessor}{)} \textcolor{comment}{/* Must be enough for ip:port */}
00150 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_BINDADDR\_MAX} 16
00151 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_MIN\_RESERVED\_FDS} 32
00152 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_LATENCY\_MONITOR\_THRESHOLD} 0
00153 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_SLAVE\_LAZY\_FLUSH} 0
00154 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_LAZYFREE\_LAZY\_EVICTION} 0
00155 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_LAZYFREE\_LAZY\_EXPIRE} 0
00156 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_LAZYFREE\_LAZY\_SERVER\_DEL} 0
00157 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_ALWAYS\_SHOW\_LOGO} 0
00158 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_ACTIVE\_DEFRAG} 0
00159 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_DEFRAG\_THRESHOLD\_LOWER} 10 \textcolor{comment}{/* don't defrag when fragmentation is below 10% */}
00160 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_DEFRAG\_THRESHOLD\_UPPER} 100 \textcolor{comment}{/* maximum defrag force at 100% fragmentation */}
00161 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_DEFRAG\_IGNORE\_BYTES} \textcolor{preprocessor}{(}100\textcolor{preprocessor}{<<}20\textcolor{preprocessor}{)} \textcolor{comment}{/* don't defrag if frag overhead is below 100mb
       */}
00162 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_DEFRAG\_CYCLE\_MIN} 25 \textcolor{comment}{/* 25% CPU min (at lower threshold) */}
00163 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_DEFRAG\_CYCLE\_MAX} 75 \textcolor{comment}{/* 75% CPU max (at upper threshold) */}
00164 
00165 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ACTIVE\_EXPIRE\_CYCLE\_LOOKUPS\_PER\_LOOP} 20 \textcolor{comment}{/* Loopkups per loop. */}
00166 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ACTIVE\_EXPIRE\_CYCLE\_FAST\_DURATION} 1000 \textcolor{comment}{/* Microseconds */}
00167 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ACTIVE\_EXPIRE\_CYCLE\_SLOW\_TIME\_PERC} 25 \textcolor{comment}{/* CPU max % for keys collection */}
00168 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ACTIVE\_EXPIRE\_CYCLE\_SLOW} 0
00169 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ACTIVE\_EXPIRE\_CYCLE\_FAST} 1
00170 
00171 \textcolor{comment}{/* Instantaneous metrics tracking. */}
00172 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{STATS\_METRIC\_SAMPLES} 16     \textcolor{comment}{/* Number of samples per metric. */}
00173 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{STATS\_METRIC\_COMMAND} 0      \textcolor{comment}{/* Number of commands executed. */}
00174 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{STATS\_METRIC\_NET\_INPUT} 1    \textcolor{comment}{/* Bytes read to network .*/}
00175 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{STATS\_METRIC\_NET\_OUTPUT} 2   \textcolor{comment}{/* Bytes written to network. */}
00176 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{STATS\_METRIC\_COUNT} 3
00177 
00178 \textcolor{comment}{/* Protocol and I/O related defines */}
00179 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{PROTO\_MAX\_QUERYBUF\_LEN}  \textcolor{preprocessor}{(}1024\textcolor{preprocessor}{*}1024\textcolor{preprocessor}{*}1024\textcolor{preprocessor}{)} \textcolor{comment}{/* 1GB max query buffer. */}
00180 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{PROTO\_IOBUF\_LEN}         \textcolor{preprocessor}{(}1024\textcolor{preprocessor}{*}16\textcolor{preprocessor}{)}  \textcolor{comment}{/* Generic I/O buffer size */}
00181 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{PROTO\_REPLY\_CHUNK\_BYTES} \textcolor{preprocessor}{(}16\textcolor{preprocessor}{*}1024\textcolor{preprocessor}{)} \textcolor{comment}{/* 16k output buffer */}
00182 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{PROTO\_INLINE\_MAX\_SIZE}   \textcolor{preprocessor}{(}1024\textcolor{preprocessor}{*}64\textcolor{preprocessor}{)} \textcolor{comment}{/* Max size of inline reads */}
00183 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{PROTO\_MBULK\_BIG\_ARG}     \textcolor{preprocessor}{(}1024\textcolor{preprocessor}{*}32\textcolor{preprocessor}{)}
00184 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LONG\_STR\_SIZE}      21          \textcolor{comment}{/* Bytes needed for long -> str + '\(\backslash\)0' */}
00185 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{AOF\_AUTOSYNC\_BYTES} \textcolor{preprocessor}{(}1024\textcolor{preprocessor}{*}1024\textcolor{preprocessor}{*}32\textcolor{preprocessor}{)} \textcolor{comment}{/* fdatasync every 32MB */}
00186 
00187 \textcolor{comment}{/* When configuring the server eventloop, we setup it so that the total number}
00188 \textcolor{comment}{ * of file descriptors we can handle are server.maxclients + RESERVED\_FDS +}
00189 \textcolor{comment}{ * a few more to stay safe. Since RESERVED\_FDS defaults to 32, we add 96}
00190 \textcolor{comment}{ * in order to make sure of not over provisioning more than 128 fds. */}
00191 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_FDSET\_INCR} \textcolor{preprocessor}{(}\hyperlink{server_8h_abcea50457e3de849eab11d0ba5d81d08}{CONFIG\_MIN\_RESERVED\_FDS}\textcolor{preprocessor}{+}96\textcolor{preprocessor}{)}
00192 
00193 \textcolor{comment}{/* Hash table parameters */}
00194 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{HASHTABLE\_MIN\_FILL}        10      \textcolor{comment}{/* Minimal hash table fill 10% */}
00195 
00196 \textcolor{comment}{/* Command flags. Please check the command table defined in the redis.c file}
00197 \textcolor{comment}{ * for more information about the meaning of every flag. */}
00198 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_WRITE} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)}            \textcolor{comment}{/* "w" flag */}
00199 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_READONLY} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}1\textcolor{preprocessor}{)}         \textcolor{comment}{/* "r" flag */}
00200 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_DENYOOM} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}2\textcolor{preprocessor}{)}          \textcolor{comment}{/* "m" flag */}
00201 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_MODULE} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}3\textcolor{preprocessor}{)}           \textcolor{comment}{/* Command exported by module. */}
00202 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_ADMIN} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}4\textcolor{preprocessor}{)}            \textcolor{comment}{/* "a" flag */}
00203 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_PUBSUB} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}5\textcolor{preprocessor}{)}           \textcolor{comment}{/* "p" flag */}
00204 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_NOSCRIPT} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}6\textcolor{preprocessor}{)}         \textcolor{comment}{/* "s" flag */}
00205 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_RANDOM} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}7\textcolor{preprocessor}{)}           \textcolor{comment}{/* "R" flag */}
00206 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_SORT\_FOR\_SCRIPT} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}8\textcolor{preprocessor}{)}  \textcolor{comment}{/* "S" flag */}
00207 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_LOADING} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}9\textcolor{preprocessor}{)}          \textcolor{comment}{/* "l" flag */}
00208 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_STALE} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}10\textcolor{preprocessor}{)}           \textcolor{comment}{/* "t" flag */}
00209 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_SKIP\_MONITOR} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}11\textcolor{preprocessor}{)}    \textcolor{comment}{/* "M" flag */}
00210 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_ASKING} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}12\textcolor{preprocessor}{)}          \textcolor{comment}{/* "k" flag */}
00211 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_FAST} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}13\textcolor{preprocessor}{)}            \textcolor{comment}{/* "F" flag */}
00212 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_MODULE\_GETKEYS} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}14\textcolor{preprocessor}{)}  \textcolor{comment}{/* Use the modules getkeys interface. */}
00213 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_MODULE\_NO\_CLUSTER} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}15\textcolor{preprocessor}{)} \textcolor{comment}{/* Deny on Redis Cluster. */}
00214 
00215 \textcolor{comment}{/* AOF states */}
00216 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{AOF\_OFF} 0             \textcolor{comment}{/* AOF is off */}
00217 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{AOF\_ON} 1              \textcolor{comment}{/* AOF is on */}
00218 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{AOF\_WAIT\_REWRITE} 2    \textcolor{comment}{/* AOF waits rewrite to start appending */}
00219 
00220 \textcolor{comment}{/* Client flags */}
00221 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_SLAVE} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)}   \textcolor{comment}{/* This client is a slave server */}
00222 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_MASTER} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}1\textcolor{preprocessor}{)}  \textcolor{comment}{/* This client is a master server */}
00223 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_MONITOR} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}2\textcolor{preprocessor}{)} \textcolor{comment}{/* This client is a slave monitor, see MONITOR */}
00224 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_MULTI} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}3\textcolor{preprocessor}{)}   \textcolor{comment}{/* This client is in a MULTI context */}
00225 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_BLOCKED} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}4\textcolor{preprocessor}{)} \textcolor{comment}{/* The client is waiting in a blocking operation */}
00226 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_DIRTY\_CAS} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}5\textcolor{preprocessor}{)} \textcolor{comment}{/* Watched keys modified. EXEC will fail. */}
00227 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_CLOSE\_AFTER\_REPLY} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}6\textcolor{preprocessor}{)} \textcolor{comment}{/* Close after writing entire reply. */}
00228 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_UNBLOCKED} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}7\textcolor{preprocessor}{)} \textcolor{comment}{/* This client was unblocked and is stored in}
00229 \textcolor{comment}{                                  server.unblocked\_clients */}
00230 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_LUA} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}8\textcolor{preprocessor}{)} \textcolor{comment}{/* This is a non connected client used by Lua */}
00231 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_ASKING} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}9\textcolor{preprocessor}{)}     \textcolor{comment}{/* Client issued the ASKING command */}
00232 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_CLOSE\_ASAP} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}10\textcolor{preprocessor}{)}\textcolor{comment}{/* Close this client ASAP */}
00233 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_UNIX\_SOCKET} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}11\textcolor{preprocessor}{)} \textcolor{comment}{/* Client connected via Unix domain socket */}
00234 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_DIRTY\_EXEC} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}12\textcolor{preprocessor}{)}  \textcolor{comment}{/* EXEC will fail for errors while queueing */}
00235 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_MASTER\_FORCE\_REPLY} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}13\textcolor{preprocessor}{)}  \textcolor{comment}{/* Queue replies even if is master */}
00236 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_FORCE\_AOF} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}14\textcolor{preprocessor}{)}   \textcolor{comment}{/* Force AOF propagation of current cmd. */}
00237 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_FORCE\_REPL} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}15\textcolor{preprocessor}{)}  \textcolor{comment}{/* Force replication of current cmd. */}
00238 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_PRE\_PSYNC} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}16\textcolor{preprocessor}{)}   \textcolor{comment}{/* Instance don't understand PSYNC. */}
00239 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_READONLY} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}17\textcolor{preprocessor}{)}    \textcolor{comment}{/* Cluster client is in read-only state. */}
00240 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_PUBSUB} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}18\textcolor{preprocessor}{)}      \textcolor{comment}{/* Client is in Pub/Sub mode. */}
00241 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_PREVENT\_AOF\_PROP} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}19\textcolor{preprocessor}{)}  \textcolor{comment}{/* Don't propagate to AOF. */}
00242 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_PREVENT\_REPL\_PROP} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}20\textcolor{preprocessor}{)}  \textcolor{comment}{/* Don't propagate to slaves. */}
00243 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_PREVENT\_PROP} \textcolor{preprocessor}{(}\hyperlink{server_8h_a9948ae3a2778b5a06b704231b921e7fa}{CLIENT\_PREVENT\_AOF\_PROP}\textcolor{preprocessor}{|}
      \hyperlink{server_8h_a01c18c16bc758787b5cfc287eb7b089e}{CLIENT\_PREVENT\_REPL\_PROP}\textcolor{preprocessor}{)}
00244 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_PENDING\_WRITE} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}21\textcolor{preprocessor}{)} \textcolor{comment}{/* Client has output to send but a write}
00245 \textcolor{comment}{                                        handler is yet not installed. */}
00246 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_REPLY\_OFF} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}22\textcolor{preprocessor}{)}   \textcolor{comment}{/* Don't send replies to client. */}
00247 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_REPLY\_SKIP\_NEXT} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}23\textcolor{preprocessor}{)}  \textcolor{comment}{/* Set CLIENT\_REPLY\_SKIP for next cmd */}
00248 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_REPLY\_SKIP} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}24\textcolor{preprocessor}{)}  \textcolor{comment}{/* Don't send just this reply. */}
00249 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_LUA\_DEBUG} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}25\textcolor{preprocessor}{)}  \textcolor{comment}{/* Run EVAL in debug mode. */}
00250 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_LUA\_DEBUG\_SYNC} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}26\textcolor{preprocessor}{)}  \textcolor{comment}{/* EVAL debugging without fork() */}
00251 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_MODULE} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}27\textcolor{preprocessor}{)} \textcolor{comment}{/* Non connected client used by some module. */}
00252 
00253 \textcolor{comment}{/* Client block type (btype field in client structure)}
00254 \textcolor{comment}{ * if CLIENT\_BLOCKED flag is set. */}
00255 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{BLOCKED\_NONE} 0    \textcolor{comment}{/* Not blocked, no CLIENT\_BLOCKED flag set. */}
00256 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{BLOCKED\_LIST} 1    \textcolor{comment}{/* BLPOP & co. */}
00257 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{BLOCKED\_WAIT} 2    \textcolor{comment}{/* WAIT for synchronous replication. */}
00258 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{BLOCKED\_MODULE} 3  \textcolor{comment}{/* Blocked by a loadable module. */}
00259 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{BLOCKED\_STREAM} 4  \textcolor{comment}{/* XREAD. */}
00260 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{BLOCKED\_NUM} 5     \textcolor{comment}{/* Number of blocked states. */}
00261 
00262 \textcolor{comment}{/* Client request types */}
00263 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{PROTO\_REQ\_INLINE} 1
00264 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{PROTO\_REQ\_MULTIBULK} 2
00265 
00266 \textcolor{comment}{/* Client classes for client limits, currently used only for}
00267 \textcolor{comment}{ * the max-client-output-buffer limit implementation. */}
00268 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_TYPE\_NORMAL} 0 \textcolor{comment}{/* Normal req-reply clients + MONITORs */}
00269 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_TYPE\_SLAVE} 1  \textcolor{comment}{/* Slaves. */}
00270 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_TYPE\_PUBSUB} 2 \textcolor{comment}{/* Clients subscribed to PubSub channels. */}
00271 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_TYPE\_MASTER} 3 \textcolor{comment}{/* Master. */}
00272 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENT\_TYPE\_OBUF\_COUNT} 3 \textcolor{comment}{/* Number of clients to expose to output}
00273 \textcolor{comment}{                                    buffer configuration. Just the first}
00274 \textcolor{comment}{                                    three: normal, slave, pubsub. */}
00275 
00276 \textcolor{comment}{/* Slave replication state. Used in server.repl\_state for slaves to remember}
00277 \textcolor{comment}{ * what to do next. */}
00278 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REPL\_STATE\_NONE} 0 \textcolor{comment}{/* No active replication */}
00279 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REPL\_STATE\_CONNECT} 1 \textcolor{comment}{/* Must connect to master */}
00280 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REPL\_STATE\_CONNECTING} 2 \textcolor{comment}{/* Connecting to master */}
00281 \textcolor{comment}{/* --- Handshake states, must be ordered --- */}
00282 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REPL\_STATE\_RECEIVE\_PONG} 3 \textcolor{comment}{/* Wait for PING reply */}
00283 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REPL\_STATE\_SEND\_AUTH} 4 \textcolor{comment}{/* Send AUTH to master */}
00284 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REPL\_STATE\_RECEIVE\_AUTH} 5 \textcolor{comment}{/* Wait for AUTH reply */}
00285 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REPL\_STATE\_SEND\_PORT} 6 \textcolor{comment}{/* Send REPLCONF listening-port */}
00286 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REPL\_STATE\_RECEIVE\_PORT} 7 \textcolor{comment}{/* Wait for REPLCONF reply */}
00287 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REPL\_STATE\_SEND\_IP} 8 \textcolor{comment}{/* Send REPLCONF ip-address */}
00288 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REPL\_STATE\_RECEIVE\_IP} 9 \textcolor{comment}{/* Wait for REPLCONF reply */}
00289 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REPL\_STATE\_SEND\_CAPA} 10 \textcolor{comment}{/* Send REPLCONF capa */}
00290 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REPL\_STATE\_RECEIVE\_CAPA} 11 \textcolor{comment}{/* Wait for REPLCONF reply */}
00291 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REPL\_STATE\_SEND\_PSYNC} 12 \textcolor{comment}{/* Send PSYNC */}
00292 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REPL\_STATE\_RECEIVE\_PSYNC} 13 \textcolor{comment}{/* Wait for PSYNC reply */}
00293 \textcolor{comment}{/* --- End of handshake states --- */}
00294 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REPL\_STATE\_TRANSFER} 14 \textcolor{comment}{/* Receiving .rdb from master */}
00295 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REPL\_STATE\_CONNECTED} 15 \textcolor{comment}{/* Connected to master */}
00296 
00297 \textcolor{comment}{/* State of slaves from the POV of the master. Used in client->replstate.}
00298 \textcolor{comment}{ * In SEND\_BULK and ONLINE state the slave receives new updates}
00299 \textcolor{comment}{ * in its output queue. In the WAIT\_BGSAVE states instead the server is waiting}
00300 \textcolor{comment}{ * to start the next background saving in order to send updates to it. */}
00301 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SLAVE\_STATE\_WAIT\_BGSAVE\_START} 6 \textcolor{comment}{/* We need to produce a new RDB file. */}
00302 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SLAVE\_STATE\_WAIT\_BGSAVE\_END} 7 \textcolor{comment}{/* Waiting RDB file creation to finish. */}
00303 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SLAVE\_STATE\_SEND\_BULK} 8 \textcolor{comment}{/* Sending RDB file to slave. */}
00304 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SLAVE\_STATE\_ONLINE} 9 \textcolor{comment}{/* RDB file transmitted, sending just updates. */}
00305 
00306 \textcolor{comment}{/* Slave capabilities. */}
00307 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SLAVE\_CAPA\_NONE} 0
00308 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SLAVE\_CAPA\_EOF} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)}    \textcolor{comment}{/* Can parse the RDB EOF streaming format. */}
00309 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SLAVE\_CAPA\_PSYNC2} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}1\textcolor{preprocessor}{)} \textcolor{comment}{/* Supports PSYNC2 protocol. */}
00310 
00311 \textcolor{comment}{/* Synchronous read timeout - slave side */}
00312 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_REPL\_SYNCIO\_TIMEOUT} 5
00313 
00314 \textcolor{comment}{/* List related stuff */}
00315 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LIST\_HEAD} 0
00316 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LIST\_TAIL} 1
00317 
00318 \textcolor{comment}{/* Sort operations */}
00319 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SORT\_OP\_GET} 0
00320 
00321 \textcolor{comment}{/* Log levels */}
00322 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LL\_DEBUG} 0
00323 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LL\_VERBOSE} 1
00324 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LL\_NOTICE} 2
00325 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LL\_WARNING} 3
00326 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LL\_RAW} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}10\textcolor{preprocessor}{)} \textcolor{comment}{/* Modifier to log without timestamp */}
00327 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_VERBOSITY} \hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE}
00328 
00329 \textcolor{comment}{/* Supervision options */}
00330 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SUPERVISED\_NONE} 0
00331 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SUPERVISED\_AUTODETECT} 1
00332 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SUPERVISED\_SYSTEMD} 2
00333 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SUPERVISED\_UPSTART} 3
00334 
00335 \textcolor{comment}{/* Anti-warning macro... */}
00336 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{UNUSED}\textcolor{preprocessor}{(}\textcolor{preprocessor}{V}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{keywordtype}{void}\textcolor{preprocessor}{)} \textcolor{preprocessor}{V}\textcolor{preprocessor}{)}
00337 
00338 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZSKIPLIST\_MAXLEVEL} 32 \textcolor{comment}{/* Should be enough for 2^32 elements */}
00339 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZSKIPLIST\_P} 0.25      \textcolor{comment}{/* Skiplist P = 1/4 */}
00340 
00341 \textcolor{comment}{/* Append only defines */}
00342 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{AOF\_FSYNC\_NO} 0
00343 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{AOF\_FSYNC\_ALWAYS} 1
00344 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{AOF\_FSYNC\_EVERYSEC} 2
00345 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_AOF\_FSYNC} \hyperlink{server_8h_a9784233b87ec796d0343556106fb778e}{AOF\_FSYNC\_EVERYSEC}
00346 
00347 \textcolor{comment}{/* Zip structure related defaults */}
00348 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_HASH\_MAX\_ZIPLIST\_ENTRIES} 512
00349 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_HASH\_MAX\_ZIPLIST\_VALUE} 64
00350 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_SET\_MAX\_INTSET\_ENTRIES} 512
00351 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_ZSET\_MAX\_ZIPLIST\_ENTRIES} 128
00352 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_ZSET\_MAX\_ZIPLIST\_VALUE} 64
00353 
00354 \textcolor{comment}{/* List defaults */}
00355 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_LIST\_MAX\_ZIPLIST\_SIZE} \textcolor{preprocessor}{-}2
00356 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_LIST\_COMPRESS\_DEPTH} 0
00357 
00358 \textcolor{comment}{/* HyperLogLog defines */}
00359 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_HLL\_SPARSE\_MAX\_BYTES} 3000
00360 
00361 \textcolor{comment}{/* Sets operations codes */}
00362 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SET\_OP\_UNION} 0
00363 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SET\_OP\_DIFF} 1
00364 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SET\_OP\_INTER} 2
00365 
00366 \textcolor{comment}{/* Redis maxmemory strategies. Instead of using just incremental number}
00367 \textcolor{comment}{ * for this defines, we use a set of flags so that testing for certain}
00368 \textcolor{comment}{ * properties common to multiple policies is faster. */}
00369 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{MAXMEMORY\_FLAG\_LRU} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)}
00370 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{MAXMEMORY\_FLAG\_LFU} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}1\textcolor{preprocessor}{)}
00371 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{MAXMEMORY\_FLAG\_ALLKEYS} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}2\textcolor{preprocessor}{)}
00372 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{MAXMEMORY\_FLAG\_NO\_SHARED\_INTEGERS}
00373     \textcolor{preprocessor}{(}\hyperlink{server_8h_a9f9503e7c7ba52df66b097c2b0b4c6d0}{MAXMEMORY\_FLAG\_LRU}\textcolor{preprocessor}{|}\hyperlink{server_8h_aac2d3ad7a604f87e06e25233dbd01c9b}{MAXMEMORY\_FLAG\_LFU}\textcolor{preprocessor}{)}
00374 
00375 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{MAXMEMORY\_VOLATILE\_LRU} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}0\textcolor{preprocessor}{<<}8\textcolor{preprocessor}{)}\textcolor{preprocessor}{|}\hyperlink{server_8h_a9f9503e7c7ba52df66b097c2b0b4c6d0}{MAXMEMORY\_FLAG\_LRU}\textcolor{preprocessor}{)}
00376 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{MAXMEMORY\_VOLATILE\_LFU} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}8\textcolor{preprocessor}{)}\textcolor{preprocessor}{|}\hyperlink{server_8h_aac2d3ad7a604f87e06e25233dbd01c9b}{MAXMEMORY\_FLAG\_LFU}\textcolor{preprocessor}{)}
00377 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{MAXMEMORY\_VOLATILE\_TTL} \textcolor{preprocessor}{(}2\textcolor{preprocessor}{<<}8\textcolor{preprocessor}{)}
00378 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{MAXMEMORY\_VOLATILE\_RANDOM} \textcolor{preprocessor}{(}3\textcolor{preprocessor}{<<}8\textcolor{preprocessor}{)}
00379 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{MAXMEMORY\_ALLKEYS\_LRU} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}4\textcolor{preprocessor}{<<}8\textcolor{preprocessor}{)}\textcolor{preprocessor}{|}\hyperlink{server_8h_a9f9503e7c7ba52df66b097c2b0b4c6d0}{MAXMEMORY\_FLAG\_LRU}\textcolor{preprocessor}{|}
      \hyperlink{server_8h_a6fccff10a0d37e23fb8114d5c87737d0}{MAXMEMORY\_FLAG\_ALLKEYS}\textcolor{preprocessor}{)}
00380 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{MAXMEMORY\_ALLKEYS\_LFU} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}5\textcolor{preprocessor}{<<}8\textcolor{preprocessor}{)}\textcolor{preprocessor}{|}\hyperlink{server_8h_aac2d3ad7a604f87e06e25233dbd01c9b}{MAXMEMORY\_FLAG\_LFU}\textcolor{preprocessor}{|}
      \hyperlink{server_8h_a6fccff10a0d37e23fb8114d5c87737d0}{MAXMEMORY\_FLAG\_ALLKEYS}\textcolor{preprocessor}{)}
00381 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{MAXMEMORY\_ALLKEYS\_RANDOM} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}6\textcolor{preprocessor}{<<}8\textcolor{preprocessor}{)}\textcolor{preprocessor}{|}\hyperlink{server_8h_a6fccff10a0d37e23fb8114d5c87737d0}{MAXMEMORY\_FLAG\_ALLKEYS}\textcolor{preprocessor}{)}
00382 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{MAXMEMORY\_NO\_EVICTION} \textcolor{preprocessor}{(}7\textcolor{preprocessor}{<<}8\textcolor{preprocessor}{)}
00383 
00384 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CONFIG\_DEFAULT\_MAXMEMORY\_POLICY} \hyperlink{server_8h_a418e5a222cf659c003df77830f1ae343}{MAXMEMORY\_NO\_EVICTION}
00385 
00386 \textcolor{comment}{/* Scripting */}
00387 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LUA\_SCRIPT\_TIME\_LIMIT} 5000 \textcolor{comment}{/* milliseconds */}
00388 
00389 \textcolor{comment}{/* Units */}
00390 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{UNIT\_SECONDS} 0
00391 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{UNIT\_MILLISECONDS} 1
00392 
00393 \textcolor{comment}{/* SHUTDOWN flags */}
00394 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SHUTDOWN\_NOFLAGS} 0      \textcolor{comment}{/* No flags. */}
00395 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SHUTDOWN\_SAVE} 1         \textcolor{comment}{/* Force SAVE on SHUTDOWN even if no save}
00396 \textcolor{comment}{                                   points are configured. */}
00397 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{SHUTDOWN\_NOSAVE} 2       \textcolor{comment}{/* Don't SAVE on SHUTDOWN. */}
00398 
00399 \textcolor{comment}{/* Command call flags, see call() function */}
00400 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_CALL\_NONE} 0
00401 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_CALL\_SLOWLOG} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)}
00402 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_CALL\_STATS} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}1\textcolor{preprocessor}{)}
00403 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_CALL\_PROPAGATE\_AOF} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}2\textcolor{preprocessor}{)}
00404 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_CALL\_PROPAGATE\_REPL} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}3\textcolor{preprocessor}{)}
00405 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_CALL\_PROPAGATE} \textcolor{preprocessor}{(}\hyperlink{server_8h_a3ca848c94df18641ac372c58fca0e236}{CMD\_CALL\_PROPAGATE\_AOF}\textcolor{preprocessor}{|}
      \hyperlink{server_8h_a69e4a8fdb26588e1028deb20fd51424a}{CMD\_CALL\_PROPAGATE\_REPL}\textcolor{preprocessor}{)}
00406 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CMD\_CALL\_FULL} \textcolor{preprocessor}{(}\hyperlink{server_8h_a934cea7b13db05a29264146cd5b14064}{CMD\_CALL\_SLOWLOG} \textcolor{preprocessor}{|} \hyperlink{server_8h_a7b1d9cf5be21e4808da0c16f03155973}{CMD\_CALL\_STATS} \textcolor{preprocessor}{|} 
      \hyperlink{server_8h_a6ee9ed603f975d0d2b6ae44f1907565f}{CMD\_CALL\_PROPAGATE}\textcolor{preprocessor}{)}
00407 
00408 \textcolor{comment}{/* Command propagation flags, see propagate() function */}
00409 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{PROPAGATE\_NONE} 0
00410 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{PROPAGATE\_AOF} 1
00411 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{PROPAGATE\_REPL} 2
00412 
00413 \textcolor{comment}{/* RDB active child save type. */}
00414 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{RDB\_CHILD\_TYPE\_NONE} 0
00415 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{RDB\_CHILD\_TYPE\_DISK} 1     \textcolor{comment}{/* RDB is written to disk. */}
00416 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{RDB\_CHILD\_TYPE\_SOCKET} 2   \textcolor{comment}{/* RDB is written to slave socket. */}
00417 
00418 \textcolor{comment}{/* Keyspace changes notification classes. Every class is associated with a}
00419 \textcolor{comment}{ * character for configuration purposes. */}
00420 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{NOTIFY\_KEYSPACE} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)}    \textcolor{comment}{/* K */}
00421 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{NOTIFY\_KEYEVENT} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}1\textcolor{preprocessor}{)}    \textcolor{comment}{/* E */}
00422 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{NOTIFY\_GENERIC} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}2\textcolor{preprocessor}{)}     \textcolor{comment}{/* g */}
00423 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{NOTIFY\_STRING} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}3\textcolor{preprocessor}{)}      \textcolor{comment}{/* $ */}
00424 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{NOTIFY\_LIST} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}4\textcolor{preprocessor}{)}        \textcolor{comment}{/* l */}
00425 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{NOTIFY\_SET} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}5\textcolor{preprocessor}{)}         \textcolor{comment}{/* s */}
00426 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{NOTIFY\_HASH} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}6\textcolor{preprocessor}{)}        \textcolor{comment}{/* h */}
00427 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{NOTIFY\_ZSET} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}7\textcolor{preprocessor}{)}        \textcolor{comment}{/* z */}
00428 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{NOTIFY\_EXPIRED} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}8\textcolor{preprocessor}{)}     \textcolor{comment}{/* x */}
00429 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{NOTIFY\_EVICTED} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}9\textcolor{preprocessor}{)}     \textcolor{comment}{/* e */}
00430 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{NOTIFY\_STREAM} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}10\textcolor{preprocessor}{)}     \textcolor{comment}{/* t */}
00431 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{NOTIFY\_ALL} \textcolor{preprocessor}{(}\hyperlink{server_8h_a9fa53dd1068e62365f3964ad3479eec2}{NOTIFY\_GENERIC} \textcolor{preprocessor}{|} \hyperlink{server_8h_a1902292b73b71baa65d86db2d61b47ce}{NOTIFY\_STRING} \textcolor{preprocessor}{|} 
      \hyperlink{server_8h_a1c0b64c84b0e66dff3554ffe3e2ec4c8}{NOTIFY\_LIST} \textcolor{preprocessor}{|} \hyperlink{server_8h_a625aec945b2152a46979b1b21f2af274}{NOTIFY\_SET} \textcolor{preprocessor}{|} \hyperlink{server_8h_afe25ae13417e6fa5011e7efc69a34bc0}{NOTIFY\_HASH} \textcolor{preprocessor}{|} 
      \hyperlink{server_8h_ab8516a5a3ff1b9eb5f1cb303abef0d2f}{NOTIFY\_ZSET} \textcolor{preprocessor}{|} \hyperlink{server_8h_a6b6b55f4f6ffcd0b1648395fea5fafc1}{NOTIFY\_EXPIRED} \textcolor{preprocessor}{|} \hyperlink{server_8h_aefeeae0f3ac953537135a902b17bf63d}{NOTIFY\_EVICTED} \textcolor{preprocessor}{|} 
      \hyperlink{server_8h_a045eabb1c5cc4dd02abfbfbae1d27c84}{NOTIFY\_STREAM}\textcolor{preprocessor}{)} \textcolor{comment}{/* A flag */}
00432 
00433 \textcolor{comment}{/* Get the first bind addr or NULL */}
00434 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{NET\_FIRST\_BIND\_ADDR} \textcolor{preprocessor}{(}\textcolor{preprocessor}{server}\textcolor{preprocessor}{.}\textcolor{preprocessor}{bindaddr\_count} \textcolor{preprocessor}{?} \textcolor{preprocessor}{server}\textcolor{preprocessor}{.}\textcolor{preprocessor}{bindaddr}\textcolor{preprocessor}{[}0\textcolor{preprocessor}{]} \textcolor{preprocessor}{:} NULL\textcolor{preprocessor}{)}
00435 
00436 \textcolor{comment}{/* Using the following macro you can run code inside serverCron() with the}
00437 \textcolor{comment}{ * specified period, specified in milliseconds.}
00438 \textcolor{comment}{ * The actual resolution depends on server.hz. */}
00439 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{run\_with\_period}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_ms\_}\textcolor{preprocessor}{)} \textcolor{keywordflow}{if} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_ms\_} \textcolor{preprocessor}{<=} 1000\textcolor{preprocessor}{/}\textcolor{preprocessor}{server}\textcolor{preprocessor}{.}\textcolor{preprocessor}{hz}\textcolor{preprocessor}{)} \textcolor{preprocessor}{||} \textcolor{preprocessor}{!}\textcolor{preprocessor}{(}\textcolor{preprocessor}{server}\textcolor{preprocessor}{.}\textcolor{preprocessor}{cronloops}\textcolor{preprocessor}{%}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_ms\_}\textcolor{preprocessor}{)}\textcolor{preprocessor}{/}\textcolor{preprocessor}{(}1000\textcolor{preprocessor}{/}\textcolor{preprocessor}{server}\textcolor{preprocessor}{.}\textcolor{preprocessor}{
      hz}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00440 
00441 \textcolor{comment}{/* We can print the stacktrace, so our assert is defined this way: */}
00442 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{serverAssertWithInfo}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_c}\textcolor{preprocessor}{,}\textcolor{preprocessor}{\_o}\textcolor{preprocessor}{,}\textcolor{preprocessor}{\_e}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_e}\textcolor{preprocessor}{)}\textcolor{preprocessor}{?}\textcolor{preprocessor}{(}\textcolor{keywordtype}{void}\textcolor{preprocessor}{)}0 \textcolor{preprocessor}{:} \textcolor{preprocessor}{(}\textcolor{preprocessor}{\_serverAssertWithInfo}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_c}\textcolor{preprocessor}{,}\textcolor{preprocessor}{\_o}\textcolor{preprocessor}{,}\textcolor{preprocessor}{#}\textcolor{preprocessor}{\_e}\textcolor{preprocessor}{,}\textcolor{preprocessor}{\_\_FILE\_\_}\textcolor{preprocessor}{,}\textcolor{preprocessor}{
      \_\_LINE\_\_}\textcolor{preprocessor}{)}\textcolor{preprocessor}{,}\textcolor{preprocessor}{\_exit}\textcolor{preprocessor}{(}1\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00443 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{serverAssert}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_e}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_e}\textcolor{preprocessor}{)}\textcolor{preprocessor}{?}\textcolor{preprocessor}{(}\textcolor{keywordtype}{void}\textcolor{preprocessor}{)}0 \textcolor{preprocessor}{:} \textcolor{preprocessor}{(}\textcolor{preprocessor}{\_serverAssert}\textcolor{preprocessor}{(}\textcolor{preprocessor}{#}\textcolor{preprocessor}{\_e}\textcolor{preprocessor}{,}\textcolor{preprocessor}{\_\_FILE\_\_}\textcolor{preprocessor}{,}\textcolor{preprocessor}{\_\_LINE\_\_}\textcolor{preprocessor}{)}\textcolor{preprocessor}{,}\textcolor{preprocessor}{\_exit}\textcolor{preprocessor}{(}1\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00444 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{serverPanic}\textcolor{preprocessor}{(}\textcolor{preprocessor}{...}\textcolor{preprocessor}{)} \textcolor{preprocessor}{\_serverPanic}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_\_FILE\_\_}\textcolor{preprocessor}{,}\textcolor{preprocessor}{\_\_LINE\_\_}\textcolor{preprocessor}{,}\textcolor{preprocessor}{\_\_VA\_ARGS\_\_}\textcolor{preprocessor}{)}\textcolor{preprocessor}{,}\textcolor{preprocessor}{\_exit}\textcolor{preprocessor}{(}1\textcolor{preprocessor}{)}
00445 
00446 \textcolor{comment}{/*-----------------------------------------------------------------------------}
00447 \textcolor{comment}{ * Data types}
00448 \textcolor{comment}{ *----------------------------------------------------------------------------*/}
00449 
00450 \textcolor{comment}{/* A redis object, that is a type able to hold a string / list / set */}
00451 
00452 \textcolor{comment}{/* The actual Redis Object */}
00453 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_STRING} 0    \textcolor{comment}{/* String object. */}
00454 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_LIST} 1      \textcolor{comment}{/* List object. */}
00455 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_SET} 2       \textcolor{comment}{/* Set object. */}
00456 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_ZSET} 3      \textcolor{comment}{/* Sorted set object. */}
00457 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_HASH} 4      \textcolor{comment}{/* Hash object. */}
00458 
00459 \textcolor{comment}{/* The "module" object type is a special one that signals that the object}
00460 \textcolor{comment}{ * is one directly managed by a Redis module. In this case the value points}
00461 \textcolor{comment}{ * to a moduleValue struct, which contains the object value (which is only}
00462 \textcolor{comment}{ * handled by the module itself) and the RedisModuleType struct which lists}
00463 \textcolor{comment}{ * function pointers in order to serialize, deserialize, AOF-rewrite and}
00464 \textcolor{comment}{ * free the object.}
00465 \textcolor{comment}{ *}
00466 \textcolor{comment}{ * Inside the RDB file, module types are encoded as OBJ\_MODULE followed}
00467 \textcolor{comment}{ * by a 64 bit module type ID, which has a 54 bits module-specific signature}
00468 \textcolor{comment}{ * in order to dispatch the loading to the right module, plus a 10 bits}
00469 \textcolor{comment}{ * encoding version. */}
00470 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_MODULE} 5    \textcolor{comment}{/* Module object. */}
00471 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_STREAM} 6    \textcolor{comment}{/* Stream object. */}
00472 
00473 \textcolor{comment}{/* Extract encver / signature from a module type ID. */}
00474 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_TYPE\_ENCVER\_BITS} 10
00475 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_TYPE\_ENCVER\_MASK} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}\hyperlink{server_8h_a5169ce355f1de463c1f0ad1ee4e470b6}{REDISMODULE\_TYPE\_ENCVER\_BITS}\textcolor{preprocessor}{)}\textcolor{preprocessor}{-}1\textcolor{preprocessor}{)}
00476 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_TYPE\_ENCVER}\textcolor{preprocessor}{(}\textcolor{preprocessor}{id}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{id} \textcolor{preprocessor}{&} \hyperlink{server_8h_a49e0bc9132809103454a030074cde2da}{REDISMODULE\_TYPE\_ENCVER\_MASK}\textcolor{preprocessor}{)}
00477 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{REDISMODULE\_TYPE\_SIGN}\textcolor{preprocessor}{(}\textcolor{preprocessor}{id}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{id} \textcolor{preprocessor}{&} \textcolor{preprocessor}{~}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint64\_t}\textcolor{preprocessor}{)}
      \hyperlink{server_8h_a49e0bc9132809103454a030074cde2da}{REDISMODULE\_TYPE\_ENCVER\_MASK}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)} \textcolor{preprocessor}{>>}
      \hyperlink{server_8h_a5169ce355f1de463c1f0ad1ee4e470b6}{REDISMODULE\_TYPE\_ENCVER\_BITS}\textcolor{preprocessor}{)}
00478 
00479 \textcolor{keyword}{struct} \hyperlink{structRedisModule}{RedisModule};
00480 \textcolor{keyword}{struct} \hyperlink{structRedisModuleIO}{RedisModuleIO};
00481 \textcolor{keyword}{struct} \hyperlink{structRedisModuleDigest}{RedisModuleDigest};
00482 \textcolor{keyword}{struct} \hyperlink{structRedisModuleCtx}{RedisModuleCtx};
00483 \textcolor{keyword}{struct} \hyperlink{structredisObject}{redisObject};
00484 
00485 \textcolor{comment}{/* Each module type implementation should export a set of methods in order}
00486 \textcolor{comment}{ * to serialize and deserialize the value in the RDB file, rewrite the AOF}
00487 \textcolor{comment}{ * log, create the digest for "DEBUG DIGEST", and free the value when a key}
00488 \textcolor{comment}{ * is deleted. */}
00489 \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} *(*moduleTypeLoadFunc)(\textcolor{keyword}{struct} \hyperlink{structRedisModuleIO}{RedisModuleIO} *io, \textcolor{keywordtype}{int} encver);
00490 \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} (*moduleTypeSaveFunc)(\textcolor{keyword}{struct} \hyperlink{structRedisModuleIO}{RedisModuleIO} *io, \textcolor{keywordtype}{void} *value);
00491 \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} (*moduleTypeRewriteFunc)(\textcolor{keyword}{struct} \hyperlink{structRedisModuleIO}{RedisModuleIO} *io, \textcolor{keyword}{struct} 
      \hyperlink{structredisObject}{redisObject} *key, \textcolor{keywordtype}{void} *value);
00492 \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} (*moduleTypeDigestFunc)(\textcolor{keyword}{struct} \hyperlink{structRedisModuleDigest}{RedisModuleDigest} *digest, \textcolor{keywordtype}{void} *value);
00493 \textcolor{keyword}{typedef} size\_t (*moduleTypeMemUsageFunc)(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *value);
00494 \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} (*moduleTypeFreeFunc)(\textcolor{keywordtype}{void} *value);
00495 
00496 \textcolor{comment}{/* The module type, which is referenced in each value of a given type, defines}
00497 \textcolor{comment}{ * the methods and links to the module exporting the type. */}
\Hypertarget{server_8h_source_l00498}\hyperlink{structRedisModuleType}{00498} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structRedisModuleType}{RedisModuleType} \{
00499     uint64\_t id; \textcolor{comment}{/* Higher 54 bits of type ID + 10 lower bits of encoding ver. */}
00500     \textcolor{keyword}{struct} \hyperlink{structRedisModule}{RedisModule} *module;
00501     moduleTypeLoadFunc rdb\_load;
00502     moduleTypeSaveFunc rdb\_save;
00503     moduleTypeRewriteFunc aof\_rewrite;
00504     moduleTypeMemUsageFunc mem\_usage;
00505     moduleTypeDigestFunc digest;
00506     moduleTypeFreeFunc free;
00507     \textcolor{keywordtype}{char} name[10]; \textcolor{comment}{/* 9 bytes name + null term. Charset: A-Z a-z 0-9 \_- */}
00508 \} moduleType;
00509 
00510 \textcolor{comment}{/* In Redis objects 'robj' structures of type OBJ\_MODULE, the value pointer}
00511 \textcolor{comment}{ * is set to the following structure, referencing the moduleType structure}
00512 \textcolor{comment}{ * in order to work with the value, and at the same time providing a raw}
00513 \textcolor{comment}{ * pointer to the value, as created by the module commands operating with}
00514 \textcolor{comment}{ * the module type.}
00515 \textcolor{comment}{ *}
00516 \textcolor{comment}{ * So for example in order to free such a value, it is possible to use}
00517 \textcolor{comment}{ * the following code:}
00518 \textcolor{comment}{ *}
00519 \textcolor{comment}{ *  if (robj->type == OBJ\_MODULE) \{}
00520 \textcolor{comment}{ *      moduleValue *mt = robj->ptr;}
00521 \textcolor{comment}{ *      mt->type->free(mt->value);}
00522 \textcolor{comment}{ *      zfree(mt); // We need to release this in-the-middle struct as well.}
00523 \textcolor{comment}{ *  \}}
00524 \textcolor{comment}{ */}
\Hypertarget{server_8h_source_l00525}\hyperlink{structmoduleValue}{00525} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structmoduleValue}{moduleValue} \{
00526     moduleType *type;
00527     \textcolor{keywordtype}{void} *value;
00528 \} moduleValue;
00529 
00530 \textcolor{comment}{/* This is a wrapper for the 'rio' streams used inside rdb.c in Redis, so that}
00531 \textcolor{comment}{ * the user does not have to take the total count of the written bytes nor}
00532 \textcolor{comment}{ * to care about error conditions. */}
\Hypertarget{server_8h_source_l00533}\hyperlink{structRedisModuleIO}{00533} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structRedisModuleIO}{RedisModuleIO} \{
00534     size\_t bytes;       \textcolor{comment}{/* Bytes read / written so far. */}
00535     rio *rio;           \textcolor{comment}{/* Rio stream. */}
00536     moduleType *type;   \textcolor{comment}{/* Module type doing the operation. */}
00537     \textcolor{keywordtype}{int} error;          \textcolor{comment}{/* True if error condition happened. */}
00538     \textcolor{keywordtype}{int} ver;            \textcolor{comment}{/* Module serialization version: 1 (old),}
00539 \textcolor{comment}{                         * 2 (current version with opcodes annotation). */}
00540     \textcolor{keyword}{struct} \hyperlink{structRedisModuleCtx}{RedisModuleCtx} *ctx; \textcolor{comment}{/* Optional context, see RM\_GetContextFromIO()*/}
00541 \} RedisModuleIO;
00542 
00543 \textcolor{comment}{/* Macro to initialize an IO context. Note that the 'ver' field is populated}
00544 \textcolor{comment}{ * inside rdb.c according to the version of the value to load. */}
00545 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{moduleInitIOContext}\textcolor{preprocessor}{(}\textcolor{preprocessor}{iovar}\textcolor{preprocessor}{,}\textcolor{preprocessor}{mtype}\textcolor{preprocessor}{,}\textcolor{preprocessor}{rioptr}\textcolor{preprocessor}{)} \textcolor{keywordflow}{do} \textcolor{preprocessor}{\{}
00546     \textcolor{preprocessor}{iovar}\textcolor{preprocessor}{.}\textcolor{preprocessor}{rio} \textcolor{preprocessor}{=} \textcolor{preprocessor}{rioptr}\textcolor{preprocessor}{;}
00547     \textcolor{preprocessor}{iovar}\textcolor{preprocessor}{.}\textcolor{preprocessor}{type} \textcolor{preprocessor}{=} \textcolor{preprocessor}{mtype}\textcolor{preprocessor}{;}
00548     \textcolor{preprocessor}{iovar}\textcolor{preprocessor}{.}\textcolor{preprocessor}{bytes} \textcolor{preprocessor}{=} 0\textcolor{preprocessor}{;}
00549     \textcolor{preprocessor}{iovar}\textcolor{preprocessor}{.}\textcolor{preprocessor}{error} \textcolor{preprocessor}{=} 0\textcolor{preprocessor}{;}
00550     \textcolor{preprocessor}{iovar}\textcolor{preprocessor}{.}\textcolor{preprocessor}{ver} \textcolor{preprocessor}{=} 0\textcolor{preprocessor}{;}
00551     \textcolor{preprocessor}{iovar}\textcolor{preprocessor}{.}\textcolor{preprocessor}{ctx} \textcolor{preprocessor}{=} NULL\textcolor{preprocessor}{;} \textcolor{preprocessor}{\(\backslash\)}
00552 \textcolor{preprocessor}{\}}\textcolor{keywordflow}{while}\textcolor{preprocessor}{(}0\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
00553 
00554 \textcolor{comment}{/* This is a structure used to export DEBUG DIGEST capabilities to Redis}
00555 \textcolor{comment}{ * modules. We want to capture both the ordered and unordered elements of}
00556 \textcolor{comment}{ * a data structure, so that a digest can be created in a way that correctly}
00557 \textcolor{comment}{ * reflects the values. See the DEBUG DIGEST command implementation for more}
00558 \textcolor{comment}{ * background. */}
\Hypertarget{server_8h_source_l00559}\hyperlink{structRedisModuleDigest}{00559} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structRedisModuleDigest}{RedisModuleDigest} \{
00560     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} o[20];    \textcolor{comment}{/* Ordered elements. */}
00561     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} x[20];    \textcolor{comment}{/* Xored elements. */}
00562 \} RedisModuleDigest;
00563 
00564 \textcolor{comment}{/* Just start with a digest composed of all zero bytes. */}
00565 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{moduleInitDigestContext}\textcolor{preprocessor}{(}\textcolor{preprocessor}{mdvar}\textcolor{preprocessor}{)} \textcolor{keywordflow}{do} \textcolor{preprocessor}{\{}
00566     \textcolor{preprocessor}{memset}\textcolor{preprocessor}{(}\textcolor{preprocessor}{mdvar}\textcolor{preprocessor}{.}\textcolor{preprocessor}{o}\textcolor{preprocessor}{,}0\textcolor{preprocessor}{,}\textcolor{keyword}{sizeof}\textcolor{preprocessor}{(}\textcolor{preprocessor}{mdvar}\textcolor{preprocessor}{.}\textcolor{preprocessor}{o}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
00567     \textcolor{preprocessor}{memset}\textcolor{preprocessor}{(}\textcolor{preprocessor}{mdvar}\textcolor{preprocessor}{.}\textcolor{preprocessor}{x}\textcolor{preprocessor}{,}0\textcolor{preprocessor}{,}\textcolor{keyword}{sizeof}\textcolor{preprocessor}{(}\textcolor{preprocessor}{mdvar}\textcolor{preprocessor}{.}\textcolor{preprocessor}{x}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}\textcolor{preprocessor}{;} \textcolor{preprocessor}{\(\backslash\)}
00568 \textcolor{preprocessor}{\}}\textcolor{keywordflow}{while}\textcolor{preprocessor}{(}0\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
00569 
00570 \textcolor{comment}{/* Objects encoding. Some kind of objects like Strings and Hashes can be}
00571 \textcolor{comment}{ * internally represented in multiple ways. The 'encoding' field of the object}
00572 \textcolor{comment}{ * is set to one of this fields for this object. */}
00573 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_ENCODING\_RAW} 0     \textcolor{comment}{/* Raw representation */}
00574 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_ENCODING\_INT} 1     \textcolor{comment}{/* Encoded as integer */}
00575 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_ENCODING\_HT} 2      \textcolor{comment}{/* Encoded as hash table */}
00576 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_ENCODING\_ZIPMAP} 3  \textcolor{comment}{/* Encoded as zipmap */}
00577 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_ENCODING\_LINKEDLIST} 4 \textcolor{comment}{/* No longer used: old list encoding. */}
00578 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_ENCODING\_ZIPLIST} 5 \textcolor{comment}{/* Encoded as ziplist */}
00579 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_ENCODING\_INTSET} 6  \textcolor{comment}{/* Encoded as intset */}
00580 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_ENCODING\_SKIPLIST} 7  \textcolor{comment}{/* Encoded as skiplist */}
00581 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_ENCODING\_EMBSTR} 8  \textcolor{comment}{/* Embedded sds string encoding */}
00582 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_ENCODING\_QUICKLIST} 9 \textcolor{comment}{/* Encoded as linked list of ziplists */}
00583 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_ENCODING\_STREAM} 10 \textcolor{comment}{/* Encoded as a radix tree of listpacks */}
00584 
00585 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LRU\_BITS} 24
00586 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LRU\_CLOCK\_MAX} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}\hyperlink{server_8h_ae839804d2b5fd0b2a83eb05e820079f3}{LRU\_BITS}\textcolor{preprocessor}{)}\textcolor{preprocessor}{-}1\textcolor{preprocessor}{)} \textcolor{comment}{/* Max value of obj->lru */}
00587 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LRU\_CLOCK\_RESOLUTION} 1000 \textcolor{comment}{/* LRU clock resolution in ms */}
00588 
00589 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_SHARED\_REFCOUNT} \textcolor{preprocessor}{INT\_MAX}
\Hypertarget{server_8h_source_l00590}\hyperlink{structredisObject}{00590} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structredisObject}{redisObject} \{
00591     \textcolor{keywordtype}{unsigned} type:4;
00592     \textcolor{keywordtype}{unsigned} encoding:4;
00593     \textcolor{keywordtype}{unsigned} lru:\hyperlink{server_8h_ae839804d2b5fd0b2a83eb05e820079f3}{LRU\_BITS}; \textcolor{comment}{/* LRU time (relative to global lru\_clock) or}
00594 \textcolor{comment}{                            * LFU data (least significant 8 bits frequency}
00595 \textcolor{comment}{                            * and most significant 16 bits access time). */}
00596     \textcolor{keywordtype}{int} refcount;
00597     \textcolor{keywordtype}{void} *ptr;
00598 \} robj;
00599 
00600 \textcolor{comment}{/* Macro used to initialize a Redis object allocated on the stack.}
00601 \textcolor{comment}{ * Note that this macro is taken near the structure definition to make sure}
00602 \textcolor{comment}{ * we'll update it when the structure is changed, to avoid bugs like}
00603 \textcolor{comment}{ * bug #85 introduced exactly in this way. */}
00604 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{initStaticStringObject}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_var}\textcolor{preprocessor}{,}\textcolor{preprocessor}{\_ptr}\textcolor{preprocessor}{)} \textcolor{keywordflow}{do} \textcolor{preprocessor}{\{}
00605     \textcolor{preprocessor}{\_var}\textcolor{preprocessor}{.}\textcolor{preprocessor}{refcount} \textcolor{preprocessor}{=} 1\textcolor{preprocessor}{;}
00606     \textcolor{preprocessor}{\_var}\textcolor{preprocessor}{.}\textcolor{preprocessor}{type} \textcolor{preprocessor}{=} \hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING}\textcolor{preprocessor}{;}
00607     \textcolor{preprocessor}{\_var}\textcolor{preprocessor}{.}\textcolor{preprocessor}{encoding} \textcolor{preprocessor}{=} \hyperlink{server_8h_a148bc85e3074e324a6dc5eebcad1bcd5}{OBJ\_ENCODING\_RAW}\textcolor{preprocessor}{;}
00608     \textcolor{preprocessor}{\_var}\textcolor{preprocessor}{.}\textcolor{preprocessor}{ptr} \textcolor{preprocessor}{=} \textcolor{preprocessor}{\_ptr}\textcolor{preprocessor}{;} \textcolor{preprocessor}{\(\backslash\)}
00609 \textcolor{preprocessor}{\}}\textcolor{keywordflow}{while}\textcolor{preprocessor}{(}0\textcolor{preprocessor}{)}
00610 
00611 \textcolor{keyword}{struct} \hyperlink{structevictionPoolEntry}{evictionPoolEntry}; \textcolor{comment}{/* Defined in evict.c */}
00612 
00613 \textcolor{comment}{/* Redis database representation. There are multiple databases identified}
00614 \textcolor{comment}{ * by integers from 0 (the default database) up to the max configured}
00615 \textcolor{comment}{ * database. The database number is the 'id' field in the structure. */}
\Hypertarget{server_8h_source_l00616}\hyperlink{structredisDb}{00616} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structredisDb}{redisDb} \{
00617     dict *dict;                 \textcolor{comment}{/* The keyspace for this DB */}
00618     \hyperlink{structdict}{dict} *expires;              \textcolor{comment}{/* Timeout of keys with a timeout set */}
00619     \hyperlink{structdict}{dict} *blocking\_keys;        \textcolor{comment}{/* Keys with clients waiting for data (BLPOP)*/}
00620     \hyperlink{structdict}{dict} *ready\_keys;           \textcolor{comment}{/* Blocked keys that received a PUSH */}
00621     \hyperlink{structdict}{dict} *watched\_keys;         \textcolor{comment}{/* WATCHED keys for MULTI/EXEC CAS */}
00622     \textcolor{keywordtype}{int} id;                     \textcolor{comment}{/* Database ID */}
00623     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} avg\_ttl;          \textcolor{comment}{/* Average TTL, just for stats */}
00624 \} redisDb;
00625 
00626 \textcolor{comment}{/* Client MULTI/EXEC state */}
\Hypertarget{server_8h_source_l00627}\hyperlink{structmultiCmd}{00627} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structmultiCmd}{multiCmd} \{
00628     robj **argv;
00629     \textcolor{keywordtype}{int} argc;
00630     \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd;
00631 \} multiCmd;
00632 
\Hypertarget{server_8h_source_l00633}\hyperlink{structmultiState}{00633} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structmultiState}{multiState} \{
00634     multiCmd *commands;     \textcolor{comment}{/* Array of MULTI commands */}
00635     \textcolor{keywordtype}{int} count;              \textcolor{comment}{/* Total number of MULTI commands */}
00636     \textcolor{keywordtype}{int} minreplicas;        \textcolor{comment}{/* MINREPLICAS for synchronous replication */}
00637     time\_t minreplicas\_timeout; \textcolor{comment}{/* MINREPLICAS timeout as unixtime. */}
00638 \} multiState;
00639 
00640 \textcolor{comment}{/* This structure holds the blocking operation state for a client.}
00641 \textcolor{comment}{ * The fields used depend on client->btype. */}
\Hypertarget{server_8h_source_l00642}\hyperlink{structblockingState}{00642} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structblockingState}{blockingState} \{
00643     \textcolor{comment}{/* Generic fields. */}
00644     mstime\_t timeout;       \textcolor{comment}{/* Blocking operation timeout. If UNIX current time}
00645 \textcolor{comment}{                             * is > timeout then the operation timed out. */}
00646 
00647     \textcolor{comment}{/* BLOCKED\_LIST and BLOCKED\_STREAM */}
00648     dict *keys;             \textcolor{comment}{/* The keys we are waiting to terminate a blocking}
00649 \textcolor{comment}{                             * operation such as BLPOP or XREAD. Or NULL. */}
00650     robj *target;           \textcolor{comment}{/* The key that should receive the element,}
00651 \textcolor{comment}{                             * for BRPOPLPUSH. */}
00652 
00653     \textcolor{comment}{/* BLOCK\_STREAM */}
00654     size\_t xread\_count;     \textcolor{comment}{/* XREAD COUNT option. */}
00655     robj *xread\_group;      \textcolor{comment}{/* XREAD group name. */}
00656     mstime\_t xread\_retry\_time, xread\_retry\_ttl;
00657 
00658     \textcolor{comment}{/* BLOCKED\_WAIT */}
00659     \textcolor{keywordtype}{int} numreplicas;        \textcolor{comment}{/* Number of replicas we are waiting for ACK. */}
00660     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} reploffset;   \textcolor{comment}{/* Replication offset to reach. */}
00661 
00662     \textcolor{comment}{/* BLOCKED\_MODULE */}
00663     \textcolor{keywordtype}{void} *module\_blocked\_handle; \textcolor{comment}{/* RedisModuleBlockedClient structure.}
00664 \textcolor{comment}{                                    which is opaque for the Redis core, only}
00665 \textcolor{comment}{                                    handled in module.c. */}
00666 \} blockingState;
00667 
00668 \textcolor{comment}{/* The following structure represents a node in the server.ready\_keys list,}
00669 \textcolor{comment}{ * where we accumulate all the keys that had clients blocked with a blocking}
00670 \textcolor{comment}{ * operation such as B[LR]POP, but received new data in the context of the}
00671 \textcolor{comment}{ * last executed command.}
00672 \textcolor{comment}{ *}
00673 \textcolor{comment}{ * After the execution of every command or script, we run this list to check}
00674 \textcolor{comment}{ * if as a result we should serve data to clients blocked, unblocking them.}
00675 \textcolor{comment}{ * Note that server.ready\_keys will not have duplicates as there dictionary}
00676 \textcolor{comment}{ * also called ready\_keys in every structure representing a Redis database,}
00677 \textcolor{comment}{ * where we make sure to remember if a given key was already added in the}
00678 \textcolor{comment}{ * server.ready\_keys list. */}
\Hypertarget{server_8h_source_l00679}\hyperlink{structreadyList}{00679} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structreadyList}{readyList} \{
00680     redisDb *db;
00681     robj *key;
00682 \} readyList;
00683 
00684 \textcolor{comment}{/* With multiplexing we need to take per-client state.}
00685 \textcolor{comment}{ * Clients are taken in a linked list. */}
\Hypertarget{server_8h_source_l00686}\hyperlink{structclient}{00686} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structclient}{client} \{
00687     uint64\_t id;            \textcolor{comment}{/* Client incremental unique ID. */}
00688     \textcolor{keywordtype}{int} fd;                 \textcolor{comment}{/* Client socket. */}
00689     redisDb *db;            \textcolor{comment}{/* Pointer to currently SELECTed DB. */}
00690     robj *name;             \textcolor{comment}{/* As set by CLIENT SETNAME. */}
00691     sds querybuf;           \textcolor{comment}{/* Buffer we use to accumulate client queries. */}
00692     sds pending\_querybuf;   \textcolor{comment}{/* If this is a master, this buffer represents the}
00693 \textcolor{comment}{                               yet not applied replication stream that we}
00694 \textcolor{comment}{                               are receiving from the master. */}
00695     size\_t querybuf\_peak;   \textcolor{comment}{/* Recent (100ms or more) peak of querybuf size. */}
00696     \textcolor{keywordtype}{int} argc;               \textcolor{comment}{/* Num of arguments of current command. */}
00697     robj **argv;            \textcolor{comment}{/* Arguments of current command. */}
00698     \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, *lastcmd;  \textcolor{comment}{/* Last command executed. */}
00699     \textcolor{keywordtype}{int} reqtype;            \textcolor{comment}{/* Request protocol type: PROTO\_REQ\_* */}
00700     \textcolor{keywordtype}{int} multibulklen;       \textcolor{comment}{/* Number of multi bulk arguments left to read. */}
00701     \textcolor{keywordtype}{long} bulklen;           \textcolor{comment}{/* Length of bulk argument in multi bulk request. */}
00702     list *reply;            \textcolor{comment}{/* List of reply objects to send to the client. */}
00703     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} reply\_bytes; \textcolor{comment}{/* Tot bytes of objects in reply list. */}
00704     size\_t sentlen;         \textcolor{comment}{/* Amount of bytes already sent in the current}
00705 \textcolor{comment}{                               buffer or object being sent. */}
00706     time\_t ctime;           \textcolor{comment}{/* Client creation time. */}
00707     time\_t lastinteraction; \textcolor{comment}{/* Time of the last interaction, used for timeout */}
00708     time\_t obuf\_soft\_limit\_reached\_time;
00709     \textcolor{keywordtype}{int} flags;              \textcolor{comment}{/* Client flags: CLIENT\_* macros. */}
00710     \textcolor{keywordtype}{int} authenticated;      \textcolor{comment}{/* When requirepass is non-NULL. */}
00711     \textcolor{keywordtype}{int} replstate;          \textcolor{comment}{/* Replication state if this is a slave. */}
00712     \textcolor{keywordtype}{int} repl\_put\_online\_on\_ack; \textcolor{comment}{/* Install slave write handler on ACK. */}
00713     \textcolor{keywordtype}{int} repldbfd;           \textcolor{comment}{/* Replication DB file descriptor. */}
00714     off\_t repldboff;        \textcolor{comment}{/* Replication DB file offset. */}
00715     off\_t repldbsize;       \textcolor{comment}{/* Replication DB file size. */}
00716     sds replpreamble;       \textcolor{comment}{/* Replication DB preamble. */}
00717     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} read\_reploff; \textcolor{comment}{/* Read replication offset if this is a master. */}
00718     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} reploff;      \textcolor{comment}{/* Applied replication offset if this is a master. */}
00719     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} repl\_ack\_off; \textcolor{comment}{/* Replication ack offset, if this is a slave. */}
00720     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} repl\_ack\_time;\textcolor{comment}{/* Replication ack time, if this is a slave. */}
00721     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} psync\_initial\_offset; \textcolor{comment}{/* FULLRESYNC reply offset other slaves}
00722 \textcolor{comment}{                                       copying this slave output buffer}
00723 \textcolor{comment}{                                       should use. */}
00724     \textcolor{keywordtype}{char} replid[\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}+1]; \textcolor{comment}{/* Master replication ID (if master). */}
00725     \textcolor{keywordtype}{int} slave\_listening\_port; \textcolor{comment}{/* As configured with: SLAVECONF listening-port */}
00726     \textcolor{keywordtype}{char} slave\_ip[\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN}]; \textcolor{comment}{/* Optionally given by REPLCONF ip-address */}
00727     \textcolor{keywordtype}{int} slave\_capa;         \textcolor{comment}{/* Slave capabilities: SLAVE\_CAPA\_* bitwise OR. */}
00728     multiState mstate;      \textcolor{comment}{/* MULTI/EXEC state */}
00729     \textcolor{keywordtype}{int} btype;              \textcolor{comment}{/* Type of blocking op if CLIENT\_BLOCKED. */}
00730     \hyperlink{structblockingState}{blockingState} bpop;     \textcolor{comment}{/* blocking state */}
00731     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} woff;         \textcolor{comment}{/* Last write global replication offset. */}
00732     list *watched\_keys;     \textcolor{comment}{/* Keys WATCHED for MULTI/EXEC CAS */}
00733     dict *pubsub\_channels;  \textcolor{comment}{/* channels a client is interested in (SUBSCRIBE) */}
00734     list *pubsub\_patterns;  \textcolor{comment}{/* patterns a client is interested in (SUBSCRIBE) */}
00735     sds peerid;             \textcolor{comment}{/* Cached peer ID. */}
00736     listNode *client\_list\_node; \textcolor{comment}{/* list node in client list */}
00737 
00738     \textcolor{comment}{/* Response buffer */}
00739     \textcolor{keywordtype}{int} bufpos;
00740     \textcolor{keywordtype}{char} buf[\hyperlink{server_8h_ab467e0a40be9097e85445616d9bb32e3}{PROTO\_REPLY\_CHUNK\_BYTES}];
00741 \} client;
00742 
\Hypertarget{server_8h_source_l00743}\hyperlink{structsaveparam}{00743} \textcolor{keyword}{struct} \hyperlink{structsaveparam}{saveparam} \{
00744     time\_t seconds;
00745     \textcolor{keywordtype}{int} changes;
00746 \};
00747 
\Hypertarget{server_8h_source_l00748}\hyperlink{structmoduleLoadQueueEntry}{00748} \textcolor{keyword}{struct} \hyperlink{structmoduleLoadQueueEntry}{moduleLoadQueueEntry} \{
00749     sds path;
00750     \textcolor{keywordtype}{int} argc;
00751     robj **argv;
00752 \};
00753 
\Hypertarget{server_8h_source_l00754}\hyperlink{structsharedObjectsStruct}{00754} \textcolor{keyword}{struct} \hyperlink{structsharedObjectsStruct}{sharedObjectsStruct} \{
00755     robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,
00756     *colon, *nullbulk, *nullmultibulk, *queued,
00757     *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,
00758     *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,
00759     *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,
00760     *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,
00761     *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,
00762     *rpop, *lpop, *lpush, *emptyscan,
00763     *select[\hyperlink{server_8h_a950a6acbe9809f9e3dc541e8175b7b44}{PROTO\_SHARED\_SELECT\_CMDS}],
00764     *integers[\hyperlink{server_8h_a311fc8b18b93af94e1ad418f1386b519}{OBJ\_SHARED\_INTEGERS}],
00765     *mbulkhdr[\hyperlink{server_8h_aff2f6e62c729d3f8b119d761818be317}{OBJ\_SHARED\_BULKHDR\_LEN}], \textcolor{comment}{/* "*<value>\(\backslash\)r\(\backslash\)n" */}
00766     *bulkhdr[\hyperlink{server_8h_aff2f6e62c729d3f8b119d761818be317}{OBJ\_SHARED\_BULKHDR\_LEN}];  \textcolor{comment}{/* "$<value>\(\backslash\)r\(\backslash\)n" */}
00767     sds minstring, maxstring;
00768 \};
00769 
00770 \textcolor{comment}{/* ZSETs use a specialized version of Skiplists */}
\Hypertarget{server_8h_source_l00771}\hyperlink{structzskiplistNode}{00771} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structzskiplistNode}{zskiplistNode} \{
00772     sds ele;
00773     \textcolor{keywordtype}{double} score;
00774     \textcolor{keyword}{struct} \hyperlink{structzskiplistNode}{zskiplistNode} *backward;
\Hypertarget{server_8h_source_l00775}\hyperlink{structzskiplistNode_structzskiplistNode_1_1zskiplistLevel}{00775}     \textcolor{keyword}{struct} \hyperlink{structzskiplistNode_structzskiplistNode_1_1zskiplistLevel}{zskiplistLevel} \{
00776         \textcolor{keyword}{struct} \hyperlink{structzskiplistNode}{zskiplistNode} *forward;
00777         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} span;
00778     \} level[];
00779 \} zskiplistNode;
00780 
\Hypertarget{server_8h_source_l00781}\hyperlink{structzskiplist}{00781} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structzskiplist}{zskiplist} \{
00782     \textcolor{keyword}{struct} \hyperlink{structzskiplistNode}{zskiplistNode} *header, *tail;
00783     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} length;
00784     \textcolor{keywordtype}{int} level;
00785 \} zskiplist;
00786 
\Hypertarget{server_8h_source_l00787}\hyperlink{structzset}{00787} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structzset}{zset} \{
00788     dict *dict;
00789     zskiplist *zsl;
00790 \} zset;
00791 
\Hypertarget{server_8h_source_l00792}\hyperlink{structclientBufferLimitsConfig}{00792} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structclientBufferLimitsConfig}{clientBufferLimitsConfig} \{
00793     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} hard\_limit\_bytes;
00794     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} soft\_limit\_bytes;
00795     time\_t soft\_limit\_seconds;
00796 \} clientBufferLimitsConfig;
00797 
00798 \textcolor{keyword}{extern} clientBufferLimitsConfig clientBufferLimitsDefaults[
      \hyperlink{server_8h_aea8f6f3fac3a68e35807eba109dbc501}{CLIENT\_TYPE\_OBUF\_COUNT}];
00799 
00800 \textcolor{comment}{/* The redisOp structure defines a Redis Operation, that is an instance of}
00801 \textcolor{comment}{ * a command with an argument vector, database ID, propagation target}
00802 \textcolor{comment}{ * (PROPAGATE\_*), and command pointer.}
00803 \textcolor{comment}{ *}
00804 \textcolor{comment}{ * Currently only used to additionally propagate more commands to AOF/Replication}
00805 \textcolor{comment}{ * after the propagation of the executed command. */}
\Hypertarget{server_8h_source_l00806}\hyperlink{structredisOp}{00806} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structredisOp}{redisOp} \{
00807     robj **argv;
00808     \textcolor{keywordtype}{int} argc, dbid, target;
00809     \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd;
00810 \} redisOp;
00811 
00812 \textcolor{comment}{/* Defines an array of Redis operations. There is an API to add to this}
00813 \textcolor{comment}{ * structure in a easy way.}
00814 \textcolor{comment}{ *}
00815 \textcolor{comment}{ * redisOpArrayInit();}
00816 \textcolor{comment}{ * redisOpArrayAppend();}
00817 \textcolor{comment}{ * redisOpArrayFree();}
00818 \textcolor{comment}{ */}
\Hypertarget{server_8h_source_l00819}\hyperlink{structredisOpArray}{00819} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structredisOpArray}{redisOpArray} \{
00820     redisOp *ops;
00821     \textcolor{keywordtype}{int} numops;
00822 \} redisOpArray;
00823 
00824 \textcolor{comment}{/* This structure is returned by the getMemoryOverheadData() function in}
00825 \textcolor{comment}{ * order to return memory overhead information. */}
\Hypertarget{server_8h_source_l00826}\hyperlink{structredisMemOverhead}{00826} \textcolor{keyword}{struct} \hyperlink{structredisMemOverhead}{redisMemOverhead} \{
00827     size\_t peak\_allocated;
00828     size\_t total\_allocated;
00829     size\_t startup\_allocated;
00830     size\_t repl\_backlog;
00831     size\_t clients\_slaves;
00832     size\_t clients\_normal;
00833     size\_t aof\_buffer;
00834     size\_t overhead\_total;
00835     size\_t dataset;
00836     size\_t total\_keys;
00837     size\_t bytes\_per\_key;
00838     \textcolor{keywordtype}{float} dataset\_perc;
00839     \textcolor{keywordtype}{float} peak\_perc;
00840     \textcolor{keywordtype}{float} fragmentation;
00841     size\_t num\_dbs;
\Hypertarget{server_8h_source_l00842}\hyperlink{structredisMemOverhead_8db}{00842}     \textcolor{keyword}{struct} \{
00843         size\_t dbid;
00844         size\_t overhead\_ht\_main;
00845         size\_t overhead\_ht\_expires;
00846     \} *db;
00847 \};
00848 
00849 \textcolor{comment}{/* This structure can be optionally passed to RDB save/load functions in}
00850 \textcolor{comment}{ * order to implement additional functionalities, by storing and loading}
00851 \textcolor{comment}{ * metadata to the RDB file.}
00852 \textcolor{comment}{ *}
00853 \textcolor{comment}{ * Currently the only use is to select a DB at load time, useful in}
00854 \textcolor{comment}{ * replication in order to make sure that chained slaves (slaves of slaves)}
00855 \textcolor{comment}{ * select the correct DB and are able to accept the stream coming from the}
00856 \textcolor{comment}{ * top-level master. */}
\Hypertarget{server_8h_source_l00857}\hyperlink{structrdbSaveInfo}{00857} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structrdbSaveInfo}{rdbSaveInfo} \{
00858     \textcolor{comment}{/* Used saving and loading. */}
00859     \textcolor{keywordtype}{int} repl\_stream\_db;  \textcolor{comment}{/* DB to select in server.master client. */}
00860 
00861     \textcolor{comment}{/* Used only loading. */}
00862     \textcolor{keywordtype}{int} repl\_id\_is\_set;  \textcolor{comment}{/* True if repl\_id field is set. */}
00863     \textcolor{keywordtype}{char} repl\_id[\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}+1];     \textcolor{comment}{/* Replication ID. */}
00864     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} repl\_offset;                  \textcolor{comment}{/* Replication offset. */}
00865 \} rdbSaveInfo;
00866 
00867 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{RDB\_SAVE\_INFO\_INIT} \textcolor{preprocessor}{\{}\textcolor{preprocessor}{-}1\textcolor{preprocessor}{,}0\textcolor{preprocessor}{,}\textcolor{stringliteral}{"000000000000000000000000000000"}\textcolor{preprocessor}{,}\textcolor{preprocessor}{-}1\textcolor{preprocessor}{\}}
00868 
00869 \textcolor{comment}{/*-----------------------------------------------------------------------------}
00870 \textcolor{comment}{ * Global server state}
00871 \textcolor{comment}{ *----------------------------------------------------------------------------*/}
00872 
00873 \textcolor{keyword}{struct} \hyperlink{structclusterState}{clusterState};
00874 
00875 \textcolor{comment}{/* AIX defines hz to \_\_hz, we don't use this define and in order to allow}
00876 \textcolor{comment}{ * Redis build on AIX we need to undef it. */}
00877 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \textcolor{preprocessor}{\_AIX}
00878 \textcolor{preprocessor}{#}\textcolor{preprocessor}{undef} \textcolor{preprocessor}{hz}
00879 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
00880 
00881 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CHILD\_INFO\_MAGIC} 0xC17DDA7A12345678LL
00882 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CHILD\_INFO\_TYPE\_RDB} 0
00883 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CHILD\_INFO\_TYPE\_AOF} 1
00884 
\Hypertarget{server_8h_source_l00885}\hyperlink{structredisServer}{00885} \textcolor{keyword}{struct} \hyperlink{structredisServer}{redisServer} \{
00886     \textcolor{comment}{/* General */}
00887     pid\_t pid;                  \textcolor{comment}{/* Main process pid. */}
00888     \textcolor{keywordtype}{char} *configfile;           \textcolor{comment}{/* Absolute config file path, or NULL */}
00889     \textcolor{keywordtype}{char} *executable;           \textcolor{comment}{/* Absolute executable file path. */}
00890     \textcolor{keywordtype}{char} **exec\_argv;           \textcolor{comment}{/* Executable argv vector (copy). */}
00891     \textcolor{keywordtype}{int} hz;                     \textcolor{comment}{/* serverCron() calls frequency in hertz */}
00892     redisDb *db;
00893     dict *commands;             \textcolor{comment}{/* Command table */}
00894     dict *orig\_commands;        \textcolor{comment}{/* Command table before command renaming. */}
00895     aeEventLoop *el;
00896     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} lruclock;      \textcolor{comment}{/* Clock for LRU eviction */}
00897     \textcolor{keywordtype}{int} shutdown\_asap;          \textcolor{comment}{/* SHUTDOWN needed ASAP */}
00898     \textcolor{keywordtype}{int} activerehashing;        \textcolor{comment}{/* Incremental rehash in serverCron() */}
00899     \textcolor{keywordtype}{int} active\_defrag\_running;  \textcolor{comment}{/* Active defragmentation running (holds current scan aggressiveness)
       */}
00900     \textcolor{keywordtype}{char} *requirepass;          \textcolor{comment}{/* Pass for AUTH command, or NULL */}
00901     \textcolor{keywordtype}{char} *pidfile;              \textcolor{comment}{/* PID file path */}
00902     \textcolor{keywordtype}{int} arch\_bits;              \textcolor{comment}{/* 32 or 64 depending on sizeof(long) */}
00903     \textcolor{keywordtype}{int} cronloops;              \textcolor{comment}{/* Number of times the cron function run */}
00904     \textcolor{keywordtype}{char} runid[\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}+1];  \textcolor{comment}{/* ID always different at every exec. */}
00905     \textcolor{keywordtype}{int} sentinel\_mode;          \textcolor{comment}{/* True if this instance is a Sentinel. */}
00906     size\_t initial\_memory\_usage; \textcolor{comment}{/* Bytes used after initialization. */}
00907     \textcolor{keywordtype}{int} always\_show\_logo;       \textcolor{comment}{/* Show logo even for non-stdout logging. */}
00908     \textcolor{comment}{/* Modules */}
00909     dict *moduleapi;            \textcolor{comment}{/* Exported APIs dictionary for modules. */}
00910     list *loadmodule\_queue;     \textcolor{comment}{/* List of modules to load at startup. */}
00911     \textcolor{keywordtype}{int} module\_blocked\_pipe[2]; \textcolor{comment}{/* Pipe used to awake the event loop if a}
00912 \textcolor{comment}{                                   client blocked on a module command needs}
00913 \textcolor{comment}{                                   to be processed. */}
00914     \textcolor{comment}{/* Networking */}
00915     \textcolor{keywordtype}{int} port;                   \textcolor{comment}{/* TCP listening port */}
00916     \textcolor{keywordtype}{int} tcp\_backlog;            \textcolor{comment}{/* TCP listen() backlog */}
00917     \textcolor{keywordtype}{char} *bindaddr[\hyperlink{server_8h_a314d02fcabccac3e59ecaa9d34f0d597}{CONFIG\_BINDADDR\_MAX}]; \textcolor{comment}{/* Addresses we should bind to */}
00918     \textcolor{keywordtype}{int} bindaddr\_count;         \textcolor{comment}{/* Number of addresses in server.bindaddr[] */}
00919     \textcolor{keywordtype}{char} *unixsocket;           \textcolor{comment}{/* UNIX socket path */}
00920     mode\_t unixsocketperm;      \textcolor{comment}{/* UNIX socket permission */}
00921     \textcolor{keywordtype}{int} ipfd[\hyperlink{server_8h_a314d02fcabccac3e59ecaa9d34f0d597}{CONFIG\_BINDADDR\_MAX}]; \textcolor{comment}{/* TCP socket file descriptors */}
00922     \textcolor{keywordtype}{int} ipfd\_count;             \textcolor{comment}{/* Used slots in ipfd[] */}
00923     \textcolor{keywordtype}{int} sofd;                   \textcolor{comment}{/* Unix socket file descriptor */}
00924     \textcolor{keywordtype}{int} cfd[\hyperlink{server_8h_a314d02fcabccac3e59ecaa9d34f0d597}{CONFIG\_BINDADDR\_MAX}];\textcolor{comment}{/* Cluster bus listening socket */}
00925     \textcolor{keywordtype}{int} cfd\_count;              \textcolor{comment}{/* Used slots in cfd[] */}
00926     list *clients;              \textcolor{comment}{/* List of active clients */}
00927     list *clients\_to\_close;     \textcolor{comment}{/* Clients to close asynchronously */}
00928     list *clients\_pending\_write; \textcolor{comment}{/* There is to write or install handler. */}
00929     list *slaves, *monitors;    \textcolor{comment}{/* List of slaves and MONITORs */}
00930     \hyperlink{structclient}{client} *current\_client; \textcolor{comment}{/* Current client, only used on crash report */}
00931     \textcolor{keywordtype}{int} clients\_paused;         \textcolor{comment}{/* True if clients are currently paused */}
00932     mstime\_t clients\_pause\_end\_time; \textcolor{comment}{/* Time when we undo clients\_paused */}
00933     \textcolor{keywordtype}{char} neterr[\hyperlink{anet_8h_a92d565f421c133e9fac9dbbe8c88922b}{ANET\_ERR\_LEN}];   \textcolor{comment}{/* Error buffer for anet.c */}
00934     dict *migrate\_cached\_sockets;\textcolor{comment}{/* MIGRATE cached sockets */}
00935     uint64\_t next\_client\_id;    \textcolor{comment}{/* Next client unique ID. Incremental. */}
00936     \textcolor{keywordtype}{int} protected\_mode;         \textcolor{comment}{/* Don't accept external connections. */}
00937     \textcolor{comment}{/* RDB / AOF loading information */}
00938     \textcolor{keywordtype}{int} loading;                \textcolor{comment}{/* We are loading data from disk if true */}
00939     off\_t loading\_total\_bytes;
00940     off\_t loading\_loaded\_bytes;
00941     time\_t loading\_start\_time;
00942     off\_t loading\_process\_events\_interval\_bytes;
00943     \textcolor{comment}{/* Fast pointers to often looked up command */}
00944     \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *delCommand, *multiCommand, *lpushCommand, *lpopCommand,
00945                         *rpopCommand, *sremCommand, *execCommand, *expireCommand,
00946                         *pexpireCommand;
00947     \textcolor{comment}{/* Fields used only for stats */}
00948     time\_t stat\_starttime;          \textcolor{comment}{/* Server start time */}
00949     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} stat\_numcommands;     \textcolor{comment}{/* Number of processed commands */}
00950     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} stat\_numconnections;  \textcolor{comment}{/* Number of connections received */}
00951     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} stat\_expiredkeys;     \textcolor{comment}{/* Number of expired keys */}
00952     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} stat\_evictedkeys;     \textcolor{comment}{/* Number of evicted keys (maxmemory) */}
00953     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} stat\_keyspace\_hits;   \textcolor{comment}{/* Number of successful lookups of keys */}
00954     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} stat\_keyspace\_misses; \textcolor{comment}{/* Number of failed lookups of keys */}
00955     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} stat\_active\_defrag\_hits;      \textcolor{comment}{/* number of allocations moved */}
00956     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} stat\_active\_defrag\_misses;    \textcolor{comment}{/* number of allocations scanned but not moved */}
00957     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} stat\_active\_defrag\_key\_hits;  \textcolor{comment}{/* number of keys with moved allocations */}
00958     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} stat\_active\_defrag\_key\_misses;\textcolor{comment}{/* number of keys scanned and not moved */}
00959     size\_t stat\_peak\_memory;        \textcolor{comment}{/* Max used memory record */}
00960     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} stat\_fork\_time;       \textcolor{comment}{/* Time needed to perform latest fork() */}
00961     \textcolor{keywordtype}{double} stat\_fork\_rate;          \textcolor{comment}{/* Fork rate in GB/sec. */}
00962     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} stat\_rejected\_conn;   \textcolor{comment}{/* Clients rejected because of maxclients */}
00963     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} stat\_sync\_full;       \textcolor{comment}{/* Number of full resyncs with slaves. */}
00964     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} stat\_sync\_partial\_ok; \textcolor{comment}{/* Number of accepted PSYNC requests. */}
00965     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} stat\_sync\_partial\_err;\textcolor{comment}{/* Number of unaccepted PSYNC requests. */}
00966     list *slowlog;                  \textcolor{comment}{/* SLOWLOG list of commands */}
00967     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} slowlog\_entry\_id;     \textcolor{comment}{/* SLOWLOG current entry ID */}
00968     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} slowlog\_log\_slower\_than; \textcolor{comment}{/* SLOWLOG time limit (to get logged) */}
00969     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} slowlog\_max\_len;     \textcolor{comment}{/* SLOWLOG max number of items logged */}
00970     size\_t resident\_set\_size;       \textcolor{comment}{/* RSS sampled in serverCron(). */}
00971     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} stat\_net\_input\_bytes; \textcolor{comment}{/* Bytes read from network. */}
00972     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} stat\_net\_output\_bytes; \textcolor{comment}{/* Bytes written to network. */}
00973     size\_t stat\_rdb\_cow\_bytes;      \textcolor{comment}{/* Copy on write bytes during RDB saving. */}
00974     size\_t stat\_aof\_cow\_bytes;      \textcolor{comment}{/* Copy on write bytes during AOF rewrite. */}
00975     \textcolor{comment}{/* The following two are used to track instantaneous metrics, like}
00976 \textcolor{comment}{     * number of operations per second, network traffic. */}
\Hypertarget{server_8h_source_l00977}\hyperlink{structredisServer_8inst__metric}{00977}     \textcolor{keyword}{struct} \{
00978         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} last\_sample\_time; \textcolor{comment}{/* Timestamp of last sample in ms */}
00979         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} last\_sample\_count;\textcolor{comment}{/* Count in last sample */}
00980         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} samples[\hyperlink{server_8h_a225a9e35f2cb8aa663571625bc59a533}{STATS\_METRIC\_SAMPLES}];
00981         \textcolor{keywordtype}{int} idx;
00982     \} inst\_metric[\hyperlink{server_8h_ad9e350cb5eeb396592d0d80f70e6e040}{STATS\_METRIC\_COUNT}];
00983     \textcolor{comment}{/* Configuration */}
00984     \textcolor{keywordtype}{int} verbosity;                  \textcolor{comment}{/* Loglevel in redis.conf */}
00985     \textcolor{keywordtype}{int} maxidletime;                \textcolor{comment}{/* Client timeout in seconds */}
00986     \textcolor{keywordtype}{int} tcpkeepalive;               \textcolor{comment}{/* Set SO\_KEEPALIVE if non-zero. */}
00987     \textcolor{keywordtype}{int} active\_expire\_enabled;      \textcolor{comment}{/* Can be disabled for testing purposes. */}
00988     \textcolor{keywordtype}{int} active\_defrag\_enabled;
00989     size\_t active\_defrag\_ignore\_bytes; \textcolor{comment}{/* minimum amount of fragmentation waste to start active defrag
       */}
00990     \textcolor{keywordtype}{int} active\_defrag\_threshold\_lower; \textcolor{comment}{/* minimum percentage of fragmentation to start active defrag
       */}
00991     \textcolor{keywordtype}{int} active\_defrag\_threshold\_upper; \textcolor{comment}{/* maximum percentage of fragmentation at which we use maximum
       effort */}
00992     \textcolor{keywordtype}{int} active\_defrag\_cycle\_min;       \textcolor{comment}{/* minimal effort for defrag in CPU percentage */}
00993     \textcolor{keywordtype}{int} active\_defrag\_cycle\_max;       \textcolor{comment}{/* maximal effort for defrag in CPU percentage */}
00994     size\_t client\_max\_querybuf\_len; \textcolor{comment}{/* Limit for client query buffer length */}
00995     \textcolor{keywordtype}{int} dbnum;                      \textcolor{comment}{/* Total number of configured DBs */}
00996     \textcolor{keywordtype}{int} supervised;                 \textcolor{comment}{/* 1 if supervised, 0 otherwise. */}
00997     \textcolor{keywordtype}{int} supervised\_mode;            \textcolor{comment}{/* See SUPERVISED\_* */}
00998     \textcolor{keywordtype}{int} daemonize;                  \textcolor{comment}{/* True if running as a daemon */}
00999     clientBufferLimitsConfig client\_obuf\_limits[\hyperlink{server_8h_aea8f6f3fac3a68e35807eba109dbc501}{CLIENT\_TYPE\_OBUF\_COUNT}];
01000     \textcolor{comment}{/* AOF persistence */}
01001     \textcolor{keywordtype}{int} aof\_state;                  \textcolor{comment}{/* AOF\_(ON|OFF|WAIT\_REWRITE) */}
01002     \textcolor{keywordtype}{int} \hyperlink{config_8h_af5994c643c434574580bb7816af82cad}{aof\_fsync};                  \textcolor{comment}{/* Kind of fsync() policy */}
01003     \textcolor{keywordtype}{char} *aof\_filename;             \textcolor{comment}{/* Name of the AOF file */}
01004     \textcolor{keywordtype}{int} aof\_no\_fsync\_on\_rewrite;    \textcolor{comment}{/* Don't fsync if a rewrite is in prog. */}
01005     \textcolor{keywordtype}{int} aof\_rewrite\_perc;           \textcolor{comment}{/* Rewrite AOF if % growth is > M and... */}
01006     off\_t aof\_rewrite\_min\_size;     \textcolor{comment}{/* the AOF file is at least N bytes. */}
01007     off\_t aof\_rewrite\_base\_size;    \textcolor{comment}{/* AOF size on latest startup or rewrite. */}
01008     off\_t aof\_current\_size;         \textcolor{comment}{/* AOF current size. */}
01009     \textcolor{keywordtype}{int} aof\_rewrite\_scheduled;      \textcolor{comment}{/* Rewrite once BGSAVE terminates. */}
01010     pid\_t aof\_child\_pid;            \textcolor{comment}{/* PID if rewriting process */}
01011     list *aof\_rewrite\_buf\_blocks;   \textcolor{comment}{/* Hold changes during an AOF rewrite. */}
01012     sds aof\_buf;      \textcolor{comment}{/* AOF buffer, written before entering the event loop */}
01013     \textcolor{keywordtype}{int} aof\_fd;       \textcolor{comment}{/* File descriptor of currently selected AOF file */}
01014     \textcolor{keywordtype}{int} aof\_selected\_db; \textcolor{comment}{/* Currently selected DB in AOF */}
01015     time\_t aof\_flush\_postponed\_start; \textcolor{comment}{/* UNIX time of postponed AOF flush */}
01016     time\_t aof\_last\_fsync;            \textcolor{comment}{/* UNIX time of last fsync() */}
01017     time\_t aof\_rewrite\_time\_last;   \textcolor{comment}{/* Time used by last AOF rewrite run. */}
01018     time\_t aof\_rewrite\_time\_start;  \textcolor{comment}{/* Current AOF rewrite start time. */}
01019     \textcolor{keywordtype}{int} aof\_lastbgrewrite\_status;   \textcolor{comment}{/* C\_OK or C\_ERR */}
01020     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} aof\_delayed\_fsync;  \textcolor{comment}{/* delayed AOF fsync() counter */}
01021     \textcolor{keywordtype}{int} aof\_rewrite\_incremental\_fsync;\textcolor{comment}{/* fsync incrementally while rewriting? */}
01022     \textcolor{keywordtype}{int} aof\_last\_write\_status;      \textcolor{comment}{/* C\_OK or C\_ERR */}
01023     \textcolor{keywordtype}{int} aof\_last\_write\_errno;       \textcolor{comment}{/* Valid if aof\_last\_write\_status is ERR */}
01024     \textcolor{keywordtype}{int} aof\_load\_truncated;         \textcolor{comment}{/* Don't stop on unexpected AOF EOF. */}
01025     \textcolor{keywordtype}{int} aof\_use\_rdb\_preamble;       \textcolor{comment}{/* Use RDB preamble on AOF rewrites. */}
01026     \textcolor{comment}{/* AOF pipes used to communicate between parent and child during rewrite. */}
01027     \textcolor{keywordtype}{int} aof\_pipe\_write\_data\_to\_child;
01028     \textcolor{keywordtype}{int} aof\_pipe\_read\_data\_from\_parent;
01029     \textcolor{keywordtype}{int} aof\_pipe\_write\_ack\_to\_parent;
01030     \textcolor{keywordtype}{int} aof\_pipe\_read\_ack\_from\_child;
01031     \textcolor{keywordtype}{int} aof\_pipe\_write\_ack\_to\_child;
01032     \textcolor{keywordtype}{int} aof\_pipe\_read\_ack\_from\_parent;
01033     \textcolor{keywordtype}{int} aof\_stop\_sending\_diff;     \textcolor{comment}{/* If true stop sending accumulated diffs}
01034 \textcolor{comment}{                                      to child process. */}
01035     sds aof\_child\_diff;             \textcolor{comment}{/* AOF diff accumulator child side. */}
01036     \textcolor{comment}{/* RDB persistence */}
01037     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} dirty;                \textcolor{comment}{/* Changes to DB from the last save */}
01038     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} dirty\_before\_bgsave;  \textcolor{comment}{/* Used to restore dirty on failed BGSAVE */}
01039     pid\_t rdb\_child\_pid;            \textcolor{comment}{/* PID of RDB saving child */}
01040     \textcolor{keyword}{struct} \hyperlink{structsaveparam}{saveparam} *saveparams;   \textcolor{comment}{/* Save points array for RDB */}
01041     \textcolor{keywordtype}{int} saveparamslen;              \textcolor{comment}{/* Number of saving points */}
01042     \textcolor{keywordtype}{char} *rdb\_filename;             \textcolor{comment}{/* Name of RDB file */}
01043     \textcolor{keywordtype}{int} rdb\_compression;            \textcolor{comment}{/* Use compression in RDB? */}
01044     \textcolor{keywordtype}{int} rdb\_checksum;               \textcolor{comment}{/* Use RDB checksum? */}
01045     time\_t lastsave;                \textcolor{comment}{/* Unix time of last successful save */}
01046     time\_t lastbgsave\_try;          \textcolor{comment}{/* Unix time of last attempted bgsave */}
01047     time\_t rdb\_save\_time\_last;      \textcolor{comment}{/* Time used by last RDB save run. */}
01048     time\_t rdb\_save\_time\_start;     \textcolor{comment}{/* Current RDB save start time. */}
01049     \textcolor{keywordtype}{int} rdb\_bgsave\_scheduled;       \textcolor{comment}{/* BGSAVE when possible if true. */}
01050     \textcolor{keywordtype}{int} rdb\_child\_type;             \textcolor{comment}{/* Type of save by active child. */}
01051     \textcolor{keywordtype}{int} lastbgsave\_status;          \textcolor{comment}{/* C\_OK or C\_ERR */}
01052     \textcolor{keywordtype}{int} stop\_writes\_on\_bgsave\_err;  \textcolor{comment}{/* Don't allow writes if can't BGSAVE */}
01053     \textcolor{keywordtype}{int} rdb\_pipe\_write\_result\_to\_parent; \textcolor{comment}{/* RDB pipes used to return the state */}
01054     \textcolor{keywordtype}{int} rdb\_pipe\_read\_result\_from\_child; \textcolor{comment}{/* of each slave in diskless SYNC. */}
01055     \textcolor{comment}{/* Pipe and data structures for child -> parent info sharing. */}
01056     \textcolor{keywordtype}{int} child\_info\_pipe[2];         \textcolor{comment}{/* Pipe used to write the child\_info\_data. */}
\Hypertarget{server_8h_source_l01057}\hyperlink{structredisServer_8child__info__data}{01057}     \textcolor{keyword}{struct} \{
01058         \textcolor{keywordtype}{int} process\_type;           \textcolor{comment}{/* AOF or RDB child? */}
01059         size\_t cow\_size;            \textcolor{comment}{/* Copy on write size. */}
01060         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} magic;   \textcolor{comment}{/* Magic value to make sure data is valid. */}
01061     \} child\_info\_data;
01062     \textcolor{comment}{/* Propagation of commands in AOF / replication */}
01063     redisOpArray also\_propagate;    \textcolor{comment}{/* Additional command to propagate. */}
01064     \textcolor{comment}{/* Logging */}
01065     \textcolor{keywordtype}{char} *logfile;                  \textcolor{comment}{/* Path of log file */}
01066     \textcolor{keywordtype}{int} syslog\_enabled;             \textcolor{comment}{/* Is syslog enabled? */}
01067     \textcolor{keywordtype}{char} *syslog\_ident;             \textcolor{comment}{/* Syslog ident */}
01068     \textcolor{keywordtype}{int} syslog\_facility;            \textcolor{comment}{/* Syslog facility */}
01069     \textcolor{comment}{/* Replication (master) */}
01070     \textcolor{keywordtype}{char} replid[\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}+1];  \textcolor{comment}{/* My current replication ID. */}
01071     \textcolor{keywordtype}{char} replid2[\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}+1]; \textcolor{comment}{/* replid inherited from master*/}
01072     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} master\_repl\_offset;   \textcolor{comment}{/* My current replication offset */}
01073     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} second\_replid\_offset; \textcolor{comment}{/* Accept offsets up to this for replid2. */}
01074     \textcolor{keywordtype}{int} slaveseldb;                 \textcolor{comment}{/* Last SELECTed DB in replication output */}
01075     \textcolor{keywordtype}{int} repl\_ping\_slave\_period;     \textcolor{comment}{/* Master pings the slave every N seconds */}
01076     \textcolor{keywordtype}{char} *repl\_backlog;             \textcolor{comment}{/* Replication backlog for partial syncs */}
01077     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} repl\_backlog\_size;    \textcolor{comment}{/* Backlog circular buffer size */}
01078     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} repl\_backlog\_histlen; \textcolor{comment}{/* Backlog actual data length */}
01079     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} repl\_backlog\_idx;     \textcolor{comment}{/* Backlog circular buffer current offset,}
01080 \textcolor{comment}{                                       that is the next byte will'll write to.*/}
01081     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} repl\_backlog\_off;     \textcolor{comment}{/* Replication "master offset" of first}
01082 \textcolor{comment}{                                       byte in the replication backlog buffer.*/}
01083     time\_t repl\_backlog\_time\_limit; \textcolor{comment}{/* Time without slaves after the backlog}
01084 \textcolor{comment}{                                       gets released. */}
01085     time\_t repl\_no\_slaves\_since;    \textcolor{comment}{/* We have no slaves since that time.}
01086 \textcolor{comment}{                                       Only valid if server.slaves len is 0. */}
01087     \textcolor{keywordtype}{int} repl\_min\_slaves\_to\_write;   \textcolor{comment}{/* Min number of slaves to write. */}
01088     \textcolor{keywordtype}{int} repl\_min\_slaves\_max\_lag;    \textcolor{comment}{/* Max lag of <count> slaves to write. */}
01089     \textcolor{keywordtype}{int} repl\_good\_slaves\_count;     \textcolor{comment}{/* Number of slaves with lag <= max\_lag. */}
01090     \textcolor{keywordtype}{int} repl\_diskless\_sync;         \textcolor{comment}{/* Send RDB to slaves sockets directly. */}
01091     \textcolor{keywordtype}{int} repl\_diskless\_sync\_delay;   \textcolor{comment}{/* Delay to start a diskless repl BGSAVE. */}
01092     \textcolor{comment}{/* Replication (slave) */}
01093     \textcolor{keywordtype}{char} *masterauth;               \textcolor{comment}{/* AUTH with this password with master */}
01094     \textcolor{keywordtype}{char} *masterhost;               \textcolor{comment}{/* Hostname of master */}
01095     \textcolor{keywordtype}{int} masterport;                 \textcolor{comment}{/* Port of master */}
01096     \textcolor{keywordtype}{int} repl\_timeout;               \textcolor{comment}{/* Timeout after N seconds of master idle */}
01097     \hyperlink{structclient}{client} *master;     \textcolor{comment}{/* Client that is master for this slave */}
01098     \hyperlink{structclient}{client} *cached\_master; \textcolor{comment}{/* Cached master to be reused for PSYNC. */}
01099     \textcolor{keywordtype}{int} repl\_syncio\_timeout; \textcolor{comment}{/* Timeout for synchronous I/O calls */}
01100     \textcolor{keywordtype}{int} repl\_state;          \textcolor{comment}{/* Replication status if the instance is a slave */}
01101     off\_t repl\_transfer\_size; \textcolor{comment}{/* Size of RDB to read from master during sync. */}
01102     off\_t repl\_transfer\_read; \textcolor{comment}{/* Amount of RDB read from master during sync. */}
01103     off\_t repl\_transfer\_last\_fsync\_off; \textcolor{comment}{/* Offset when we fsync-ed last time. */}
01104     \textcolor{keywordtype}{int} repl\_transfer\_s;     \textcolor{comment}{/* Slave -> Master SYNC socket */}
01105     \textcolor{keywordtype}{int} repl\_transfer\_fd;    \textcolor{comment}{/* Slave -> Master SYNC temp file descriptor */}
01106     \textcolor{keywordtype}{char} *repl\_transfer\_tmpfile; \textcolor{comment}{/* Slave-> master SYNC temp file name */}
01107     time\_t repl\_transfer\_lastio; \textcolor{comment}{/* Unix time of the latest read, for timeout */}
01108     \textcolor{keywordtype}{int} repl\_serve\_stale\_data; \textcolor{comment}{/* Serve stale data when link is down? */}
01109     \textcolor{keywordtype}{int} repl\_slave\_ro;          \textcolor{comment}{/* Slave is read only? */}
01110     time\_t repl\_down\_since; \textcolor{comment}{/* Unix time at which link with master went down */}
01111     \textcolor{keywordtype}{int} repl\_disable\_tcp\_nodelay;   \textcolor{comment}{/* Disable TCP\_NODELAY after SYNC? */}
01112     \textcolor{keywordtype}{int} slave\_priority;             \textcolor{comment}{/* Reported in INFO and used by Sentinel. */}
01113     \textcolor{keywordtype}{int} slave\_announce\_port;        \textcolor{comment}{/* Give the master this listening port. */}
01114     \textcolor{keywordtype}{char} *slave\_announce\_ip;        \textcolor{comment}{/* Give the master this ip address. */}
01115     \textcolor{comment}{/* The following two fields is where we store master PSYNC replid/offset}
01116 \textcolor{comment}{     * while the PSYNC is in progress. At the end we'll copy the fields into}
01117 \textcolor{comment}{     * the server->master client structure. */}
01118     \textcolor{keywordtype}{char} master\_replid[\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}+1];  \textcolor{comment}{/* Master PSYNC runid. */}
01119     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} master\_initial\_offset;           \textcolor{comment}{/* Master PSYNC offset. */}
01120     \textcolor{keywordtype}{int} repl\_slave\_lazy\_flush;          \textcolor{comment}{/* Lazy FLUSHALL before loading DB? */}
01121     \textcolor{comment}{/* Replication script cache. */}
01122     dict *repl\_scriptcache\_dict;        \textcolor{comment}{/* SHA1 all slaves are aware of. */}
01123     list *repl\_scriptcache\_fifo;        \textcolor{comment}{/* First in, first out LRU eviction. */}
01124     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} repl\_scriptcache\_size; \textcolor{comment}{/* Max number of elements. */}
01125     \textcolor{comment}{/* Synchronous replication. */}
01126     list *clients\_waiting\_acks;         \textcolor{comment}{/* Clients waiting in WAIT command. */}
01127     \textcolor{keywordtype}{int} get\_ack\_from\_slaves;            \textcolor{comment}{/* If true we send REPLCONF GETACK. */}
01128     \textcolor{comment}{/* Limits */}
01129     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} maxclients;            \textcolor{comment}{/* Max number of simultaneous clients */}
01130     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} maxmemory;   \textcolor{comment}{/* Max number of memory bytes to use */}
01131     \textcolor{keywordtype}{int} maxmemory\_policy;           \textcolor{comment}{/* Policy for key eviction */}
01132     \textcolor{keywordtype}{int} maxmemory\_samples;          \textcolor{comment}{/* Pricision of random sampling */}
01133     \textcolor{keywordtype}{int} lfu\_log\_factor;             \textcolor{comment}{/* LFU logarithmic counter factor. */}
01134     \textcolor{keywordtype}{int} lfu\_decay\_time;             \textcolor{comment}{/* LFU counter decay factor. */}
01135     \textcolor{comment}{/* Blocked clients */}
01136     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} blocked\_clients;   \textcolor{comment}{/* # of clients executing a blocking cmd.*/}
01137     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} blocked\_clients\_by\_type[\hyperlink{server_8h_a7b2645977d2cac8f57f1b8b51048a3ef}{BLOCKED\_NUM}];
01138     list *unblocked\_clients; \textcolor{comment}{/* list of clients to unblock before next loop */}
01139     list *ready\_keys;        \textcolor{comment}{/* List of readyList structures for BLPOP & co */}
01140     \textcolor{comment}{/* Sort parameters - qsort\_r() is only available under BSD so we}
01141 \textcolor{comment}{     * have to take this state global, in order to pass it to sortCompare() */}
01142     \textcolor{keywordtype}{int} sort\_desc;
01143     \textcolor{keywordtype}{int} sort\_alpha;
01144     \textcolor{keywordtype}{int} sort\_bypattern;
01145     \textcolor{keywordtype}{int} sort\_store;
01146     \textcolor{comment}{/* Zip structure config, see redis.conf for more information  */}
01147     size\_t hash\_max\_ziplist\_entries;
01148     size\_t hash\_max\_ziplist\_value;
01149     size\_t set\_max\_intset\_entries;
01150     size\_t zset\_max\_ziplist\_entries;
01151     size\_t zset\_max\_ziplist\_value;
01152     size\_t hll\_sparse\_max\_bytes;
01153     \textcolor{comment}{/* List parameters */}
01154     \textcolor{keywordtype}{int} list\_max\_ziplist\_size;
01155     \textcolor{keywordtype}{int} list\_compress\_depth;
01156     \textcolor{comment}{/* time cache */}
01157     time\_t unixtime;    \textcolor{comment}{/* Unix time sampled every cron cycle. */}
01158     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} mstime;   \textcolor{comment}{/* Like 'unixtime' but with milliseconds resolution. */}
01159     \textcolor{comment}{/* Pubsub */}
01160     dict *pubsub\_channels;  \textcolor{comment}{/* Map channels to list of subscribed clients */}
01161     list *pubsub\_patterns;  \textcolor{comment}{/* A list of pubsub\_patterns */}
01162     \textcolor{keywordtype}{int} notify\_keyspace\_events; \textcolor{comment}{/* Events to propagate via Pub/Sub. This is an}
01163 \textcolor{comment}{                                   xor of NOTIFY\_... flags. */}
01164     \textcolor{comment}{/* Cluster */}
01165     \textcolor{keywordtype}{int} cluster\_enabled;      \textcolor{comment}{/* Is cluster enabled? */}
01166     mstime\_t cluster\_node\_timeout; \textcolor{comment}{/* Cluster node timeout. */}
01167     \textcolor{keywordtype}{char} *cluster\_configfile; \textcolor{comment}{/* Cluster auto-generated config file name. */}
01168     \textcolor{keyword}{struct} \hyperlink{structclusterState}{clusterState} *cluster;  \textcolor{comment}{/* State of the cluster */}
01169     \textcolor{keywordtype}{int} cluster\_migration\_barrier; \textcolor{comment}{/* Cluster replicas migration barrier. */}
01170     \textcolor{keywordtype}{int} cluster\_slave\_validity\_factor; \textcolor{comment}{/* Slave max data age for failover. */}
01171     \textcolor{keywordtype}{int} cluster\_require\_full\_coverage; \textcolor{comment}{/* If true, put the cluster down if}
01172 \textcolor{comment}{                                          there is at least an uncovered slot.*/}
01173     \textcolor{keywordtype}{char} *cluster\_announce\_ip;  \textcolor{comment}{/* IP address to announce on cluster bus. */}
01174     \textcolor{keywordtype}{int} cluster\_announce\_port;     \textcolor{comment}{/* base port to announce on cluster bus. */}
01175     \textcolor{keywordtype}{int} cluster\_announce\_bus\_port; \textcolor{comment}{/* bus port to announce on cluster bus. */}
01176     \textcolor{comment}{/* Scripting */}
01177     lua\_State *lua; \textcolor{comment}{/* The Lua interpreter. We use just one for all clients */}
01178     \hyperlink{structclient}{client} *lua\_client;   \textcolor{comment}{/* The "fake client" to query Redis from Lua */}
01179     \hyperlink{structclient}{client} *lua\_caller;   \textcolor{comment}{/* The client running EVAL right now, or NULL */}
01180     dict *lua\_scripts;         \textcolor{comment}{/* A dictionary of SHA1 -> Lua scripts */}
01181     mstime\_t lua\_time\_limit;  \textcolor{comment}{/* Script timeout in milliseconds */}
01182     mstime\_t lua\_time\_start;  \textcolor{comment}{/* Start time of script, milliseconds time */}
01183     \textcolor{keywordtype}{int} lua\_write\_dirty;  \textcolor{comment}{/* True if a write command was called during the}
01184 \textcolor{comment}{                             execution of the current script. */}
01185     \textcolor{keywordtype}{int} lua\_random\_dirty; \textcolor{comment}{/* True if a random command was called during the}
01186 \textcolor{comment}{                             execution of the current script. */}
01187     \textcolor{keywordtype}{int} lua\_replicate\_commands; \textcolor{comment}{/* True if we are doing single commands repl. */}
01188     \textcolor{keywordtype}{int} lua\_multi\_emitted;\textcolor{comment}{/* True if we already proagated MULTI. */}
01189     \textcolor{keywordtype}{int} lua\_repl;         \textcolor{comment}{/* Script replication flags for redis.set\_repl(). */}
01190     \textcolor{keywordtype}{int} lua\_timedout;     \textcolor{comment}{/* True if we reached the time limit for script}
01191 \textcolor{comment}{                             execution. */}
01192     \textcolor{keywordtype}{int} lua\_kill;         \textcolor{comment}{/* Kill the script if true. */}
01193     \textcolor{keywordtype}{int} lua\_always\_replicate\_commands; \textcolor{comment}{/* Default replication type. */}
01194     \textcolor{comment}{/* Lazy free */}
01195     \textcolor{keywordtype}{int} lazyfree\_lazy\_eviction;
01196     \textcolor{keywordtype}{int} lazyfree\_lazy\_expire;
01197     \textcolor{keywordtype}{int} lazyfree\_lazy\_server\_del;
01198     \textcolor{comment}{/* Latency monitor */}
01199     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} latency\_monitor\_threshold;
01200     dict *latency\_events;
01201     \textcolor{comment}{/* Assert & bug reporting */}
01202     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *assert\_failed;
01203     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *assert\_file;
01204     \textcolor{keywordtype}{int} assert\_line;
01205     \textcolor{keywordtype}{int} bug\_report\_start; \textcolor{comment}{/* True if bug report header was already logged. */}
01206     \textcolor{keywordtype}{int} watchdog\_period;  \textcolor{comment}{/* Software watchdog period in ms. 0 = off */}
01207     \textcolor{comment}{/* System hardware info */}
01208     size\_t system\_memory\_size;  \textcolor{comment}{/* Total memory in system as reported by OS */}
01209 
01210     \textcolor{comment}{/* Mutexes used to protect atomic variables when atomic builtins are}
01211 \textcolor{comment}{     * not available. */}
01212     pthread\_mutex\_t lruclock\_mutex;
01213     pthread\_mutex\_t next\_client\_id\_mutex;
01214     pthread\_mutex\_t unixtime\_mutex;
01215 \};
01216 
\Hypertarget{server_8h_source_l01217}\hyperlink{structpubsubPattern}{01217} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structpubsubPattern}{pubsubPattern} \{
01218     \hyperlink{structclient}{client} *client;
01219     robj *pattern;
01220 \} pubsubPattern;
01221 
01222 \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} redisCommandProc(\hyperlink{structclient}{client} *c);
01223 \textcolor{keyword}{typedef} \textcolor{keywordtype}{int} *redisGetKeysProc(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} *
      numkeys);
\Hypertarget{server_8h_source_l01224}\hyperlink{structredisCommand}{01224} \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} \{
01225     \textcolor{keywordtype}{char} *name;
01226     redisCommandProc *proc;
01227     \textcolor{keywordtype}{int} arity;
01228     \textcolor{keywordtype}{char} *sflags; \textcolor{comment}{/* Flags as string representation, one char per flag. */}
01229     \textcolor{keywordtype}{int} flags;    \textcolor{comment}{/* The actual flags, obtained from the 'sflags' field. */}
01230     \textcolor{comment}{/* Use a function to determine keys arguments in a command line.}
01231 \textcolor{comment}{     * Used for Redis Cluster redirect. */}
01232     redisGetKeysProc *getkeys\_proc;
01233     \textcolor{comment}{/* What keys should be loaded in background when calling this command? */}
01234     \textcolor{keywordtype}{int} firstkey; \textcolor{comment}{/* The first argument that's a key (0 = no keys) */}
01235     \textcolor{keywordtype}{int} lastkey;  \textcolor{comment}{/* The last argument that's a key */}
01236     \textcolor{keywordtype}{int} keystep;  \textcolor{comment}{/* The step between first and last key */}
01237     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} microseconds, calls;
01238 \};
01239 
\Hypertarget{server_8h_source_l01240}\hyperlink{structredisFunctionSym}{01240} \textcolor{keyword}{struct} \hyperlink{structredisFunctionSym}{redisFunctionSym} \{
01241     \textcolor{keywordtype}{char} *name;
01242     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} pointer;
01243 \};
01244 
\Hypertarget{server_8h_source_l01245}\hyperlink{struct__redisSortObject}{01245} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{struct__redisSortObject}{\_redisSortObject} \{
01246     robj *obj;
\Hypertarget{server_8h_source_l01247}\hyperlink{union__redisSortObject_8u}{01247}     \textcolor{keyword}{union} \{
01248         \textcolor{keywordtype}{double} score;
01249         robj *cmpobj;
01250     \} u;
01251 \} redisSortObject;
01252 
\Hypertarget{server_8h_source_l01253}\hyperlink{struct__redisSortOperation}{01253} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{struct__redisSortOperation}{\_redisSortOperation} \{
01254     \textcolor{keywordtype}{int} type;
01255     robj *pattern;
01256 \} redisSortOperation;
01257 
01258 \textcolor{comment}{/* Structure to hold list iteration abstraction. */}
\Hypertarget{server_8h_source_l01259}\hyperlink{structlistTypeIterator}{01259} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \{
01260     robj *subject;
01261     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} encoding;
01262     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} direction; \textcolor{comment}{/* Iteration direction */}
01263     quicklistIter *iter;
01264 \} listTypeIterator;
01265 
01266 \textcolor{comment}{/* Structure for an entry while iterating over a list. */}
\Hypertarget{server_8h_source_l01267}\hyperlink{structlistTypeEntry}{01267} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \{
01268     listTypeIterator *li;
01269     quicklistEntry entry; \textcolor{comment}{/* Entry in quicklist */}
01270 \} listTypeEntry;
01271 
01272 \textcolor{comment}{/* Structure to hold set iteration abstraction. */}
\Hypertarget{server_8h_source_l01273}\hyperlink{structsetTypeIterator}{01273} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \{
01274     robj *subject;
01275     \textcolor{keywordtype}{int} encoding;
01276     \textcolor{keywordtype}{int} ii; \textcolor{comment}{/* intset iterator */}
01277     dictIterator *di;
01278 \} setTypeIterator;
01279 
01280 \textcolor{comment}{/* Structure to hold hash iteration abstraction. Note that iteration over}
01281 \textcolor{comment}{ * hashes involves both fields and values. Because it is possible that}
01282 \textcolor{comment}{ * not both are required, store pointers in the iterator to avoid}
01283 \textcolor{comment}{ * unnecessary memory allocation for fields/values. */}
\Hypertarget{server_8h_source_l01284}\hyperlink{structhashTypeIterator}{01284} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \{
01285     robj *subject;
01286     \textcolor{keywordtype}{int} encoding;
01287 
01288     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *fptr, *vptr;
01289 
01290     dictIterator *di;
01291     dictEntry *de;
01292 \} hashTypeIterator;
01293 
01294 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_HASH\_KEY} 1
01295 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{OBJ\_HASH\_VALUE} 2
01296 
01297 \textcolor{comment}{/*-----------------------------------------------------------------------------}
01298 \textcolor{comment}{ * Extern declarations}
01299 \textcolor{comment}{ *----------------------------------------------------------------------------*/}
01300 
01301 \textcolor{keyword}{extern} \textcolor{keyword}{struct} \hyperlink{structredisServer}{redisServer} server;
01302 \textcolor{keyword}{extern} \textcolor{keyword}{struct} \hyperlink{structsharedObjectsStruct}{sharedObjectsStruct} shared;
01303 \textcolor{keyword}{extern} dictType objectKeyPointerValueDictType;
01304 \textcolor{keyword}{extern} dictType objectKeyHeapPointerValueDictType;
01305 \textcolor{keyword}{extern} dictType setDictType;
01306 \textcolor{keyword}{extern} dictType zsetDictType;
01307 \textcolor{keyword}{extern} dictType clusterNodesDictType;
01308 \textcolor{keyword}{extern} dictType clusterNodesBlackListDictType;
01309 \textcolor{keyword}{extern} dictType dbDictType;
01310 \textcolor{keyword}{extern} dictType shaScriptObjectDictType;
01311 \textcolor{keyword}{extern} \textcolor{keywordtype}{double} R\_Zero, R\_PosInf, R\_NegInf, R\_Nan;
01312 \textcolor{keyword}{extern} dictType hashDictType;
01313 \textcolor{keyword}{extern} dictType replScriptCacheDictType;
01314 \textcolor{keyword}{extern} dictType keyptrDictType;
01315 \textcolor{keyword}{extern} dictType modulesDictType;
01316 
01317 \textcolor{comment}{/*-----------------------------------------------------------------------------}
01318 \textcolor{comment}{ * Functions prototypes}
01319 \textcolor{comment}{ *----------------------------------------------------------------------------*/}
01320 
01321 \textcolor{comment}{/* Modules */}
01322 \textcolor{keywordtype}{void} moduleInitModulesSystem(\textcolor{keywordtype}{void});
01323 \textcolor{keywordtype}{int} moduleLoad(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *path, \textcolor{keywordtype}{void} **argv, \textcolor{keywordtype}{int} argc);
01324 \textcolor{keywordtype}{void} moduleLoadFromQueue(\textcolor{keywordtype}{void});
01325 \textcolor{keywordtype}{int} *moduleGetCommandKeysViaAPI(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} *
      numkeys);
01326 moduleType *moduleTypeLookupModuleByID(uint64\_t id);
01327 \textcolor{keywordtype}{void} moduleTypeNameByID(\textcolor{keywordtype}{char} *name, uint64\_t moduleid);
01328 \textcolor{keywordtype}{void} moduleFreeContext(\textcolor{keyword}{struct} \hyperlink{structRedisModuleCtx}{RedisModuleCtx} *ctx);
01329 \textcolor{keywordtype}{void} unblockClientFromModule(\hyperlink{structclient}{client} *c);
01330 \textcolor{keywordtype}{void} moduleHandleBlockedClients(\textcolor{keywordtype}{void});
01331 \textcolor{keywordtype}{void} moduleBlockedClientTimedOut(\hyperlink{structclient}{client} *c);
01332 \textcolor{keywordtype}{void} moduleBlockedClientPipeReadable(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask);
01333 size\_t moduleCount(\textcolor{keywordtype}{void});
01334 \textcolor{keywordtype}{void} moduleAcquireGIL(\textcolor{keywordtype}{void});
01335 \textcolor{keywordtype}{void} moduleReleaseGIL(\textcolor{keywordtype}{void});
01336 
01337 \textcolor{comment}{/* Utils */}
01338 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ustime(\textcolor{keywordtype}{void});
01339 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} mstime(\textcolor{keywordtype}{void});
01340 \textcolor{keywordtype}{void} getRandomHexChars(\textcolor{keywordtype}{char} *p, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len);
01341 uint64\_t crc64(uint64\_t crc, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *s, uint64\_t l);
01342 \textcolor{keywordtype}{void} exitFromChild(\textcolor{keywordtype}{int} retcode);
01343 size\_t redisPopcount(\textcolor{keywordtype}{void} *s, \textcolor{keywordtype}{long} count);
01344 \textcolor{keywordtype}{void} redisSetProcTitle(\textcolor{keywordtype}{char} *title);
01345 
01346 \textcolor{comment}{/* networking.c -- Networking and Client related operations */}
01347 \hyperlink{structclient}{client} *createClient(\textcolor{keywordtype}{int} fd);
01348 \textcolor{keywordtype}{void} closeTimedoutClients(\textcolor{keywordtype}{void});
01349 \textcolor{keywordtype}{void} freeClient(\hyperlink{structclient}{client} *c);
01350 \textcolor{keywordtype}{void} freeClientAsync(\hyperlink{structclient}{client} *c);
01351 \textcolor{keywordtype}{void} resetClient(\hyperlink{structclient}{client} *c);
01352 \textcolor{keywordtype}{void} sendReplyToClient(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask);
01353 \textcolor{keywordtype}{void} *addDeferredMultiBulkLength(\hyperlink{structclient}{client} *c);
01354 \textcolor{keywordtype}{void} setDeferredMultiBulkLength(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{void} *node, \textcolor{keywordtype}{long} length);
01355 \textcolor{keywordtype}{void} processInputBuffer(\hyperlink{structclient}{client} *c);
01356 \textcolor{keywordtype}{void} acceptHandler(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask);
01357 \textcolor{keywordtype}{void} acceptTcpHandler(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask);
01358 \textcolor{keywordtype}{void} acceptUnixHandler(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask);
01359 \textcolor{keywordtype}{void} readQueryFromClient(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask);
01360 \textcolor{keywordtype}{void} addReplyString(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, size\_t len);
01361 \textcolor{keywordtype}{void} addReplyBulk(\hyperlink{structclient}{client} *c, robj *obj);
01362 \textcolor{keywordtype}{void} addReplyBulkCString(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *s);
01363 \textcolor{keywordtype}{void} addReplyBulkCBuffer(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *p, size\_t len);
01364 \textcolor{keywordtype}{void} addReplyBulkLongLong(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ll);
01365 \textcolor{keywordtype}{void} addReply(\hyperlink{structclient}{client} *c, robj *obj);
01366 \textcolor{keywordtype}{void} addReplySds(\hyperlink{structclient}{client} *c, sds s);
01367 \textcolor{keywordtype}{void} addReplyBulkSds(\hyperlink{structclient}{client} *c, sds s);
01368 \textcolor{keywordtype}{void} addReplyError(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *err);
01369 \textcolor{keywordtype}{void} addReplyStatus(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *status);
01370 \textcolor{keywordtype}{void} addReplyDouble(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{double} d);
01371 \textcolor{keywordtype}{void} addReplyHumanLongDouble(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} d);
01372 \textcolor{keywordtype}{void} addReplyLongLong(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ll);
01373 \textcolor{keywordtype}{void} addReplyMultiBulkLen(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{long} length);
01374 \textcolor{keywordtype}{void} addReplyHelp(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} **help);
01375 \textcolor{keywordtype}{void} copyClientOutputBuffer(\hyperlink{structclient}{client} *dst, \hyperlink{structclient}{client} *src);
01376 size\_t sdsZmallocSize(sds s);
01377 size\_t getStringObjectSdsUsedMemory(robj *o);
01378 \textcolor{keywordtype}{void} *dupClientReplyValue(\textcolor{keywordtype}{void} *o);
01379 \textcolor{keywordtype}{void} getClientsMaxBuffers(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *longest\_output\_list,
01380                           \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *biggest\_input\_buffer);
01381 \textcolor{keywordtype}{char} *getClientPeerId(\hyperlink{structclient}{client} *client);
01382 sds catClientInfoString(sds s, \hyperlink{structclient}{client} *client);
01383 sds getAllClientsInfoString(\textcolor{keywordtype}{void});
01384 \textcolor{keywordtype}{void} rewriteClientCommandVector(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} argc, ...);
01385 \textcolor{keywordtype}{void} rewriteClientCommandArgument(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} i, robj *newval);
01386 \textcolor{keywordtype}{void} replaceClientCommandVector(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} argc, robj **argv);
01387 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} getClientOutputBufferMemoryUsage(\hyperlink{structclient}{client} *c);
01388 \textcolor{keywordtype}{void} freeClientsInAsyncFreeQueue(\textcolor{keywordtype}{void});
01389 \textcolor{keywordtype}{void} asyncCloseClientOnOutputBufferLimitReached(\hyperlink{structclient}{client} *c);
01390 \textcolor{keywordtype}{int} getClientType(\hyperlink{structclient}{client} *c);
01391 \textcolor{keywordtype}{int} getClientTypeByName(\textcolor{keywordtype}{char} *name);
01392 \textcolor{keywordtype}{char} *getClientTypeName(\textcolor{keywordtype}{int} \textcolor{keyword}{class});
01393 \textcolor{keywordtype}{void} flushSlavesOutputBuffers(\textcolor{keywordtype}{void});
01394 \textcolor{keywordtype}{void} disconnectSlaves(\textcolor{keywordtype}{void});
01395 \textcolor{keywordtype}{int} listenToPort(\textcolor{keywordtype}{int} port, \textcolor{keywordtype}{int} *fds, \textcolor{keywordtype}{int} *count);
01396 \textcolor{keywordtype}{void} pauseClients(mstime\_t duration);
01397 \textcolor{keywordtype}{int} clientsArePaused(\textcolor{keywordtype}{void});
01398 \textcolor{keywordtype}{int} processEventsWhileBlocked(\textcolor{keywordtype}{void});
01399 \textcolor{keywordtype}{int} handleClientsWithPendingWrites(\textcolor{keywordtype}{void});
01400 \textcolor{keywordtype}{int} clientHasPendingReplies(\hyperlink{structclient}{client} *c);
01401 \textcolor{keywordtype}{void} unlinkClient(\hyperlink{structclient}{client} *c);
01402 \textcolor{keywordtype}{int} writeToClient(\textcolor{keywordtype}{int} fd, \hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} handler\_installed);
01403 \textcolor{keywordtype}{void} linkClient(\hyperlink{structclient}{client} *c);
01404 
01405 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \_\_GNUC\_\_
01406 \textcolor{keywordtype}{void} addReplyErrorFormat(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, ...)
01407     \textcolor{keyword}{\_\_attribute\_\_}((format(printf, 2, 3)));
01408 \textcolor{keywordtype}{void} addReplyStatusFormat(\hyperlink{structclient}{client} *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, ...)
01409     \textcolor{keyword}{\_\_attribute\_\_}((format(printf, 2, 3)));
01410 \textcolor{preprocessor}{#}\textcolor{preprocessor}{else}
01411 \textcolor{keywordtype}{void} addReplyErrorFormat(client *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, ...);
01412 \textcolor{keywordtype}{void} addReplyStatusFormat(client *c, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, ...);
01413 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
01414 
01415 \textcolor{comment}{/* List data type */}
01416 \textcolor{keywordtype}{void} listTypeTryConversion(robj *subject, robj *value);
01417 \textcolor{keywordtype}{void} listTypePush(robj *subject, robj *value, \textcolor{keywordtype}{int} where);
01418 robj *listTypePop(robj *subject, \textcolor{keywordtype}{int} where);
01419 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} listTypeLength(\textcolor{keyword}{const} robj *subject);
01420 listTypeIterator *listTypeInitIterator(robj *subject, \textcolor{keywordtype}{long} index, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} direction);
01421 \textcolor{keywordtype}{void} listTypeReleaseIterator(listTypeIterator *li);
01422 \textcolor{keywordtype}{int} listTypeNext(listTypeIterator *li, listTypeEntry *entry);
01423 robj *listTypeGet(listTypeEntry *entry);
01424 \textcolor{keywordtype}{void} listTypeInsert(listTypeEntry *entry, robj *value, \textcolor{keywordtype}{int} where);
01425 \textcolor{keywordtype}{int} listTypeEqual(listTypeEntry *entry, robj *o);
01426 \textcolor{keywordtype}{void} listTypeDelete(listTypeIterator *iter, listTypeEntry *entry);
01427 \textcolor{keywordtype}{void} listTypeConvert(robj *subject, \textcolor{keywordtype}{int} enc);
01428 \textcolor{keywordtype}{void} unblockClientWaitingData(\hyperlink{structclient}{client} *c);
01429 \textcolor{keywordtype}{void} popGenericCommand(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} where);
01430 
01431 \textcolor{comment}{/* MULTI/EXEC/WATCH... */}
01432 \textcolor{keywordtype}{void} unwatchAllKeys(\hyperlink{structclient}{client} *c);
01433 \textcolor{keywordtype}{void} initClientMultiState(\hyperlink{structclient}{client} *c);
01434 \textcolor{keywordtype}{void} freeClientMultiState(\hyperlink{structclient}{client} *c);
01435 \textcolor{keywordtype}{void} queueMultiCommand(\hyperlink{structclient}{client} *c);
01436 \textcolor{keywordtype}{void} touchWatchedKey(redisDb *db, robj *key);
01437 \textcolor{keywordtype}{void} touchWatchedKeysOnFlush(\textcolor{keywordtype}{int} dbid);
01438 \textcolor{keywordtype}{void} discardTransaction(\hyperlink{structclient}{client} *c);
01439 \textcolor{keywordtype}{void} flagTransaction(\hyperlink{structclient}{client} *c);
01440 \textcolor{keywordtype}{void} execCommandPropagateMulti(\hyperlink{structclient}{client} *c);
01441 
01442 \textcolor{comment}{/* Redis object implementation */}
01443 \textcolor{keywordtype}{void} decrRefCount(robj *o);
01444 \textcolor{keywordtype}{void} decrRefCountVoid(\textcolor{keywordtype}{void} *o);
01445 \textcolor{keywordtype}{void} incrRefCount(robj *o);
01446 robj *makeObjectShared(robj *o);
01447 robj *resetRefCount(robj *obj);
01448 \textcolor{keywordtype}{void} freeStringObject(robj *o);
01449 \textcolor{keywordtype}{void} freeListObject(robj *o);
01450 \textcolor{keywordtype}{void} freeSetObject(robj *o);
01451 \textcolor{keywordtype}{void} freeZsetObject(robj *o);
01452 \textcolor{keywordtype}{void} freeHashObject(robj *o);
01453 robj *createObject(\textcolor{keywordtype}{int} type, \textcolor{keywordtype}{void} *ptr);
01454 robj *createStringObject(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *ptr, size\_t len);
01455 robj *createRawStringObject(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *ptr, size\_t len);
01456 robj *createEmbeddedStringObject(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *ptr, size\_t len);
01457 robj *dupStringObject(\textcolor{keyword}{const} robj *o);
01458 \textcolor{keywordtype}{int} isSdsRepresentableAsLongLong(sds s, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} *llval);
01459 \textcolor{keywordtype}{int} isObjectRepresentableAsLongLong(robj *o, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} *llongval);
01460 robj *tryObjectEncoding(robj *o);
01461 robj *getDecodedObject(robj *o);
01462 size\_t stringObjectLen(robj *o);
01463 robj *createStringObjectFromLongLong(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value);
01464 robj *createStringObjectFromLongDouble(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double} value, \textcolor{keywordtype}{int} humanfriendly);
01465 robj *createQuicklistObject(\textcolor{keywordtype}{void});
01466 robj *createZiplistObject(\textcolor{keywordtype}{void});
01467 robj *createSetObject(\textcolor{keywordtype}{void});
01468 robj *createIntsetObject(\textcolor{keywordtype}{void});
01469 robj *createHashObject(\textcolor{keywordtype}{void});
01470 robj *createZsetObject(\textcolor{keywordtype}{void});
01471 robj *createZsetZiplistObject(\textcolor{keywordtype}{void});
01472 robj *createStreamObject(\textcolor{keywordtype}{void});
01473 robj *createModuleObject(moduleType *mt, \textcolor{keywordtype}{void} *value);
01474 \textcolor{keywordtype}{int} getLongFromObjectOrReply(\hyperlink{structclient}{client} *c, robj *o, \textcolor{keywordtype}{long} *target, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *msg);
01475 \textcolor{keywordtype}{int} checkType(\hyperlink{structclient}{client} *c, robj *o, \textcolor{keywordtype}{int} type);
01476 \textcolor{keywordtype}{int} getLongLongFromObjectOrReply(\hyperlink{structclient}{client} *c, robj *o, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} *target, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *msg);
01477 \textcolor{keywordtype}{int} getDoubleFromObjectOrReply(\hyperlink{structclient}{client} *c, robj *o, \textcolor{keywordtype}{double} *target, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *msg);
01478 \textcolor{keywordtype}{int} getDoubleFromObject(\textcolor{keyword}{const} robj *o, \textcolor{keywordtype}{double} *target);
01479 \textcolor{keywordtype}{int} getLongLongFromObject(robj *o, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} *target);
01480 \textcolor{keywordtype}{int} getLongDoubleFromObject(robj *o, \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} *target);
01481 \textcolor{keywordtype}{int} getLongDoubleFromObjectOrReply(\hyperlink{structclient}{client} *c, robj *o, \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} *target, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *msg);
01482 \textcolor{keywordtype}{char} *strEncoding(\textcolor{keywordtype}{int} encoding);
01483 \textcolor{keywordtype}{int} compareStringObjects(robj *a, robj *b);
01484 \textcolor{keywordtype}{int} collateStringObjects(robj *a, robj *b);
01485 \textcolor{keywordtype}{int} equalStringObjects(robj *a, robj *b);
01486 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} estimateObjectIdleTime(robj *o);
01487 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{sdsEncodedObject}\textcolor{preprocessor}{(}\textcolor{preprocessor}{objptr}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{objptr}\textcolor{preprocessor}{->}\textcolor{preprocessor}{encoding} \textcolor{preprocessor}{==} \hyperlink{server_8h_a148bc85e3074e324a6dc5eebcad1bcd5}{OBJ\_ENCODING\_RAW} \textcolor{preprocessor}{||} \textcolor{preprocessor}{objptr}\textcolor{preprocessor}{->}\textcolor{preprocessor}{
      encoding} \textcolor{preprocessor}{==} \hyperlink{server_8h_ac5bb76b546161fd0da4b0ff89b3142ee}{OBJ\_ENCODING\_EMBSTR}\textcolor{preprocessor}{)}
01488 
01489 \textcolor{comment}{/* Synchronous I/O with timeout */}
01490 ssize\_t syncWrite(\textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{char} *ptr, ssize\_t size, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} timeout);
01491 ssize\_t syncRead(\textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{char} *ptr, ssize\_t size, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} timeout);
01492 ssize\_t syncReadLine(\textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{char} *ptr, ssize\_t size, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} timeout);
01493 
01494 \textcolor{comment}{/* Replication */}
01495 \textcolor{keywordtype}{void} replicationFeedSlaves(list *slaves, \textcolor{keywordtype}{int} dictid, robj **argv, \textcolor{keywordtype}{int} argc);
01496 \textcolor{keywordtype}{void} replicationFeedSlavesFromMasterStream(list *slaves, \textcolor{keywordtype}{char} *buf, size\_t buflen);
01497 \textcolor{keywordtype}{void} replicationFeedMonitors(\hyperlink{structclient}{client} *c, list *monitors, \textcolor{keywordtype}{int} dictid, robj **argv, \textcolor{keywordtype}{int} argc);
01498 \textcolor{keywordtype}{void} updateSlavesWaitingBgsave(\textcolor{keywordtype}{int} bgsaveerr, \textcolor{keywordtype}{int} type);
01499 \textcolor{keywordtype}{void} replicationCron(\textcolor{keywordtype}{void});
01500 \textcolor{keywordtype}{void} replicationHandleMasterDisconnection(\textcolor{keywordtype}{void});
01501 \textcolor{keywordtype}{void} replicationCacheMaster(\hyperlink{structclient}{client} *c);
01502 \textcolor{keywordtype}{void} resizeReplicationBacklog(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} newsize);
01503 \textcolor{keywordtype}{void} replicationSetMaster(\textcolor{keywordtype}{char} *ip, \textcolor{keywordtype}{int} port);
01504 \textcolor{keywordtype}{void} replicationUnsetMaster(\textcolor{keywordtype}{void});
01505 \textcolor{keywordtype}{void} refreshGoodSlavesCount(\textcolor{keywordtype}{void});
01506 \textcolor{keywordtype}{void} replicationScriptCacheInit(\textcolor{keywordtype}{void});
01507 \textcolor{keywordtype}{void} replicationScriptCacheFlush(\textcolor{keywordtype}{void});
01508 \textcolor{keywordtype}{void} replicationScriptCacheAdd(sds sha1);
01509 \textcolor{keywordtype}{int} replicationScriptCacheExists(sds sha1);
01510 \textcolor{keywordtype}{void} processClientsWaitingReplicas(\textcolor{keywordtype}{void});
01511 \textcolor{keywordtype}{void} unblockClientWaitingReplicas(\hyperlink{structclient}{client} *c);
01512 \textcolor{keywordtype}{int} replicationCountAcksByOffset(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} offset);
01513 \textcolor{keywordtype}{void} replicationSendNewlineToMaster(\textcolor{keywordtype}{void});
01514 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} replicationGetSlaveOffset(\textcolor{keywordtype}{void});
01515 \textcolor{keywordtype}{char} *replicationGetSlaveName(\hyperlink{structclient}{client} *c);
01516 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} getPsyncInitialOffset(\textcolor{keywordtype}{void});
01517 \textcolor{keywordtype}{int} replicationSetupSlaveForFullResync(\hyperlink{structclient}{client} *slave, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} offset);
01518 \textcolor{keywordtype}{void} changeReplicationId(\textcolor{keywordtype}{void});
01519 \textcolor{keywordtype}{void} clearReplicationId2(\textcolor{keywordtype}{void});
01520 \textcolor{keywordtype}{void} chopReplicationBacklog(\textcolor{keywordtype}{void});
01521 \textcolor{keywordtype}{void} replicationCacheMasterUsingMyself(\textcolor{keywordtype}{void});
01522 \textcolor{keywordtype}{void} feedReplicationBacklog(\textcolor{keywordtype}{void} *ptr, size\_t len);
01523 
01524 \textcolor{comment}{/* Generic persistence functions */}
01525 \textcolor{keywordtype}{void} startLoading(FILE *fp);
01526 \textcolor{keywordtype}{void} loadingProgress(off\_t pos);
01527 \textcolor{keywordtype}{void} stopLoading(\textcolor{keywordtype}{void});
01528 
01529 \textcolor{comment}{/* RDB persistence */}
01530 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{rdb_8h}{"rdb.h"}
01531 \textcolor{keywordtype}{int} rdbSaveRio(rio *rdb, \textcolor{keywordtype}{int} *error, \textcolor{keywordtype}{int} flags, rdbSaveInfo *rsi);
01532 
01533 \textcolor{comment}{/* AOF persistence */}
01534 \textcolor{keywordtype}{void} flushAppendOnlyFile(\textcolor{keywordtype}{int} force);
01535 \textcolor{keywordtype}{void} feedAppendOnlyFile(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, \textcolor{keywordtype}{int} dictid, robj **argv, \textcolor{keywordtype}{int} argc);
01536 \textcolor{keywordtype}{void} aofRemoveTempFile(pid\_t childpid);
01537 \textcolor{keywordtype}{int} rewriteAppendOnlyFileBackground(\textcolor{keywordtype}{void});
01538 \textcolor{keywordtype}{int} loadAppendOnlyFile(\textcolor{keywordtype}{char} *filename);
01539 \textcolor{keywordtype}{void} stopAppendOnly(\textcolor{keywordtype}{void});
01540 \textcolor{keywordtype}{int} startAppendOnly(\textcolor{keywordtype}{void});
01541 \textcolor{keywordtype}{void} backgroundRewriteDoneHandler(\textcolor{keywordtype}{int} exitcode, \textcolor{keywordtype}{int} bysignal);
01542 \textcolor{keywordtype}{void} aofRewriteBufferReset(\textcolor{keywordtype}{void});
01543 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} aofRewriteBufferSize(\textcolor{keywordtype}{void});
01544 ssize\_t aofReadDiffFromParent(\textcolor{keywordtype}{void});
01545 
01546 \textcolor{comment}{/* Child info */}
01547 \textcolor{keywordtype}{void} openChildInfoPipe(\textcolor{keywordtype}{void});
01548 \textcolor{keywordtype}{void} closeChildInfoPipe(\textcolor{keywordtype}{void});
01549 \textcolor{keywordtype}{void} sendChildInfo(\textcolor{keywordtype}{int} process\_type);
01550 \textcolor{keywordtype}{void} receiveChildInfo(\textcolor{keywordtype}{void});
01551 
01552 \textcolor{comment}{/* Sorted sets data type */}
01553 
01554 \textcolor{comment}{/* Input flags. */}
01555 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZADD\_NONE} 0
01556 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZADD\_INCR} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)}    \textcolor{comment}{/* Increment the score instead of setting it. */}
01557 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZADD\_NX} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}1\textcolor{preprocessor}{)}      \textcolor{comment}{/* Don't touch elements not already existing. */}
01558 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZADD\_XX} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}2\textcolor{preprocessor}{)}      \textcolor{comment}{/* Only touch elements already exisitng. */}
01559 
01560 \textcolor{comment}{/* Output flags. */}
01561 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZADD\_NOP} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}3\textcolor{preprocessor}{)}     \textcolor{comment}{/* Operation not performed because of conditionals.*/}
01562 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZADD\_NAN} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}4\textcolor{preprocessor}{)}     \textcolor{comment}{/* Only touch elements already exisitng. */}
01563 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZADD\_ADDED} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}5\textcolor{preprocessor}{)}   \textcolor{comment}{/* The element was new and was added. */}
01564 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZADD\_UPDATED} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}6\textcolor{preprocessor}{)} \textcolor{comment}{/* The element already existed, score updated. */}
01565 
01566 \textcolor{comment}{/* Flags only used by the ZADD command but not by zsetAdd() API: */}
01567 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZADD\_CH} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}16\textcolor{preprocessor}{)}      \textcolor{comment}{/* Return num of elements added or updated. */}
01568 
01569 \textcolor{comment}{/* Struct to hold a inclusive/exclusive range spec by score comparison. */}
\Hypertarget{server_8h_source_l01570}\hyperlink{structzrangespec}{01570} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \{
01571     \textcolor{keywordtype}{double} min, max;
01572     \textcolor{keywordtype}{int} minex, maxex; \textcolor{comment}{/* are min or max exclusive? */}
01573 \} zrangespec;
01574 
01575 \textcolor{comment}{/* Struct to hold an inclusive/exclusive range spec by lexicographic comparison. */}
\Hypertarget{server_8h_source_l01576}\hyperlink{structzlexrangespec}{01576} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \{
01577     sds min, max;     \textcolor{comment}{/* May be set to shared.(minstring|maxstring) */}
01578     \textcolor{keywordtype}{int} minex, maxex; \textcolor{comment}{/* are min or max exclusive? */}
01579 \} zlexrangespec;
01580 
01581 zskiplist *zslCreate(\textcolor{keywordtype}{void});
01582 \textcolor{keywordtype}{void} zslFree(zskiplist *zsl);
01583 zskiplistNode *zslInsert(zskiplist *zsl, \textcolor{keywordtype}{double} score, sds ele);
01584 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zzlInsert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, sds ele, \textcolor{keywordtype}{double} score);
01585 \textcolor{keywordtype}{int} zslDelete(zskiplist *zsl, \textcolor{keywordtype}{double} score, sds ele, zskiplistNode **node);
01586 zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range);
01587 zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range);
01588 \textcolor{keywordtype}{double} zzlGetScore(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *sptr);
01589 \textcolor{keywordtype}{void} zzlNext(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **eptr, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **sptr);
01590 \textcolor{keywordtype}{void} zzlPrev(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **eptr, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **sptr);
01591 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zzlFirstInRange(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, zrangespec *range);
01592 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zzlLastInRange(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, zrangespec *range);
01593 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} zsetLength(\textcolor{keyword}{const} robj *zobj);
01594 \textcolor{keywordtype}{void} zsetConvert(robj *zobj, \textcolor{keywordtype}{int} encoding);
01595 \textcolor{keywordtype}{void} zsetConvertToZiplistIfNeeded(robj *zobj, size\_t maxelelen);
01596 \textcolor{keywordtype}{int} zsetScore(robj *zobj, sds member, \textcolor{keywordtype}{double} *score);
01597 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} zslGetRank(zskiplist *zsl, \textcolor{keywordtype}{double} score, sds o);
01598 \textcolor{keywordtype}{int} zsetAdd(robj *zobj, \textcolor{keywordtype}{double} score, sds ele, \textcolor{keywordtype}{int} *flags, \textcolor{keywordtype}{double} *newscore);
01599 \textcolor{keywordtype}{long} zsetRank(robj *zobj, sds ele, \textcolor{keywordtype}{int} reverse);
01600 \textcolor{keywordtype}{int} zsetDel(robj *zobj, sds ele);
01601 sds ziplistGetObject(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *sptr);
01602 \textcolor{keywordtype}{int} zslValueGteMin(\textcolor{keywordtype}{double} value, zrangespec *spec);
01603 \textcolor{keywordtype}{int} zslValueLteMax(\textcolor{keywordtype}{double} value, zrangespec *spec);
01604 \textcolor{keywordtype}{void} zslFreeLexRange(zlexrangespec *spec);
01605 \textcolor{keywordtype}{int} zslParseLexRange(robj *min, robj *max, zlexrangespec *spec);
01606 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zzlFirstInLexRange(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, zlexrangespec *range);
01607 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zzlLastInLexRange(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, zlexrangespec *range);
01608 zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range);
01609 zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range);
01610 \textcolor{keywordtype}{int} zzlLexValueGteMin(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, zlexrangespec *spec);
01611 \textcolor{keywordtype}{int} zzlLexValueLteMax(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, zlexrangespec *spec);
01612 \textcolor{keywordtype}{int} zslLexValueGteMin(sds value, zlexrangespec *spec);
01613 \textcolor{keywordtype}{int} zslLexValueLteMax(sds value, zlexrangespec *spec);
01614 
01615 \textcolor{comment}{/* Core functions */}
01616 \textcolor{keywordtype}{int} freeMemoryIfNeeded(\textcolor{keywordtype}{void});
01617 \textcolor{keywordtype}{int} processCommand(\hyperlink{structclient}{client} *c);
01618 \textcolor{keywordtype}{void} setupSignalHandlers(\textcolor{keywordtype}{void});
01619 \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *lookupCommand(sds name);
01620 \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *lookupCommandByCString(\textcolor{keywordtype}{char} *s);
01621 \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *lookupCommandOrOriginal(sds name);
01622 \textcolor{keywordtype}{void} call(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} flags);
01623 \textcolor{keywordtype}{void} propagate(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, \textcolor{keywordtype}{int} dbid, robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} flags);
01624 \textcolor{keywordtype}{void} alsoPropagate(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, \textcolor{keywordtype}{int} dbid, robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} target);
01625 \textcolor{keywordtype}{void} forceCommandPropagation(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} flags);
01626 \textcolor{keywordtype}{void} preventCommandPropagation(\hyperlink{structclient}{client} *c);
01627 \textcolor{keywordtype}{void} preventCommandAOF(\hyperlink{structclient}{client} *c);
01628 \textcolor{keywordtype}{void} preventCommandReplication(\hyperlink{structclient}{client} *c);
01629 \textcolor{keywordtype}{int} prepareForShutdown();
01630 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \_\_GNUC\_\_
01631 \textcolor{keywordtype}{void} serverLog(\textcolor{keywordtype}{int} level, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, ...)
01632     \textcolor{keyword}{\_\_attribute\_\_}((format(printf, 2, 3)));
01633 \textcolor{preprocessor}{#}\textcolor{preprocessor}{else}
01634 \textcolor{keywordtype}{void} serverLog(\textcolor{keywordtype}{int} level, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, ...);
01635 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
01636 \textcolor{keywordtype}{void} serverLogRaw(\textcolor{keywordtype}{int} level, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *msg);
01637 \textcolor{keywordtype}{void} serverLogFromHandler(\textcolor{keywordtype}{int} level, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *msg);
01638 \textcolor{keywordtype}{void} usage(\textcolor{keywordtype}{void});
01639 \textcolor{keywordtype}{void} updateDictResizePolicy(\textcolor{keywordtype}{void});
01640 \textcolor{keywordtype}{int} htNeedsResize(dict *dict);
01641 \textcolor{keywordtype}{void} populateCommandTable(\textcolor{keywordtype}{void});
01642 \textcolor{keywordtype}{void} resetCommandTableStats(\textcolor{keywordtype}{void});
01643 \textcolor{keywordtype}{void} adjustOpenFilesLimit(\textcolor{keywordtype}{void});
01644 \textcolor{keywordtype}{void} closeListeningSockets(\textcolor{keywordtype}{int} unlink\_unix\_socket);
01645 \textcolor{keywordtype}{void} updateCachedTime(\textcolor{keywordtype}{void});
01646 \textcolor{keywordtype}{void} resetServerStats(\textcolor{keywordtype}{void});
01647 \textcolor{keywordtype}{void} activeDefragCycle(\textcolor{keywordtype}{void});
01648 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} getLRUClock(\textcolor{keywordtype}{void});
01649 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} LRU\_CLOCK(\textcolor{keywordtype}{void});
01650 \textcolor{keyword}{const} \textcolor{keywordtype}{char} *evictPolicyToString(\textcolor{keywordtype}{void});
01651 \textcolor{keyword}{struct} \hyperlink{structredisMemOverhead}{redisMemOverhead} *getMemoryOverheadData(\textcolor{keywordtype}{void});
01652 \textcolor{keywordtype}{void} freeMemoryOverheadData(\textcolor{keyword}{struct} \hyperlink{structredisMemOverhead}{redisMemOverhead} *mh);
01653 
01654 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{RESTART\_SERVER\_NONE} 0
01655 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{RESTART\_SERVER\_GRACEFULLY} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)}     \textcolor{comment}{/* Do proper shutdown. */}
01656 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{RESTART\_SERVER\_CONFIG\_REWRITE} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}1\textcolor{preprocessor}{)} \textcolor{comment}{/* CONFIG REWRITE before restart.*/}
01657 \textcolor{keywordtype}{int} restartServer(\textcolor{keywordtype}{int} flags, mstime\_t delay);
01658 
01659 \textcolor{comment}{/* Set data type */}
01660 robj *setTypeCreate(sds value);
01661 \textcolor{keywordtype}{int} setTypeAdd(robj *subject, sds value);
01662 \textcolor{keywordtype}{int} setTypeRemove(robj *subject, sds value);
01663 \textcolor{keywordtype}{int} setTypeIsMember(robj *subject, sds value);
01664 setTypeIterator *setTypeInitIterator(robj *subject);
01665 \textcolor{keywordtype}{void} setTypeReleaseIterator(setTypeIterator *si);
01666 \textcolor{keywordtype}{int} setTypeNext(setTypeIterator *si, sds *sdsele, int64\_t *llele);
01667 sds setTypeNextObject(setTypeIterator *si);
01668 \textcolor{keywordtype}{int} setTypeRandomElement(robj *setobj, sds *sdsele, int64\_t *llele);
01669 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} setTypeRandomElements(robj *set, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} count, robj *aux\_set);
01670 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} setTypeSize(\textcolor{keyword}{const} robj *subject);
01671 \textcolor{keywordtype}{void} setTypeConvert(robj *subject, \textcolor{keywordtype}{int} enc);
01672 
01673 \textcolor{comment}{/* Hash data type */}
01674 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{HASH\_SET\_TAKE\_FIELD} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)}
01675 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{HASH\_SET\_TAKE\_VALUE} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}1\textcolor{preprocessor}{)}
01676 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{HASH\_SET\_COPY} 0
01677 
01678 \textcolor{keywordtype}{void} hashTypeConvert(robj *o, \textcolor{keywordtype}{int} enc);
01679 \textcolor{keywordtype}{void} hashTypeTryConversion(robj *subject, robj **argv, \textcolor{keywordtype}{int} start, \textcolor{keywordtype}{int} end);
01680 \textcolor{keywordtype}{void} hashTypeTryObjectEncoding(robj *subject, robj **o1, robj **o2);
01681 \textcolor{keywordtype}{int} hashTypeExists(robj *o, sds key);
01682 \textcolor{keywordtype}{int} hashTypeDelete(robj *o, sds key);
01683 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} hashTypeLength(\textcolor{keyword}{const} robj *o);
01684 hashTypeIterator *hashTypeInitIterator(robj *subject);
01685 \textcolor{keywordtype}{void} hashTypeReleaseIterator(hashTypeIterator *hi);
01686 \textcolor{keywordtype}{int} hashTypeNext(hashTypeIterator *hi);
01687 \textcolor{keywordtype}{void} hashTypeCurrentFromZiplist(hashTypeIterator *hi, \textcolor{keywordtype}{int} what,
01688                                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **vstr,
01689                                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *vlen,
01690                                 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} *vll);
01691 sds hashTypeCurrentFromHashTable(hashTypeIterator *hi, \textcolor{keywordtype}{int} what);
01692 \textcolor{keywordtype}{void} hashTypeCurrentObject(hashTypeIterator *hi, \textcolor{keywordtype}{int} what, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **vstr, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *vlen, \textcolor{keywordtype}{
      long} \textcolor{keywordtype}{long} *vll);
01693 sds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, \textcolor{keywordtype}{int} what);
01694 robj *hashTypeLookupWriteOrCreate(\hyperlink{structclient}{client} *c, robj *key);
01695 robj *hashTypeGetValueObject(robj *o, sds field);
01696 \textcolor{keywordtype}{int} hashTypeSet(robj *o, sds field, sds value, \textcolor{keywordtype}{int} flags);
01697 
01698 \textcolor{comment}{/* Pub / Sub */}
01699 \textcolor{keywordtype}{int} pubsubUnsubscribeAllChannels(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} notify);
01700 \textcolor{keywordtype}{int} pubsubUnsubscribeAllPatterns(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} notify);
01701 \textcolor{keywordtype}{void} freePubsubPattern(\textcolor{keywordtype}{void} *p);
01702 \textcolor{keywordtype}{int} listMatchPubsubPattern(\textcolor{keywordtype}{void} *a, \textcolor{keywordtype}{void} *b);
01703 \textcolor{keywordtype}{int} pubsubPublishMessage(robj *channel, robj *message);
01704 
01705 \textcolor{comment}{/* Keyspace events notification */}
01706 \textcolor{keywordtype}{void} notifyKeyspaceEvent(\textcolor{keywordtype}{int} type, \textcolor{keywordtype}{char} *event, robj *key, \textcolor{keywordtype}{int} dbid);
01707 \textcolor{keywordtype}{int} keyspaceEventsStringToFlags(\textcolor{keywordtype}{char} *classes);
01708 sds keyspaceEventsFlagsToString(\textcolor{keywordtype}{int} flags);
01709 
01710 \textcolor{comment}{/* Configuration */}
01711 \textcolor{keywordtype}{void} loadServerConfig(\textcolor{keywordtype}{char} *filename, \textcolor{keywordtype}{char} *options);
01712 \textcolor{keywordtype}{void} appendServerSaveParams(time\_t seconds, \textcolor{keywordtype}{int} changes);
01713 \textcolor{keywordtype}{void} resetServerSaveParams(\textcolor{keywordtype}{void});
01714 \textcolor{keyword}{struct} rewriteConfigState; \textcolor{comment}{/* Forward declaration to export API. */}
01715 \textcolor{keywordtype}{void} rewriteConfigRewriteLine(\textcolor{keyword}{struct} rewriteConfigState *state, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *option, sds line, \textcolor{keywordtype}{int} 
      force);
01716 \textcolor{keywordtype}{int} rewriteConfig(\textcolor{keywordtype}{char} *path);
01717 
01718 \textcolor{comment}{/* db.c -- Keyspace access API */}
01719 \textcolor{keywordtype}{int} removeExpire(redisDb *db, robj *key);
01720 \textcolor{keywordtype}{void} propagateExpire(redisDb *db, robj *key, \textcolor{keywordtype}{int} lazy);
01721 \textcolor{keywordtype}{int} expireIfNeeded(redisDb *db, robj *key);
01722 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} getExpire(redisDb *db, robj *key);
01723 \textcolor{keywordtype}{void} setExpire(\hyperlink{structclient}{client} *c, redisDb *db, robj *key, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} when);
01724 robj *lookupKey(redisDb *db, robj *key, \textcolor{keywordtype}{int} flags);
01725 robj *lookupKeyRead(redisDb *db, robj *key);
01726 robj *lookupKeyWrite(redisDb *db, robj *key);
01727 robj *lookupKeyReadOrReply(\hyperlink{structclient}{client} *c, robj *key, robj *reply);
01728 robj *lookupKeyWriteOrReply(\hyperlink{structclient}{client} *c, robj *key, robj *reply);
01729 robj *lookupKeyReadWithFlags(redisDb *db, robj *key, \textcolor{keywordtype}{int} flags);
01730 robj *objectCommandLookup(\hyperlink{structclient}{client} *c, robj *key);
01731 robj *objectCommandLookupOrReply(\hyperlink{structclient}{client} *c, robj *key, robj *reply);
01732 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LOOKUP\_NONE} 0
01733 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LOOKUP\_NOTOUCH} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)}
01734 \textcolor{keywordtype}{void} dbAdd(redisDb *db, robj *key, robj *val);
01735 \textcolor{keywordtype}{void} dbOverwrite(redisDb *db, robj *key, robj *val);
01736 \textcolor{keywordtype}{void} setKey(redisDb *db, robj *key, robj *val);
01737 \textcolor{keywordtype}{int} dbExists(redisDb *db, robj *key);
01738 robj *dbRandomKey(redisDb *db);
01739 \textcolor{keywordtype}{int} dbSyncDelete(redisDb *db, robj *key);
01740 \textcolor{keywordtype}{int} dbDelete(redisDb *db, robj *key);
01741 robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o);
01742 
01743 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{EMPTYDB\_NO\_FLAGS} 0      \textcolor{comment}{/* No flags. */}
01744 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{EMPTYDB\_ASYNC} \textcolor{preprocessor}{(}1\textcolor{preprocessor}{<<}0\textcolor{preprocessor}{)}    \textcolor{comment}{/* Reclaim memory in another thread. */}
01745 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} emptyDb(\textcolor{keywordtype}{int} dbnum, \textcolor{keywordtype}{int} flags, \textcolor{keywordtype}{void}(callback)(\textcolor{keywordtype}{void}*));
01746 
01747 \textcolor{keywordtype}{int} selectDb(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} id);
01748 \textcolor{keywordtype}{void} signalModifiedKey(redisDb *db, robj *key);
01749 \textcolor{keywordtype}{void} signalFlushedDb(\textcolor{keywordtype}{int} dbid);
01750 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} getKeysInSlot(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} hashslot, robj **keys, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} count);
01751 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} countKeysInSlot(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} hashslot);
01752 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} delKeysInSlot(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} hashslot);
01753 \textcolor{keywordtype}{int} verifyClusterConfigWithData(\textcolor{keywordtype}{void});
01754 \textcolor{keywordtype}{void} scanGenericCommand(\hyperlink{structclient}{client} *c, robj *o, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} cursor);
01755 \textcolor{keywordtype}{int} parseScanCursorOrReply(\hyperlink{structclient}{client} *c, robj *o, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *cursor);
01756 \textcolor{keywordtype}{void} slotToKeyAdd(robj *key);
01757 \textcolor{keywordtype}{void} slotToKeyDel(robj *key);
01758 \textcolor{keywordtype}{void} slotToKeyFlush(\textcolor{keywordtype}{void});
01759 \textcolor{keywordtype}{int} dbAsyncDelete(redisDb *db, robj *key);
01760 \textcolor{keywordtype}{void} emptyDbAsync(redisDb *db);
01761 \textcolor{keywordtype}{void} slotToKeyFlushAsync(\textcolor{keywordtype}{void});
01762 size\_t lazyfreeGetPendingObjectsCount(\textcolor{keywordtype}{void});
01763 
01764 \textcolor{comment}{/* API to get key arguments from commands */}
01765 \textcolor{keywordtype}{int} *getKeysFromCommand(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} *numkeys);
01766 \textcolor{keywordtype}{void} getKeysFreeResult(\textcolor{keywordtype}{int} *result);
01767 \textcolor{keywordtype}{int} *zunionInterGetKeys(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd,robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} *numkeys);
01768 \textcolor{keywordtype}{int} *evalGetKeys(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} *numkeys);
01769 \textcolor{keywordtype}{int} *sortGetKeys(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} *numkeys);
01770 \textcolor{keywordtype}{int} *migrateGetKeys(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} *numkeys);
01771 \textcolor{keywordtype}{int} *georadiusGetKeys(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} *numkeys);
01772 \textcolor{keywordtype}{int} *xreadGetKeys(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} *numkeys);
01773 
01774 \textcolor{comment}{/* Cluster */}
01775 \textcolor{keywordtype}{void} clusterInit(\textcolor{keywordtype}{void});
01776 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} crc16(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *buf, \textcolor{keywordtype}{int} len);
01777 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} keyHashSlot(\textcolor{keywordtype}{char} *key, \textcolor{keywordtype}{int} keylen);
01778 \textcolor{keywordtype}{void} clusterCron(\textcolor{keywordtype}{void});
01779 \textcolor{keywordtype}{void} clusterPropagatePublish(robj *channel, robj *message);
01780 \textcolor{keywordtype}{void} migrateCloseTimedoutSockets(\textcolor{keywordtype}{void});
01781 \textcolor{keywordtype}{void} clusterBeforeSleep(\textcolor{keywordtype}{void});
01782 
01783 \textcolor{comment}{/* Sentinel */}
01784 \textcolor{keywordtype}{void} initSentinelConfig(\textcolor{keywordtype}{void});
01785 \textcolor{keywordtype}{void} initSentinel(\textcolor{keywordtype}{void});
01786 \textcolor{keywordtype}{void} sentinelTimer(\textcolor{keywordtype}{void});
01787 \textcolor{keywordtype}{char} *sentinelHandleConfiguration(\textcolor{keywordtype}{char} **argv, \textcolor{keywordtype}{int} argc);
01788 \textcolor{keywordtype}{void} sentinelIsRunning(\textcolor{keywordtype}{void});
01789 
01790 \textcolor{comment}{/* redis-check-rdb & aof */}
01791 \textcolor{keywordtype}{int} redis\_check\_rdb(\textcolor{keywordtype}{char} *rdbfilename, FILE *fp);
01792 \textcolor{keywordtype}{int} redis\_check\_rdb\_main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv, FILE *fp);
01793 \textcolor{keywordtype}{int} redis\_check\_aof\_main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv);
01794 
01795 \textcolor{comment}{/* Scripting */}
01796 \textcolor{keywordtype}{void} scriptingInit(\textcolor{keywordtype}{int} setup);
01797 \textcolor{keywordtype}{int} ldbRemoveChild(pid\_t pid);
01798 \textcolor{keywordtype}{void} ldbKillForkedSessions(\textcolor{keywordtype}{void});
01799 \textcolor{keywordtype}{int} ldbPendingChildren(\textcolor{keywordtype}{void});
01800 sds luaCreateFunction(\hyperlink{structclient}{client} *c, lua\_State *lua, robj *body);
01801 
01802 \textcolor{comment}{/* Blocked clients */}
01803 \textcolor{keywordtype}{void} processUnblockedClients(\textcolor{keywordtype}{void});
01804 \textcolor{keywordtype}{void} blockClient(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} btype);
01805 \textcolor{keywordtype}{void} unblockClient(\hyperlink{structclient}{client} *c);
01806 \textcolor{keywordtype}{void} replyToBlockedClientTimedOut(\hyperlink{structclient}{client} *c);
01807 \textcolor{keywordtype}{int} getTimeoutFromObjectOrReply(\hyperlink{structclient}{client} *c, robj *object, mstime\_t *timeout, \textcolor{keywordtype}{int} unit);
01808 \textcolor{keywordtype}{void} disconnectAllBlockedClients(\textcolor{keywordtype}{void});
01809 \textcolor{keywordtype}{void} handleClientsBlockedOnKeys(\textcolor{keywordtype}{void});
01810 \textcolor{keywordtype}{void} signalKeyAsReady(redisDb *db, robj *key);
01811 \textcolor{keywordtype}{void} blockForKeys(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} btype, robj **keys, \textcolor{keywordtype}{int} numkeys, mstime\_t timeout, robj *target
      , streamID *ids);
01812 
01813 \textcolor{comment}{/* expire.c -- Handling of expired keys */}
01814 \textcolor{keywordtype}{void} activeExpireCycle(\textcolor{keywordtype}{int} type);
01815 \textcolor{keywordtype}{void} expireSlaveKeys(\textcolor{keywordtype}{void});
01816 \textcolor{keywordtype}{void} rememberSlaveKeyWithExpire(redisDb *db, robj *key);
01817 \textcolor{keywordtype}{void} flushSlaveKeysWithExpireList(\textcolor{keywordtype}{void});
01818 size\_t getSlaveKeyWithExpireCount(\textcolor{keywordtype}{void});
01819 
01820 \textcolor{comment}{/* evict.c -- maxmemory handling and LRU eviction. */}
01821 \textcolor{keywordtype}{void} evictionPoolAlloc(\textcolor{keywordtype}{void});
01822 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LFU\_INIT\_VAL} 5
01823 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} LFUGetTimeInMinutes(\textcolor{keywordtype}{void});
01824 uint8\_t LFULogIncr(uint8\_t value);
01825 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} LFUDecrAndReturn(robj *o);
01826 
01827 \textcolor{comment}{/* Keys hashing / comparison functions for dict.c hash tables. */}
01828 uint64\_t dictSdsHash(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *key);
01829 \textcolor{keywordtype}{int} dictSdsKeyCompare(\textcolor{keywordtype}{void} *privdata, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key1, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key2);
01830 \textcolor{keywordtype}{void} dictSdsDestructor(\textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{void} *val);
01831 
01832 \textcolor{comment}{/* Git SHA1 */}
01833 \textcolor{keywordtype}{char} *redisGitSHA1(\textcolor{keywordtype}{void});
01834 \textcolor{keywordtype}{char} *redisGitDirty(\textcolor{keywordtype}{void});
01835 uint64\_t redisBuildId(\textcolor{keywordtype}{void});
01836 
01837 \textcolor{comment}{/* Commands prototypes */}
01838 \textcolor{keywordtype}{void} authCommand(\hyperlink{structclient}{client} *c);
01839 \textcolor{keywordtype}{void} pingCommand(\hyperlink{structclient}{client} *c);
01840 \textcolor{keywordtype}{void} echoCommand(\hyperlink{structclient}{client} *c);
01841 \textcolor{keywordtype}{void} commandCommand(\hyperlink{structclient}{client} *c);
01842 \textcolor{keywordtype}{void} setCommand(\hyperlink{structclient}{client} *c);
01843 \textcolor{keywordtype}{void} setnxCommand(\hyperlink{structclient}{client} *c);
01844 \textcolor{keywordtype}{void} setexCommand(\hyperlink{structclient}{client} *c);
01845 \textcolor{keywordtype}{void} psetexCommand(\hyperlink{structclient}{client} *c);
01846 \textcolor{keywordtype}{void} getCommand(\hyperlink{structclient}{client} *c);
01847 \textcolor{keywordtype}{void} delCommand(\hyperlink{structclient}{client} *c);
01848 \textcolor{keywordtype}{void} unlinkCommand(\hyperlink{structclient}{client} *c);
01849 \textcolor{keywordtype}{void} existsCommand(\hyperlink{structclient}{client} *c);
01850 \textcolor{keywordtype}{void} setbitCommand(\hyperlink{structclient}{client} *c);
01851 \textcolor{keywordtype}{void} getbitCommand(\hyperlink{structclient}{client} *c);
01852 \textcolor{keywordtype}{void} bitfieldCommand(\hyperlink{structclient}{client} *c);
01853 \textcolor{keywordtype}{void} setrangeCommand(\hyperlink{structclient}{client} *c);
01854 \textcolor{keywordtype}{void} getrangeCommand(\hyperlink{structclient}{client} *c);
01855 \textcolor{keywordtype}{void} incrCommand(\hyperlink{structclient}{client} *c);
01856 \textcolor{keywordtype}{void} decrCommand(\hyperlink{structclient}{client} *c);
01857 \textcolor{keywordtype}{void} incrbyCommand(\hyperlink{structclient}{client} *c);
01858 \textcolor{keywordtype}{void} decrbyCommand(\hyperlink{structclient}{client} *c);
01859 \textcolor{keywordtype}{void} incrbyfloatCommand(\hyperlink{structclient}{client} *c);
01860 \textcolor{keywordtype}{void} selectCommand(\hyperlink{structclient}{client} *c);
01861 \textcolor{keywordtype}{void} swapdbCommand(\hyperlink{structclient}{client} *c);
01862 \textcolor{keywordtype}{void} randomkeyCommand(\hyperlink{structclient}{client} *c);
01863 \textcolor{keywordtype}{void} keysCommand(\hyperlink{structclient}{client} *c);
01864 \textcolor{keywordtype}{void} scanCommand(\hyperlink{structclient}{client} *c);
01865 \textcolor{keywordtype}{void} dbsizeCommand(\hyperlink{structclient}{client} *c);
01866 \textcolor{keywordtype}{void} lastsaveCommand(\hyperlink{structclient}{client} *c);
01867 \textcolor{keywordtype}{void} saveCommand(\hyperlink{structclient}{client} *c);
01868 \textcolor{keywordtype}{void} bgsaveCommand(\hyperlink{structclient}{client} *c);
01869 \textcolor{keywordtype}{void} bgrewriteaofCommand(\hyperlink{structclient}{client} *c);
01870 \textcolor{keywordtype}{void} shutdownCommand(\hyperlink{structclient}{client} *c);
01871 \textcolor{keywordtype}{void} moveCommand(\hyperlink{structclient}{client} *c);
01872 \textcolor{keywordtype}{void} renameCommand(\hyperlink{structclient}{client} *c);
01873 \textcolor{keywordtype}{void} renamenxCommand(\hyperlink{structclient}{client} *c);
01874 \textcolor{keywordtype}{void} lpushCommand(\hyperlink{structclient}{client} *c);
01875 \textcolor{keywordtype}{void} rpushCommand(\hyperlink{structclient}{client} *c);
01876 \textcolor{keywordtype}{void} lpushxCommand(\hyperlink{structclient}{client} *c);
01877 \textcolor{keywordtype}{void} rpushxCommand(\hyperlink{structclient}{client} *c);
01878 \textcolor{keywordtype}{void} linsertCommand(\hyperlink{structclient}{client} *c);
01879 \textcolor{keywordtype}{void} lpopCommand(\hyperlink{structclient}{client} *c);
01880 \textcolor{keywordtype}{void} rpopCommand(\hyperlink{structclient}{client} *c);
01881 \textcolor{keywordtype}{void} llenCommand(\hyperlink{structclient}{client} *c);
01882 \textcolor{keywordtype}{void} lindexCommand(\hyperlink{structclient}{client} *c);
01883 \textcolor{keywordtype}{void} lrangeCommand(\hyperlink{structclient}{client} *c);
01884 \textcolor{keywordtype}{void} ltrimCommand(\hyperlink{structclient}{client} *c);
01885 \textcolor{keywordtype}{void} typeCommand(\hyperlink{structclient}{client} *c);
01886 \textcolor{keywordtype}{void} lsetCommand(\hyperlink{structclient}{client} *c);
01887 \textcolor{keywordtype}{void} saddCommand(\hyperlink{structclient}{client} *c);
01888 \textcolor{keywordtype}{void} sremCommand(\hyperlink{structclient}{client} *c);
01889 \textcolor{keywordtype}{void} smoveCommand(\hyperlink{structclient}{client} *c);
01890 \textcolor{keywordtype}{void} sismemberCommand(\hyperlink{structclient}{client} *c);
01891 \textcolor{keywordtype}{void} scardCommand(\hyperlink{structclient}{client} *c);
01892 \textcolor{keywordtype}{void} spopCommand(\hyperlink{structclient}{client} *c);
01893 \textcolor{keywordtype}{void} srandmemberCommand(\hyperlink{structclient}{client} *c);
01894 \textcolor{keywordtype}{void} sinterCommand(\hyperlink{structclient}{client} *c);
01895 \textcolor{keywordtype}{void} sinterstoreCommand(\hyperlink{structclient}{client} *c);
01896 \textcolor{keywordtype}{void} sunionCommand(\hyperlink{structclient}{client} *c);
01897 \textcolor{keywordtype}{void} sunionstoreCommand(\hyperlink{structclient}{client} *c);
01898 \textcolor{keywordtype}{void} sdiffCommand(\hyperlink{structclient}{client} *c);
01899 \textcolor{keywordtype}{void} sdiffstoreCommand(\hyperlink{structclient}{client} *c);
01900 \textcolor{keywordtype}{void} sscanCommand(\hyperlink{structclient}{client} *c);
01901 \textcolor{keywordtype}{void} syncCommand(\hyperlink{structclient}{client} *c);
01902 \textcolor{keywordtype}{void} flushdbCommand(\hyperlink{structclient}{client} *c);
01903 \textcolor{keywordtype}{void} flushallCommand(\hyperlink{structclient}{client} *c);
01904 \textcolor{keywordtype}{void} sortCommand(\hyperlink{structclient}{client} *c);
01905 \textcolor{keywordtype}{void} lremCommand(\hyperlink{structclient}{client} *c);
01906 \textcolor{keywordtype}{void} rpoplpushCommand(\hyperlink{structclient}{client} *c);
01907 \textcolor{keywordtype}{void} infoCommand(\hyperlink{structclient}{client} *c);
01908 \textcolor{keywordtype}{void} mgetCommand(\hyperlink{structclient}{client} *c);
01909 \textcolor{keywordtype}{void} monitorCommand(\hyperlink{structclient}{client} *c);
01910 \textcolor{keywordtype}{void} expireCommand(\hyperlink{structclient}{client} *c);
01911 \textcolor{keywordtype}{void} expireatCommand(\hyperlink{structclient}{client} *c);
01912 \textcolor{keywordtype}{void} pexpireCommand(\hyperlink{structclient}{client} *c);
01913 \textcolor{keywordtype}{void} pexpireatCommand(\hyperlink{structclient}{client} *c);
01914 \textcolor{keywordtype}{void} getsetCommand(\hyperlink{structclient}{client} *c);
01915 \textcolor{keywordtype}{void} ttlCommand(\hyperlink{structclient}{client} *c);
01916 \textcolor{keywordtype}{void} touchCommand(\hyperlink{structclient}{client} *c);
01917 \textcolor{keywordtype}{void} pttlCommand(\hyperlink{structclient}{client} *c);
01918 \textcolor{keywordtype}{void} persistCommand(\hyperlink{structclient}{client} *c);
01919 \textcolor{keywordtype}{void} slaveofCommand(\hyperlink{structclient}{client} *c);
01920 \textcolor{keywordtype}{void} roleCommand(\hyperlink{structclient}{client} *c);
01921 \textcolor{keywordtype}{void} debugCommand(\hyperlink{structclient}{client} *c);
01922 \textcolor{keywordtype}{void} msetCommand(\hyperlink{structclient}{client} *c);
01923 \textcolor{keywordtype}{void} msetnxCommand(\hyperlink{structclient}{client} *c);
01924 \textcolor{keywordtype}{void} zaddCommand(\hyperlink{structclient}{client} *c);
01925 \textcolor{keywordtype}{void} zincrbyCommand(\hyperlink{structclient}{client} *c);
01926 \textcolor{keywordtype}{void} zrangeCommand(\hyperlink{structclient}{client} *c);
01927 \textcolor{keywordtype}{void} zrangebyscoreCommand(\hyperlink{structclient}{client} *c);
01928 \textcolor{keywordtype}{void} zrevrangebyscoreCommand(\hyperlink{structclient}{client} *c);
01929 \textcolor{keywordtype}{void} zrangebylexCommand(\hyperlink{structclient}{client} *c);
01930 \textcolor{keywordtype}{void} zrevrangebylexCommand(\hyperlink{structclient}{client} *c);
01931 \textcolor{keywordtype}{void} zcountCommand(\hyperlink{structclient}{client} *c);
01932 \textcolor{keywordtype}{void} zlexcountCommand(\hyperlink{structclient}{client} *c);
01933 \textcolor{keywordtype}{void} zrevrangeCommand(\hyperlink{structclient}{client} *c);
01934 \textcolor{keywordtype}{void} zcardCommand(\hyperlink{structclient}{client} *c);
01935 \textcolor{keywordtype}{void} zremCommand(\hyperlink{structclient}{client} *c);
01936 \textcolor{keywordtype}{void} zscoreCommand(\hyperlink{structclient}{client} *c);
01937 \textcolor{keywordtype}{void} zremrangebyscoreCommand(\hyperlink{structclient}{client} *c);
01938 \textcolor{keywordtype}{void} zremrangebylexCommand(\hyperlink{structclient}{client} *c);
01939 \textcolor{keywordtype}{void} multiCommand(\hyperlink{structclient}{client} *c);
01940 \textcolor{keywordtype}{void} execCommand(\hyperlink{structclient}{client} *c);
01941 \textcolor{keywordtype}{void} discardCommand(\hyperlink{structclient}{client} *c);
01942 \textcolor{keywordtype}{void} blpopCommand(\hyperlink{structclient}{client} *c);
01943 \textcolor{keywordtype}{void} brpopCommand(\hyperlink{structclient}{client} *c);
01944 \textcolor{keywordtype}{void} brpoplpushCommand(\hyperlink{structclient}{client} *c);
01945 \textcolor{keywordtype}{void} appendCommand(\hyperlink{structclient}{client} *c);
01946 \textcolor{keywordtype}{void} strlenCommand(\hyperlink{structclient}{client} *c);
01947 \textcolor{keywordtype}{void} zrankCommand(\hyperlink{structclient}{client} *c);
01948 \textcolor{keywordtype}{void} zrevrankCommand(\hyperlink{structclient}{client} *c);
01949 \textcolor{keywordtype}{void} hsetCommand(\hyperlink{structclient}{client} *c);
01950 \textcolor{keywordtype}{void} hsetnxCommand(\hyperlink{structclient}{client} *c);
01951 \textcolor{keywordtype}{void} hgetCommand(\hyperlink{structclient}{client} *c);
01952 \textcolor{keywordtype}{void} hmsetCommand(\hyperlink{structclient}{client} *c);
01953 \textcolor{keywordtype}{void} hmgetCommand(\hyperlink{structclient}{client} *c);
01954 \textcolor{keywordtype}{void} hdelCommand(\hyperlink{structclient}{client} *c);
01955 \textcolor{keywordtype}{void} hlenCommand(\hyperlink{structclient}{client} *c);
01956 \textcolor{keywordtype}{void} hstrlenCommand(\hyperlink{structclient}{client} *c);
01957 \textcolor{keywordtype}{void} zremrangebyrankCommand(\hyperlink{structclient}{client} *c);
01958 \textcolor{keywordtype}{void} zunionstoreCommand(\hyperlink{structclient}{client} *c);
01959 \textcolor{keywordtype}{void} zinterstoreCommand(\hyperlink{structclient}{client} *c);
01960 \textcolor{keywordtype}{void} zscanCommand(\hyperlink{structclient}{client} *c);
01961 \textcolor{keywordtype}{void} hkeysCommand(\hyperlink{structclient}{client} *c);
01962 \textcolor{keywordtype}{void} hvalsCommand(\hyperlink{structclient}{client} *c);
01963 \textcolor{keywordtype}{void} hgetallCommand(\hyperlink{structclient}{client} *c);
01964 \textcolor{keywordtype}{void} hexistsCommand(\hyperlink{structclient}{client} *c);
01965 \textcolor{keywordtype}{void} hscanCommand(\hyperlink{structclient}{client} *c);
01966 \textcolor{keywordtype}{void} configCommand(\hyperlink{structclient}{client} *c);
01967 \textcolor{keywordtype}{void} hincrbyCommand(\hyperlink{structclient}{client} *c);
01968 \textcolor{keywordtype}{void} hincrbyfloatCommand(\hyperlink{structclient}{client} *c);
01969 \textcolor{keywordtype}{void} subscribeCommand(\hyperlink{structclient}{client} *c);
01970 \textcolor{keywordtype}{void} unsubscribeCommand(\hyperlink{structclient}{client} *c);
01971 \textcolor{keywordtype}{void} psubscribeCommand(\hyperlink{structclient}{client} *c);
01972 \textcolor{keywordtype}{void} punsubscribeCommand(\hyperlink{structclient}{client} *c);
01973 \textcolor{keywordtype}{void} publishCommand(\hyperlink{structclient}{client} *c);
01974 \textcolor{keywordtype}{void} pubsubCommand(\hyperlink{structclient}{client} *c);
01975 \textcolor{keywordtype}{void} watchCommand(\hyperlink{structclient}{client} *c);
01976 \textcolor{keywordtype}{void} unwatchCommand(\hyperlink{structclient}{client} *c);
01977 \textcolor{keywordtype}{void} clusterCommand(\hyperlink{structclient}{client} *c);
01978 \textcolor{keywordtype}{void} restoreCommand(\hyperlink{structclient}{client} *c);
01979 \textcolor{keywordtype}{void} migrateCommand(\hyperlink{structclient}{client} *c);
01980 \textcolor{keywordtype}{void} askingCommand(\hyperlink{structclient}{client} *c);
01981 \textcolor{keywordtype}{void} readonlyCommand(\hyperlink{structclient}{client} *c);
01982 \textcolor{keywordtype}{void} readwriteCommand(\hyperlink{structclient}{client} *c);
01983 \textcolor{keywordtype}{void} dumpCommand(\hyperlink{structclient}{client} *c);
01984 \textcolor{keywordtype}{void} objectCommand(\hyperlink{structclient}{client} *c);
01985 \textcolor{keywordtype}{void} memoryCommand(\hyperlink{structclient}{client} *c);
01986 \textcolor{keywordtype}{void} clientCommand(\hyperlink{structclient}{client} *c);
01987 \textcolor{keywordtype}{void} evalCommand(\hyperlink{structclient}{client} *c);
01988 \textcolor{keywordtype}{void} evalShaCommand(\hyperlink{structclient}{client} *c);
01989 \textcolor{keywordtype}{void} scriptCommand(\hyperlink{structclient}{client} *c);
01990 \textcolor{keywordtype}{void} timeCommand(\hyperlink{structclient}{client} *c);
01991 \textcolor{keywordtype}{void} bitopCommand(\hyperlink{structclient}{client} *c);
01992 \textcolor{keywordtype}{void} bitcountCommand(\hyperlink{structclient}{client} *c);
01993 \textcolor{keywordtype}{void} bitposCommand(\hyperlink{structclient}{client} *c);
01994 \textcolor{keywordtype}{void} replconfCommand(\hyperlink{structclient}{client} *c);
01995 \textcolor{keywordtype}{void} waitCommand(\hyperlink{structclient}{client} *c);
01996 \textcolor{keywordtype}{void} geoencodeCommand(\hyperlink{structclient}{client} *c);
01997 \textcolor{keywordtype}{void} geodecodeCommand(\hyperlink{structclient}{client} *c);
01998 \textcolor{keywordtype}{void} georadiusbymemberCommand(\hyperlink{structclient}{client} *c);
01999 \textcolor{keywordtype}{void} georadiusbymemberroCommand(\hyperlink{structclient}{client} *c);
02000 \textcolor{keywordtype}{void} georadiusCommand(\hyperlink{structclient}{client} *c);
02001 \textcolor{keywordtype}{void} georadiusroCommand(\hyperlink{structclient}{client} *c);
02002 \textcolor{keywordtype}{void} geoaddCommand(\hyperlink{structclient}{client} *c);
02003 \textcolor{keywordtype}{void} geohashCommand(\hyperlink{structclient}{client} *c);
02004 \textcolor{keywordtype}{void} geoposCommand(\hyperlink{structclient}{client} *c);
02005 \textcolor{keywordtype}{void} geodistCommand(\hyperlink{structclient}{client} *c);
02006 \textcolor{keywordtype}{void} pfselftestCommand(\hyperlink{structclient}{client} *c);
02007 \textcolor{keywordtype}{void} pfaddCommand(\hyperlink{structclient}{client} *c);
02008 \textcolor{keywordtype}{void} pfcountCommand(\hyperlink{structclient}{client} *c);
02009 \textcolor{keywordtype}{void} pfmergeCommand(\hyperlink{structclient}{client} *c);
02010 \textcolor{keywordtype}{void} pfdebugCommand(\hyperlink{structclient}{client} *c);
02011 \textcolor{keywordtype}{void} latencyCommand(\hyperlink{structclient}{client} *c);
02012 \textcolor{keywordtype}{void} moduleCommand(\hyperlink{structclient}{client} *c);
02013 \textcolor{keywordtype}{void} securityWarningCommand(\hyperlink{structclient}{client} *c);
02014 \textcolor{keywordtype}{void} xaddCommand(\hyperlink{structclient}{client} *c);
02015 \textcolor{keywordtype}{void} xrangeCommand(\hyperlink{structclient}{client} *c);
02016 \textcolor{keywordtype}{void} xrevrangeCommand(\hyperlink{structclient}{client} *c);
02017 \textcolor{keywordtype}{void} xlenCommand(\hyperlink{structclient}{client} *c);
02018 \textcolor{keywordtype}{void} xreadCommand(\hyperlink{structclient}{client} *c);
02019 
02020 \textcolor{preprocessor}{#}\textcolor{preprocessor}{if} \textcolor{preprocessor}{defined}\textcolor{preprocessor}{(}\_\_GNUC\_\_\textcolor{preprocessor}{)}
02021 \textcolor{keywordtype}{void} *calloc(size\_t count, size\_t size) \textcolor{keyword}{\_\_attribute\_\_} ((deprecated));
02022 \textcolor{keywordtype}{void} free(\textcolor{keywordtype}{void} *ptr) \textcolor{keyword}{\_\_attribute\_\_} ((deprecated));
02023 \textcolor{keywordtype}{void} *malloc(size\_t size) \textcolor{keyword}{\_\_attribute\_\_} ((deprecated));
02024 \textcolor{keywordtype}{void} *realloc(\textcolor{keywordtype}{void} *ptr, size\_t size) \textcolor{keyword}{\_\_attribute\_\_} ((deprecated));
02025 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
02026 
02027 \textcolor{comment}{/* Debugging stuff */}
02028 \textcolor{keywordtype}{void} \_serverAssertWithInfo(\textcolor{keyword}{const} \hyperlink{structclient}{client} *c, \textcolor{keyword}{const} robj *o, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *estr, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *file, \textcolor{keywordtype}{
      int} line);
02029 \textcolor{keywordtype}{void} \_serverAssert(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *estr, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *file, \textcolor{keywordtype}{int} line);
02030 \textcolor{keywordtype}{void} \_serverPanic(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *file, \textcolor{keywordtype}{int} line, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *msg, ...);
02031 \textcolor{keywordtype}{void} bugReportStart(\textcolor{keywordtype}{void});
02032 \textcolor{keywordtype}{void} serverLogObjectDebugInfo(\textcolor{keyword}{const} robj *o);
02033 \textcolor{keywordtype}{void} sigsegvHandler(\textcolor{keywordtype}{int} sig, siginfo\_t *info, \textcolor{keywordtype}{void} *secret);
02034 sds genRedisInfoString(\textcolor{keywordtype}{char} *section);
02035 \textcolor{keywordtype}{void} enableWatchdog(\textcolor{keywordtype}{int} period);
02036 \textcolor{keywordtype}{void} disableWatchdog(\textcolor{keywordtype}{void});
02037 \textcolor{keywordtype}{void} watchdogScheduleSignal(\textcolor{keywordtype}{int} period);
02038 \textcolor{keywordtype}{void} serverLogHexDump(\textcolor{keywordtype}{int} level, \textcolor{keywordtype}{char} *descr, \textcolor{keywordtype}{void} *value, size\_t len);
02039 \textcolor{keywordtype}{int} memtest\_preserving\_test(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *m, size\_t bytes, \textcolor{keywordtype}{int} passes);
02040 \textcolor{keywordtype}{void} mixDigest(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *digest, \textcolor{keywordtype}{void} *ptr, size\_t len);
02041 \textcolor{keywordtype}{void} xorDigest(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *digest, \textcolor{keywordtype}{void} *ptr, size\_t len);
02042 
02043 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{redisDebug}\textcolor{preprocessor}{(}\textcolor{preprocessor}{fmt}\textcolor{preprocessor}{,} \textcolor{preprocessor}{...}\textcolor{preprocessor}{)}
02044     \textcolor{preprocessor}{printf}\textcolor{preprocessor}{(}\textcolor{stringliteral}{"DEBUG %s:%d > "} \textcolor{preprocessor}{fmt} \textcolor{stringliteral}{"\(\backslash\)n"}\textcolor{preprocessor}{,} \textcolor{preprocessor}{\_\_FILE\_\_}\textcolor{preprocessor}{,} \textcolor{preprocessor}{\_\_LINE\_\_}\textcolor{preprocessor}{,} \textcolor{preprocessor}{\_\_VA\_ARGS\_\_}\textcolor{preprocessor}{)}
02045 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{redisDebugMark}\textcolor{preprocessor}{(}\textcolor{preprocessor}{)}
02046     \textcolor{preprocessor}{printf}\textcolor{preprocessor}{(}\textcolor{stringliteral}{"-- MARK %s:%d --\(\backslash\)n"}\textcolor{preprocessor}{,} \textcolor{preprocessor}{\_\_FILE\_\_}\textcolor{preprocessor}{,} \textcolor{preprocessor}{\_\_LINE\_\_}\textcolor{preprocessor}{)}
02047 
02048 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
\end{DoxyCode}
