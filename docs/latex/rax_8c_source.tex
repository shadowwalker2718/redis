\hypertarget{rax_8c_source}{}\section{rax.\+c}
\label{rax_8c_source}\index{src/rax.\+c@{src/rax.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* Rax -- A radix tree implementation.}
00002 \textcolor{comment}{ *}
00003 \textcolor{comment}{ * Copyright (c) 2017, Salvatore Sanfilippo <antirez at gmail dot com>}
00004 \textcolor{comment}{ * All rights reserved.}
00005 \textcolor{comment}{ *}
00006 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00007 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00008 \textcolor{comment}{ *}
00009 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00010 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00011 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00012 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00013 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00014 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00015 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00016 \textcolor{comment}{ *     specific prior written permission.}
00017 \textcolor{comment}{ *}
00018 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00019 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00020 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00021 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00022 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00023 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00024 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00025 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00026 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00027 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00028 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00029 \textcolor{comment}{ */}
00030 
00031 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdlib}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00032 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{string}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00033 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{assert}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00034 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdio}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00035 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{errno}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00036 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{math}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00037 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{rax_8h}{"rax.h"}
00038 
00039 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifndef} \textcolor{preprocessor}{RAX\_MALLOC\_INCLUDE}
00040 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{RAX\_MALLOC\_INCLUDE} \textcolor{stringliteral}{"rax\_malloc.h"}
00041 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
00042 
00043 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{RAX\_MALLOC\_INCLUDE}
00044 
00045 \textcolor{comment}{/* This is a special pointer that is guaranteed to never have the same value}
00046 \textcolor{comment}{ * of a radix tree node. It's used in order to report "not found" error without}
00047 \textcolor{comment}{ * requiring the function to have multiple return values. */}
00048 \textcolor{keywordtype}{void} *raxNotFound = (\textcolor{keywordtype}{void}*)\textcolor{stringliteral}{"rax-not-found-pointer"};
00049 
00050 \textcolor{comment}{/* -------------------------------- Debugging ------------------------------ */}
00051 
00052 \textcolor{keywordtype}{void} raxDebugShowNode(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *msg, raxNode *n);
00053 
00054 \textcolor{comment}{/* Turn debugging messages on/off. */}
00055 \textcolor{preprocessor}{#}\textcolor{preprocessor}{if} 0
00056 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{debugf}\textcolor{preprocessor}{(}\textcolor{preprocessor}{...}\textcolor{preprocessor}{)}
00057     \textcolor{preprocessor}{do} \textcolor{preprocessor}{\{}
00058         \textcolor{preprocessor}{printf}\textcolor{preprocessor}{(}\textcolor{stringliteral}{"%s:%s:%d:\(\backslash\)t"}\textcolor{preprocessor}{,} \textcolor{preprocessor}{\_\_FILE\_\_}\textcolor{preprocessor}{,} \textcolor{preprocessor}{\_\_FUNCTION\_\_}\textcolor{preprocessor}{,} \textcolor{preprocessor}{\_\_LINE\_\_}\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
00059         \textcolor{preprocessor}{printf}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_\_VA\_ARGS\_\_}\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
00060         \textcolor{preprocessor}{fflush}\textcolor{preprocessor}{(}\textcolor{preprocessor}{stdout}\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
00061     \textcolor{preprocessor}{\}} \textcolor{preprocessor}{while} \textcolor{preprocessor}{(}0\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
00062 
00063 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{debugnode}\textcolor{preprocessor}{(}\textcolor{preprocessor}{msg}\textcolor{preprocessor}{,}\textcolor{preprocessor}{n}\textcolor{preprocessor}{)} \textcolor{preprocessor}{raxDebugShowNode}\textcolor{preprocessor}{(}\textcolor{preprocessor}{msg}\textcolor{preprocessor}{,}\textcolor{preprocessor}{n}\textcolor{preprocessor}{)}
00064 \textcolor{preprocessor}{#}\textcolor{preprocessor}{else}
00065 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{debugf}\textcolor{preprocessor}{(}\textcolor{preprocessor}{...}\textcolor{preprocessor}{)}
00066 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{debugnode}\textcolor{preprocessor}{(}\textcolor{preprocessor}{msg}\textcolor{preprocessor}{,}\textcolor{preprocessor}{n}\textcolor{preprocessor}{)}
00067 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
00068 
00069 \textcolor{comment}{/* ------------------------- raxStack functions --------------------------}
00070 \textcolor{comment}{ * The raxStack is a simple stack of pointers that is capable of switching}
00071 \textcolor{comment}{ * from using a stack-allocated array to dynamic heap once a given number of}
00072 \textcolor{comment}{ * items are reached. It is used in order to retain the list of parent nodes}
00073 \textcolor{comment}{ * while walking the radix tree in order to implement certain operations that}
00074 \textcolor{comment}{ * need to navigate the tree upward.}
00075 \textcolor{comment}{ * ------------------------------------------------------------------------- */}
00076 
00077 \textcolor{comment}{/* Initialize the stack. */}
00078 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} raxStackInit(\hyperlink{structraxStack}{raxStack} *ts) \{
00079     ts->stack = ts->static\_items;
00080     ts->items = 0;
00081     ts->maxitems = \hyperlink{rax_8h_aff05c7893713f82d106c046f55ac1bf5}{RAX\_STACK\_STATIC\_ITEMS};
00082     ts->oom = 0;
00083 \}
00084 
00085 \textcolor{comment}{/* Push an item into the stack, returns 1 on success, 0 on out of memory. */}
00086 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{int} raxStackPush(\hyperlink{structraxStack}{raxStack} *ts, \textcolor{keywordtype}{void} *ptr) \{
00087     \textcolor{keywordflow}{if} (ts->items == ts->maxitems) \{
00088         \textcolor{keywordflow}{if} (ts->stack == ts->static\_items) \{
00089             ts->stack = \hyperlink{rax__malloc_8h_aba4b5d6a50f54903fe9c330308beb66a}{rax\_malloc}(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*)*ts->maxitems*2);
00090             \textcolor{keywordflow}{if} (ts->stack == NULL) \{
00091                 ts->stack = ts->static\_items;
00092                 ts->oom = 1;
00093                 errno = ENOMEM;
00094                 \textcolor{keywordflow}{return} 0;
00095             \}
00096             memcpy(ts->stack,ts->static\_items,\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*)*ts->maxitems);
00097         \} \textcolor{keywordflow}{else} \{
00098             \textcolor{keywordtype}{void} **newalloc = \hyperlink{rax__malloc_8h_a4aa041a0e1eaa6d8476e889547280467}{rax\_realloc}(ts->stack,\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*)*ts->maxitems*2);
00099             \textcolor{keywordflow}{if} (newalloc == NULL) \{
00100                 ts->oom = 1;
00101                 errno = ENOMEM;
00102                 \textcolor{keywordflow}{return} 0;
00103             \}
00104             ts->stack = newalloc;
00105         \}
00106         ts->maxitems *= 2;
00107     \}
00108     ts->stack[ts->items] = ptr;
00109     ts->items++;
00110     \textcolor{keywordflow}{return} 1;
00111 \}
00112 
00113 \textcolor{comment}{/* Pop an item from the stack, the function returns NULL if there are no}
00114 \textcolor{comment}{ * items to pop. */}
00115 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} *raxStackPop(\hyperlink{structraxStack}{raxStack} *ts) \{
00116     \textcolor{keywordflow}{if} (ts->items == 0) \textcolor{keywordflow}{return} NULL;
00117     ts->items--;
00118     \textcolor{keywordflow}{return} ts->stack[ts->items];
00119 \}
00120 
00121 \textcolor{comment}{/* Return the stack item at the top of the stack without actually consuming}
00122 \textcolor{comment}{ * it. */}
00123 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} *raxStackPeek(\hyperlink{structraxStack}{raxStack} *ts) \{
00124     \textcolor{keywordflow}{if} (ts->items == 0) \textcolor{keywordflow}{return} NULL;
00125     \textcolor{keywordflow}{return} ts->stack[ts->items-1];
00126 \}
00127 
00128 \textcolor{comment}{/* Free the stack in case we used heap allocation. */}
00129 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{void} raxStackFree(\hyperlink{structraxStack}{raxStack} *ts) \{
00130     \textcolor{keywordflow}{if} (ts->stack != ts->static\_items) \hyperlink{rax__malloc_8h_a3adfa16bca6cd23b6e125fd441465e49}{rax\_free}(ts->stack);
00131 \}
00132 
00133 \textcolor{comment}{/* ----------------------------------------------------------------------------}
00134 \textcolor{comment}{ * Radix tree implementation}
00135 \textcolor{comment}{ * --------------------------------------------------------------------------*/}
00136 
00137 \textcolor{comment}{/* Allocate a new non compressed node with the specified number of children.}
00138 \textcolor{comment}{ * If datafiled is true, the allocation is made large enough to hold the}
00139 \textcolor{comment}{ * associated data pointer.}
00140 \textcolor{comment}{ * Returns the new node pointer. On out of memory NULL is returned. */}
00141 raxNode *raxNewNode(size\_t children, \textcolor{keywordtype}{int} datafield) \{
00142     size\_t nodesize = \textcolor{keyword}{sizeof}(raxNode)+children+
00143                       \textcolor{keyword}{sizeof}(raxNode*)*children;
00144     \textcolor{keywordflow}{if} (datafield) nodesize += \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*);
00145     raxNode *node = \hyperlink{rax__malloc_8h_aba4b5d6a50f54903fe9c330308beb66a}{rax\_malloc}(nodesize);
00146     \textcolor{keywordflow}{if} (node == NULL) \textcolor{keywordflow}{return} NULL;
00147     node->iskey = 0;
00148     node->isnull = 0;
00149     node->iscompr = 0;
00150     node->size = children;
00151     \textcolor{keywordflow}{return} node;
00152 \}
00153 
00154 \textcolor{comment}{/* Allocate a new rax and return its pointer. On out of memory the function}
00155 \textcolor{comment}{ * returns NULL. */}
00156 rax *raxNew(\textcolor{keywordtype}{void}) \{
00157     rax *rax = \hyperlink{rax__malloc_8h_aba4b5d6a50f54903fe9c330308beb66a}{rax\_malloc}(\textcolor{keyword}{sizeof}(*rax));
00158     \textcolor{keywordflow}{if} (rax == NULL) \textcolor{keywordflow}{return} NULL;
00159     rax->numele = 0;
00160     rax->numnodes = 1;
00161     rax->head = raxNewNode(0,0);
00162     \textcolor{keywordflow}{if} (rax->head == NULL) \{
00163         \hyperlink{rax__malloc_8h_a3adfa16bca6cd23b6e125fd441465e49}{rax\_free}(rax);
00164         \textcolor{keywordflow}{return} NULL;
00165     \} \textcolor{keywordflow}{else} \{
00166         \textcolor{keywordflow}{return} rax;
00167     \}
00168 \}
00169 
00170 \textcolor{comment}{/* Return the current total size of the node. */}
00171 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{raxNodeCurrentLength}\textcolor{preprocessor}{(}\textcolor{preprocessor}{n}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}
00172     \textcolor{keyword}{sizeof}\textcolor{preprocessor}{(}\textcolor{preprocessor}{raxNode}\textcolor{preprocessor}{)}\textcolor{preprocessor}{+}\textcolor{preprocessor}{(}\textcolor{preprocessor}{n}\textcolor{preprocessor}{)}\textcolor{preprocessor}{->}\textcolor{preprocessor}{size}\textcolor{preprocessor}{+}
00173     \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{n}\textcolor{preprocessor}{)}\textcolor{preprocessor}{->}\textcolor{preprocessor}{iscompr} \textcolor{preprocessor}{?} \textcolor{keyword}{sizeof}\textcolor{preprocessor}{(}\textcolor{preprocessor}{raxNode}\textcolor{preprocessor}{*}\textcolor{preprocessor}{)} \textcolor{preprocessor}{:} \textcolor{keyword}{sizeof}\textcolor{preprocessor}{(}\textcolor{preprocessor}{raxNode}\textcolor{preprocessor}{*}\textcolor{preprocessor}{)}\textcolor{preprocessor}{*}\textcolor{preprocessor}{(}\textcolor{preprocessor}{n}\textcolor{preprocessor}{)}\textcolor{preprocessor}{->}\textcolor{preprocessor}{size}\textcolor{preprocessor}{)}\textcolor{preprocessor}{+}
00174     \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{n}\textcolor{preprocessor}{)}\textcolor{preprocessor}{->}\textcolor{preprocessor}{iskey} \textcolor{preprocessor}{&&} \textcolor{preprocessor}{!}\textcolor{preprocessor}{(}\textcolor{preprocessor}{n}\textcolor{preprocessor}{)}\textcolor{preprocessor}{->}\textcolor{preprocessor}{isnull}\textcolor{preprocessor}{)}\textcolor{preprocessor}{*}\textcolor{keyword}{sizeof}\textcolor{preprocessor}{(}\textcolor{keywordtype}{void}\textcolor{preprocessor}{*}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)} \textcolor{preprocessor}{\(\backslash\)}
00175 \textcolor{preprocessor}{)}
00176 
00177 \textcolor{comment}{/* realloc the node to make room for auxiliary data in order}
00178 \textcolor{comment}{ * to store an item in that node. On out of memory NULL is returned. */}
00179 raxNode *raxReallocForData(raxNode *n, \textcolor{keywordtype}{void} *data) \{
00180     \textcolor{keywordflow}{if} (data == NULL) \textcolor{keywordflow}{return} n; \textcolor{comment}{/* No reallocation needed, setting isnull=1 */}
00181     size\_t curlen = \hyperlink{rax_8c_a93300b0f45c900ba0bdb80f3f7a83f5e}{raxNodeCurrentLength}(n);
00182     \textcolor{keywordflow}{return} \hyperlink{rax__malloc_8h_a4aa041a0e1eaa6d8476e889547280467}{rax\_realloc}(n,curlen+\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*));
00183 \}
00184 
00185 \textcolor{comment}{/* Set the node auxiliary data to the specified pointer. */}
00186 \textcolor{keywordtype}{void} raxSetData(raxNode *n, \textcolor{keywordtype}{void} *data) \{
00187     n->iskey = 1;
00188     \textcolor{keywordflow}{if} (data != NULL) \{
00189         n->isnull = 0;
00190         \textcolor{keywordtype}{void} **ndata = (\textcolor{keywordtype}{void}**)
00191             ((\textcolor{keywordtype}{char}*)n+\hyperlink{rax_8c_a93300b0f45c900ba0bdb80f3f7a83f5e}{raxNodeCurrentLength}(n)-\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*));
00192         memcpy(ndata,&data,\textcolor{keyword}{sizeof}(data));
00193     \} \textcolor{keywordflow}{else} \{
00194         n->isnull = 1;
00195     \}
00196 \}
00197 
00198 \textcolor{comment}{/* Get the node auxiliary data. */}
00199 \textcolor{keywordtype}{void} *raxGetData(raxNode *n) \{
00200     \textcolor{keywordflow}{if} (n->isnull) \textcolor{keywordflow}{return} NULL;
00201     \textcolor{keywordtype}{void} **ndata =(\textcolor{keywordtype}{void}**)((\textcolor{keywordtype}{char}*)n+\hyperlink{rax_8c_a93300b0f45c900ba0bdb80f3f7a83f5e}{raxNodeCurrentLength}(n)-\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*));
00202     \textcolor{keywordtype}{void} *data;
00203     memcpy(&data,ndata,\textcolor{keyword}{sizeof}(data));
00204     \textcolor{keywordflow}{return} data;
00205 \}
00206 
00207 \textcolor{comment}{/* Add a new child to the node 'n' representing the character 'c' and return}
00208 \textcolor{comment}{ * its new pointer, as well as the child pointer by reference. Additionally}
00209 \textcolor{comment}{ * '***parentlink' is populated with the raxNode pointer-to-pointer of where}
00210 \textcolor{comment}{ * the new child was stored, which is useful for the caller to replace the}
00211 \textcolor{comment}{ * child pointer if it gets reallocated.}
00212 \textcolor{comment}{ *}
00213 \textcolor{comment}{ * On success the new parent node pointer is returned (it may change because}
00214 \textcolor{comment}{ * of the realloc, so the caller should discard 'n' and use the new value).}
00215 \textcolor{comment}{ * On out of memory NULL is returned, and the old node is still valid. */}
00216 raxNode *raxAddChild(raxNode *n, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c, raxNode **childptr, raxNode ***parentlink) \{
00217     \hyperlink{redisassert_8h_a993abaa2c168852c1592879472938781}{assert}(n->iscompr == 0);
00218 
00219     size\_t curlen = \textcolor{keyword}{sizeof}(raxNode)+
00220                     n->size+
00221                     \textcolor{keyword}{sizeof}(raxNode*)*n->size;
00222     size\_t newlen;
00223 
00224     \textcolor{comment}{/* Alloc the new child we will link to 'n'. */}
00225     raxNode *child = raxNewNode(0,0);
00226     \textcolor{keywordflow}{if} (child == NULL) \textcolor{keywordflow}{return} NULL;
00227 
00228     \textcolor{comment}{/* Make space in the original node. */}
00229     \textcolor{keywordflow}{if} (n->iskey) curlen += \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*);
00230     newlen = curlen+\textcolor{keyword}{sizeof}(raxNode*)+1; \textcolor{comment}{/* Add 1 char and 1 pointer. */}
00231     raxNode *newn = \hyperlink{rax__malloc_8h_a4aa041a0e1eaa6d8476e889547280467}{rax\_realloc}(n,newlen);
00232     \textcolor{keywordflow}{if} (newn == NULL) \{
00233         \hyperlink{rax__malloc_8h_a3adfa16bca6cd23b6e125fd441465e49}{rax\_free}(child);
00234         \textcolor{keywordflow}{return} NULL;
00235     \}
00236     n = newn;
00237 
00238     \textcolor{comment}{/* After the reallocation, we have 5/9 (depending on the system}
00239 \textcolor{comment}{     * pointer size) bytes at the end, that is, the additional char}
00240 \textcolor{comment}{     * in the 'data' section, plus one pointer to the new child:}
00241 \textcolor{comment}{     *}
00242 \textcolor{comment}{     * [numc][abx][ap][bp][xp]|auxp|.....}
00243 \textcolor{comment}{     *}
00244 \textcolor{comment}{     * Let's find where to insert the new child in order to make sure}
00245 \textcolor{comment}{     * it is inserted in-place lexicographically. */}
00246     \textcolor{keywordtype}{int} pos;
00247     \textcolor{keywordflow}{for} (pos = 0; pos < n->size; pos++) \{
00248         \textcolor{keywordflow}{if} (n->data[pos] > c) \textcolor{keywordflow}{break};
00249     \}
00250 
00251     \textcolor{comment}{/* Now, if present, move auxiliary data pointer at the end}
00252 \textcolor{comment}{     * so that we can mess with the other data without overwriting it.}
00253 \textcolor{comment}{     * We will obtain something like that:}
00254 \textcolor{comment}{     *}
00255 \textcolor{comment}{     * [numc][abx][ap][bp][xp].....|auxp| */}
00256     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *src;
00257     \textcolor{keywordflow}{if} (n->iskey && !n->isnull) \{
00258         src = n->data+n->size+\textcolor{keyword}{sizeof}(raxNode*)*n->size;
00259         memmove(src+1+\textcolor{keyword}{sizeof}(raxNode*),src,\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*));
00260     \}
00261 
00262     \textcolor{comment}{/* Now imagine we are adding a node with edge 'c'. The insertion}
00263 \textcolor{comment}{     * point is between 'b' and 'x', so the 'pos' variable value is}
00264 \textcolor{comment}{     * To start, move all the child pointers after the insertion point}
00265 \textcolor{comment}{     * of 1+sizeof(pointer) bytes on the right, to obtain:}
00266 \textcolor{comment}{     *}
00267 \textcolor{comment}{     * [numc][abx][ap][bp].....[xp]|auxp| */}
00268     src = n->data+n->size+\textcolor{keyword}{sizeof}(raxNode*)*pos;
00269     memmove(src+1+\textcolor{keyword}{sizeof}(raxNode*),src,\textcolor{keyword}{sizeof}(raxNode*)*(n->size-pos));
00270 
00271     \textcolor{comment}{/* Now make the space for the additional char in the data section,}
00272 \textcolor{comment}{     * but also move the pointers before the insertion point in the right}
00273 \textcolor{comment}{     * by 1 byte, in order to obtain the following:}
00274 \textcolor{comment}{     *}
00275 \textcolor{comment}{     * [numc][ab.x][ap][bp]....[xp]|auxp| */}
00276     src = n->data+pos;
00277     memmove(src+1,src,n->size-pos+\textcolor{keyword}{sizeof}(raxNode*)*pos);
00278 
00279     \textcolor{comment}{/* We can now set the character and its child node pointer to get:}
00280 \textcolor{comment}{     *}
00281 \textcolor{comment}{     * [numc][abcx][ap][bp][cp]....|auxp|}
00282 \textcolor{comment}{     * [numc][abcx][ap][bp][cp][xp]|auxp| */}
00283     n->data[pos] = c;
00284     n->size++;
00285     raxNode **childfield = (raxNode**)(n->data+n->size+\textcolor{keyword}{sizeof}(raxNode*)*pos);
00286     memcpy(childfield,&child,\textcolor{keyword}{sizeof}(child));
00287     *childptr = child;
00288     *parentlink = childfield;
00289     \textcolor{keywordflow}{return} n;
00290 \}
00291 
00292 \textcolor{comment}{/* Return the pointer to the last child pointer in a node. For the compressed}
00293 \textcolor{comment}{ * nodes this is the only child pointer. */}
00294 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{raxNodeLastChildPtr}\textcolor{preprocessor}{(}\textcolor{preprocessor}{n}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{raxNode}\textcolor{preprocessor}{*}\textcolor{preprocessor}{*}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}
00295     \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{keywordtype}{char}\textcolor{preprocessor}{*}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{preprocessor}{n}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)} \textcolor{preprocessor}{+}
00296     \hyperlink{rax_8c_a93300b0f45c900ba0bdb80f3f7a83f5e}{raxNodeCurrentLength}\textcolor{preprocessor}{(}\textcolor{preprocessor}{n}\textcolor{preprocessor}{)} \textcolor{preprocessor}{-}
00297     \textcolor{keyword}{sizeof}\textcolor{preprocessor}{(}\textcolor{preprocessor}{raxNode}\textcolor{preprocessor}{*}\textcolor{preprocessor}{)} \textcolor{preprocessor}{-}
00298     \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{n}\textcolor{preprocessor}{)}\textcolor{preprocessor}{->}\textcolor{preprocessor}{iskey} \textcolor{preprocessor}{&&} \textcolor{preprocessor}{!}\textcolor{preprocessor}{(}\textcolor{preprocessor}{n}\textcolor{preprocessor}{)}\textcolor{preprocessor}{->}\textcolor{preprocessor}{isnull}\textcolor{preprocessor}{)} \textcolor{preprocessor}{?} \textcolor{keyword}{sizeof}\textcolor{preprocessor}{(}\textcolor{keywordtype}{void}\textcolor{preprocessor}{*}\textcolor{preprocessor}{)} \textcolor{preprocessor}{:} 0\textcolor{preprocessor}{)} \textcolor{preprocessor}{\(\backslash\)}
00299 \textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00300 
00301 \textcolor{comment}{/* Return the pointer to the first child pointer. */}
00302 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{raxNodeFirstChildPtr}\textcolor{preprocessor}{(}\textcolor{preprocessor}{n}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{raxNode}\textcolor{preprocessor}{*}\textcolor{preprocessor}{*}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{n}\textcolor{preprocessor}{)}\textcolor{preprocessor}{->}\textcolor{preprocessor}{data}\textcolor{preprocessor}{+}\textcolor{preprocessor}{(}\textcolor{preprocessor}{n}\textcolor{preprocessor}{)}\textcolor{preprocessor}{->}\textcolor{preprocessor}{size}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00303 
00304 \textcolor{comment}{/* Turn the node 'n', that must be a node without any children, into a}
00305 \textcolor{comment}{ * compressed node representing a set of nodes linked one after the other}
00306 \textcolor{comment}{ * and having exactly one child each. The node can be a key or not: this}
00307 \textcolor{comment}{ * property and the associated value if any will be preserved.}
00308 \textcolor{comment}{ *}
00309 \textcolor{comment}{ * The function also returns a child node, since the last node of the}
00310 \textcolor{comment}{ * compressed chain cannot be part of the chain: it has zero children while}
00311 \textcolor{comment}{ * we can only compress inner nodes with exactly one child each. */}
00312 raxNode *raxCompressNode(raxNode *n, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *s, size\_t len, raxNode **child) \{
00313     \hyperlink{redisassert_8h_a993abaa2c168852c1592879472938781}{assert}(n->size == 0 && n->iscompr == 0);
00314     \textcolor{keywordtype}{void} *data = NULL; \textcolor{comment}{/* Initialized only to avoid warnings. */}
00315     size\_t newsize;
00316 
00317     \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"Compress node: %.*s\(\backslash\)n"}, (\textcolor{keywordtype}{int})len,s);
00318 
00319     \textcolor{comment}{/* Allocate the child to link to this node. */}
00320     *child = raxNewNode(0,0);
00321     \textcolor{keywordflow}{if} (*child == NULL) \textcolor{keywordflow}{return} NULL;
00322 
00323     \textcolor{comment}{/* Make space in the parent node. */}
00324     newsize = \textcolor{keyword}{sizeof}(raxNode)+len+\textcolor{keyword}{sizeof}(raxNode*);
00325     \textcolor{keywordflow}{if} (n->iskey) \{
00326         data = raxGetData(n); \textcolor{comment}{/* To restore it later. */}
00327         \textcolor{keywordflow}{if} (!n->isnull) newsize += \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*);
00328     \}
00329     raxNode *newn = \hyperlink{rax__malloc_8h_a4aa041a0e1eaa6d8476e889547280467}{rax\_realloc}(n,newsize);
00330     \textcolor{keywordflow}{if} (newn == NULL) \{
00331         \hyperlink{rax__malloc_8h_a3adfa16bca6cd23b6e125fd441465e49}{rax\_free}(*child);
00332         \textcolor{keywordflow}{return} NULL;
00333     \}
00334     n = newn;
00335 
00336     n->iscompr = 1;
00337     n->size = len;
00338     memcpy(n->data,s,len);
00339     \textcolor{keywordflow}{if} (n->iskey) raxSetData(n,data);
00340     raxNode **childfield = \hyperlink{rax_8c_a2c5310b0d00672508a8f935a7109f4ce}{raxNodeLastChildPtr}(n);
00341     memcpy(childfield,child,\textcolor{keyword}{sizeof}(*child));
00342     \textcolor{keywordflow}{return} n;
00343 \}
00344 
00345 \textcolor{comment}{/* Low level function that walks the tree looking for the string}
00346 \textcolor{comment}{ * 's' of 'len' bytes. The function returns the number of characters}
00347 \textcolor{comment}{ * of the key that was possible to process: if the returned integer}
00348 \textcolor{comment}{ * is the same as 'len', then it means that the node corresponding to the}
00349 \textcolor{comment}{ * string was found (however it may not be a key in case the node->iskey is}
00350 \textcolor{comment}{ * zero or if simply we stopped in the middle of a compressed node, so that}
00351 \textcolor{comment}{ * 'splitpos' is non zero).}
00352 \textcolor{comment}{ *}
00353 \textcolor{comment}{ * Otherwise if the returned integer is not the same as 'len', there was an}
00354 \textcolor{comment}{ * early stop during the tree walk because of a character mismatch.}
00355 \textcolor{comment}{ *}
00356 \textcolor{comment}{ * The node where the search ended (because the full string was processed}
00357 \textcolor{comment}{ * or because there was an early stop) is returned by reference as}
00358 \textcolor{comment}{ * '*stopnode' if the passed pointer is not NULL. This node link in the}
00359 \textcolor{comment}{ * parent's node is returned as '*plink' if not NULL. Finally, if the}
00360 \textcolor{comment}{ * search stopped in a compressed node, '*splitpos' returns the index}
00361 \textcolor{comment}{ * inside the compressed node where the search ended. This is useful to}
00362 \textcolor{comment}{ * know where to split the node for insertion. */}
00363 \textcolor{keyword}{static} \textcolor{keyword}{inline} size\_t raxLowWalk(rax *rax, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *s, size\_t len, raxNode **stopnode, raxNode **
      *plink, \textcolor{keywordtype}{int} *splitpos, raxStack *ts) \{
00364     raxNode *h = rax->head;
00365     raxNode **parentlink = &rax->head;
00366 
00367     size\_t i = 0; \textcolor{comment}{/* Position in the string. */}
00368     size\_t j = 0; \textcolor{comment}{/* Position in the node children (or bytes if compressed).*/}
00369     \textcolor{keywordflow}{while}(h->size && i < len) \{
00370         \hyperlink{rax_8c_a622b73fbdc398cdbfa8cc1fb87283cb4}{debugnode}(\textcolor{stringliteral}{"Lookup current node"},h);
00371         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *v = h->data;
00372 
00373         \textcolor{keywordflow}{if} (h->iscompr) \{
00374             \textcolor{keywordflow}{for} (j = 0; j < h->size && i < len; j++, i++) \{
00375                 \textcolor{keywordflow}{if} (v[j] != s[i]) \textcolor{keywordflow}{break};
00376             \}
00377             \textcolor{keywordflow}{if} (j != h->size) \textcolor{keywordflow}{break};
00378         \} \textcolor{keywordflow}{else} \{
00379             \textcolor{comment}{/* Even when h->size is large, linear scan provides good}
00380 \textcolor{comment}{             * performances compared to other approaches that are in theory}
00381 \textcolor{comment}{             * more sounding, like performing a binary search. */}
00382             \textcolor{keywordflow}{for} (j = 0; j < h->size; j++) \{
00383                 \textcolor{keywordflow}{if} (v[j] == s[i]) \textcolor{keywordflow}{break};
00384             \}
00385             \textcolor{keywordflow}{if} (j == h->size) \textcolor{keywordflow}{break};
00386             i++;
00387         \}
00388 
00389         \textcolor{keywordflow}{if} (ts) raxStackPush(ts,h); \textcolor{comment}{/* Save stack of parent nodes. */}
00390         raxNode **children = \hyperlink{rax_8c_aa94163a0d02b30219ef18e5a3ea06ca6}{raxNodeFirstChildPtr}(h);
00391         \textcolor{keywordflow}{if} (h->iscompr) j = 0; \textcolor{comment}{/* Compressed node only child is at index 0. */}
00392         memcpy(&h,children+j,\textcolor{keyword}{sizeof}(h));
00393         parentlink = children+j;
00394         j = 0; \textcolor{comment}{/* If the new node is compressed and we do not}
00395 \textcolor{comment}{                  iterate again (since i == l) set the split}
00396 \textcolor{comment}{                  position to 0 to signal this node represents}
00397 \textcolor{comment}{                  the searched key. */}
00398     \}
00399     \hyperlink{rax_8c_a622b73fbdc398cdbfa8cc1fb87283cb4}{debugnode}(\textcolor{stringliteral}{"Lookup stop node is"},h);
00400     \textcolor{keywordflow}{if} (stopnode) *stopnode = h;
00401     \textcolor{keywordflow}{if} (plink) *plink = parentlink;
00402     \textcolor{keywordflow}{if} (splitpos && h->iscompr) *splitpos = j;
00403     \textcolor{keywordflow}{return} i;
00404 \}
00405 
00406 \textcolor{comment}{/* Insert the element 's' of size 'len', setting as auxiliary data}
00407 \textcolor{comment}{ * the pointer 'data'. If the element is already present, the associated}
00408 \textcolor{comment}{ * data is updated, and 0 is returned, otherwise the element is inserted}
00409 \textcolor{comment}{ * and 1 is returned. On out of memory the function returns 0 as well but}
00410 \textcolor{comment}{ * sets errno to ENOMEM, otherwise errno will be set to 0. */}
00411 \textcolor{keywordtype}{int} raxInsert(rax *rax, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *s, size\_t len, \textcolor{keywordtype}{void} *data, \textcolor{keywordtype}{void} **old) \{
00412     size\_t i;
00413     \textcolor{keywordtype}{int} j = 0; \textcolor{comment}{/* Split position. If raxLowWalk() stops in a compressed}
00414 \textcolor{comment}{                  node, the index 'j' represents the char we stopped within the}
00415 \textcolor{comment}{                  compressed node, that is, the position where to split the}
00416 \textcolor{comment}{                  node for insertion. */}
00417     raxNode *h, **parentlink;
00418 
00419     \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"### Insert %.*s with value %p\(\backslash\)n"}, (\textcolor{keywordtype}{int})len, s, data);
00420     i = raxLowWalk(rax,s,len,&h,&parentlink,&j,NULL);
00421 
00422     \textcolor{comment}{/* If i == len we walked following the whole string. If we are not}
00423 \textcolor{comment}{     * in the middle of a compressed node, the string is either already}
00424 \textcolor{comment}{     * inserted or this middle node is currently not a key, but can represent}
00425 \textcolor{comment}{     * our key. We have just to reallocate the node and make space for the}
00426 \textcolor{comment}{     * data pointer. */}
00427     \textcolor{keywordflow}{if} (i == len && (!h->iscompr || j == 0 \textcolor{comment}{/* not in the middle if j is 0 */})) \{
00428         \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"### Insert: node representing key exists\(\backslash\)n"});
00429         \textcolor{keywordflow}{if} (!h->iskey || h->isnull) \{
00430             h = raxReallocForData(h,data);
00431             \textcolor{keywordflow}{if} (h) memcpy(parentlink,&h,\textcolor{keyword}{sizeof}(h));
00432         \}
00433         \textcolor{keywordflow}{if} (h == NULL) \{
00434             errno = ENOMEM;
00435             \textcolor{keywordflow}{return} 0;
00436         \}
00437         \textcolor{keywordflow}{if} (h->iskey) \{
00438             \textcolor{keywordflow}{if} (old) *old = raxGetData(h);
00439             raxSetData(h,data);
00440             errno = 0;
00441             \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* Element already exists. */}
00442         \}
00443         raxSetData(h,data);
00444         rax->numele++;
00445         \textcolor{keywordflow}{return} 1; \textcolor{comment}{/* Element inserted. */}
00446     \}
00447 
00448     \textcolor{comment}{/* If the node we stopped at is a compressed node, we need to}
00449 \textcolor{comment}{     * split it before to continue.}
00450 \textcolor{comment}{     *}
00451 \textcolor{comment}{     * Splitting a compressed node have a few possibile cases.}
00452 \textcolor{comment}{     * Imagine that the node 'h' we are currently at is a compressed}
00453 \textcolor{comment}{     * node contaning the string "ANNIBALE" (it means that it represents}
00454 \textcolor{comment}{     * nodes A -> N -> N -> I -> B -> A -> L -> E with the only child}
00455 \textcolor{comment}{     * pointer of this node pointing at the 'E' node, because remember that}
00456 \textcolor{comment}{     * we have characters at the edges of the graph, not inside the nodes}
00457 \textcolor{comment}{     * themselves.}
00458 \textcolor{comment}{     *}
00459 \textcolor{comment}{     * In order to show a real case imagine our node to also point to}
00460 \textcolor{comment}{     * another compressed node, that finally points at the node without}
00461 \textcolor{comment}{     * children, representing 'O':}
00462 \textcolor{comment}{     *}
00463 \textcolor{comment}{     *     "ANNIBALE" -> "SCO" -> []}
00464 \textcolor{comment}{     *}
00465 \textcolor{comment}{     * When inserting we may face the following cases. Note that all the cases}
00466 \textcolor{comment}{     * require the insertion of a non compressed node with exactly two}
00467 \textcolor{comment}{     * children, except for the last case which just requires splitting a}
00468 \textcolor{comment}{     * compressed node.}
00469 \textcolor{comment}{     *}
00470 \textcolor{comment}{     * 1) Inserting "ANNIENTARE"}
00471 \textcolor{comment}{     *}
00472 \textcolor{comment}{     *               |B| -> "ALE" -> "SCO" -> []}
00473 \textcolor{comment}{     *     "ANNI" -> |-|}
00474 \textcolor{comment}{     *               |E| -> (... continue algo ...) "NTARE" -> []}
00475 \textcolor{comment}{     *}
00476 \textcolor{comment}{     * 2) Inserting "ANNIBALI"}
00477 \textcolor{comment}{     *}
00478 \textcolor{comment}{     *                  |E| -> "SCO" -> []}
00479 \textcolor{comment}{     *     "ANNIBAL" -> |-|}
00480 \textcolor{comment}{     *                  |I| -> (... continue algo ...) []}
00481 \textcolor{comment}{     *}
00482 \textcolor{comment}{     * 3) Inserting "AGO" (Like case 1, but set iscompr = 0 into original node)}
00483 \textcolor{comment}{     *}
00484 \textcolor{comment}{     *            |N| -> "NIBALE" -> "SCO" -> []}
00485 \textcolor{comment}{     *     |A| -> |-|}
00486 \textcolor{comment}{     *            |G| -> (... continue algo ...) |O| -> []}
00487 \textcolor{comment}{     *}
00488 \textcolor{comment}{     * 4) Inserting "CIAO"}
00489 \textcolor{comment}{     *}
00490 \textcolor{comment}{     *     |A| -> "NNIBALE" -> "SCO" -> []}
00491 \textcolor{comment}{     *     |-|}
00492 \textcolor{comment}{     *     |C| -> (... continue algo ...) "IAO" -> []}
00493 \textcolor{comment}{     *}
00494 \textcolor{comment}{     * 5) Inserting "ANNI"}
00495 \textcolor{comment}{     *}
00496 \textcolor{comment}{     *     "ANNI" -> "BALE" -> "SCO" -> []}
00497 \textcolor{comment}{     *}
00498 \textcolor{comment}{     * The final algorithm for insertion covering all the above cases is as}
00499 \textcolor{comment}{     * follows.}
00500 \textcolor{comment}{     *}
00501 \textcolor{comment}{     * ============================= ALGO 1 =============================}
00502 \textcolor{comment}{     *}
00503 \textcolor{comment}{     * For the above cases 1 to 4, that is, all cases where we stopped in}
00504 \textcolor{comment}{     * the middle of a compressed node for a character mismatch, do:}
00505 \textcolor{comment}{     *}
00506 \textcolor{comment}{     * Let $SPLITPOS be the zero-based index at which, in the}
00507 \textcolor{comment}{     * compressed node array of characters, we found the mismatching}
00508 \textcolor{comment}{     * character. For example if the node contains "ANNIBALE" and we add}
00509 \textcolor{comment}{     * "ANNIENTARE" the $SPLITPOS is 4, that is, the index at which the}
00510 \textcolor{comment}{     * mismatching character is found.}
00511 \textcolor{comment}{     *}
00512 \textcolor{comment}{     * 1. Save the current compressed node $NEXT pointer (the pointer to the}
00513 \textcolor{comment}{     *    child element, that is always present in compressed nodes).}
00514 \textcolor{comment}{     *}
00515 \textcolor{comment}{     * 2. Create "split node" having as child the non common letter}
00516 \textcolor{comment}{     *    at the compressed node. The other non common letter (at the key)}
00517 \textcolor{comment}{     *    will be added later as we continue the normal insertion algorithm}
00518 \textcolor{comment}{     *    at step "6".}
00519 \textcolor{comment}{     *}
00520 \textcolor{comment}{     * 3a. IF $SPLITPOS == 0:}
00521 \textcolor{comment}{     *     Replace the old node with the split node, by copying the auxiliary}
00522 \textcolor{comment}{     *     data if any. Fix parent's reference. Free old node eventually}
00523 \textcolor{comment}{     *     (we still need its data for the next steps of the algorithm).}
00524 \textcolor{comment}{     *}
00525 \textcolor{comment}{     * 3b. IF $SPLITPOS != 0:}
00526 \textcolor{comment}{     *     Trim the compressed node (reallocating it as well) in order to}
00527 \textcolor{comment}{     *     contain $splitpos characters. Change chilid pointer in order to link}
00528 \textcolor{comment}{     *     to the split node. If new compressed node len is just 1, set}
00529 \textcolor{comment}{     *     iscompr to 0 (layout is the same). Fix parent's reference.}
00530 \textcolor{comment}{     *}
00531 \textcolor{comment}{     * 4a. IF the postfix len (the length of the remaining string of the}
00532 \textcolor{comment}{     *     original compressed node after the split character) is non zero,}
00533 \textcolor{comment}{     *     create a "postfix node". If the postfix node has just one character}
00534 \textcolor{comment}{     *     set iscompr to 0, otherwise iscompr to 1. Set the postfix node}
00535 \textcolor{comment}{     *     child pointer to $NEXT.}
00536 \textcolor{comment}{     *}
00537 \textcolor{comment}{     * 4b. IF the postfix len is zero, just use $NEXT as postfix pointer.}
00538 \textcolor{comment}{     *}
00539 \textcolor{comment}{     * 5. Set child[0] of split node to postfix node.}
00540 \textcolor{comment}{     *}
00541 \textcolor{comment}{     * 6. Set the split node as the current node, set current index at child[1]}
00542 \textcolor{comment}{     *    and continue insertion algorithm as usually.}
00543 \textcolor{comment}{     *}
00544 \textcolor{comment}{     * ============================= ALGO 2 =============================}
00545 \textcolor{comment}{     *}
00546 \textcolor{comment}{     * For case 5, that is, if we stopped in the middle of a compressed}
00547 \textcolor{comment}{     * node but no mismatch was found, do:}
00548 \textcolor{comment}{     *}
00549 \textcolor{comment}{     * Let $SPLITPOS be the zero-based index at which, in the}
00550 \textcolor{comment}{     * compressed node array of characters, we stopped iterating because}
00551 \textcolor{comment}{     * there were no more keys character to match. So in the example of}
00552 \textcolor{comment}{     * the node "ANNIBALE", addig the string "ANNI", the $SPLITPOS is 4.}
00553 \textcolor{comment}{     *}
00554 \textcolor{comment}{     * 1. Save the current compressed node $NEXT pointer (the pointer to the}
00555 \textcolor{comment}{     *    child element, that is always present in compressed nodes).}
00556 \textcolor{comment}{     *}
00557 \textcolor{comment}{     * 2. Create a "postfix node" containing all the characters from $SPLITPOS}
00558 \textcolor{comment}{     *    to the end. Use $NEXT as the postfix node child pointer.}
00559 \textcolor{comment}{     *    If the postfix node length is 1, set iscompr to 0.}
00560 \textcolor{comment}{     *    Set the node as a key with the associated value of the new}
00561 \textcolor{comment}{     *    inserted key.}
00562 \textcolor{comment}{     *}
00563 \textcolor{comment}{     * 3. Trim the current node to contain the first $SPLITPOS characters.}
00564 \textcolor{comment}{     *    As usually if the new node length is just 1, set iscompr to 0.}
00565 \textcolor{comment}{     *    Take the iskey / associated value as it was in the orignal node.}
00566 \textcolor{comment}{     *    Fix the parent's reference.}
00567 \textcolor{comment}{     *}
00568 \textcolor{comment}{     * 4. Set the postfix node as the only child pointer of the trimmed}
00569 \textcolor{comment}{     *    node created at step 1.}
00570 \textcolor{comment}{     */}
00571 
00572     \textcolor{comment}{/* ------------------------- ALGORITHM 1 --------------------------- */}
00573     \textcolor{keywordflow}{if} (h->iscompr && i != len) \{
00574         \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"ALGO 1: Stopped at compressed node %.*s (%p)\(\backslash\)n"},
00575             h->size, h->data, (\textcolor{keywordtype}{void}*)h);
00576         \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"Still to insert: %.*s\(\backslash\)n"}, (\textcolor{keywordtype}{int})(len-i), s+i);
00577         \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"Splitting at %d: '%c'\(\backslash\)n"}, j, ((\textcolor{keywordtype}{char}*)h->data)[j]);
00578         \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"Other (key) letter is '%c'\(\backslash\)n"}, s[i]);
00579 
00580         \textcolor{comment}{/* 1: Save next pointer. */}
00581         raxNode **childfield = \hyperlink{rax_8c_a2c5310b0d00672508a8f935a7109f4ce}{raxNodeLastChildPtr}(h);
00582         raxNode *next;
00583         memcpy(&next,childfield,\textcolor{keyword}{sizeof}(next));
00584         \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"Next is %p\(\backslash\)n"}, (\textcolor{keywordtype}{void}*)next);
00585         \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"iskey %d\(\backslash\)n"}, h->iskey);
00586         \textcolor{keywordflow}{if} (h->iskey) \{
00587             \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"key value is %p\(\backslash\)n"}, raxGetData(h));
00588         \}
00589 
00590         \textcolor{comment}{/* Set the length of the additional nodes we will need. */}
00591         size\_t trimmedlen = j;
00592         size\_t postfixlen = h->size - j - 1;
00593         \textcolor{keywordtype}{int} split\_node\_is\_key = !trimmedlen && h->iskey && !h->isnull;
00594         size\_t nodesize;
00595 
00596         \textcolor{comment}{/* 2: Create the split node. Also allocate the other nodes we'll need}
00597 \textcolor{comment}{         *    ASAP, so that it will be simpler to handle OOM. */}
00598         raxNode *splitnode = raxNewNode(1, split\_node\_is\_key);
00599         raxNode *trimmed = NULL;
00600         raxNode *postfix = NULL;
00601 
00602         \textcolor{keywordflow}{if} (trimmedlen) \{
00603             nodesize = \textcolor{keyword}{sizeof}(raxNode)+trimmedlen+\textcolor{keyword}{sizeof}(raxNode*);
00604             \textcolor{keywordflow}{if} (h->iskey && !h->isnull) nodesize += \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*);
00605             trimmed = \hyperlink{rax__malloc_8h_aba4b5d6a50f54903fe9c330308beb66a}{rax\_malloc}(nodesize);
00606         \}
00607 
00608         \textcolor{keywordflow}{if} (postfixlen) \{
00609             nodesize = \textcolor{keyword}{sizeof}(raxNode)+postfixlen+
00610                        \textcolor{keyword}{sizeof}(raxNode*);
00611             postfix = \hyperlink{rax__malloc_8h_aba4b5d6a50f54903fe9c330308beb66a}{rax\_malloc}(nodesize);
00612         \}
00613 
00614         \textcolor{comment}{/* OOM? Abort now that the tree is untouched. */}
00615         \textcolor{keywordflow}{if} (splitnode == NULL ||
00616             (trimmedlen && trimmed == NULL) ||
00617             (postfixlen && postfix == NULL))
00618         \{
00619             \hyperlink{rax__malloc_8h_a3adfa16bca6cd23b6e125fd441465e49}{rax\_free}(splitnode);
00620             \hyperlink{rax__malloc_8h_a3adfa16bca6cd23b6e125fd441465e49}{rax\_free}(trimmed);
00621             \hyperlink{rax__malloc_8h_a3adfa16bca6cd23b6e125fd441465e49}{rax\_free}(postfix);
00622             errno = ENOMEM;
00623             \textcolor{keywordflow}{return} 0;
00624         \}
00625         splitnode->data[0] = h->data[j];
00626 
00627         \textcolor{keywordflow}{if} (j == 0) \{
00628             \textcolor{comment}{/* 3a: Replace the old node with the split node. */}
00629             \textcolor{keywordflow}{if} (h->iskey) \{
00630                 \textcolor{keywordtype}{void} *ndata = raxGetData(h);
00631                 raxSetData(splitnode,ndata);
00632             \}
00633             memcpy(parentlink,&splitnode,\textcolor{keyword}{sizeof}(splitnode));
00634         \} \textcolor{keywordflow}{else} \{
00635             \textcolor{comment}{/* 3b: Trim the compressed node. */}
00636             trimmed->size = j;
00637             memcpy(trimmed->data,h->data,j);
00638             trimmed->iscompr = j > 1 ? 1 : 0;
00639             trimmed->iskey = h->iskey;
00640             trimmed->isnull = h->isnull;
00641             \textcolor{keywordflow}{if} (h->iskey && !h->isnull) \{
00642                 \textcolor{keywordtype}{void} *ndata = raxGetData(h);
00643                 raxSetData(trimmed,ndata);
00644             \}
00645             raxNode **cp = \hyperlink{rax_8c_a2c5310b0d00672508a8f935a7109f4ce}{raxNodeLastChildPtr}(trimmed);
00646             memcpy(cp,&splitnode,\textcolor{keyword}{sizeof}(splitnode));
00647             memcpy(parentlink,&trimmed,\textcolor{keyword}{sizeof}(trimmed));
00648             parentlink = cp; \textcolor{comment}{/* Set parentlink to splitnode parent. */}
00649             rax->numnodes++;
00650         \}
00651 
00652         \textcolor{comment}{/* 4: Create the postfix node: what remains of the original}
00653 \textcolor{comment}{         * compressed node after the split. */}
00654         \textcolor{keywordflow}{if} (postfixlen) \{
00655             \textcolor{comment}{/* 4a: create a postfix node. */}
00656             postfix->iskey = 0;
00657             postfix->isnull = 0;
00658             postfix->size = postfixlen;
00659             postfix->iscompr = postfixlen > 1;
00660             memcpy(postfix->data,h->data+j+1,postfixlen);
00661             raxNode **cp = \hyperlink{rax_8c_a2c5310b0d00672508a8f935a7109f4ce}{raxNodeLastChildPtr}(postfix);
00662             memcpy(cp,&next,\textcolor{keyword}{sizeof}(next));
00663             rax->numnodes++;
00664         \} \textcolor{keywordflow}{else} \{
00665             \textcolor{comment}{/* 4b: just use next as postfix node. */}
00666             postfix = next;
00667         \}
00668 
00669         \textcolor{comment}{/* 5: Set splitnode first child as the postfix node. */}
00670         raxNode **splitchild = \hyperlink{rax_8c_a2c5310b0d00672508a8f935a7109f4ce}{raxNodeLastChildPtr}(splitnode);
00671         memcpy(splitchild,&postfix,\textcolor{keyword}{sizeof}(postfix));
00672 
00673         \textcolor{comment}{/* 6. Continue insertion: this will cause the splitnode to}
00674 \textcolor{comment}{         * get a new child (the non common character at the currently}
00675 \textcolor{comment}{         * inserted key). */}
00676         \hyperlink{rax__malloc_8h_a3adfa16bca6cd23b6e125fd441465e49}{rax\_free}(h);
00677         h = splitnode;
00678     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (h->iscompr && i == len) \{
00679     \textcolor{comment}{/* ------------------------- ALGORITHM 2 --------------------------- */}
00680         \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"ALGO 2: Stopped at compressed node %.*s (%p) j = %d\(\backslash\)n"},
00681             h->size, h->data, (\textcolor{keywordtype}{void}*)h, j);
00682 
00683         \textcolor{comment}{/* Allocate postfix & trimmed nodes ASAP to fail for OOM gracefully. */}
00684         size\_t postfixlen = h->size - j;
00685         size\_t nodesize = \textcolor{keyword}{sizeof}(raxNode)+postfixlen+\textcolor{keyword}{sizeof}(raxNode*);
00686         \textcolor{keywordflow}{if} (data != NULL) nodesize += \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*);
00687         raxNode *postfix = \hyperlink{rax__malloc_8h_aba4b5d6a50f54903fe9c330308beb66a}{rax\_malloc}(nodesize);
00688 
00689         nodesize = \textcolor{keyword}{sizeof}(raxNode)+j+\textcolor{keyword}{sizeof}(raxNode*);
00690         \textcolor{keywordflow}{if} (h->iskey && !h->isnull) nodesize += \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*);
00691         raxNode *trimmed = \hyperlink{rax__malloc_8h_aba4b5d6a50f54903fe9c330308beb66a}{rax\_malloc}(nodesize);
00692 
00693         \textcolor{keywordflow}{if} (postfix == NULL || trimmed == NULL) \{
00694             \hyperlink{rax__malloc_8h_a3adfa16bca6cd23b6e125fd441465e49}{rax\_free}(postfix);
00695             \hyperlink{rax__malloc_8h_a3adfa16bca6cd23b6e125fd441465e49}{rax\_free}(trimmed);
00696             errno = ENOMEM;
00697             \textcolor{keywordflow}{return} 0;
00698         \}
00699 
00700         \textcolor{comment}{/* 1: Save next pointer. */}
00701         raxNode **childfield = \hyperlink{rax_8c_a2c5310b0d00672508a8f935a7109f4ce}{raxNodeLastChildPtr}(h);
00702         raxNode *next;
00703         memcpy(&next,childfield,\textcolor{keyword}{sizeof}(next));
00704 
00705         \textcolor{comment}{/* 2: Create the postfix node. */}
00706         postfix->size = postfixlen;
00707         postfix->iscompr = postfixlen > 1;
00708         postfix->iskey = 1;
00709         postfix->isnull = 0;
00710         memcpy(postfix->data,h->data+j,postfixlen);
00711         raxSetData(postfix,data);
00712         raxNode **cp = \hyperlink{rax_8c_a2c5310b0d00672508a8f935a7109f4ce}{raxNodeLastChildPtr}(postfix);
00713         memcpy(cp,&next,\textcolor{keyword}{sizeof}(next));
00714         rax->numnodes++;
00715 
00716         \textcolor{comment}{/* 3: Trim the compressed node. */}
00717         trimmed->size = j;
00718         trimmed->iscompr = j > 1;
00719         trimmed->iskey = 0;
00720         trimmed->isnull = 0;
00721         memcpy(trimmed->data,h->data,j);
00722         memcpy(parentlink,&trimmed,\textcolor{keyword}{sizeof}(trimmed));
00723         \textcolor{keywordflow}{if} (h->iskey) \{
00724             \textcolor{keywordtype}{void} *aux = raxGetData(h);
00725             raxSetData(trimmed,aux);
00726         \}
00727 
00728         \textcolor{comment}{/* Fix the trimmed node child pointer to point to}
00729 \textcolor{comment}{         * the postfix node. */}
00730         cp = \hyperlink{rax_8c_a2c5310b0d00672508a8f935a7109f4ce}{raxNodeLastChildPtr}(trimmed);
00731         memcpy(cp,&postfix,\textcolor{keyword}{sizeof}(postfix));
00732 
00733         \textcolor{comment}{/* Finish! We don't need to contine with the insertion}
00734 \textcolor{comment}{         * algorithm for ALGO 2. The key is already inserted. */}
00735         rax->numele++;
00736         \hyperlink{rax__malloc_8h_a3adfa16bca6cd23b6e125fd441465e49}{rax\_free}(h);
00737         \textcolor{keywordflow}{return} 1; \textcolor{comment}{/* Key inserted. */}
00738     \}
00739 
00740     \textcolor{comment}{/* We walked the radix tree as far as we could, but still there are left}
00741 \textcolor{comment}{     * chars in our string. We need to insert the missing nodes. */}
00742     \textcolor{keywordflow}{while}(i < len) \{
00743         raxNode *child;
00744 
00745         \textcolor{comment}{/* If this node is going to have a single child, and there}
00746 \textcolor{comment}{         * are other characters, so that that would result in a chain}
00747 \textcolor{comment}{         * of single-childed nodes, turn it into a compressed node. */}
00748         \textcolor{keywordflow}{if} (h->size == 0 && len-i > 1) \{
00749             \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"Inserting compressed node\(\backslash\)n"});
00750             size\_t comprsize = len-i;
00751             \textcolor{keywordflow}{if} (comprsize > \hyperlink{rax_8h_a3b97483d00f37dd12e2d5efa4a9f23ce}{RAX\_NODE\_MAX\_SIZE})
00752                 comprsize = \hyperlink{rax_8h_a3b97483d00f37dd12e2d5efa4a9f23ce}{RAX\_NODE\_MAX\_SIZE};
00753             raxNode *newh = raxCompressNode(h,s+i,comprsize,&child);
00754             \textcolor{keywordflow}{if} (newh == NULL) \textcolor{keywordflow}{goto} oom;
00755             h = newh;
00756             memcpy(parentlink,&h,\textcolor{keyword}{sizeof}(h));
00757             parentlink = \hyperlink{rax_8c_a2c5310b0d00672508a8f935a7109f4ce}{raxNodeLastChildPtr}(h);
00758             i += comprsize;
00759         \} \textcolor{keywordflow}{else} \{
00760             \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"Inserting normal node\(\backslash\)n"});
00761             raxNode **new\_parentlink;
00762             raxNode *newh = raxAddChild(h,s[i],&child,&new\_parentlink);
00763             \textcolor{keywordflow}{if} (newh == NULL) \textcolor{keywordflow}{goto} oom;
00764             h = newh;
00765             memcpy(parentlink,&h,\textcolor{keyword}{sizeof}(h));
00766             parentlink = new\_parentlink;
00767             i++;
00768         \}
00769         rax->numnodes++;
00770         h = child;
00771     \}
00772     raxNode *newh = raxReallocForData(h,data);
00773     \textcolor{keywordflow}{if} (newh == NULL) \textcolor{keywordflow}{goto} oom;
00774     h = newh;
00775     \textcolor{keywordflow}{if} (!h->iskey) rax->numele++;
00776     raxSetData(h,data);
00777     memcpy(parentlink,&h,\textcolor{keyword}{sizeof}(h));
00778     \textcolor{keywordflow}{return} 1; \textcolor{comment}{/* Element inserted. */}
00779 
00780 oom:
00781     \textcolor{comment}{/* This code path handles out of memory after part of the sub-tree was}
00782 \textcolor{comment}{     * already modified. Set the node as a key, and then remove it. However we}
00783 \textcolor{comment}{     * do that only if the node is a terminal node, otherwise if the OOM}
00784 \textcolor{comment}{     * happened reallocating a node in the middle, we don't need to free}
00785 \textcolor{comment}{     * anything. */}
00786     \textcolor{keywordflow}{if} (h->size == 0) \{
00787         h->isnull = 1;
00788         h->iskey = 1;
00789         rax->numele++; \textcolor{comment}{/* Compensate the next remove. */}
00790         \hyperlink{redisassert_8h_a993abaa2c168852c1592879472938781}{assert}(raxRemove(rax,s,i,NULL) != 0);
00791     \}
00792     errno = ENOMEM;
00793     \textcolor{keywordflow}{return} 0;
00794 \}
00795 
00796 \textcolor{comment}{/* Find a key in the rax, returns raxNotFound special void pointer value}
00797 \textcolor{comment}{ * if the item was not found, otherwise the value associated with the}
00798 \textcolor{comment}{ * item is returned. */}
00799 \textcolor{keywordtype}{void} *raxFind(rax *rax, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *s, size\_t len) \{
00800     raxNode *h;
00801 
00802     \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"### Lookup: %.*s\(\backslash\)n"}, (\textcolor{keywordtype}{int})len, s);
00803     \textcolor{keywordtype}{int} splitpos = 0;
00804     size\_t i = raxLowWalk(rax,s,len,&h,NULL,&splitpos,NULL);
00805     \textcolor{keywordflow}{if} (i != len || (h->iscompr && splitpos != 0) || !h->iskey)
00806         \textcolor{keywordflow}{return} raxNotFound;
00807     \textcolor{keywordflow}{return} raxGetData(h);
00808 \}
00809 
00810 \textcolor{comment}{/* Return the memory address where the 'parent' node stores the specified}
00811 \textcolor{comment}{ * 'child' pointer, so that the caller can update the pointer with another}
00812 \textcolor{comment}{ * one if needed. The function assumes it will find a match, otherwise the}
00813 \textcolor{comment}{ * operation is an undefined behavior (it will continue scanning the}
00814 \textcolor{comment}{ * memory without any bound checking). */}
00815 raxNode **raxFindParentLink(raxNode *parent, raxNode *child) \{
00816     raxNode **cp = \hyperlink{rax_8c_aa94163a0d02b30219ef18e5a3ea06ca6}{raxNodeFirstChildPtr}(parent);
00817     raxNode *c;
00818     \textcolor{keywordflow}{while}(1) \{
00819         memcpy(&c,cp,\textcolor{keyword}{sizeof}(c));
00820         \textcolor{keywordflow}{if} (c == child) \textcolor{keywordflow}{break};
00821         cp++;
00822     \}
00823     \textcolor{keywordflow}{return} cp;
00824 \}
00825 
00826 \textcolor{comment}{/* Low level child removal from node. The new node pointer (after the child}
00827 \textcolor{comment}{ * removal) is returned. Note that this function does not fix the pointer}
00828 \textcolor{comment}{ * of the parent node in its parent, so this task is up to the caller.}
00829 \textcolor{comment}{ * The function never fails for out of memory. */}
00830 raxNode *raxRemoveChild(raxNode *parent, raxNode *child) \{
00831     \hyperlink{rax_8c_a622b73fbdc398cdbfa8cc1fb87283cb4}{debugnode}(\textcolor{stringliteral}{"raxRemoveChild before"}, parent);
00832     \textcolor{comment}{/* If parent is a compressed node (having a single child, as for definition}
00833 \textcolor{comment}{     * of the data structure), the removal of the child consists into turning}
00834 \textcolor{comment}{     * it into a normal node without children. */}
00835     \textcolor{keywordflow}{if} (parent->iscompr) \{
00836         \textcolor{keywordtype}{void} *data = NULL;
00837         \textcolor{keywordflow}{if} (parent->iskey) data = raxGetData(parent);
00838         parent->isnull = 0;
00839         parent->iscompr = 0;
00840         parent->size = 0;
00841         \textcolor{keywordflow}{if} (parent->iskey) raxSetData(parent,data);
00842         \hyperlink{rax_8c_a622b73fbdc398cdbfa8cc1fb87283cb4}{debugnode}(\textcolor{stringliteral}{"raxRemoveChild after"}, parent);
00843         \textcolor{keywordflow}{return} parent;
00844     \}
00845 
00846     \textcolor{comment}{/* Otherwise we need to scan for the children pointer and memmove()}
00847 \textcolor{comment}{     * accordingly.}
00848 \textcolor{comment}{     *}
00849 \textcolor{comment}{     * 1. To start we seek the first element in both the children}
00850 \textcolor{comment}{     *    pointers and edge bytes in the node. */}
00851     raxNode **cp = \hyperlink{rax_8c_aa94163a0d02b30219ef18e5a3ea06ca6}{raxNodeFirstChildPtr}(parent);
00852     raxNode **c = cp;
00853     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *e = parent->data;
00854 
00855     \textcolor{comment}{/* 2. Search the child pointer to remove inside the array of children}
00856 \textcolor{comment}{     *    pointers. */}
00857     \textcolor{keywordflow}{while}(1) \{
00858         raxNode *aux;
00859         memcpy(&aux,c,\textcolor{keyword}{sizeof}(aux));
00860         \textcolor{keywordflow}{if} (aux == child) \textcolor{keywordflow}{break};
00861         c++;
00862         e++;
00863     \}
00864 
00865     \textcolor{comment}{/* 3. Remove the edge and the pointer by memmoving the remaining children}
00866 \textcolor{comment}{     *    pointer and edge bytes one position before. */}
00867     \textcolor{keywordtype}{int} taillen = parent->size - (e - parent->data) - 1;
00868     \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"raxRemoveChild tail len: %d\(\backslash\)n"}, taillen);
00869     memmove(e,e+1,taillen);
00870 
00871     \textcolor{comment}{/* Since we have one data byte less, also child pointers start one byte}
00872 \textcolor{comment}{     * before now. */}
00873     memmove(((\textcolor{keywordtype}{char}*)cp)-1,cp,(parent->size-taillen-1)*\textcolor{keyword}{sizeof}(raxNode**));
00874 
00875     \textcolor{comment}{/* Move the remaining "tail" pointer at the right position as well. */}
00876     size\_t valuelen = (parent->iskey && !parent->isnull) ? \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*) : 0;
00877     memmove(((\textcolor{keywordtype}{char}*)c)-1,c+1,taillen*\textcolor{keyword}{sizeof}(raxNode**)+valuelen);
00878 
00879     \textcolor{comment}{/* 4. Update size. */}
00880     parent->size--;
00881 
00882     \textcolor{comment}{/* realloc the node according to the theoretical memory usage, to free}
00883 \textcolor{comment}{     * data if we are over-allocating right now. */}
00884     raxNode *newnode = \hyperlink{rax__malloc_8h_a4aa041a0e1eaa6d8476e889547280467}{rax\_realloc}(parent,\hyperlink{rax_8c_a93300b0f45c900ba0bdb80f3f7a83f5e}{raxNodeCurrentLength}(parent))
      ;
00885     \textcolor{keywordflow}{if} (newnode) \{
00886         \hyperlink{rax_8c_a622b73fbdc398cdbfa8cc1fb87283cb4}{debugnode}(\textcolor{stringliteral}{"raxRemoveChild after"}, newnode);
00887     \}
00888     \textcolor{comment}{/* Note: if rax\_realloc() fails we just return the old address, which}
00889 \textcolor{comment}{     * is valid. */}
00890     \textcolor{keywordflow}{return} newnode ? newnode : parent;
00891 \}
00892 
00893 \textcolor{comment}{/* Remove the specified item. Returns 1 if the item was found and}
00894 \textcolor{comment}{ * deleted, 0 otherwise. */}
00895 \textcolor{keywordtype}{int} raxRemove(rax *rax, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *s, size\_t len, \textcolor{keywordtype}{void} **old) \{
00896     raxNode *h;
00897     \hyperlink{structraxStack}{raxStack} ts;
00898 
00899     \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"### Delete: %.*s\(\backslash\)n"}, (\textcolor{keywordtype}{int})len, s);
00900     raxStackInit(&ts);
00901     \textcolor{keywordtype}{int} splitpos = 0;
00902     size\_t i = raxLowWalk(rax,s,len,&h,NULL,&splitpos,&ts);
00903     \textcolor{keywordflow}{if} (i != len || (h->iscompr && splitpos != 0) || !h->iskey) \{
00904         raxStackFree(&ts);
00905         \textcolor{keywordflow}{return} 0;
00906     \}
00907     \textcolor{keywordflow}{if} (old) *old = raxGetData(h);
00908     h->iskey = 0;
00909     rax->numele--;
00910 
00911     \textcolor{comment}{/* If this node has no children, the deletion needs to reclaim the}
00912 \textcolor{comment}{     * no longer used nodes. This is an iterative process that needs to}
00913 \textcolor{comment}{     * walk the three upward, deleting all the nodes with just one child}
00914 \textcolor{comment}{     * that are not keys, until the head of the rax is reached or the first}
00915 \textcolor{comment}{     * node with more than one child is found. */}
00916 
00917     \textcolor{keywordtype}{int} trycompress = 0; \textcolor{comment}{/* Will be set to 1 if we should try to optimize the}
00918 \textcolor{comment}{                            tree resulting from the deletion. */}
00919 
00920     \textcolor{keywordflow}{if} (h->size == 0) \{
00921         \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"Key deleted in node without children. Cleanup needed.\(\backslash\)n"});
00922         raxNode *child = NULL;
00923         \textcolor{keywordflow}{while}(h != rax->head) \{
00924             child = h;
00925             \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"Freeing child %p [%.*s] key:%d\(\backslash\)n"}, (\textcolor{keywordtype}{void}*)child,
00926                 (\textcolor{keywordtype}{int})child->size, (\textcolor{keywordtype}{char}*)child->data, child->iskey);
00927             \hyperlink{rax__malloc_8h_a3adfa16bca6cd23b6e125fd441465e49}{rax\_free}(child);
00928             rax->numnodes--;
00929             h = raxStackPop(&ts);
00930              \textcolor{comment}{/* If this node has more then one child, or actually holds}
00931 \textcolor{comment}{              * a key, stop here. */}
00932             \textcolor{keywordflow}{if} (h->iskey || (!h->iscompr && h->size != 1)) \textcolor{keywordflow}{break};
00933         \}
00934         \textcolor{keywordflow}{if} (child) \{
00935             \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"Unlinking child %p from parent %p\(\backslash\)n"},
00936                 (\textcolor{keywordtype}{void}*)child, (\textcolor{keywordtype}{void}*)h);
00937             raxNode *\textcolor{keyword}{new} = raxRemoveChild(h,child);
00938             \textcolor{keywordflow}{if} (\textcolor{keyword}{new} != h) \{
00939                 raxNode *parent = raxStackPeek(&ts);
00940                 raxNode **parentlink;
00941                 \textcolor{keywordflow}{if} (parent == NULL) \{
00942                     parentlink = &rax->head;
00943                 \} \textcolor{keywordflow}{else} \{
00944                     parentlink = raxFindParentLink(parent,h);
00945                 \}
00946                 memcpy(parentlink,&\textcolor{keyword}{new},\textcolor{keyword}{sizeof}(\textcolor{keyword}{new}));
00947             \}
00948 
00949             \textcolor{comment}{/* If after the removal the node has just a single child}
00950 \textcolor{comment}{             * and is not a key, we need to try to compress it. */}
00951             \textcolor{keywordflow}{if} (\textcolor{keyword}{new}->size == 1 && \textcolor{keyword}{new}->iskey == 0) \{
00952                 trycompress = 1;
00953                 h = \textcolor{keyword}{new};
00954             \}
00955         \}
00956     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (h->size == 1) \{
00957         \textcolor{comment}{/* If the node had just one child, after the removal of the key}
00958 \textcolor{comment}{         * further compression with adjacent nodes is pontentially possible. */}
00959         trycompress = 1;
00960     \}
00961 
00962     \textcolor{comment}{/* Don't try node compression if our nodes pointers stack is not}
00963 \textcolor{comment}{     * complete because of OOM while executing raxLowWalk() */}
00964     \textcolor{keywordflow}{if} (trycompress && ts.oom) trycompress = 0;
00965 
00966     \textcolor{comment}{/* Recompression: if trycompress is true, 'h' points to a radix tree node}
00967 \textcolor{comment}{     * that changed in a way that could allow to compress nodes in this}
00968 \textcolor{comment}{     * sub-branch. Compressed nodes represent chains of nodes that are not}
00969 \textcolor{comment}{     * keys and have a single child, so there are two deletion events that}
00970 \textcolor{comment}{     * may alter the tree so that further compression is needed:}
00971 \textcolor{comment}{     *}
00972 \textcolor{comment}{     * 1) A node with a single child was a key and now no longer is a key.}
00973 \textcolor{comment}{     * 2) A node with two children now has just one child.}
00974 \textcolor{comment}{     *}
00975 \textcolor{comment}{     * We try to navigate upward till there are other nodes that can be}
00976 \textcolor{comment}{     * compressed, when we reach the upper node which is not a key and has}
00977 \textcolor{comment}{     * a single child, we scan the chain of children to collect the}
00978 \textcolor{comment}{     * compressable part of the tree, and replace the current node with the}
00979 \textcolor{comment}{     * new one, fixing the child pointer to reference the first non}
00980 \textcolor{comment}{     * compressable node.}
00981 \textcolor{comment}{     *}
00982 \textcolor{comment}{     * Example of case "1". A tree stores the keys "FOO" = 1 and}
00983 \textcolor{comment}{     * "FOOBAR" = 2:}
00984 \textcolor{comment}{     *}
00985 \textcolor{comment}{     *}
00986 \textcolor{comment}{     * "FOO" -> "BAR" -> [] (2)}
00987 \textcolor{comment}{     *           (1)}
00988 \textcolor{comment}{     *}
00989 \textcolor{comment}{     * After the removal of "FOO" the tree can be compressed as:}
00990 \textcolor{comment}{     *}
00991 \textcolor{comment}{     * "FOOBAR" -> [] (2)}
00992 \textcolor{comment}{     *}
00993 \textcolor{comment}{     *}
00994 \textcolor{comment}{     * Example of case "2". A tree stores the keys "FOOBAR" = 1 and}
00995 \textcolor{comment}{     * "FOOTER" = 2:}
00996 \textcolor{comment}{     *}
00997 \textcolor{comment}{     *          |B| -> "AR" -> [] (1)}
00998 \textcolor{comment}{     * "FOO" -> |-|}
00999 \textcolor{comment}{     *          |T| -> "ER" -> [] (2)}
01000 \textcolor{comment}{     *}
01001 \textcolor{comment}{     * After the removal of "FOOTER" the resulting tree is:}
01002 \textcolor{comment}{     *}
01003 \textcolor{comment}{     * "FOO" -> |B| -> "AR" -> [] (1)}
01004 \textcolor{comment}{     *}
01005 \textcolor{comment}{     * That can be compressed into:}
01006 \textcolor{comment}{     *}
01007 \textcolor{comment}{     * "FOOBAR" -> [] (1)}
01008 \textcolor{comment}{     */}
01009     \textcolor{keywordflow}{if} (trycompress) \{
01010         \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"After removing %.*s:\(\backslash\)n"}, (\textcolor{keywordtype}{int})len, s);
01011         \hyperlink{rax_8c_a622b73fbdc398cdbfa8cc1fb87283cb4}{debugnode}(\textcolor{stringliteral}{"Compression may be needed"},h);
01012         \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"Seek start node\(\backslash\)n"});
01013 
01014         \textcolor{comment}{/* Try to reach the upper node that is compressible.}
01015 \textcolor{comment}{         * At the end of the loop 'h' will point to the first node we}
01016 \textcolor{comment}{         * can try to compress and 'parent' to its parent. */}
01017         raxNode *parent;
01018         \textcolor{keywordflow}{while}(1) \{
01019             parent = raxStackPop(&ts);
01020             \textcolor{keywordflow}{if} (!parent || parent->iskey ||
01021                 (!parent->iscompr && parent->size != 1)) \textcolor{keywordflow}{break};
01022             h = parent;
01023             \hyperlink{rax_8c_a622b73fbdc398cdbfa8cc1fb87283cb4}{debugnode}(\textcolor{stringliteral}{"Going up to"},h);
01024         \}
01025         raxNode *start = h; \textcolor{comment}{/* Compression starting node. */}
01026 
01027         \textcolor{comment}{/* Scan chain of nodes we can compress. */}
01028         size\_t comprsize = h->size;
01029         \textcolor{keywordtype}{int} nodes = 1;
01030         \textcolor{keywordflow}{while}(h->size != 0) \{
01031             raxNode **cp = \hyperlink{rax_8c_a2c5310b0d00672508a8f935a7109f4ce}{raxNodeLastChildPtr}(h);
01032             memcpy(&h,cp,\textcolor{keyword}{sizeof}(h));
01033             \textcolor{keywordflow}{if} (h->iskey || (!h->iscompr && h->size != 1)) \textcolor{keywordflow}{break};
01034             \textcolor{comment}{/* Stop here if going to the next node would result into}
01035 \textcolor{comment}{             * a compressed node larger than h->size can hold. */}
01036             \textcolor{keywordflow}{if} (comprsize + h->size > \hyperlink{rax_8h_a3b97483d00f37dd12e2d5efa4a9f23ce}{RAX\_NODE\_MAX\_SIZE}) \textcolor{keywordflow}{break};
01037             nodes++;
01038             comprsize += h->size;
01039         \}
01040         \textcolor{keywordflow}{if} (nodes > 1) \{
01041             \textcolor{comment}{/* If we can compress, create the new node and populate it. */}
01042             size\_t nodesize =
01043                 \textcolor{keyword}{sizeof}(raxNode)+comprsize+\textcolor{keyword}{sizeof}(raxNode*);
01044             raxNode *\textcolor{keyword}{new} = \hyperlink{rax__malloc_8h_aba4b5d6a50f54903fe9c330308beb66a}{rax\_malloc}(nodesize);
01045             \textcolor{comment}{/* An out of memory here just means we cannot optimize this}
01046 \textcolor{comment}{             * node, but the tree is left in a consistent state. */}
01047             \textcolor{keywordflow}{if} (\textcolor{keyword}{new} == NULL) \{
01048                 raxStackFree(&ts);
01049                 \textcolor{keywordflow}{return} 1;
01050             \}
01051             \textcolor{keyword}{new}->iskey = 0;
01052             \textcolor{keyword}{new}->isnull = 0;
01053             \textcolor{keyword}{new}->iscompr = 1;
01054             \textcolor{keyword}{new}->size = comprsize;
01055             rax->numnodes++;
01056 
01057             \textcolor{comment}{/* Scan again, this time to populate the new node content and}
01058 \textcolor{comment}{             * to fix the new node child pointer. At the same time we free}
01059 \textcolor{comment}{             * all the nodes that we'll no longer use. */}
01060             comprsize = 0;
01061             h = start;
01062             \textcolor{keywordflow}{while}(h->size != 0) \{
01063                 memcpy(\textcolor{keyword}{new}->data+comprsize,h->data,h->size);
01064                 comprsize += h->size;
01065                 raxNode **cp = \hyperlink{rax_8c_a2c5310b0d00672508a8f935a7109f4ce}{raxNodeLastChildPtr}(h);
01066                 raxNode *tofree = h;
01067                 memcpy(&h,cp,\textcolor{keyword}{sizeof}(h));
01068                 \hyperlink{rax__malloc_8h_a3adfa16bca6cd23b6e125fd441465e49}{rax\_free}(tofree); rax->numnodes--;
01069                 \textcolor{keywordflow}{if} (h->iskey || (!h->iscompr && h->size != 1)) \textcolor{keywordflow}{break};
01070             \}
01071             \hyperlink{rax_8c_a622b73fbdc398cdbfa8cc1fb87283cb4}{debugnode}(\textcolor{stringliteral}{"New node"},\textcolor{keyword}{new});
01072 
01073             \textcolor{comment}{/* Now 'h' points to the first node that we still need to use,}
01074 \textcolor{comment}{             * so our new node child pointer will point to it. */}
01075             raxNode **cp = \hyperlink{rax_8c_a2c5310b0d00672508a8f935a7109f4ce}{raxNodeLastChildPtr}(\textcolor{keyword}{new});
01076             memcpy(cp,&h,\textcolor{keyword}{sizeof}(h));
01077 
01078             \textcolor{comment}{/* Fix parent link. */}
01079             \textcolor{keywordflow}{if} (parent) \{
01080                 raxNode **parentlink = raxFindParentLink(parent,start);
01081                 memcpy(parentlink,&\textcolor{keyword}{new},\textcolor{keyword}{sizeof}(\textcolor{keyword}{new}));
01082             \} \textcolor{keywordflow}{else} \{
01083                 rax->head = \textcolor{keyword}{new};
01084             \}
01085 
01086             \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"Compressed %d nodes, %d total bytes\(\backslash\)n"},
01087                 nodes, (\textcolor{keywordtype}{int})comprsize);
01088         \}
01089     \}
01090     raxStackFree(&ts);
01091     \textcolor{keywordflow}{return} 1;
01092 \}
01093 
01094 \textcolor{comment}{/* This is the core of raxFree(): performs a depth-first scan of the}
01095 \textcolor{comment}{ * tree and releases all the nodes found. */}
01096 \textcolor{keywordtype}{void} raxRecursiveFree(rax *rax, raxNode *n, \textcolor{keywordtype}{void} (*free\_callback)(\textcolor{keywordtype}{void}*)) \{
01097     \hyperlink{rax_8c_a622b73fbdc398cdbfa8cc1fb87283cb4}{debugnode}(\textcolor{stringliteral}{"free traversing"},n);
01098     \textcolor{keywordtype}{int} numchildren = n->iscompr ? 1 : n->size;
01099     raxNode **cp = \hyperlink{rax_8c_a2c5310b0d00672508a8f935a7109f4ce}{raxNodeLastChildPtr}(n);
01100     \textcolor{keywordflow}{while}(numchildren--) \{
01101         raxNode *child;
01102         memcpy(&child,cp,\textcolor{keyword}{sizeof}(child));
01103         raxRecursiveFree(rax,child,free\_callback);
01104         cp--;
01105     \}
01106     \hyperlink{rax_8c_a622b73fbdc398cdbfa8cc1fb87283cb4}{debugnode}(\textcolor{stringliteral}{"free depth-first"},n);
01107     \textcolor{keywordflow}{if} (free\_callback && n->iskey && !n->isnull)
01108         free\_callback(raxGetData(n));
01109     \hyperlink{rax__malloc_8h_a3adfa16bca6cd23b6e125fd441465e49}{rax\_free}(n);
01110     rax->numnodes--;
01111 \}
01112 
01113 \textcolor{comment}{/* Free a whole radix tree, calling the specified callback in order to}
01114 \textcolor{comment}{ * free the auxiliary data. */}
01115 \textcolor{keywordtype}{void} raxFreeWithCallback(rax *rax, \textcolor{keywordtype}{void} (*free\_callback)(\textcolor{keywordtype}{void}*)) \{
01116     raxRecursiveFree(rax,rax->head,free\_callback);
01117     \hyperlink{redisassert_8h_a993abaa2c168852c1592879472938781}{assert}(rax->numnodes == 0);
01118     \hyperlink{rax__malloc_8h_a3adfa16bca6cd23b6e125fd441465e49}{rax\_free}(rax);
01119 \}
01120 
01121 \textcolor{comment}{/* Free a whole radix tree. */}
01122 \textcolor{keywordtype}{void} raxFree(rax *rax) \{
01123     raxFreeWithCallback(rax,NULL);
01124 \}
01125 
01126 \textcolor{comment}{/* ------------------------------- Iterator --------------------------------- */}
01127 
01128 \textcolor{comment}{/* Initialize a Rax iterator. This call should be performed a single time}
01129 \textcolor{comment}{ * to initialize the iterator, and must be followed by a raxSeek() call,}
01130 \textcolor{comment}{ * otherwise the raxPrev()/raxNext() functions will just return EOF. */}
01131 \textcolor{keywordtype}{void} raxStart(\hyperlink{structraxIterator}{raxIterator} *it, rax *rt) \{
01132     it->flags = \hyperlink{rax_8h_a4fb08a914b84ba0a39daa86297176e1c}{RAX\_ITER\_EOF}; \textcolor{comment}{/* No crash if the iterator is not seeked. */}
01133     it->rt = rt;
01134     it->key\_len = 0;
01135     it->key = it->key\_static\_string;
01136     it->key\_max = \hyperlink{rax_8h_a172e740ce3572b21018192e7877217dd}{RAX\_ITER\_STATIC\_LEN};
01137     it->data = NULL;
01138     raxStackInit(&it->stack);
01139 \}
01140 
01141 \textcolor{comment}{/* Append characters at the current key string of the iterator 'it'. This}
01142 \textcolor{comment}{ * is a low level function used to implement the iterator, not callable by}
01143 \textcolor{comment}{ * the user. Returns 0 on out of memory, otherwise 1 is returned. */}
01144 \textcolor{keywordtype}{int} raxIteratorAddChars(\hyperlink{structraxIterator}{raxIterator} *it, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *s, size\_t len) \{
01145     \textcolor{keywordflow}{if} (it->key\_max < it->key\_len+len) \{
01146         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *old = (it->key == it->key\_static\_string) ? NULL :
01147                                                                   it->key;
01148         size\_t new\_max = (it->key\_len+len)*2;
01149         it->key = \hyperlink{rax__malloc_8h_a4aa041a0e1eaa6d8476e889547280467}{rax\_realloc}(old,new\_max);
01150         \textcolor{keywordflow}{if} (it->key == NULL) \{
01151             it->key = (!old) ? it->key\_static\_string : old;
01152             errno = ENOMEM;
01153             \textcolor{keywordflow}{return} 0;
01154         \}
01155         \textcolor{keywordflow}{if} (old == NULL) memcpy(it->key,it->key\_static\_string,it->key\_len);
01156         it->key\_max = new\_max;
01157     \}
01158     \textcolor{comment}{/* Use memmove since there could be an overlap between 's' and}
01159 \textcolor{comment}{     * it->key when we use the current key in order to re-seek. */}
01160     memmove(it->key+it->key\_len,s,len);
01161     it->key\_len += len;
01162     \textcolor{keywordflow}{return} 1;
01163 \}
01164 
01165 \textcolor{comment}{/* Remove the specified number of chars from the right of the current}
01166 \textcolor{comment}{ * iterator key. */}
01167 \textcolor{keywordtype}{void} raxIteratorDelChars(\hyperlink{structraxIterator}{raxIterator} *it, size\_t count) \{
01168     it->key\_len -= count;
01169 \}
01170 
01171 \textcolor{comment}{/* Do an iteration step towards the next element. At the end of the step the}
01172 \textcolor{comment}{ * iterator key will represent the (new) current key. If it is not possible}
01173 \textcolor{comment}{ * to step in the specified direction since there are no longer elements, the}
01174 \textcolor{comment}{ * iterator is flagged with RAX\_ITER\_EOF.}
01175 \textcolor{comment}{ *}
01176 \textcolor{comment}{ * If 'noup' is true the function starts directly scanning for the next}
01177 \textcolor{comment}{ * lexicographically smaller children, and the current node is already assumed}
01178 \textcolor{comment}{ * to be the parent of the last key node, so the first operation to go back to}
01179 \textcolor{comment}{ * the parent will be skipped. This option is used by raxSeek() when}
01180 \textcolor{comment}{ * implementing seeking a non existing element with the ">" or "<" options:}
01181 \textcolor{comment}{ * the starting node is not a key in that particular case, so we start the scan}
01182 \textcolor{comment}{ * from a node that does not represent the key set.}
01183 \textcolor{comment}{ *}
01184 \textcolor{comment}{ * The function returns 1 on success or 0 on out of memory. */}
01185 \textcolor{keywordtype}{int} raxIteratorNextStep(\hyperlink{structraxIterator}{raxIterator} *it, \textcolor{keywordtype}{int} noup) \{
01186     \textcolor{keywordflow}{if} (it->flags & \hyperlink{rax_8h_a4fb08a914b84ba0a39daa86297176e1c}{RAX\_ITER\_EOF}) \{
01187         \textcolor{keywordflow}{return} 1;
01188     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (it->flags & \hyperlink{rax_8h_a665a029bbb4c6864ca2153b3ba3b746c}{RAX\_ITER\_JUST\_SEEKED}) \{
01189         it->flags &= ~\hyperlink{rax_8h_a665a029bbb4c6864ca2153b3ba3b746c}{RAX\_ITER\_JUST\_SEEKED};
01190         \textcolor{keywordflow}{return} 1;
01191     \}
01192 
01193     \textcolor{comment}{/* Save key len, stack items and the node where we are currently}
01194 \textcolor{comment}{     * so that on iterator EOF we can restore the current key and state. */}
01195     size\_t orig\_key\_len = it->key\_len;
01196     size\_t orig\_stack\_items = it->stack.items;
01197     raxNode *orig\_node = it->node;
01198 
01199     \textcolor{keywordflow}{while}(1) \{
01200         \textcolor{keywordtype}{int} children = it->node->iscompr ? 1 : it->node->size;
01201         \textcolor{keywordflow}{if} (!noup && children) \{
01202             \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"GO DEEPER\(\backslash\)n"});
01203             \textcolor{comment}{/* Seek the lexicographically smaller key in this subtree, which}
01204 \textcolor{comment}{             * is the first one found always going torwards the first child}
01205 \textcolor{comment}{             * of every successive node. */}
01206             \textcolor{keywordflow}{if} (!raxStackPush(&it->stack,it->node)) \textcolor{keywordflow}{return} 0;
01207             raxNode **cp = \hyperlink{rax_8c_aa94163a0d02b30219ef18e5a3ea06ca6}{raxNodeFirstChildPtr}(it->node);
01208             \textcolor{keywordflow}{if} (!raxIteratorAddChars(it,it->node->data,
01209                 it->node->iscompr ? it->node->size : 1)) \textcolor{keywordflow}{return} 0;
01210             memcpy(&it->node,cp,\textcolor{keyword}{sizeof}(it->node));
01211             \textcolor{comment}{/* For "next" step, stop every time we find a key along the}
01212 \textcolor{comment}{             * way, since the key is lexicograhically smaller compared to}
01213 \textcolor{comment}{             * what follows in the sub-children. */}
01214             \textcolor{keywordflow}{if} (it->node->iskey) \{
01215                 it->data = raxGetData(it->node);
01216                 \textcolor{keywordflow}{return} 1;
01217             \}
01218         \} \textcolor{keywordflow}{else} \{
01219             \textcolor{comment}{/* If we finished exporing the previous sub-tree, switch to the}
01220 \textcolor{comment}{             * new one: go upper until a node is found where there are}
01221 \textcolor{comment}{             * children representing keys lexicographically greater than the}
01222 \textcolor{comment}{             * current key. */}
01223             \textcolor{keywordflow}{while}(1) \{
01224                 \textcolor{keywordtype}{int} old\_noup = noup;
01225 
01226                 \textcolor{comment}{/* Already on head? Can't go up, iteration finished. */}
01227                 \textcolor{keywordflow}{if} (!noup && it->node == it->rt->head) \{
01228                     it->flags |= \hyperlink{rax_8h_a4fb08a914b84ba0a39daa86297176e1c}{RAX\_ITER\_EOF};
01229                     it->stack.items = orig\_stack\_items;
01230                     it->key\_len = orig\_key\_len;
01231                     it->node = orig\_node;
01232                     \textcolor{keywordflow}{return} 1;
01233                 \}
01234                 \textcolor{comment}{/* If there are no children at the current node, try parent's}
01235 \textcolor{comment}{                 * next child. */}
01236                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} prevchild = it->key[it->key\_len-1];
01237                 \textcolor{keywordflow}{if} (!noup) \{
01238                     it->node = raxStackPop(&it->stack);
01239                 \} \textcolor{keywordflow}{else} \{
01240                     noup = 0;
01241                 \}
01242                 \textcolor{comment}{/* Adjust the current key to represent the node we are}
01243 \textcolor{comment}{                 * at. */}
01244                 \textcolor{keywordtype}{int} todel = it->node->iscompr ? it->node->size : 1;
01245                 raxIteratorDelChars(it,todel);
01246 
01247                 \textcolor{comment}{/* Try visiting the next child if there was at least one}
01248 \textcolor{comment}{                 * additional child. */}
01249                 \textcolor{keywordflow}{if} (!it->node->iscompr && it->node->size > (old\_noup ? 0 : 1)) \{
01250                     raxNode **cp = \hyperlink{rax_8c_aa94163a0d02b30219ef18e5a3ea06ca6}{raxNodeFirstChildPtr}(it->node);
01251                     \textcolor{keywordtype}{int} i = 0;
01252                     \textcolor{keywordflow}{while} (i < it->node->size) \{
01253                         \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"SCAN NEXT %c\(\backslash\)n"}, it->node->data[i]);
01254                         \textcolor{keywordflow}{if} (it->node->data[i] > prevchild) \textcolor{keywordflow}{break};
01255                         i++;
01256                         cp++;
01257                     \}
01258                     \textcolor{keywordflow}{if} (i != it->node->size) \{
01259                         \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"SCAN found a new node\(\backslash\)n"});
01260                         raxIteratorAddChars(it,it->node->data+i,1);
01261                         \textcolor{keywordflow}{if} (!raxStackPush(&it->stack,it->node)) \textcolor{keywordflow}{return} 0;
01262                         memcpy(&it->node,cp,\textcolor{keyword}{sizeof}(it->node));
01263                         \textcolor{keywordflow}{if} (it->node->iskey) \{
01264                             it->data = raxGetData(it->node);
01265                             \textcolor{keywordflow}{return} 1;
01266                         \}
01267                         \textcolor{keywordflow}{break};
01268                     \}
01269                 \}
01270             \}
01271         \}
01272     \}
01273 \}
01274 
01275 \textcolor{comment}{/* Seek the grestest key in the subtree at the current node. Return 0 on}
01276 \textcolor{comment}{ * out of memory, otherwise 1. This is an helper function for different}
01277 \textcolor{comment}{ * iteration functions below. */}
01278 \textcolor{keywordtype}{int} raxSeekGreatest(\hyperlink{structraxIterator}{raxIterator} *it) \{
01279     \textcolor{keywordflow}{while}(it->node->size) \{
01280         \textcolor{keywordflow}{if} (it->node->iscompr) \{
01281             \textcolor{keywordflow}{if} (!raxIteratorAddChars(it,it->node->data,
01282                 it->node->size)) \textcolor{keywordflow}{return} 0;
01283         \} \textcolor{keywordflow}{else} \{
01284             \textcolor{keywordflow}{if} (!raxIteratorAddChars(it,it->node->data+it->node->size-1,1))
01285                 \textcolor{keywordflow}{return} 0;
01286         \}
01287         raxNode **cp = \hyperlink{rax_8c_a2c5310b0d00672508a8f935a7109f4ce}{raxNodeLastChildPtr}(it->node);
01288         \textcolor{keywordflow}{if} (!raxStackPush(&it->stack,it->node)) \textcolor{keywordflow}{return} 0;
01289         memcpy(&it->node,cp,\textcolor{keyword}{sizeof}(it->node));
01290     \}
01291     \textcolor{keywordflow}{return} 1;
01292 \}
01293 
01294 \textcolor{comment}{/* Like raxIteratorNextStep() but implements an iteration step moving}
01295 \textcolor{comment}{ * to the lexicographically previous element. The 'noup' option has a similar}
01296 \textcolor{comment}{ * effect to the one of raxIteratorPrevSte(). */}
01297 \textcolor{keywordtype}{int} raxIteratorPrevStep(\hyperlink{structraxIterator}{raxIterator} *it, \textcolor{keywordtype}{int} noup) \{
01298     \textcolor{keywordflow}{if} (it->flags & \hyperlink{rax_8h_a4fb08a914b84ba0a39daa86297176e1c}{RAX\_ITER\_EOF}) \{
01299         \textcolor{keywordflow}{return} 1;
01300     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (it->flags & \hyperlink{rax_8h_a665a029bbb4c6864ca2153b3ba3b746c}{RAX\_ITER\_JUST\_SEEKED}) \{
01301         it->flags &= ~\hyperlink{rax_8h_a665a029bbb4c6864ca2153b3ba3b746c}{RAX\_ITER\_JUST\_SEEKED};
01302         \textcolor{keywordflow}{return} 1;
01303     \}
01304 
01305     \textcolor{comment}{/* Save key len, stack items and the node where we are currently}
01306 \textcolor{comment}{     * so that on iterator EOF we can restore the current key and state. */}
01307     size\_t orig\_key\_len = it->key\_len;
01308     size\_t orig\_stack\_items = it->stack.items;
01309     raxNode *orig\_node = it->node;
01310 
01311     \textcolor{keywordflow}{while}(1) \{
01312         \textcolor{keywordtype}{int} old\_noup = noup;
01313 
01314         \textcolor{comment}{/* Already on head? Can't go up, iteration finished. */}
01315         \textcolor{keywordflow}{if} (!noup && it->node == it->rt->head) \{
01316             it->flags |= \hyperlink{rax_8h_a4fb08a914b84ba0a39daa86297176e1c}{RAX\_ITER\_EOF};
01317             it->stack.items = orig\_stack\_items;
01318             it->key\_len = orig\_key\_len;
01319             it->node = orig\_node;
01320             \textcolor{keywordflow}{return} 1;
01321         \}
01322 
01323         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} prevchild = it->key[it->key\_len-1];
01324         \textcolor{keywordflow}{if} (!noup) \{
01325             it->node = raxStackPop(&it->stack);
01326         \} \textcolor{keywordflow}{else} \{
01327             noup = 0;
01328         \}
01329 
01330         \textcolor{comment}{/* Adjust the current key to represent the node we are}
01331 \textcolor{comment}{         * at. */}
01332         \textcolor{keywordtype}{int} todel = it->node->iscompr ? it->node->size : 1;
01333         raxIteratorDelChars(it,todel);
01334 
01335         \textcolor{comment}{/* Try visiting the prev child if there is at least one}
01336 \textcolor{comment}{         * child. */}
01337         \textcolor{keywordflow}{if} (!it->node->iscompr && it->node->size > (old\_noup ? 0 : 1)) \{
01338             raxNode **cp = \hyperlink{rax_8c_a2c5310b0d00672508a8f935a7109f4ce}{raxNodeLastChildPtr}(it->node);
01339             \textcolor{keywordtype}{int} i = it->node->size-1;
01340             \textcolor{keywordflow}{while} (i >= 0) \{
01341                 \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"SCAN PREV %c\(\backslash\)n"}, it->node->data[i]);
01342                 \textcolor{keywordflow}{if} (it->node->data[i] < prevchild) \textcolor{keywordflow}{break};
01343                 i--;
01344                 cp--;
01345             \}
01346             \textcolor{comment}{/* If we found a new subtree to explore in this node,}
01347 \textcolor{comment}{             * go deeper following all the last children in order to}
01348 \textcolor{comment}{             * find the key lexicographically greater. */}
01349             \textcolor{keywordflow}{if} (i != -1) \{
01350                 \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"SCAN found a new node\(\backslash\)n"});
01351                 \textcolor{comment}{/* Enter the node we just found. */}
01352                 \textcolor{keywordflow}{if} (!raxIteratorAddChars(it,it->node->data+i,1)) \textcolor{keywordflow}{return} 0;
01353                 \textcolor{keywordflow}{if} (!raxStackPush(&it->stack,it->node)) \textcolor{keywordflow}{return} 0;
01354                 memcpy(&it->node,cp,\textcolor{keyword}{sizeof}(it->node));
01355                 \textcolor{comment}{/* Seek sub-tree max. */}
01356                 \textcolor{keywordflow}{if} (!raxSeekGreatest(it)) \textcolor{keywordflow}{return} 0;
01357             \}
01358         \}
01359 
01360         \textcolor{comment}{/* Return the key: this could be the key we found scanning a new}
01361 \textcolor{comment}{         * subtree, or if we did not find a new subtree to explore here,}
01362 \textcolor{comment}{         * before giving up with this node, check if it's a key itself. */}
01363         \textcolor{keywordflow}{if} (it->node->iskey) \{
01364             it->data = raxGetData(it->node);
01365             \textcolor{keywordflow}{return} 1;
01366         \}
01367     \}
01368 \}
01369 
01370 \textcolor{comment}{/* Seek an iterator at the specified element.}
01371 \textcolor{comment}{ * Return 0 if the seek failed for syntax error or out of memory. Otherwise}
01372 \textcolor{comment}{ * 1 is returned. When 0 is returned for out of memory, errno is set to}
01373 \textcolor{comment}{ * the ENOMEM value. */}
01374 \textcolor{keywordtype}{int} raxSeek(\hyperlink{structraxIterator}{raxIterator} *it, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *op, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ele, size\_t len) \{
01375     \textcolor{keywordtype}{int} eq = 0, lt = 0, gt = 0, first = 0, last = 0;
01376 
01377     it->stack.items = 0; \textcolor{comment}{/* Just resetting. Intialized by raxStart(). */}
01378     it->flags |= \hyperlink{rax_8h_a665a029bbb4c6864ca2153b3ba3b746c}{RAX\_ITER\_JUST\_SEEKED};
01379     it->flags &= ~\hyperlink{rax_8h_a4fb08a914b84ba0a39daa86297176e1c}{RAX\_ITER\_EOF};
01380     it->key\_len = 0;
01381     it->node = NULL;
01382 
01383     \textcolor{comment}{/* Set flags according to the operator used to perform the seek. */}
01384     \textcolor{keywordflow}{if} (op[0] == \textcolor{stringliteral}{'>'}) \{
01385         gt = 1;
01386         \textcolor{keywordflow}{if} (op[1] == \textcolor{stringliteral}{'='}) eq = 1;
01387     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op[0] == \textcolor{stringliteral}{'<'}) \{
01388         lt = 1;
01389         \textcolor{keywordflow}{if} (op[1] == \textcolor{stringliteral}{'='}) eq = 1;
01390     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op[0] == \textcolor{stringliteral}{'='}) \{
01391         eq = 1;
01392     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op[0] == \textcolor{stringliteral}{'^'}) \{
01393         first = 1;
01394     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op[0] == \textcolor{stringliteral}{'$'}) \{
01395         last = 1;
01396     \} \textcolor{keywordflow}{else} \{
01397         errno = 0;
01398         \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* Error. */}
01399     \}
01400 
01401     \textcolor{comment}{/* If there are no elements, set the EOF condition immediately and}
01402 \textcolor{comment}{     * return. */}
01403     \textcolor{keywordflow}{if} (it->rt->numele == 0) \{
01404         it->flags |= \hyperlink{rax_8h_a4fb08a914b84ba0a39daa86297176e1c}{RAX\_ITER\_EOF};
01405         \textcolor{keywordflow}{return} 1;
01406     \}
01407 
01408     \textcolor{keywordflow}{if} (first) \{
01409         \textcolor{comment}{/* Seeking the first key greater or equal to the empty string}
01410 \textcolor{comment}{         * is equivalent to seeking the smaller key available. */}
01411         \textcolor{keywordflow}{return} raxSeek(it,\textcolor{stringliteral}{">="},NULL,0);
01412     \}
01413 
01414     \textcolor{keywordflow}{if} (last) \{
01415         \textcolor{comment}{/* Find the greatest key taking always the last child till a}
01416 \textcolor{comment}{         * final node is found. */}
01417         it->node = it->rt->head;
01418         \textcolor{keywordflow}{if} (!raxSeekGreatest(it)) \textcolor{keywordflow}{return} 0;
01419         \hyperlink{redisassert_8h_a993abaa2c168852c1592879472938781}{assert}(it->node->iskey);
01420         it->data = raxGetData(it->node);
01421         \textcolor{keywordflow}{return} 1;
01422     \}
01423 
01424     \textcolor{comment}{/* We need to seek the specified key. What we do here is to actually}
01425 \textcolor{comment}{     * perform a lookup, and later invoke the prev/next key code that}
01426 \textcolor{comment}{     * we already use for iteration. */}
01427     \textcolor{keywordtype}{int} splitpos = 0;
01428     size\_t i = raxLowWalk(it->rt,ele,len,&it->node,NULL,&splitpos,&it->stack);
01429 
01430     \textcolor{comment}{/* Return OOM on incomplete stack info. */}
01431     \textcolor{keywordflow}{if} (it->stack.oom) \textcolor{keywordflow}{return} 0;
01432 
01433     \textcolor{keywordflow}{if} (eq && i == len && (!it->node->iscompr || splitpos == 0) &&
01434         it->node->iskey)
01435     \{
01436         \textcolor{comment}{/* We found our node, since the key matches and we have an}
01437 \textcolor{comment}{         * "equal" condition. */}
01438         \textcolor{keywordflow}{if} (!raxIteratorAddChars(it,ele,len)) \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* OOM. */}
01439         it->data = raxGetData(it->node);
01440     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (lt || gt) \{
01441         \textcolor{comment}{/* Exact key not found or eq flag not set. We have to set as current}
01442 \textcolor{comment}{         * key the one represented by the node we stopped at, and perform}
01443 \textcolor{comment}{         * a next/prev operation to seek. To reconstruct the key at this node}
01444 \textcolor{comment}{         * we start from the parent and go to the current node, accumulating}
01445 \textcolor{comment}{         * the characters found along the way. */}
01446         \textcolor{keywordflow}{if} (!raxStackPush(&it->stack,it->node)) \textcolor{keywordflow}{return} 0;
01447         \textcolor{keywordflow}{for} (size\_t j = 1; j < it->stack.items; j++) \{
01448             raxNode *parent = it->stack.stack[j-1];
01449             raxNode *child = it->stack.stack[j];
01450             \textcolor{keywordflow}{if} (parent->iscompr) \{
01451                 \textcolor{keywordflow}{if} (!raxIteratorAddChars(it,parent->data,parent->size))
01452                     \textcolor{keywordflow}{return} 0;
01453             \} \textcolor{keywordflow}{else} \{
01454                 raxNode **cp = \hyperlink{rax_8c_aa94163a0d02b30219ef18e5a3ea06ca6}{raxNodeFirstChildPtr}(parent);
01455                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p = parent->data;
01456                 \textcolor{keywordflow}{while}(1) \{
01457                     raxNode *aux;
01458                     memcpy(&aux,cp,\textcolor{keyword}{sizeof}(aux));
01459                     \textcolor{keywordflow}{if} (aux == child) \textcolor{keywordflow}{break};
01460                     cp++;
01461                     p++;
01462                 \}
01463                 \textcolor{keywordflow}{if} (!raxIteratorAddChars(it,p,1)) \textcolor{keywordflow}{return} 0;
01464             \}
01465         \}
01466         raxStackPop(&it->stack);
01467 
01468         \textcolor{comment}{/* We need to set the iterator in the correct state to call next/prev}
01469 \textcolor{comment}{         * step in order to seek the desired element. */}
01470         \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"After initial seek: i=%d len=%d key=%.*s\(\backslash\)n"},
01471             (\textcolor{keywordtype}{int})i, (\textcolor{keywordtype}{int})len, (\textcolor{keywordtype}{int})it->key\_len, it->key);
01472         \textcolor{keywordflow}{if} (i != len && !it->node->iscompr) \{
01473             \textcolor{comment}{/* If we stopped in the middle of a normal node because of a}
01474 \textcolor{comment}{             * mismatch, add the mismatching character to the current key}
01475 \textcolor{comment}{             * and call the iterator with the 'noup' flag so that it will try}
01476 \textcolor{comment}{             * to seek the next/prev child in the current node directly based}
01477 \textcolor{comment}{             * on the mismatching character. */}
01478             \textcolor{keywordflow}{if} (!raxIteratorAddChars(it,ele+i,1)) \textcolor{keywordflow}{return} 0;
01479             \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"Seek normal node on mismatch: %.*s\(\backslash\)n"},
01480                 (\textcolor{keywordtype}{int})it->key\_len, (\textcolor{keywordtype}{char}*)it->key);
01481 
01482             it->flags &= ~\hyperlink{rax_8h_a665a029bbb4c6864ca2153b3ba3b746c}{RAX\_ITER\_JUST\_SEEKED};
01483             \textcolor{keywordflow}{if} (lt && !raxIteratorPrevStep(it,1)) \textcolor{keywordflow}{return} 0;
01484             \textcolor{keywordflow}{if} (gt && !raxIteratorNextStep(it,1)) \textcolor{keywordflow}{return} 0;
01485             it->flags |= \hyperlink{rax_8h_a665a029bbb4c6864ca2153b3ba3b746c}{RAX\_ITER\_JUST\_SEEKED}; \textcolor{comment}{/* Ignore next call. */}
01486         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (i != len && it->node->iscompr) \{
01487             \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"Compressed mismatch: %.*s\(\backslash\)n"},
01488                 (\textcolor{keywordtype}{int})it->key\_len, (\textcolor{keywordtype}{char}*)it->key);
01489             \textcolor{comment}{/* In case of a mismatch within a compressed node. */}
01490             \textcolor{keywordtype}{int} nodechar = it->node->data[splitpos];
01491             \textcolor{keywordtype}{int} keychar = ele[i];
01492             it->flags &= ~\hyperlink{rax_8h_a665a029bbb4c6864ca2153b3ba3b746c}{RAX\_ITER\_JUST\_SEEKED};
01493             \textcolor{keywordflow}{if} (gt) \{
01494                 \textcolor{comment}{/* If the key the compressed node represents is greater}
01495 \textcolor{comment}{                 * than our seek element, continue forward, otherwise set the}
01496 \textcolor{comment}{                 * state in order to go back to the next sub-tree. */}
01497                 \textcolor{keywordflow}{if} (nodechar > keychar) \{
01498                     \textcolor{keywordflow}{if} (!raxIteratorNextStep(it,0)) \textcolor{keywordflow}{return} 0;
01499                 \} \textcolor{keywordflow}{else} \{
01500                     \textcolor{keywordflow}{if} (!raxIteratorAddChars(it,it->node->data,it->node->size))
01501                         \textcolor{keywordflow}{return} 0;
01502                     \textcolor{keywordflow}{if} (!raxIteratorNextStep(it,1)) \textcolor{keywordflow}{return} 0;
01503                 \}
01504             \}
01505             \textcolor{keywordflow}{if} (lt) \{
01506                 \textcolor{comment}{/* If the key the compressed node represents is smaller}
01507 \textcolor{comment}{                 * than our seek element, seek the greater key in this}
01508 \textcolor{comment}{                 * subtree, otherwise set the state in order to go back to}
01509 \textcolor{comment}{                 * the previous sub-tree. */}
01510                 \textcolor{keywordflow}{if} (nodechar < keychar) \{
01511                     \textcolor{keywordflow}{if} (!raxSeekGreatest(it)) \textcolor{keywordflow}{return} 0;
01512                     it->data = raxGetData(it->node);
01513                 \} \textcolor{keywordflow}{else} \{
01514                     \textcolor{keywordflow}{if} (!raxIteratorAddChars(it,it->node->data,it->node->size))
01515                         \textcolor{keywordflow}{return} 0;
01516                     \textcolor{keywordflow}{if} (!raxIteratorPrevStep(it,1)) \textcolor{keywordflow}{return} 0;
01517                 \}
01518             \}
01519             it->flags |= \hyperlink{rax_8h_a665a029bbb4c6864ca2153b3ba3b746c}{RAX\_ITER\_JUST\_SEEKED}; \textcolor{comment}{/* Ignore next call. */}
01520         \} \textcolor{keywordflow}{else} \{
01521             \hyperlink{rax_8c_a10b215c81aa397dbc44adfb3e436befb}{debugf}(\textcolor{stringliteral}{"No mismatch: %.*s\(\backslash\)n"},
01522                 (\textcolor{keywordtype}{int})it->key\_len, (\textcolor{keywordtype}{char}*)it->key);
01523             \textcolor{comment}{/* If there was no mismatch we are into a node representing the}
01524 \textcolor{comment}{             * key, (but which is not a key or the seek operator does not}
01525 \textcolor{comment}{             * include 'eq'), or we stopped in the middle of a compressed node}
01526 \textcolor{comment}{             * after processing all the key. Cotinue iterating as this was}
01527 \textcolor{comment}{             * a legitimate key we stopped at. */}
01528             it->flags &= ~\hyperlink{rax_8h_a665a029bbb4c6864ca2153b3ba3b746c}{RAX\_ITER\_JUST\_SEEKED};
01529             \textcolor{keywordflow}{if} (gt && !raxIteratorNextStep(it,0)) \textcolor{keywordflow}{return} 0;
01530             \textcolor{keywordflow}{if} (lt && !raxIteratorPrevStep(it,0)) \textcolor{keywordflow}{return} 0;
01531             it->flags |= \hyperlink{rax_8h_a665a029bbb4c6864ca2153b3ba3b746c}{RAX\_ITER\_JUST\_SEEKED}; \textcolor{comment}{/* Ignore next call. */}
01532         \}
01533     \} \textcolor{keywordflow}{else} \{
01534         \textcolor{comment}{/* If we are here just eq was set but no match was found. */}
01535         it->flags |= \hyperlink{rax_8h_a4fb08a914b84ba0a39daa86297176e1c}{RAX\_ITER\_EOF};
01536         \textcolor{keywordflow}{return} 1;
01537     \}
01538     \textcolor{keywordflow}{return} 1;
01539 \}
01540 
01541 \textcolor{comment}{/* Go to the next element in the scope of the iterator 'it'.}
01542 \textcolor{comment}{ * If EOF (or out of memory) is reached, 0 is returned, otherwise 1 is}
01543 \textcolor{comment}{ * returned. In case 0 is returned because of OOM, errno is set to ENOMEM. */}
01544 \textcolor{keywordtype}{int} raxNext(\hyperlink{structraxIterator}{raxIterator} *it) \{
01545     \textcolor{keywordflow}{if} (!raxIteratorNextStep(it,0)) \{
01546         errno = ENOMEM;
01547         \textcolor{keywordflow}{return} 0;
01548     \}
01549     \textcolor{keywordflow}{if} (it->flags & \hyperlink{rax_8h_a4fb08a914b84ba0a39daa86297176e1c}{RAX\_ITER\_EOF}) \{
01550         errno = 0;
01551         \textcolor{keywordflow}{return} 0;
01552     \}
01553     \textcolor{keywordflow}{return} 1;
01554 \}
01555 
01556 \textcolor{comment}{/* Go to the previous element in the scope of the iterator 'it'.}
01557 \textcolor{comment}{ * If EOF (or out of memory) is reached, 0 is returned, otherwise 1 is}
01558 \textcolor{comment}{ * returned. In case 0 is returned because of OOM, errno is set to ENOMEM. */}
01559 \textcolor{keywordtype}{int} raxPrev(\hyperlink{structraxIterator}{raxIterator} *it) \{
01560     \textcolor{keywordflow}{if} (!raxIteratorPrevStep(it,0)) \{
01561         errno = ENOMEM;
01562         \textcolor{keywordflow}{return} 0;
01563     \}
01564     \textcolor{keywordflow}{if} (it->flags & \hyperlink{rax_8h_a4fb08a914b84ba0a39daa86297176e1c}{RAX\_ITER\_EOF}) \{
01565         errno = 0;
01566         \textcolor{keywordflow}{return} 0;
01567     \}
01568     \textcolor{keywordflow}{return} 1;
01569 \}
01570 
01571 \textcolor{comment}{/* Perform a random walk starting in the current position of the iterator.}
01572 \textcolor{comment}{ * Return 0 if the tree is empty or on out of memory. Otherwise 1 is returned}
01573 \textcolor{comment}{ * and the iterator is set to the node reached after doing a random walk}
01574 \textcolor{comment}{ * of 'steps' steps. If the 'steps' argument is 0, the random walk is performed}
01575 \textcolor{comment}{ * using a random number of steps between 1 and two times the logarithm of}
01576 \textcolor{comment}{ * the number of elements.}
01577 \textcolor{comment}{ *}
01578 \textcolor{comment}{ * NOTE: if you use this function to generate random elements from the radix}
01579 \textcolor{comment}{ * tree, expect a disappointing distribution. A random walk produces good}
01580 \textcolor{comment}{ * random elements if the tree is not sparse, however in the case of a radix}
01581 \textcolor{comment}{ * tree certain keys will be reported much more often than others. At least}
01582 \textcolor{comment}{ * this function should be able to expore every possible element eventually. */}
01583 \textcolor{keywordtype}{int} raxRandomWalk(\hyperlink{structraxIterator}{raxIterator} *it, size\_t steps) \{
01584     \textcolor{keywordflow}{if} (it->rt->numele == 0) \{
01585         it->flags |= \hyperlink{rax_8h_a4fb08a914b84ba0a39daa86297176e1c}{RAX\_ITER\_EOF};
01586         \textcolor{keywordflow}{return} 0;
01587     \}
01588 
01589     \textcolor{keywordflow}{if} (steps == 0) \{
01590         size\_t fle = floor(log(it->rt->numele));
01591         fle *= 2;
01592         steps = 1 + rand() % fle;
01593     \}
01594 
01595     raxNode *n = it->node;
01596     \textcolor{keywordflow}{while}(steps > 0 || !n->iskey) \{
01597         \textcolor{keywordtype}{int} numchildren = n->iscompr ? 1 : n->size;
01598         \textcolor{keywordtype}{int} r = rand() % (numchildren+(n != it->rt->head));
01599 
01600         \textcolor{keywordflow}{if} (r == numchildren) \{
01601             \textcolor{comment}{/* Go up to parent. */}
01602             n = raxStackPop(&it->stack);
01603             \textcolor{keywordtype}{int} todel = n->iscompr ? n->size : 1;
01604             raxIteratorDelChars(it,todel);
01605         \} \textcolor{keywordflow}{else} \{
01606             \textcolor{comment}{/* Select a random child. */}
01607             \textcolor{keywordflow}{if} (n->iscompr) \{
01608                 \textcolor{keywordflow}{if} (!raxIteratorAddChars(it,n->data,n->size)) \textcolor{keywordflow}{return} 0;
01609             \} \textcolor{keywordflow}{else} \{
01610                 \textcolor{keywordflow}{if} (!raxIteratorAddChars(it,n->data+r,1)) \textcolor{keywordflow}{return} 0;
01611             \}
01612             raxNode **cp = \hyperlink{rax_8c_aa94163a0d02b30219ef18e5a3ea06ca6}{raxNodeFirstChildPtr}(n)+r;
01613             \textcolor{keywordflow}{if} (!raxStackPush(&it->stack,n)) \textcolor{keywordflow}{return} 0;
01614             memcpy(&n,cp,\textcolor{keyword}{sizeof}(n));
01615         \}
01616         \textcolor{keywordflow}{if} (n->iskey) steps--;
01617     \}
01618     it->node = n;
01619     \textcolor{keywordflow}{return} 1;
01620 \}
01621 
01622 \textcolor{comment}{/* Compare the key currently pointed by the iterator to the specified}
01623 \textcolor{comment}{ * key according to the specified operator. Returns 1 if the comparison is}
01624 \textcolor{comment}{ * true, otherwise 0 is returned. */}
01625 \textcolor{keywordtype}{int} raxCompare(\hyperlink{structraxIterator}{raxIterator} *iter, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *op, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *key, size\_t key\_len) \{
01626     \textcolor{keywordtype}{int} eq = 0, lt = 0, gt = 0;
01627 
01628     \textcolor{keywordflow}{if} (op[0] == \textcolor{stringliteral}{'='} || op[1] == \textcolor{stringliteral}{'='}) eq = 1;
01629     \textcolor{keywordflow}{if} (op[1] == \textcolor{stringliteral}{'>'}) gt = 1;
01630     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op[1] == \textcolor{stringliteral}{'<'}) lt = 1;
01631     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (op[1] != \textcolor{stringliteral}{'='}) \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* Syntax error. */}
01632 
01633     size\_t minlen = key\_len < iter->key\_len ? key\_len : iter->key\_len;
01634     \textcolor{keywordtype}{int} cmp = memcmp(iter->key,key,minlen);
01635 
01636     \textcolor{comment}{/* Handle == */}
01637     \textcolor{keywordflow}{if} (lt == 0 && gt == 0) \textcolor{keywordflow}{return} cmp == 0 && key\_len == iter->key\_len;
01638 
01639     \textcolor{comment}{/* Handle >, >=, <, <= */}
01640     \textcolor{keywordflow}{if} (cmp == 0) \{
01641         \textcolor{comment}{/* Same prefix: longer wins. */}
01642         \textcolor{keywordflow}{if} (eq && key\_len == iter->key\_len) \textcolor{keywordflow}{return} 1;
01643         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (lt) \textcolor{keywordflow}{return} iter->key\_len < key\_len;
01644         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (gt) \textcolor{keywordflow}{return} iter->key\_len > key\_len;
01645     \} \textcolor{keywordflow}{if} (cmp > 0) \{
01646         \textcolor{keywordflow}{return} gt ? 1 : 0;
01647     \} \textcolor{keywordflow}{else} \textcolor{comment}{/* (cmp < 0) */} \{
01648         \textcolor{keywordflow}{return} lt ? 1 : 0;
01649     \}
01650 \}
01651 
01652 \textcolor{comment}{/* Free the iterator. */}
01653 \textcolor{keywordtype}{void} raxStop(\hyperlink{structraxIterator}{raxIterator} *it) \{
01654     \textcolor{keywordflow}{if} (it->key != it->key\_static\_string) \hyperlink{rax__malloc_8h_a3adfa16bca6cd23b6e125fd441465e49}{rax\_free}(it->key);
01655     raxStackFree(&it->stack);
01656 \}
01657 
01658 \textcolor{comment}{/* Return if the iterator is in an EOF state. This happens when raxSeek()}
01659 \textcolor{comment}{ * failed to seek an appropriate element, so that raxNext() or raxPrev()}
01660 \textcolor{comment}{ * will return zero, or when an EOF condition was reached while iterating}
01661 \textcolor{comment}{ * with raxNext() and raxPrev(). */}
01662 \textcolor{keywordtype}{int} raxEOF(\hyperlink{structraxIterator}{raxIterator} *it) \{
01663     \textcolor{keywordflow}{return} it->flags & \hyperlink{rax_8h_a4fb08a914b84ba0a39daa86297176e1c}{RAX\_ITER\_EOF};
01664 \}
01665 
01666 \textcolor{comment}{/* Return the number of elements inside the radix tree. */}
01667 uint64\_t raxSize(rax *rax) \{
01668     \textcolor{keywordflow}{return} rax->numele;
01669 \}
01670 
01671 \textcolor{comment}{/* ----------------------------- Introspection ------------------------------ */}
01672 
01673 \textcolor{comment}{/* This function is mostly used for debugging and learning purposes.}
01674 \textcolor{comment}{ * It shows an ASCII representation of a tree on standard output, outling}
01675 \textcolor{comment}{ * all the nodes and the contained keys.}
01676 \textcolor{comment}{ *}
01677 \textcolor{comment}{ * The representation is as follow:}
01678 \textcolor{comment}{ *}
01679 \textcolor{comment}{ *  "foobar" (compressed node)}
01680 \textcolor{comment}{ *  [abc] (normal node with three children)}
01681 \textcolor{comment}{ *  [abc]=0x12345678 (node is a key, pointing to value 0x12345678)}
01682 \textcolor{comment}{ *  [] (a normal empty node)}
01683 \textcolor{comment}{ *}
01684 \textcolor{comment}{ *  Children are represented in new idented lines, each children prefixed by}
01685 \textcolor{comment}{ *  the "`-(x)" string, where "x" is the edge byte.}
01686 \textcolor{comment}{ *}
01687 \textcolor{comment}{ *  [abc]}
01688 \textcolor{comment}{ *   `-(a) "ladin"}
01689 \textcolor{comment}{ *   `-(b) [kj]}
01690 \textcolor{comment}{ *   `-(c) []}
01691 \textcolor{comment}{ *}
01692 \textcolor{comment}{ *  However when a node has a single child the following representation}
01693 \textcolor{comment}{ *  is used instead:}
01694 \textcolor{comment}{ *}
01695 \textcolor{comment}{ *  [abc] -> "ladin" -> []}
01696 \textcolor{comment}{ */}
01697 
01698 \textcolor{comment}{/* The actual implementation of raxShow(). */}
01699 \textcolor{keywordtype}{void} raxRecursiveShow(\textcolor{keywordtype}{int} level, \textcolor{keywordtype}{int} lpad, raxNode *n) \{
01700     \textcolor{keywordtype}{char} s = n->iscompr ? \textcolor{stringliteral}{'"'} : \textcolor{stringliteral}{'['};
01701     \textcolor{keywordtype}{char} e = n->iscompr ? \textcolor{stringliteral}{'"'} : \textcolor{stringliteral}{']'};
01702 
01703     \textcolor{keywordtype}{int} numchars = printf(\textcolor{stringliteral}{"%c%.*s%c"}, s, n->size, n->data, e);
01704     \textcolor{keywordflow}{if} (n->iskey) \{
01705         numchars += printf(\textcolor{stringliteral}{"=%p"},raxGetData(n));
01706     \}
01707 
01708     \textcolor{keywordtype}{int} numchildren = n->iscompr ? 1 : n->size;
01709     \textcolor{comment}{/* Note that 7 and 4 magic constants are the string length}
01710 \textcolor{comment}{     * of " `-(x) " and " -> " respectively. */}
01711     \textcolor{keywordflow}{if} (level) \{
01712         lpad += (numchildren > 1) ? 7 : 4;
01713         \textcolor{keywordflow}{if} (numchildren == 1) lpad += numchars;
01714     \}
01715     raxNode **cp = \hyperlink{rax_8c_aa94163a0d02b30219ef18e5a3ea06ca6}{raxNodeFirstChildPtr}(n);
01716     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < numchildren; i++) \{
01717         \textcolor{keywordtype}{char} *branch = \textcolor{stringliteral}{" `-(%c) "};
01718         \textcolor{keywordflow}{if} (numchildren > 1) \{
01719             printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01720             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < lpad; j++) putchar(\textcolor{stringliteral}{' '});
01721             printf(branch,n->data[i]);
01722         \} \textcolor{keywordflow}{else} \{
01723             printf(\textcolor{stringliteral}{" -> "});
01724         \}
01725         raxNode *child;
01726         memcpy(&child,cp,\textcolor{keyword}{sizeof}(child));
01727         raxRecursiveShow(level+1,lpad,child);
01728         cp++;
01729     \}
01730 \}
01731 
01732 \textcolor{comment}{/* Show a tree, as outlined in the comment above. */}
01733 \textcolor{keywordtype}{void} raxShow(rax *rax) \{
01734     raxRecursiveShow(0,0,rax->head);
01735     putchar(\textcolor{stringliteral}{'\(\backslash\)n'});
01736 \}
01737 
01738 \textcolor{comment}{/* Used by debugnode() macro to show info about a given node. */}
01739 \textcolor{keywordtype}{void} raxDebugShowNode(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *msg, raxNode *n) \{
01740     printf(\textcolor{stringliteral}{"%s: %p [%.*s] key:%d size:%d children:"},
01741         msg, (\textcolor{keywordtype}{void}*)n, (\textcolor{keywordtype}{int})n->size, (\textcolor{keywordtype}{char}*)n->data, n->iskey, n->size);
01742     \textcolor{keywordtype}{int} numcld = n->iscompr ? 1 : n->size;
01743     raxNode **cldptr = \hyperlink{rax_8c_a2c5310b0d00672508a8f935a7109f4ce}{raxNodeLastChildPtr}(n) - (numcld-1);
01744     \textcolor{keywordflow}{while}(numcld--) \{
01745         raxNode *child;
01746         memcpy(&child,cldptr,\textcolor{keyword}{sizeof}(child));
01747         cldptr++;
01748         printf(\textcolor{stringliteral}{"%p "}, (\textcolor{keywordtype}{void}*)child);
01749     \}
01750     printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01751     fflush(stdout);
01752 \}
\end{DoxyCode}
