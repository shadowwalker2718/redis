\hypertarget{ziplist_8c_source}{}\section{ziplist.\+c}
\label{ziplist_8c_source}\index{src/ziplist.\+c@{src/ziplist.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* The ziplist is a specially encoded dually linked list that is designed}
00002 \textcolor{comment}{ * to be very memory efficient. It stores both strings and integer values,}
00003 \textcolor{comment}{ * where integers are encoded as actual integers instead of a series of}
00004 \textcolor{comment}{ * characters. It allows push and pop operations on either side of the list}
00005 \textcolor{comment}{ * in O(1) time. However, because every operation requires a reallocation of}
00006 \textcolor{comment}{ * the memory used by the ziplist, the actual complexity is related to the}
00007 \textcolor{comment}{ * amount of memory used by the ziplist.}
00008 \textcolor{comment}{ *}
00009 \textcolor{comment}{ * ----------------------------------------------------------------------------}
00010 \textcolor{comment}{ *}
00011 \textcolor{comment}{ * ZIPLIST OVERALL LAYOUT}
00012 \textcolor{comment}{ * ======================}
00013 \textcolor{comment}{ *}
00014 \textcolor{comment}{ * The general layout of the ziplist is as follows:}
00015 \textcolor{comment}{ *}
00016 \textcolor{comment}{ * <zlbytes> <zltail> <zllen> <entry> <entry> ... <entry> <zlend>}
00017 \textcolor{comment}{ *}
00018 \textcolor{comment}{ * NOTE: all fields are stored in little endian, if not specified otherwise.}
00019 \textcolor{comment}{ *}
00020 \textcolor{comment}{ * <uint32\_t zlbytes> is an unsigned integer to hold the number of bytes that}
00021 \textcolor{comment}{ * the ziplist occupies, including the four bytes of the zlbytes field itself.}
00022 \textcolor{comment}{ * This value needs to be stored to be able to resize the entire structure}
00023 \textcolor{comment}{ * without the need to traverse it first.}
00024 \textcolor{comment}{ *}
00025 \textcolor{comment}{ * <uint32\_t zltail> is the offset to the last entry in the list. This allows}
00026 \textcolor{comment}{ * a pop operation on the far side of the list without the need for full}
00027 \textcolor{comment}{ * traversal.}
00028 \textcolor{comment}{ *}
00029 \textcolor{comment}{ * <uint16\_t zllen> is the number of entries. When there are more than}
00030 \textcolor{comment}{ * 2^16-2 entires, this value is set to 2^16-1 and we need to traverse the}
00031 \textcolor{comment}{ * entire list to know how many items it holds.}
00032 \textcolor{comment}{ *}
00033 \textcolor{comment}{ * <uint8\_t zlend> is a special entry representing the end of the ziplist.}
00034 \textcolor{comment}{ * Is encoded as a single byte equal to 255. No other normal entry starts}
00035 \textcolor{comment}{ * with a byte set to the value of 255.}
00036 \textcolor{comment}{ *}
00037 \textcolor{comment}{ * ZIPLIST ENTRIES}
00038 \textcolor{comment}{ * ===============}
00039 \textcolor{comment}{ *}
00040 \textcolor{comment}{ * Every entry in the ziplist is prefixed by metadata that contains two pieces}
00041 \textcolor{comment}{ * of information. First, the length of the previous entry is stored to be}
00042 \textcolor{comment}{ * able to traverse the list from back to front. Second, the entry encoding is}
00043 \textcolor{comment}{ * provided. It represents the entry type, integer or string, and in the case}
00044 \textcolor{comment}{ * of strings it also represents the length of the string payload.}
00045 \textcolor{comment}{ * So a complete entry is stored like this:}
00046 \textcolor{comment}{ *}
00047 \textcolor{comment}{ * <prevlen> <encoding> <entry-data>}
00048 \textcolor{comment}{ *}
00049 \textcolor{comment}{ * Sometimes the encoding represents the entry itself, like for small integers}
00050 \textcolor{comment}{ * as we'll see later. In such a case the <entry-data> part is missing, and we}
00051 \textcolor{comment}{ * could have just:}
00052 \textcolor{comment}{ *}
00053 \textcolor{comment}{ * <prevlen> <encoding>}
00054 \textcolor{comment}{ *}
00055 \textcolor{comment}{ * The length of the previous entry, <prevlen>, is encoded in the following way:}
00056 \textcolor{comment}{ * If this length is smaller than 255 bytes, it will only consume a single}
00057 \textcolor{comment}{ * byte representing the length as an unsinged 8 bit integer. When the length}
00058 \textcolor{comment}{ * is greater than or equal to 255, it will consume 5 bytes. The first byte is}
00059 \textcolor{comment}{ * set to 255 (FF) to indicate a larger value is following. The remaining 4}
00060 \textcolor{comment}{ * bytes take the length of the previous entry as value.}
00061 \textcolor{comment}{ *}
00062 \textcolor{comment}{ * So practically an entry is encoded in the following way:}
00063 \textcolor{comment}{ *}
00064 \textcolor{comment}{ * <prevlen from 0 to 254> <encoding> <entry>}
00065 \textcolor{comment}{ *}
00066 \textcolor{comment}{ * Or alternatively if the previous entry length is greater than 254 bytes}
00067 \textcolor{comment}{ * the following encoding is used:}
00068 \textcolor{comment}{ *}
00069 \textcolor{comment}{ * 0xFF <4 bytes unsigned little endian prevlen> <encoding> <entry>}
00070 \textcolor{comment}{ *}
00071 \textcolor{comment}{ * The encoding field of the entry depends on the content of the}
00072 \textcolor{comment}{ * entry. When the entry is a string, the first 2 bits of the encoding first}
00073 \textcolor{comment}{ * byte will hold the type of encoding used to store the length of the string,}
00074 \textcolor{comment}{ * followed by the actual length of the string. When the entry is an integer}
00075 \textcolor{comment}{ * the first 2 bits are both set to 1. The following 2 bits are used to specify}
00076 \textcolor{comment}{ * what kind of integer will be stored after this header. An overview of the}
00077 \textcolor{comment}{ * different types and encodings is as follows. The first byte is always enough}
00078 \textcolor{comment}{ * to determine the kind of entry.}
00079 \textcolor{comment}{ *}
00080 \textcolor{comment}{ * |00pppppp| - 1 byte}
00081 \textcolor{comment}{ *      String value with length less than or equal to 63 bytes (6 bits).}
00082 \textcolor{comment}{ *      "pppppp" represents the unsigned 6 bit length.}
00083 \textcolor{comment}{ * |01pppppp|qqqqqqqq| - 2 bytes}
00084 \textcolor{comment}{ *      String value with length less than or equal to 16383 bytes (14 bits).}
00085 \textcolor{comment}{ *      IMPORTANT: The 14 bit number is stored in big endian.}
00086 \textcolor{comment}{ * |10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes}
00087 \textcolor{comment}{ *      String value with length greater than or equal to 16384 bytes.}
00088 \textcolor{comment}{ *      Only the 4 bytes following the first byte represents the length}
00089 \textcolor{comment}{ *      up to 32^2-1. The 6 lower bits of the first byte are not used and}
00090 \textcolor{comment}{ *      are set to zero.}
00091 \textcolor{comment}{ *      IMPORTANT: The 32 bit number is stored in big endian.}
00092 \textcolor{comment}{ * |11000000| - 3 bytes}
00093 \textcolor{comment}{ *      Integer encoded as int16\_t (2 bytes).}
00094 \textcolor{comment}{ * |11010000| - 5 bytes}
00095 \textcolor{comment}{ *      Integer encoded as int32\_t (4 bytes).}
00096 \textcolor{comment}{ * |11100000| - 9 bytes}
00097 \textcolor{comment}{ *      Integer encoded as int64\_t (8 bytes).}
00098 \textcolor{comment}{ * |11110000| - 4 bytes}
00099 \textcolor{comment}{ *      Integer encoded as 24 bit signed (3 bytes).}
00100 \textcolor{comment}{ * |11111110| - 2 bytes}
00101 \textcolor{comment}{ *      Integer encoded as 8 bit signed (1 byte).}
00102 \textcolor{comment}{ * |1111xxxx| - (with xxxx between 0000 and 1101) immediate 4 bit integer.}
00103 \textcolor{comment}{ *      Unsigned integer from 0 to 12. The encoded value is actually from}
00104 \textcolor{comment}{ *      1 to 13 because 0000 and 1111 can not be used, so 1 should be}
00105 \textcolor{comment}{ *      subtracted from the encoded 4 bit value to obtain the right value.}
00106 \textcolor{comment}{ * |11111111| - End of ziplist special entry.}
00107 \textcolor{comment}{ *}
00108 \textcolor{comment}{ * Like for the ziplist header, all the integers are represented in little}
00109 \textcolor{comment}{ * endian byte order, even when this code is compiled in big endian systems.}
00110 \textcolor{comment}{ *}
00111 \textcolor{comment}{ * EXAMPLES OF ACTUAL ZIPLISTS}
00112 \textcolor{comment}{ * ===========================}
00113 \textcolor{comment}{ *}
00114 \textcolor{comment}{ * The following is a ziplist containing the two elements representing}
00115 \textcolor{comment}{ * the strings "2" and "5". It is composed of 15 bytes, that we visually}
00116 \textcolor{comment}{ * split into sections:}
00117 \textcolor{comment}{ *}
00118 \textcolor{comment}{ *  [0f 00 00 00] [0c 00 00 00] [02 00] [00 f3] [02 f6] [ff]}
00119 \textcolor{comment}{ *        |             |          |       |       |     |}
00120 \textcolor{comment}{ *     zlbytes        zltail    entries   "2"     "5"   end}
00121 \textcolor{comment}{ *}
00122 \textcolor{comment}{ * The first 4 bytes represent the number 15, that is the number of bytes}
00123 \textcolor{comment}{ * the whole ziplist is composed of. The second 4 bytes are the offset}
00124 \textcolor{comment}{ * at which the last ziplist entry is found, that is 12, in fact the}
00125 \textcolor{comment}{ * last entry, that is "5", is at offset 12 inside the ziplist.}
00126 \textcolor{comment}{ * The next 16 bit integer represents the number of elements inside the}
00127 \textcolor{comment}{ * ziplist, its value is 2 since there are just two elements inside.}
00128 \textcolor{comment}{ * Finally "00 f3" is the first entry representing the number 2. It is}
00129 \textcolor{comment}{ * composed of the previous entry length, which is zero because this is}
00130 \textcolor{comment}{ * our first entry, and the byte F3 which corresponds to the encoding}
00131 \textcolor{comment}{ * |1111xxxx| with xxxx between 0001 and 1101. We need to remove the "F"}
00132 \textcolor{comment}{ * higher order bits 1111, and subtract 1 from the "3", so the entry value}
00133 \textcolor{comment}{ * is "2". The next entry has a prevlen of 02, since the first entry is}
00134 \textcolor{comment}{ * composed of exactly two bytes. The entry itself, F6, is encoded exactly}
00135 \textcolor{comment}{ * like the first entry, and 6-1 = 5, so the value of the entry is 5.}
00136 \textcolor{comment}{ * Finally the special entry FF signals the end of the ziplist.}
00137 \textcolor{comment}{ *}
00138 \textcolor{comment}{ * Adding another element to the above string with the value "Hello World"}
00139 \textcolor{comment}{ * allows us to show how the ziplist encodes small strings. We'll just show}
00140 \textcolor{comment}{ * the hex dump of the entry itself. Imagine the bytes as following the}
00141 \textcolor{comment}{ * entry that stores "5" in the ziplist above:}
00142 \textcolor{comment}{ *}
00143 \textcolor{comment}{ * [02] [0b] [48 65 6c 6c 6f 20 57 6f 72 6c 64]}
00144 \textcolor{comment}{ *}
00145 \textcolor{comment}{ * The first byte, 02, is the length of the previous entry. The next}
00146 \textcolor{comment}{ * byte represents the encoding in the pattern |00pppppp| that means}
00147 \textcolor{comment}{ * that the entry is a string of length <pppppp>, so 0B means that}
00148 \textcolor{comment}{ * an 11 bytes string follows. From the third byte (48) to the last (64)}
00149 \textcolor{comment}{ * there are just the ASCII characters for "Hello World".}
00150 \textcolor{comment}{ *}
00151 \textcolor{comment}{ * ----------------------------------------------------------------------------}
00152 \textcolor{comment}{ *}
00153 \textcolor{comment}{ * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>}
00154 \textcolor{comment}{ * Copyright (c) 2009-2017, Salvatore Sanfilippo <antirez at gmail dot com>}
00155 \textcolor{comment}{ * All rights reserved.}
00156 \textcolor{comment}{ *}
00157 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00158 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00159 \textcolor{comment}{ *}
00160 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00161 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00162 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00163 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00164 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00165 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00166 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00167 \textcolor{comment}{ *     specific prior written permission.}
00168 \textcolor{comment}{ *}
00169 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00170 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00171 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00172 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00173 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00174 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00175 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00176 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00177 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00178 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00179 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00180 \textcolor{comment}{ */}
00181 
00182 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdio}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00183 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdlib}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00184 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{string}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00185 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdint}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00186 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{limits}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00187 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{zmalloc_8h}{"zmalloc.h"}
00188 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{util_8h}{"util.h"}
00189 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{ziplist_8h}{"ziplist.h"}
00190 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{endianconv_8h}{"endianconv.h"}
00191 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{redisassert_8h}{"redisassert.h"}
00192 
00193 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_END} 255         \textcolor{comment}{/* Special "end of ziplist" entry. */}
00194 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_BIG\_PREVLEN} 254 \textcolor{comment}{/* Max number of bytes of the previous entry, for}
00195 \textcolor{comment}{                               the "prevlen" field prefixing each entry, to be}
00196 \textcolor{comment}{                               represented with just a single byte. Otherwise}
00197 \textcolor{comment}{                               it is represented as FF AA BB CC DD, where}
00198 \textcolor{comment}{                               AA BB CC DD are a 4 bytes unsigned integer}
00199 \textcolor{comment}{                               representing the previous entry len. */}
00200 
00201 \textcolor{comment}{/* Different encoding/length possibilities */}
00202 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_STR\_MASK} 0xc0
00203 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_INT\_MASK} 0x30
00204 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_STR\_06B} \textcolor{preprocessor}{(}0 \textcolor{preprocessor}{<<} 6\textcolor{preprocessor}{)}
00205 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_STR\_14B} \textcolor{preprocessor}{(}1 \textcolor{preprocessor}{<<} 6\textcolor{preprocessor}{)}
00206 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_STR\_32B} \textcolor{preprocessor}{(}2 \textcolor{preprocessor}{<<} 6\textcolor{preprocessor}{)}
00207 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_INT\_16B} \textcolor{preprocessor}{(}0xc0 \textcolor{preprocessor}{|} 0\textcolor{preprocessor}{<<}4\textcolor{preprocessor}{)}
00208 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_INT\_32B} \textcolor{preprocessor}{(}0xc0 \textcolor{preprocessor}{|} 1\textcolor{preprocessor}{<<}4\textcolor{preprocessor}{)}
00209 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_INT\_64B} \textcolor{preprocessor}{(}0xc0 \textcolor{preprocessor}{|} 2\textcolor{preprocessor}{<<}4\textcolor{preprocessor}{)}
00210 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_INT\_24B} \textcolor{preprocessor}{(}0xc0 \textcolor{preprocessor}{|} 3\textcolor{preprocessor}{<<}4\textcolor{preprocessor}{)}
00211 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_INT\_8B} 0xfe
00212 
00213 \textcolor{comment}{/* 4 bit integer immediate encoding |1111xxxx| with xxxx between}
00214 \textcolor{comment}{ * 0001 and 1101. */}
00215 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_INT\_IMM\_MASK} 0x0f   \textcolor{comment}{/* Mask to extract the 4 bits value. To add}
00216 \textcolor{comment}{                                   one is needed to reconstruct the value. */}
00217 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_INT\_IMM\_MIN} 0xf1    \textcolor{comment}{/* 11110001 */}
00218 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_INT\_IMM\_MAX} 0xfd    \textcolor{comment}{/* 11111101 */}
00219 
00220 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{INT24\_MAX} 0x7fffff
00221 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{INT24\_MIN} \textcolor{preprocessor}{(}\textcolor{preprocessor}{-}\hyperlink{ziplist_8c_a4ade7f65b05984f1f21a8223e70c9fac}{INT24\_MAX} \textcolor{preprocessor}{-} 1\textcolor{preprocessor}{)}
00222 
00223 \textcolor{comment}{/* Macro to determine if the entry is a string. String entries never start}
00224 \textcolor{comment}{ * with "11" as most significant bits of the first byte. */}
00225 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_IS\_STR}\textcolor{preprocessor}{(}\textcolor{preprocessor}{enc}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{enc}\textcolor{preprocessor}{)} \textcolor{preprocessor}{&} \hyperlink{ziplist_8c_a8e8a0c4c5531ab6885734f42c1fb4398}{ZIP\_STR\_MASK}\textcolor{preprocessor}{)} \textcolor{preprocessor}{<} \hyperlink{ziplist_8c_a8e8a0c4c5531ab6885734f42c1fb4398}{ZIP\_STR\_MASK}\textcolor{preprocessor}{)}
00226 
00227 \textcolor{comment}{/* Utility macros.*/}
00228 
00229 \textcolor{comment}{/* Return total bytes a ziplist is composed of. */}
00230 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIPLIST\_BYTES}\textcolor{preprocessor}{(}\textcolor{preprocessor}{zl}\textcolor{preprocessor}{)}       \textcolor{preprocessor}{(}\textcolor{preprocessor}{*}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint32\_t}\textcolor{preprocessor}{*}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{preprocessor}{zl}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00231 
00232 \textcolor{comment}{/* Return the offset of the last item inside the ziplist. */}
00233 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIPLIST\_TAIL\_OFFSET}\textcolor{preprocessor}{(}\textcolor{preprocessor}{zl}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{*}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint32\_t}\textcolor{preprocessor}{*}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{zl}\textcolor{preprocessor}{)}\textcolor{preprocessor}{+}\textcolor{keyword}{sizeof}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint32\_t}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00234 
00235 \textcolor{comment}{/* Return the length of a ziplist, or UINT16\_MAX if the length cannot be}
00236 \textcolor{comment}{ * determined without scanning the whole ziplist. */}
00237 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIPLIST\_LENGTH}\textcolor{preprocessor}{(}\textcolor{preprocessor}{zl}\textcolor{preprocessor}{)}      \textcolor{preprocessor}{(}\textcolor{preprocessor}{*}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint16\_t}\textcolor{preprocessor}{*}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{zl}\textcolor{preprocessor}{)}\textcolor{preprocessor}{+}\textcolor{keyword}{sizeof}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint32\_t}\textcolor{preprocessor}{)}\textcolor{preprocessor}{*}2\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00238 
00239 \textcolor{comment}{/* The size of a ziplist header: two 32 bit integers for the total}
00240 \textcolor{comment}{ * bytes count and last item offset. One 16 bit integer for the number}
00241 \textcolor{comment}{ * of items field. */}
00242 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIPLIST\_HEADER\_SIZE}     \textcolor{preprocessor}{(}\textcolor{keyword}{sizeof}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint32\_t}\textcolor{preprocessor}{)}\textcolor{preprocessor}{*}2\textcolor{preprocessor}{+}\textcolor{keyword}{sizeof}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint16\_t}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00243 
00244 \textcolor{comment}{/* Size of the "end of ziplist" entry. Just one byte. */}
00245 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIPLIST\_END\_SIZE}        \textcolor{preprocessor}{(}\textcolor{keyword}{sizeof}\textcolor{preprocessor}{(}\textcolor{preprocessor}{uint8\_t}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00246 
00247 \textcolor{comment}{/* Return the pointer to the first entry of a ziplist. */}
00248 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIPLIST\_ENTRY\_HEAD}\textcolor{preprocessor}{(}\textcolor{preprocessor}{zl}\textcolor{preprocessor}{)}  \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{zl}\textcolor{preprocessor}{)}\textcolor{preprocessor}{+}\hyperlink{ziplist_8c_a3b8ef40d77ce00bcad424d0c07e2de95}{ZIPLIST\_HEADER\_SIZE}\textcolor{preprocessor}{)}
00249 
00250 \textcolor{comment}{/* Return the pointer to the last entry of a ziplist, using the}
00251 \textcolor{comment}{ * last entry offset inside the ziplist header. */}
00252 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIPLIST\_ENTRY\_TAIL}\textcolor{preprocessor}{(}\textcolor{preprocessor}{zl}\textcolor{preprocessor}{)}  \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{zl}\textcolor{preprocessor}{)}\textcolor{preprocessor}{+}\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}\textcolor{preprocessor}{(}
      \hyperlink{ziplist_8c_adf2235d74c81861c85fb5d2ffa209397}{ZIPLIST\_TAIL\_OFFSET}\textcolor{preprocessor}{(}\textcolor{preprocessor}{zl}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}
00253 
00254 \textcolor{comment}{/* Return the pointer to the last byte of a ziplist, which is, the}
00255 \textcolor{comment}{ * end of ziplist FF entry. */}
00256 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIPLIST\_ENTRY\_END}\textcolor{preprocessor}{(}\textcolor{preprocessor}{zl}\textcolor{preprocessor}{)}   \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{zl}\textcolor{preprocessor}{)}\textcolor{preprocessor}{+}\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}\textcolor{preprocessor}{(}
      \hyperlink{ziplist_8c_a28b9c7884758bc2d52f204903a4bb642}{ZIPLIST\_BYTES}\textcolor{preprocessor}{(}\textcolor{preprocessor}{zl}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}\textcolor{preprocessor}{-}1\textcolor{preprocessor}{)}
00257 
00258 \textcolor{comment}{/* Increment the number of items field in the ziplist header. Note that this}
00259 \textcolor{comment}{ * macro should never overflow the unsigned 16 bit integer, since entires are}
00260 \textcolor{comment}{ * always pushed one at a time. When UINT16\_MAX is reached we want the count}
00261 \textcolor{comment}{ * to stay there to signal that a full scan is needed to get the number of}
00262 \textcolor{comment}{ * items inside the ziplist. */}
00263 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIPLIST\_INCR\_LENGTH}\textcolor{preprocessor}{(}\textcolor{preprocessor}{zl}\textcolor{preprocessor}{,}\textcolor{preprocessor}{incr}\textcolor{preprocessor}{)} \textcolor{preprocessor}{\{}
00264     \textcolor{keywordflow}{if} \textcolor{preprocessor}{(}\hyperlink{ziplist_8c_a6d779e84aca736e354768fcf87393b98}{ZIPLIST\_LENGTH}\textcolor{preprocessor}{(}\textcolor{preprocessor}{zl}\textcolor{preprocessor}{)} \textcolor{preprocessor}{<} UINT16\_MAX\textcolor{preprocessor}{)}
00265         \hyperlink{ziplist_8c_a6d779e84aca736e354768fcf87393b98}{ZIPLIST\_LENGTH}\textcolor{preprocessor}{(}\textcolor{preprocessor}{zl}\textcolor{preprocessor}{)} \textcolor{preprocessor}{=} \hyperlink{endianconv_8h_a47540b5867d4cb1e322e83eaf2b50b56}{intrev16ifbe}\textcolor{preprocessor}{(}
      \hyperlink{endianconv_8h_a47540b5867d4cb1e322e83eaf2b50b56}{intrev16ifbe}\textcolor{preprocessor}{(}\hyperlink{ziplist_8c_a6d779e84aca736e354768fcf87393b98}{ZIPLIST\_LENGTH}\textcolor{preprocessor}{(}\textcolor{preprocessor}{zl}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}\textcolor{preprocessor}{+}\textcolor{preprocessor}{incr}\textcolor{preprocessor}{)}\textcolor{preprocessor}{;} \textcolor{preprocessor}{\(\backslash\)}
00266 \textcolor{preprocessor}{\}}
00267 
00268 \textcolor{comment}{/* We use this function to receive information about a ziplist entry.}
00269 \textcolor{comment}{ * Note that this is not how the data is actually encoded, is just what we}
00270 \textcolor{comment}{ * get filled by a function in order to operate more easily. */}
\Hypertarget{ziplist_8c_source_l00271}\hyperlink{structzlentry}{00271} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structzlentry}{zlentry} \{
00272     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} prevrawlensize; \textcolor{comment}{/* Bytes used to encode the previos entry len*/}
00273     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} prevrawlen;     \textcolor{comment}{/* Previous entry len. */}
00274     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} lensize;        \textcolor{comment}{/* Bytes used to encode this entry type/len.}
00275 \textcolor{comment}{                                    For example strings have a 1, 2 or 5 bytes}
00276 \textcolor{comment}{                                    header. Integers always use a single byte.*/}
00277     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len;            \textcolor{comment}{/* Bytes used to represent the actual entry.}
00278 \textcolor{comment}{                                    For strings this is just the string length}
00279 \textcolor{comment}{                                    while for integers it is 1, 2, 3, 4, 8 or}
00280 \textcolor{comment}{                                    0 (for 4 bit immediate) depending on the}
00281 \textcolor{comment}{                                    number range. */}
00282     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} headersize;     \textcolor{comment}{/* prevrawlensize + lensize. */}
00283     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} encoding;      \textcolor{comment}{/* Set to ZIP\_STR\_* or ZIP\_INT\_* depending on}
00284 \textcolor{comment}{                                    the entry encoding. However for 4 bits}
00285 \textcolor{comment}{                                    immediate integers this can assume a range}
00286 \textcolor{comment}{                                    of values and must be range-checked. */}
00287     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p;            \textcolor{comment}{/* Pointer to the very start of the entry, that}
00288 \textcolor{comment}{                                    is, this points to prev-entry-len field. */}
00289 \} zlentry;
00290 
00291 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIPLIST\_ENTRY\_ZERO}\textcolor{preprocessor}{(}\textcolor{preprocessor}{zle}\textcolor{preprocessor}{)} \textcolor{preprocessor}{\{}
00292     \textcolor{preprocessor}{(}\textcolor{preprocessor}{zle}\textcolor{preprocessor}{)}\textcolor{preprocessor}{->}\textcolor{preprocessor}{prevrawlensize} \textcolor{preprocessor}{=} \textcolor{preprocessor}{(}\textcolor{preprocessor}{zle}\textcolor{preprocessor}{)}\textcolor{preprocessor}{->}\textcolor{preprocessor}{prevrawlen} \textcolor{preprocessor}{=} 0\textcolor{preprocessor}{;}
00293     \textcolor{preprocessor}{(}\textcolor{preprocessor}{zle}\textcolor{preprocessor}{)}\textcolor{preprocessor}{->}\textcolor{preprocessor}{lensize} \textcolor{preprocessor}{=} \textcolor{preprocessor}{(}\textcolor{preprocessor}{zle}\textcolor{preprocessor}{)}\textcolor{preprocessor}{->}\textcolor{preprocessor}{len} \textcolor{preprocessor}{=} \textcolor{preprocessor}{(}\textcolor{preprocessor}{zle}\textcolor{preprocessor}{)}\textcolor{preprocessor}{->}\textcolor{preprocessor}{headersize} \textcolor{preprocessor}{=} 0\textcolor{preprocessor}{;}
00294     \textcolor{preprocessor}{(}\textcolor{preprocessor}{zle}\textcolor{preprocessor}{)}\textcolor{preprocessor}{->}\textcolor{preprocessor}{encoding} \textcolor{preprocessor}{=} 0\textcolor{preprocessor}{;}
00295     \textcolor{preprocessor}{(}\textcolor{preprocessor}{zle}\textcolor{preprocessor}{)}\textcolor{preprocessor}{->}\textcolor{preprocessor}{p} \textcolor{preprocessor}{=} NULL\textcolor{preprocessor}{;} \textcolor{preprocessor}{\(\backslash\)}
00296 \textcolor{preprocessor}{\}}
00297 
00298 \textcolor{comment}{/* Extract the encoding from the byte pointed by 'ptr' and set it into}
00299 \textcolor{comment}{ * 'encoding' field of the zlentry structure. */}
00300 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_ENTRY\_ENCODING}\textcolor{preprocessor}{(}\textcolor{preprocessor}{ptr}\textcolor{preprocessor}{,} \textcolor{preprocessor}{encoding}\textcolor{preprocessor}{)} \textcolor{keywordflow}{do} \textcolor{preprocessor}{\{}
00301     \textcolor{preprocessor}{(}\textcolor{preprocessor}{encoding}\textcolor{preprocessor}{)} \textcolor{preprocessor}{=} \textcolor{preprocessor}{(}\textcolor{preprocessor}{ptr}\textcolor{preprocessor}{[}0\textcolor{preprocessor}{]}\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
00302     \textcolor{keywordflow}{if} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{encoding}\textcolor{preprocessor}{)} \textcolor{preprocessor}{<} \hyperlink{ziplist_8c_a8e8a0c4c5531ab6885734f42c1fb4398}{ZIP\_STR\_MASK}\textcolor{preprocessor}{)} \textcolor{preprocessor}{(}\textcolor{preprocessor}{encoding}\textcolor{preprocessor}{)} \textcolor{preprocessor}{&=} \hyperlink{ziplist_8c_a8e8a0c4c5531ab6885734f42c1fb4398}{ZIP\_STR\_MASK}\textcolor{preprocessor}{;} \textcolor{preprocessor}{\(\backslash\)}
00303 \textcolor{preprocessor}{\}}\textcolor{keywordflow}{while}\textcolor{preprocessor}{(}0\textcolor{preprocessor}{)}
00304 
00305 \textcolor{comment}{/* Return bytes needed to store integer encoded by 'encoding'. */}
00306 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} zipIntSize(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} encoding) \{
00307     \textcolor{keywordflow}{switch}(encoding) \{
00308     \textcolor{keywordflow}{case} \hyperlink{ziplist_8c_a0c6338e8866d85135cfc7c340b2c213c}{ZIP\_INT\_8B}:  \textcolor{keywordflow}{return} 1;
00309     \textcolor{keywordflow}{case} \hyperlink{ziplist_8c_a57e9bc0aacf9f30d8b76566e40c31a6b}{ZIP\_INT\_16B}: \textcolor{keywordflow}{return} 2;
00310     \textcolor{keywordflow}{case} \hyperlink{ziplist_8c_a74a906bccde7afa94f1068634a637152}{ZIP\_INT\_24B}: \textcolor{keywordflow}{return} 3;
00311     \textcolor{keywordflow}{case} \hyperlink{ziplist_8c_addebc046cc76d482d22d7b4bf90a0649}{ZIP\_INT\_32B}: \textcolor{keywordflow}{return} 4;
00312     \textcolor{keywordflow}{case} \hyperlink{ziplist_8c_a1f551b3ab3a4d79190f367e59d6dab0a}{ZIP\_INT\_64B}: \textcolor{keywordflow}{return} 8;
00313     \}
00314     \textcolor{keywordflow}{if} (encoding >= \hyperlink{ziplist_8c_af5120069edca0811f31d130674a0de47}{ZIP\_INT\_IMM\_MIN} && encoding <= 
      \hyperlink{ziplist_8c_a69ea30cd75038067a13d2151a1c741ad}{ZIP\_INT\_IMM\_MAX})
00315         \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* 4 bit immediate */}
00316     \hyperlink{redisassert_8h_a1445e207e36c97ff84c54b47288cea19}{panic}(\textcolor{stringliteral}{"Invalid integer encoding 0x%02X"}, encoding);
00317     \textcolor{keywordflow}{return} 0;
00318 \}
00319 
00320 \textcolor{comment}{/* Write the encoidng header of the entry in 'p'. If p is NULL it just returns}
00321 \textcolor{comment}{ * the amount of bytes required to encode such a length. Arguments:}
00322 \textcolor{comment}{ *}
00323 \textcolor{comment}{ * 'encoding' is the encoding we are using for the entry. It could be}
00324 \textcolor{comment}{ * ZIP\_INT\_* or ZIP\_STR\_* or between ZIP\_INT\_IMM\_MIN and ZIP\_INT\_IMM\_MAX}
00325 \textcolor{comment}{ * for single-byte small immediate integers.}
00326 \textcolor{comment}{ *}
00327 \textcolor{comment}{ * 'rawlen' is only used for ZIP\_STR\_* encodings and is the length of the}
00328 \textcolor{comment}{ * srting that this entry represents.}
00329 \textcolor{comment}{ *}
00330 \textcolor{comment}{ * The function returns the number of bytes used by the encoding/length}
00331 \textcolor{comment}{ * header stored in 'p'. */}
00332 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} zipStoreEntryEncoding(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} encoding, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rawlen) \{
00333     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} len = 1, buf[5];
00334 
00335     \textcolor{keywordflow}{if} (\hyperlink{ziplist_8c_a2cb79e478d5bda74592c92230cfd6761}{ZIP\_IS\_STR}(encoding)) \{
00336         \textcolor{comment}{/* Although encoding is given it may not be set for strings,}
00337 \textcolor{comment}{         * so we determine it here using the raw length. */}
00338         \textcolor{keywordflow}{if} (rawlen <= 0x3f) \{
00339             \textcolor{keywordflow}{if} (!p) \textcolor{keywordflow}{return} len;
00340             buf[0] = \hyperlink{ziplist_8c_aa60ad99f14e9fc441ba912c694f2e9ae}{ZIP\_STR\_06B} | rawlen;
00341         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rawlen <= 0x3fff) \{
00342             len += 1;
00343             \textcolor{keywordflow}{if} (!p) \textcolor{keywordflow}{return} len;
00344             buf[0] = \hyperlink{ziplist_8c_a755263ebd8d5ac7daf2cc479e3cde7a0}{ZIP\_STR\_14B} | ((rawlen >> 8) & 0x3f);
00345             buf[1] = rawlen & 0xff;
00346         \} \textcolor{keywordflow}{else} \{
00347             len += 4;
00348             \textcolor{keywordflow}{if} (!p) \textcolor{keywordflow}{return} len;
00349             buf[0] = \hyperlink{ziplist_8c_a40174f4ec7db11cdaaab4d6387e0a79e}{ZIP\_STR\_32B};
00350             buf[1] = (rawlen >> 24) & 0xff;
00351             buf[2] = (rawlen >> 16) & 0xff;
00352             buf[3] = (rawlen >> 8) & 0xff;
00353             buf[4] = rawlen & 0xff;
00354         \}
00355     \} \textcolor{keywordflow}{else} \{
00356         \textcolor{comment}{/* Implies integer encoding, so length is always 1. */}
00357         \textcolor{keywordflow}{if} (!p) \textcolor{keywordflow}{return} len;
00358         buf[0] = encoding;
00359     \}
00360 
00361     \textcolor{comment}{/* Store this length at p. */}
00362     memcpy(p,buf,len);
00363     \textcolor{keywordflow}{return} len;
00364 \}
00365 
00366 \textcolor{comment}{/* Decode the entry encoding type and data length (string length for strings,}
00367 \textcolor{comment}{ * number of bytes used for the integer for integer entries) encoded in 'ptr'.}
00368 \textcolor{comment}{ * The 'encoding' variable will hold the entry encoding, the 'lensize'}
00369 \textcolor{comment}{ * variable will hold the number of bytes required to encode the entry}
00370 \textcolor{comment}{ * length, and the 'len' variable will hold the entry length. */}
00371 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_DECODE\_LENGTH}\textcolor{preprocessor}{(}\textcolor{preprocessor}{ptr}\textcolor{preprocessor}{,} \textcolor{preprocessor}{encoding}\textcolor{preprocessor}{,} \textcolor{preprocessor}{lensize}\textcolor{preprocessor}{,} \textcolor{preprocessor}{len}\textcolor{preprocessor}{)} \textcolor{keywordflow}{do} \textcolor{preprocessor}{\{}
00372     \hyperlink{ziplist_8c_aec82eca55c364327e705c74e6e636585}{ZIP\_ENTRY\_ENCODING}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{ptr}\textcolor{preprocessor}{)}\textcolor{preprocessor}{,} \textcolor{preprocessor}{(}\textcolor{preprocessor}{encoding}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
00373     \textcolor{keywordflow}{if} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{encoding}\textcolor{preprocessor}{)} \textcolor{preprocessor}{<} \hyperlink{ziplist_8c_a8e8a0c4c5531ab6885734f42c1fb4398}{ZIP\_STR\_MASK}\textcolor{preprocessor}{)} \textcolor{preprocessor}{\{}
00374         \textcolor{keywordflow}{if} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{encoding}\textcolor{preprocessor}{)} \textcolor{preprocessor}{==} \hyperlink{ziplist_8c_aa60ad99f14e9fc441ba912c694f2e9ae}{ZIP\_STR\_06B}\textcolor{preprocessor}{)} \textcolor{preprocessor}{\{}
00375             \textcolor{preprocessor}{(}\textcolor{preprocessor}{lensize}\textcolor{preprocessor}{)} \textcolor{preprocessor}{=} 1\textcolor{preprocessor}{;}
00376             \textcolor{preprocessor}{(}\textcolor{preprocessor}{len}\textcolor{preprocessor}{)} \textcolor{preprocessor}{=} \textcolor{preprocessor}{(}\textcolor{preprocessor}{ptr}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}0\textcolor{preprocessor}{]} \textcolor{preprocessor}{&} 0x3f\textcolor{preprocessor}{;}
00377         \textcolor{preprocessor}{\}} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{encoding}\textcolor{preprocessor}{)} \textcolor{preprocessor}{==} \hyperlink{ziplist_8c_a755263ebd8d5ac7daf2cc479e3cde7a0}{ZIP\_STR\_14B}\textcolor{preprocessor}{)} \textcolor{preprocessor}{\{}
00378             \textcolor{preprocessor}{(}\textcolor{preprocessor}{lensize}\textcolor{preprocessor}{)} \textcolor{preprocessor}{=} 2\textcolor{preprocessor}{;}
00379             \textcolor{preprocessor}{(}\textcolor{preprocessor}{len}\textcolor{preprocessor}{)} \textcolor{preprocessor}{=} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{ptr}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}0\textcolor{preprocessor}{]} \textcolor{preprocessor}{&} 0x3f\textcolor{preprocessor}{)} \textcolor{preprocessor}{<<} 8\textcolor{preprocessor}{)} \textcolor{preprocessor}{|} \textcolor{preprocessor}{(}\textcolor{preprocessor}{ptr}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}1\textcolor{preprocessor}{]}\textcolor{preprocessor}{;}
00380         \textcolor{preprocessor}{\}} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{encoding}\textcolor{preprocessor}{)} \textcolor{preprocessor}{==} \hyperlink{ziplist_8c_a40174f4ec7db11cdaaab4d6387e0a79e}{ZIP\_STR\_32B}\textcolor{preprocessor}{)} \textcolor{preprocessor}{\{}
00381             \textcolor{preprocessor}{(}\textcolor{preprocessor}{lensize}\textcolor{preprocessor}{)} \textcolor{preprocessor}{=} 5\textcolor{preprocessor}{;}
00382             \textcolor{preprocessor}{(}\textcolor{preprocessor}{len}\textcolor{preprocessor}{)} \textcolor{preprocessor}{=} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{ptr}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}1\textcolor{preprocessor}{]} \textcolor{preprocessor}{<<} 24\textcolor{preprocessor}{)} \textcolor{preprocessor}{|}
00383                     \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{ptr}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}2\textcolor{preprocessor}{]} \textcolor{preprocessor}{<<} 16\textcolor{preprocessor}{)} \textcolor{preprocessor}{|}
00384                     \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{ptr}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}3\textcolor{preprocessor}{]} \textcolor{preprocessor}{<<}  8\textcolor{preprocessor}{)} \textcolor{preprocessor}{|}
00385                     \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{ptr}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}4\textcolor{preprocessor}{]}\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
00386         \textcolor{preprocessor}{\}} \textcolor{keywordflow}{else} \textcolor{preprocessor}{\{}
00387             \hyperlink{redisassert_8h_a1445e207e36c97ff84c54b47288cea19}{panic}\textcolor{preprocessor}{(}\textcolor{stringliteral}{"Invalid string encoding 0x%02X"}\textcolor{preprocessor}{,} \textcolor{preprocessor}{(}\textcolor{preprocessor}{encoding}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
00388         \textcolor{preprocessor}{\}}
00389     \textcolor{preprocessor}{\}} \textcolor{keywordflow}{else} \textcolor{preprocessor}{\{}
00390         \textcolor{preprocessor}{(}\textcolor{preprocessor}{lensize}\textcolor{preprocessor}{)} \textcolor{preprocessor}{=} 1\textcolor{preprocessor}{;}
00391         \textcolor{preprocessor}{(}\textcolor{preprocessor}{len}\textcolor{preprocessor}{)} \textcolor{preprocessor}{=} \textcolor{preprocessor}{zipIntSize}\textcolor{preprocessor}{(}\textcolor{preprocessor}{encoding}\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
00392     \textcolor{preprocessor}{\}}                                                                          \textcolor{preprocessor}{\(\backslash\)}
00393 \textcolor{preprocessor}{\}}\textcolor{keywordflow}{while}\textcolor{preprocessor}{(}0\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
00394 
00395 \textcolor{comment}{/* Encode the length of the previous entry and write it to "p". This only}
00396 \textcolor{comment}{ * uses the larger encoding (required in \_\_ziplistCascadeUpdate). */}
00397 \textcolor{keywordtype}{int} zipStorePrevEntryLengthLarge(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len) \{
00398     \textcolor{keywordflow}{if} (p != NULL) \{
00399         p[0] = \hyperlink{ziplist_8c_a71ab0a14d45281783972841212042df8}{ZIP\_BIG\_PREVLEN};
00400         memcpy(p+1,&len,\textcolor{keyword}{sizeof}(len));
00401         \hyperlink{endianconv_8h_a771f3656eb7d11a1e7f7294b657d8978}{memrev32ifbe}(p+1);
00402     \}
00403     \textcolor{keywordflow}{return} 1+\textcolor{keyword}{sizeof}(len);
00404 \}
00405 
00406 \textcolor{comment}{/* Encode the length of the previous entry and write it to "p". Return the}
00407 \textcolor{comment}{ * number of bytes needed to encode this length if "p" is NULL. */}
00408 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} zipStorePrevEntryLength(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len) \{
00409     \textcolor{keywordflow}{if} (p == NULL) \{
00410         \textcolor{keywordflow}{return} (len < \hyperlink{ziplist_8c_a71ab0a14d45281783972841212042df8}{ZIP\_BIG\_PREVLEN}) ? 1 : \textcolor{keyword}{sizeof}(len)+1;
00411     \} \textcolor{keywordflow}{else} \{
00412         \textcolor{keywordflow}{if} (len < \hyperlink{ziplist_8c_a71ab0a14d45281783972841212042df8}{ZIP\_BIG\_PREVLEN}) \{
00413             p[0] = len;
00414             \textcolor{keywordflow}{return} 1;
00415         \} \textcolor{keywordflow}{else} \{
00416             \textcolor{keywordflow}{return} zipStorePrevEntryLengthLarge(p,len);
00417         \}
00418     \}
00419 \}
00420 
00421 \textcolor{comment}{/* Return the number of bytes used to encode the length of the previous}
00422 \textcolor{comment}{ * entry. The length is returned by setting the var 'prevlensize'. */}
00423 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_DECODE\_PREVLENSIZE}\textcolor{preprocessor}{(}\textcolor{preprocessor}{ptr}\textcolor{preprocessor}{,} \textcolor{preprocessor}{prevlensize}\textcolor{preprocessor}{)} \textcolor{keywordflow}{do} \textcolor{preprocessor}{\{}
00424     \textcolor{keywordflow}{if} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{ptr}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}0\textcolor{preprocessor}{]} \textcolor{preprocessor}{<} \hyperlink{ziplist_8c_a71ab0a14d45281783972841212042df8}{ZIP\_BIG\_PREVLEN}\textcolor{preprocessor}{)} \textcolor{preprocessor}{\{}
00425         \textcolor{preprocessor}{(}\textcolor{preprocessor}{prevlensize}\textcolor{preprocessor}{)} \textcolor{preprocessor}{=} 1\textcolor{preprocessor}{;}
00426     \textcolor{preprocessor}{\}} \textcolor{keywordflow}{else} \textcolor{preprocessor}{\{}
00427         \textcolor{preprocessor}{(}\textcolor{preprocessor}{prevlensize}\textcolor{preprocessor}{)} \textcolor{preprocessor}{=} 5\textcolor{preprocessor}{;}
00428     \textcolor{preprocessor}{\}}                                                                          \textcolor{preprocessor}{\(\backslash\)}
00429 \textcolor{preprocessor}{\}}\textcolor{keywordflow}{while}\textcolor{preprocessor}{(}0\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
00430 
00431 \textcolor{comment}{/* Return the length of the previous element, and the number of bytes that}
00432 \textcolor{comment}{ * are used in order to encode the previous element length.}
00433 \textcolor{comment}{ * 'ptr' must point to the prevlen prefix of an entry (that encodes the}
00434 \textcolor{comment}{ * length of the previos entry in order to navigate the elements backward).}
00435 \textcolor{comment}{ * The length of the previous entry is stored in 'prevlen', the number of}
00436 \textcolor{comment}{ * bytes needed to encode the previous entry length are stored in}
00437 \textcolor{comment}{ * 'prevlensize'. */}
00438 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{ZIP\_DECODE\_PREVLEN}\textcolor{preprocessor}{(}\textcolor{preprocessor}{ptr}\textcolor{preprocessor}{,} \textcolor{preprocessor}{prevlensize}\textcolor{preprocessor}{,} \textcolor{preprocessor}{prevlen}\textcolor{preprocessor}{)} \textcolor{keywordflow}{do} \textcolor{preprocessor}{\{}
00439     \hyperlink{ziplist_8c_a0bae94c4c67cbd6a27ea3e2f17fb0210}{ZIP\_DECODE\_PREVLENSIZE}\textcolor{preprocessor}{(}\textcolor{preprocessor}{ptr}\textcolor{preprocessor}{,} \textcolor{preprocessor}{prevlensize}\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
00440     \textcolor{keywordflow}{if} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{prevlensize}\textcolor{preprocessor}{)} \textcolor{preprocessor}{==} 1\textcolor{preprocessor}{)} \textcolor{preprocessor}{\{}
00441         \textcolor{preprocessor}{(}\textcolor{preprocessor}{prevlen}\textcolor{preprocessor}{)} \textcolor{preprocessor}{=} \textcolor{preprocessor}{(}\textcolor{preprocessor}{ptr}\textcolor{preprocessor}{)}\textcolor{preprocessor}{[}0\textcolor{preprocessor}{]}\textcolor{preprocessor}{;}
00442     \textcolor{preprocessor}{\}} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{prevlensize}\textcolor{preprocessor}{)} \textcolor{preprocessor}{==} 5\textcolor{preprocessor}{)} \textcolor{preprocessor}{\{}
00443         \hyperlink{redisassert_8h_a993abaa2c168852c1592879472938781}{assert}\textcolor{preprocessor}{(}\textcolor{keyword}{sizeof}\textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{preprocessor}{prevlensize}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)} \textcolor{preprocessor}{==} 4\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
00444         \textcolor{preprocessor}{memcpy}\textcolor{preprocessor}{(}\textcolor{preprocessor}{&}\textcolor{preprocessor}{(}\textcolor{preprocessor}{prevlen}\textcolor{preprocessor}{)}\textcolor{preprocessor}{,} \textcolor{preprocessor}{(}\textcolor{preprocessor}{(}\textcolor{keywordtype}{char}\textcolor{preprocessor}{*}\textcolor{preprocessor}{)}\textcolor{preprocessor}{(}\textcolor{preprocessor}{ptr}\textcolor{preprocessor}{)}\textcolor{preprocessor}{)} \textcolor{preprocessor}{+} 1\textcolor{preprocessor}{,} 4\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
00445         \hyperlink{endianconv_8h_a771f3656eb7d11a1e7f7294b657d8978}{memrev32ifbe}\textcolor{preprocessor}{(}\textcolor{preprocessor}{&}\textcolor{preprocessor}{prevlen}\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
00446     \textcolor{preprocessor}{\}}                                                                          \textcolor{preprocessor}{\(\backslash\)}
00447 \textcolor{preprocessor}{\}}\textcolor{keywordflow}{while}\textcolor{preprocessor}{(}0\textcolor{preprocessor}{)}\textcolor{preprocessor}{;}
00448 
00449 \textcolor{comment}{/* Given a pointer 'p' to the prevlen info that prefixes an entry, this}
00450 \textcolor{comment}{ * function returns the difference in number of bytes needed to encode}
00451 \textcolor{comment}{ * the prevlen if the previous entry changes of size.}
00452 \textcolor{comment}{ *}
00453 \textcolor{comment}{ * So if A is the number of bytes used right now to encode the 'prevlen'}
00454 \textcolor{comment}{ * field.}
00455 \textcolor{comment}{ *}
00456 \textcolor{comment}{ * And B is the number of bytes that are needed in order to encode the}
00457 \textcolor{comment}{ * 'prevlen' if the previous element will be updated to one of size 'len'.}
00458 \textcolor{comment}{ *}
00459 \textcolor{comment}{ * Then the function returns B - A}
00460 \textcolor{comment}{ *}
00461 \textcolor{comment}{ * So the function returns a positive number if more space is needed,}
00462 \textcolor{comment}{ * a negative number if less space is needed, or zero if the same space}
00463 \textcolor{comment}{ * is needed. */}
00464 \textcolor{keywordtype}{int} zipPrevLenByteDiff(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len) \{
00465     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} prevlensize;
00466     \hyperlink{ziplist_8c_a0bae94c4c67cbd6a27ea3e2f17fb0210}{ZIP\_DECODE\_PREVLENSIZE}(p, prevlensize);
00467     \textcolor{keywordflow}{return} zipStorePrevEntryLength(NULL, len) - prevlensize;
00468 \}
00469 
00470 \textcolor{comment}{/* Return the total number of bytes used by the entry pointed to by 'p'. */}
00471 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} zipRawEntryLength(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p) \{
00472     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} prevlensize, encoding, lensize, len;
00473     \hyperlink{ziplist_8c_a0bae94c4c67cbd6a27ea3e2f17fb0210}{ZIP\_DECODE\_PREVLENSIZE}(p, prevlensize);
00474     \hyperlink{ziplist_8c_acdddca374b430c930d4b2d08f5de7a62}{ZIP\_DECODE\_LENGTH}(p + prevlensize, encoding, lensize, len);
00475     \textcolor{keywordflow}{return} prevlensize + lensize + len;
00476 \}
00477 
00478 \textcolor{comment}{/* Check if string pointed to by 'entry' can be encoded as an integer.}
00479 \textcolor{comment}{ * Stores the integer value in 'v' and its encoding in 'encoding'. */}
00480 \textcolor{keywordtype}{int} zipTryEncoding(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *entry, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} entrylen, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} *v, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *encoding)
       \{
00481     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value;
00482 
00483     \textcolor{keywordflow}{if} (entrylen >= 32 || entrylen == 0) \textcolor{keywordflow}{return} 0;
00484     \textcolor{keywordflow}{if} (string2ll((\textcolor{keywordtype}{char}*)entry,entrylen,&value)) \{
00485         \textcolor{comment}{/* Great, the string can be encoded. Check what's the smallest}
00486 \textcolor{comment}{         * of our encoding types that can hold this value. */}
00487         \textcolor{keywordflow}{if} (value >= 0 && value <= 12) \{
00488             *encoding = \hyperlink{ziplist_8c_af5120069edca0811f31d130674a0de47}{ZIP\_INT\_IMM\_MIN}+value;
00489         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value >= INT8\_MIN && value <= INT8\_MAX) \{
00490             *encoding = \hyperlink{ziplist_8c_a0c6338e8866d85135cfc7c340b2c213c}{ZIP\_INT\_8B};
00491         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value >= INT16\_MIN && value <= INT16\_MAX) \{
00492             *encoding = \hyperlink{ziplist_8c_a57e9bc0aacf9f30d8b76566e40c31a6b}{ZIP\_INT\_16B};
00493         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value >= \hyperlink{ziplist_8c_a6e56f9eebea6721ecf9e59d3a5190617}{INT24\_MIN} && value <= \hyperlink{ziplist_8c_a4ade7f65b05984f1f21a8223e70c9fac}{INT24\_MAX}) \{
00494             *encoding = \hyperlink{ziplist_8c_a74a906bccde7afa94f1068634a637152}{ZIP\_INT\_24B};
00495         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value >= INT32\_MIN && value <= INT32\_MAX) \{
00496             *encoding = \hyperlink{ziplist_8c_addebc046cc76d482d22d7b4bf90a0649}{ZIP\_INT\_32B};
00497         \} \textcolor{keywordflow}{else} \{
00498             *encoding = \hyperlink{ziplist_8c_a1f551b3ab3a4d79190f367e59d6dab0a}{ZIP\_INT\_64B};
00499         \}
00500         *v = value;
00501         \textcolor{keywordflow}{return} 1;
00502     \}
00503     \textcolor{keywordflow}{return} 0;
00504 \}
00505 
00506 \textcolor{comment}{/* Store integer 'value' at 'p', encoded as 'encoding' */}
00507 \textcolor{keywordtype}{void} zipSaveInteger(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, int64\_t value, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} encoding) \{
00508     int16\_t i16;
00509     int32\_t i32;
00510     int64\_t i64;
00511     \textcolor{keywordflow}{if} (encoding == \hyperlink{ziplist_8c_a0c6338e8866d85135cfc7c340b2c213c}{ZIP\_INT\_8B}) \{
00512         ((int8\_t*)p)[0] = (int8\_t)value;
00513     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (encoding == \hyperlink{ziplist_8c_a57e9bc0aacf9f30d8b76566e40c31a6b}{ZIP\_INT\_16B}) \{
00514         i16 = value;
00515         memcpy(p,&i16,\textcolor{keyword}{sizeof}(i16));
00516         \hyperlink{endianconv_8h_a49372891e83ab7a970f0d98dda1870d9}{memrev16ifbe}(p);
00517     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (encoding == \hyperlink{ziplist_8c_a74a906bccde7afa94f1068634a637152}{ZIP\_INT\_24B}) \{
00518         i32 = value<<8;
00519         \hyperlink{endianconv_8h_a771f3656eb7d11a1e7f7294b657d8978}{memrev32ifbe}(&i32);
00520         memcpy(p,((uint8\_t*)&i32)+1,\textcolor{keyword}{sizeof}(i32)-\textcolor{keyword}{sizeof}(uint8\_t));
00521     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (encoding == \hyperlink{ziplist_8c_addebc046cc76d482d22d7b4bf90a0649}{ZIP\_INT\_32B}) \{
00522         i32 = value;
00523         memcpy(p,&i32,\textcolor{keyword}{sizeof}(i32));
00524         \hyperlink{endianconv_8h_a771f3656eb7d11a1e7f7294b657d8978}{memrev32ifbe}(p);
00525     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (encoding == \hyperlink{ziplist_8c_a1f551b3ab3a4d79190f367e59d6dab0a}{ZIP\_INT\_64B}) \{
00526         i64 = value;
00527         memcpy(p,&i64,\textcolor{keyword}{sizeof}(i64));
00528         \hyperlink{endianconv_8h_aa311b9f944c3b988f3601698a95890c1}{memrev64ifbe}(p);
00529     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (encoding >= \hyperlink{ziplist_8c_af5120069edca0811f31d130674a0de47}{ZIP\_INT\_IMM\_MIN} && encoding <= 
      \hyperlink{ziplist_8c_a69ea30cd75038067a13d2151a1c741ad}{ZIP\_INT\_IMM\_MAX}) \{
00530         \textcolor{comment}{/* Nothing to do, the value is stored in the encoding itself. */}
00531     \} \textcolor{keywordflow}{else} \{
00532         \hyperlink{redisassert_8h_a993abaa2c168852c1592879472938781}{assert}(NULL);
00533     \}
00534 \}
00535 
00536 \textcolor{comment}{/* Read integer encoded as 'encoding' from 'p' */}
00537 int64\_t zipLoadInteger(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} encoding) \{
00538     int16\_t i16;
00539     int32\_t i32;
00540     int64\_t i64, ret = 0;
00541     \textcolor{keywordflow}{if} (encoding == \hyperlink{ziplist_8c_a0c6338e8866d85135cfc7c340b2c213c}{ZIP\_INT\_8B}) \{
00542         ret = ((int8\_t*)p)[0];
00543     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (encoding == \hyperlink{ziplist_8c_a57e9bc0aacf9f30d8b76566e40c31a6b}{ZIP\_INT\_16B}) \{
00544         memcpy(&i16,p,\textcolor{keyword}{sizeof}(i16));
00545         \hyperlink{endianconv_8h_a49372891e83ab7a970f0d98dda1870d9}{memrev16ifbe}(&i16);
00546         ret = i16;
00547     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (encoding == \hyperlink{ziplist_8c_addebc046cc76d482d22d7b4bf90a0649}{ZIP\_INT\_32B}) \{
00548         memcpy(&i32,p,\textcolor{keyword}{sizeof}(i32));
00549         \hyperlink{endianconv_8h_a771f3656eb7d11a1e7f7294b657d8978}{memrev32ifbe}(&i32);
00550         ret = i32;
00551     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (encoding == \hyperlink{ziplist_8c_a74a906bccde7afa94f1068634a637152}{ZIP\_INT\_24B}) \{
00552         i32 = 0;
00553         memcpy(((uint8\_t*)&i32)+1,p,\textcolor{keyword}{sizeof}(i32)-\textcolor{keyword}{sizeof}(uint8\_t));
00554         \hyperlink{endianconv_8h_a771f3656eb7d11a1e7f7294b657d8978}{memrev32ifbe}(&i32);
00555         ret = i32>>8;
00556     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (encoding == \hyperlink{ziplist_8c_a1f551b3ab3a4d79190f367e59d6dab0a}{ZIP\_INT\_64B}) \{
00557         memcpy(&i64,p,\textcolor{keyword}{sizeof}(i64));
00558         \hyperlink{endianconv_8h_aa311b9f944c3b988f3601698a95890c1}{memrev64ifbe}(&i64);
00559         ret = i64;
00560     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (encoding >= \hyperlink{ziplist_8c_af5120069edca0811f31d130674a0de47}{ZIP\_INT\_IMM\_MIN} && encoding <= 
      \hyperlink{ziplist_8c_a69ea30cd75038067a13d2151a1c741ad}{ZIP\_INT\_IMM\_MAX}) \{
00561         ret = (encoding & \hyperlink{ziplist_8c_a7f67361d1c0359f801c75c65b9a2b07e}{ZIP\_INT\_IMM\_MASK})-1;
00562     \} \textcolor{keywordflow}{else} \{
00563         \hyperlink{redisassert_8h_a993abaa2c168852c1592879472938781}{assert}(NULL);
00564     \}
00565     \textcolor{keywordflow}{return} ret;
00566 \}
00567 
00568 \textcolor{comment}{/* Return a struct with all information about an entry. */}
00569 \textcolor{keywordtype}{void} zipEntry(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, zlentry *e) \{
00570 
00571     \hyperlink{ziplist_8c_a3e5b2bc4707dc1097db2726494cc3728}{ZIP\_DECODE\_PREVLEN}(p, e->prevrawlensize, e->prevrawlen);
00572     \hyperlink{ziplist_8c_acdddca374b430c930d4b2d08f5de7a62}{ZIP\_DECODE\_LENGTH}(p + e->prevrawlensize, e->encoding, e->lensize, e->len);
00573     e->headersize = e->prevrawlensize + e->lensize;
00574     e->p = p;
00575 \}
00576 
00577 \textcolor{comment}{/* Create a new empty ziplist. */}
00578 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ziplistNew(\textcolor{keywordtype}{void}) \{
00579     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} bytes = \hyperlink{ziplist_8c_a3b8ef40d77ce00bcad424d0c07e2de95}{ZIPLIST\_HEADER\_SIZE}+1;
00580     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl = zmalloc(bytes);
00581     \hyperlink{ziplist_8c_a28b9c7884758bc2d52f204903a4bb642}{ZIPLIST\_BYTES}(zl) = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(bytes);
00582     \hyperlink{ziplist_8c_adf2235d74c81861c85fb5d2ffa209397}{ZIPLIST\_TAIL\_OFFSET}(zl) = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(
      \hyperlink{ziplist_8c_a3b8ef40d77ce00bcad424d0c07e2de95}{ZIPLIST\_HEADER\_SIZE});
00583     \hyperlink{ziplist_8c_a6d779e84aca736e354768fcf87393b98}{ZIPLIST\_LENGTH}(zl) = 0;
00584     zl[bytes-1] = \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END};
00585     \textcolor{keywordflow}{return} zl;
00586 \}
00587 
00588 \textcolor{comment}{/* Resize the ziplist. */}
00589 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ziplistResize(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len) \{
00590     zl = zrealloc(zl,len);
00591     \hyperlink{ziplist_8c_a28b9c7884758bc2d52f204903a4bb642}{ZIPLIST\_BYTES}(zl) = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(len);
00592     zl[len-1] = \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END};
00593     \textcolor{keywordflow}{return} zl;
00594 \}
00595 
00596 \textcolor{comment}{/* When an entry is inserted, we need to set the prevlen field of the next}
00597 \textcolor{comment}{ * entry to equal the length of the inserted entry. It can occur that this}
00598 \textcolor{comment}{ * length cannot be encoded in 1 byte and the next entry needs to be grow}
00599 \textcolor{comment}{ * a bit larger to hold the 5-byte encoded prevlen. This can be done for free,}
00600 \textcolor{comment}{ * because this only happens when an entry is already being inserted (which}
00601 \textcolor{comment}{ * causes a realloc and memmove). However, encoding the prevlen may require}
00602 \textcolor{comment}{ * that this entry is grown as well. This effect may cascade throughout}
00603 \textcolor{comment}{ * the ziplist when there are consecutive entries with a size close to}
00604 \textcolor{comment}{ * ZIP\_BIG\_PREVLEN, so we need to check that the prevlen can be encoded in}
00605 \textcolor{comment}{ * every consecutive entry.}
00606 \textcolor{comment}{ *}
00607 \textcolor{comment}{ * Note that this effect can also happen in reverse, where the bytes required}
00608 \textcolor{comment}{ * to encode the prevlen field can shrink. This effect is deliberately ignored,}
00609 \textcolor{comment}{ * because it can cause a "flapping" effect where a chain prevlen fields is}
00610 \textcolor{comment}{ * first grown and then shrunk again after consecutive inserts. Rather, the}
00611 \textcolor{comment}{ * field is allowed to stay larger than necessary, because a large prevlen}
00612 \textcolor{comment}{ * field implies the ziplist is holding large entries anyway.}
00613 \textcolor{comment}{ *}
00614 \textcolor{comment}{ * The pointer "p" points to the first entry that does NOT need to be}
00615 \textcolor{comment}{ * updated, i.e. consecutive fields MAY need an update. */}
00616 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *\_\_ziplistCascadeUpdate(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p) \{
00617     size\_t curlen = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{ziplist_8c_a28b9c7884758bc2d52f204903a4bb642}{ZIPLIST\_BYTES}(zl)), rawlen, rawlensize;
00618     size\_t offset, noffset, extra;
00619     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *np;
00620     zlentry cur, next;
00621 
00622     \textcolor{keywordflow}{while} (p[0] != \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END}) \{
00623         zipEntry(p, &cur);
00624         rawlen = cur.headersize + cur.len;
00625         rawlensize = zipStorePrevEntryLength(NULL,rawlen);
00626 
00627         \textcolor{comment}{/* Abort if there is no next entry. */}
00628         \textcolor{keywordflow}{if} (p[rawlen] == \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END}) \textcolor{keywordflow}{break};
00629         zipEntry(p+rawlen, &next);
00630 
00631         \textcolor{comment}{/* Abort when "prevlen" has not changed. */}
00632         \textcolor{keywordflow}{if} (next.prevrawlen == rawlen) \textcolor{keywordflow}{break};
00633 
00634         \textcolor{keywordflow}{if} (next.prevrawlensize < rawlensize) \{
00635             \textcolor{comment}{/* The "prevlen" field of "next" needs more bytes to hold}
00636 \textcolor{comment}{             * the raw length of "cur". */}
00637             offset = p-zl;
00638             extra = rawlensize-next.prevrawlensize;
00639             zl = ziplistResize(zl,curlen+extra);
00640             p = zl+offset;
00641 
00642             \textcolor{comment}{/* Current pointer and offset for next element. */}
00643             np = p+rawlen;
00644             noffset = np-zl;
00645 
00646             \textcolor{comment}{/* Update tail offset when next element is not the tail element. */}
00647             \textcolor{keywordflow}{if} ((zl+\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{ziplist_8c_adf2235d74c81861c85fb5d2ffa209397}{ZIPLIST\_TAIL\_OFFSET}(zl))) != np) \{
00648                 \hyperlink{ziplist_8c_adf2235d74c81861c85fb5d2ffa209397}{ZIPLIST\_TAIL\_OFFSET}(zl) =
00649                     \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(
      \hyperlink{ziplist_8c_adf2235d74c81861c85fb5d2ffa209397}{ZIPLIST\_TAIL\_OFFSET}(zl))+extra);
00650             \}
00651 
00652             \textcolor{comment}{/* Move the tail to the back. */}
00653             memmove(np+rawlensize,
00654                 np+next.prevrawlensize,
00655                 curlen-noffset-next.prevrawlensize-1);
00656             zipStorePrevEntryLength(np,rawlen);
00657 
00658             \textcolor{comment}{/* Advance the cursor */}
00659             p += rawlen;
00660             curlen += extra;
00661         \} \textcolor{keywordflow}{else} \{
00662             \textcolor{keywordflow}{if} (next.prevrawlensize > rawlensize) \{
00663                 \textcolor{comment}{/* This would result in shrinking, which we want to avoid.}
00664 \textcolor{comment}{                 * So, set "rawlen" in the available bytes. */}
00665                 zipStorePrevEntryLengthLarge(p+rawlen,rawlen);
00666             \} \textcolor{keywordflow}{else} \{
00667                 zipStorePrevEntryLength(p+rawlen,rawlen);
00668             \}
00669 
00670             \textcolor{comment}{/* Stop here, as the raw length of "next" has not changed. */}
00671             \textcolor{keywordflow}{break};
00672         \}
00673     \}
00674     \textcolor{keywordflow}{return} zl;
00675 \}
00676 
00677 \textcolor{comment}{/* Delete "num" entries, starting at "p". Returns pointer to the ziplist. */}
00678 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *\_\_ziplistDelete(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} num) \{
00679     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i, totlen, deleted = 0;
00680     size\_t offset;
00681     \textcolor{keywordtype}{int} nextdiff = 0;
00682     zlentry first, tail;
00683 
00684     zipEntry(p, &first);
00685     \textcolor{keywordflow}{for} (i = 0; p[0] != \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END} && i < num; i++) \{
00686         p += zipRawEntryLength(p);
00687         deleted++;
00688     \}
00689 
00690     totlen = p-first.p; \textcolor{comment}{/* Bytes taken by the element(s) to delete. */}
00691     \textcolor{keywordflow}{if} (totlen > 0) \{
00692         \textcolor{keywordflow}{if} (p[0] != \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END}) \{
00693             \textcolor{comment}{/* Storing `prevrawlen` in this entry may increase or decrease the}
00694 \textcolor{comment}{             * number of bytes required compare to the current `prevrawlen`.}
00695 \textcolor{comment}{             * There always is room to store this, because it was previously}
00696 \textcolor{comment}{             * stored by an entry that is now being deleted. */}
00697             nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);
00698 
00699             \textcolor{comment}{/* Note that there is always space when p jumps backward: if}
00700 \textcolor{comment}{             * the new previous entry is large, one of the deleted elements}
00701 \textcolor{comment}{             * had a 5 bytes prevlen header, so there is for sure at least}
00702 \textcolor{comment}{             * 5 bytes free and we need just 4. */}
00703             p -= nextdiff;
00704             zipStorePrevEntryLength(p,first.prevrawlen);
00705 
00706             \textcolor{comment}{/* Update offset for tail */}
00707             \hyperlink{ziplist_8c_adf2235d74c81861c85fb5d2ffa209397}{ZIPLIST\_TAIL\_OFFSET}(zl) =
00708                 \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(
      \hyperlink{ziplist_8c_adf2235d74c81861c85fb5d2ffa209397}{ZIPLIST\_TAIL\_OFFSET}(zl))-totlen);
00709 
00710             \textcolor{comment}{/* When the tail contains more than one entry, we need to take}
00711 \textcolor{comment}{             * "nextdiff" in account as well. Otherwise, a change in the}
00712 \textcolor{comment}{             * size of prevlen doesn't have an effect on the *tail* offset. */}
00713             zipEntry(p, &tail);
00714             \textcolor{keywordflow}{if} (p[tail.headersize+tail.len] != \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END}) \{
00715                 \hyperlink{ziplist_8c_adf2235d74c81861c85fb5d2ffa209397}{ZIPLIST\_TAIL\_OFFSET}(zl) =
00716                    \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(
      \hyperlink{ziplist_8c_adf2235d74c81861c85fb5d2ffa209397}{ZIPLIST\_TAIL\_OFFSET}(zl))+nextdiff);
00717             \}
00718 
00719             \textcolor{comment}{/* Move tail to the front of the ziplist */}
00720             memmove(first.p,p,
00721                 \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{ziplist_8c_a28b9c7884758bc2d52f204903a4bb642}{ZIPLIST\_BYTES}(zl))-(p-zl)-1);
00722         \} \textcolor{keywordflow}{else} \{
00723             \textcolor{comment}{/* The entire tail was deleted. No need to move memory. */}
00724             \hyperlink{ziplist_8c_adf2235d74c81861c85fb5d2ffa209397}{ZIPLIST\_TAIL\_OFFSET}(zl) =
00725                 \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}((first.p-zl)-first.prevrawlen);
00726         \}
00727 
00728         \textcolor{comment}{/* Resize and update length */}
00729         offset = first.p-zl;
00730         zl = ziplistResize(zl, \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{ziplist_8c_a28b9c7884758bc2d52f204903a4bb642}{ZIPLIST\_BYTES}(zl))-totlen+
      nextdiff);
00731         \hyperlink{ziplist_8c_a929244a46d13b9b5e1007136d3922daf}{ZIPLIST\_INCR\_LENGTH}(zl,-deleted);
00732         p = zl+offset;
00733 
00734         \textcolor{comment}{/* When nextdiff != 0, the raw length of the next entry has changed, so}
00735 \textcolor{comment}{         * we need to cascade the update throughout the ziplist */}
00736         \textcolor{keywordflow}{if} (nextdiff != 0)
00737             zl = \_\_ziplistCascadeUpdate(zl,p);
00738     \}
00739     \textcolor{keywordflow}{return} zl;
00740 \}
00741 
00742 \textcolor{comment}{/* Insert item at "p". */}
00743 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *\_\_ziplistInsert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *s, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} 
      slen) \{
00744     size\_t curlen = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{ziplist_8c_a28b9c7884758bc2d52f204903a4bb642}{ZIPLIST\_BYTES}(zl)), reqlen;
00745     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} prevlensize, prevlen = 0;
00746     size\_t offset;
00747     \textcolor{keywordtype}{int} nextdiff = 0;
00748     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} encoding = 0;
00749     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value = 123456789; \textcolor{comment}{/* initialized to avoid warning. Using a value}
00750 \textcolor{comment}{                                    that is easy to see if for some reason}
00751 \textcolor{comment}{                                    we use it uninitialized. */}
00752     zlentry tail;
00753 
00754     \textcolor{comment}{/* Find out prevlen for the entry that is inserted. */}
00755     \textcolor{keywordflow}{if} (p[0] != \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END}) \{
00756         \hyperlink{ziplist_8c_a3e5b2bc4707dc1097db2726494cc3728}{ZIP\_DECODE\_PREVLEN}(p, prevlensize, prevlen);
00757     \} \textcolor{keywordflow}{else} \{
00758         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ptail = \hyperlink{ziplist_8c_a13a02cab4315ab94186102584601273e}{ZIPLIST\_ENTRY\_TAIL}(zl);
00759         \textcolor{keywordflow}{if} (ptail[0] != \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END}) \{
00760             prevlen = zipRawEntryLength(ptail);
00761         \}
00762     \}
00763 
00764     \textcolor{comment}{/* See if the entry can be encoded */}
00765     \textcolor{keywordflow}{if} (zipTryEncoding(s,slen,&value,&encoding)) \{
00766         \textcolor{comment}{/* 'encoding' is set to the appropriate integer encoding */}
00767         reqlen = zipIntSize(encoding);
00768     \} \textcolor{keywordflow}{else} \{
00769         \textcolor{comment}{/* 'encoding' is untouched, however zipStoreEntryEncoding will use the}
00770 \textcolor{comment}{         * string length to figure out how to encode it. */}
00771         reqlen = slen;
00772     \}
00773     \textcolor{comment}{/* We need space for both the length of the previous entry and}
00774 \textcolor{comment}{     * the length of the payload. */}
00775     reqlen += zipStorePrevEntryLength(NULL,prevlen);
00776     reqlen += zipStoreEntryEncoding(NULL,encoding,slen);
00777 
00778     \textcolor{comment}{/* When the insert position is not equal to the tail, we need to}
00779 \textcolor{comment}{     * make sure that the next entry can hold this entry's length in}
00780 \textcolor{comment}{     * its prevlen field. */}
00781     \textcolor{keywordtype}{int} forcelarge = 0;
00782     nextdiff = (p[0] != \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END}) ? zipPrevLenByteDiff(p,reqlen) : 0;
00783     \textcolor{keywordflow}{if} (nextdiff == -4 && reqlen < 4) \{
00784         nextdiff = 0;
00785         forcelarge = 1;
00786     \}
00787 
00788     \textcolor{comment}{/* Store offset because a realloc may change the address of zl. */}
00789     offset = p-zl;
00790     zl = ziplistResize(zl,curlen+reqlen+nextdiff);
00791     p = zl+offset;
00792 
00793     \textcolor{comment}{/* Apply memory move when necessary and update tail offset. */}
00794     \textcolor{keywordflow}{if} (p[0] != \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END}) \{
00795         \textcolor{comment}{/* Subtract one because of the ZIP\_END bytes */}
00796         memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);
00797 
00798         \textcolor{comment}{/* Encode this entry's raw length in the next entry. */}
00799         \textcolor{keywordflow}{if} (forcelarge)
00800             zipStorePrevEntryLengthLarge(p+reqlen,reqlen);
00801         \textcolor{keywordflow}{else}
00802             zipStorePrevEntryLength(p+reqlen,reqlen);
00803 
00804         \textcolor{comment}{/* Update offset for tail */}
00805         \hyperlink{ziplist_8c_adf2235d74c81861c85fb5d2ffa209397}{ZIPLIST\_TAIL\_OFFSET}(zl) =
00806             \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(
      \hyperlink{ziplist_8c_adf2235d74c81861c85fb5d2ffa209397}{ZIPLIST\_TAIL\_OFFSET}(zl))+reqlen);
00807 
00808         \textcolor{comment}{/* When the tail contains more than one entry, we need to take}
00809 \textcolor{comment}{         * "nextdiff" in account as well. Otherwise, a change in the}
00810 \textcolor{comment}{         * size of prevlen doesn't have an effect on the *tail* offset. */}
00811         zipEntry(p+reqlen, &tail);
00812         \textcolor{keywordflow}{if} (p[reqlen+tail.headersize+tail.len] != \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END}) \{
00813             \hyperlink{ziplist_8c_adf2235d74c81861c85fb5d2ffa209397}{ZIPLIST\_TAIL\_OFFSET}(zl) =
00814                 \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(
      \hyperlink{ziplist_8c_adf2235d74c81861c85fb5d2ffa209397}{ZIPLIST\_TAIL\_OFFSET}(zl))+nextdiff);
00815         \}
00816     \} \textcolor{keywordflow}{else} \{
00817         \textcolor{comment}{/* This element will be the new tail. */}
00818         \hyperlink{ziplist_8c_adf2235d74c81861c85fb5d2ffa209397}{ZIPLIST\_TAIL\_OFFSET}(zl) = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(p-zl);
00819     \}
00820 
00821     \textcolor{comment}{/* When nextdiff != 0, the raw length of the next entry has changed, so}
00822 \textcolor{comment}{     * we need to cascade the update throughout the ziplist */}
00823     \textcolor{keywordflow}{if} (nextdiff != 0) \{
00824         offset = p-zl;
00825         zl = \_\_ziplistCascadeUpdate(zl,p+reqlen);
00826         p = zl+offset;
00827     \}
00828 
00829     \textcolor{comment}{/* Write the entry */}
00830     p += zipStorePrevEntryLength(p,prevlen);
00831     p += zipStoreEntryEncoding(p,encoding,slen);
00832     \textcolor{keywordflow}{if} (\hyperlink{ziplist_8c_a2cb79e478d5bda74592c92230cfd6761}{ZIP\_IS\_STR}(encoding)) \{
00833         memcpy(p,s,slen);
00834     \} \textcolor{keywordflow}{else} \{
00835         zipSaveInteger(p,value,encoding);
00836     \}
00837     \hyperlink{ziplist_8c_a929244a46d13b9b5e1007136d3922daf}{ZIPLIST\_INCR\_LENGTH}(zl,1);
00838     \textcolor{keywordflow}{return} zl;
00839 \}
00840 
00841 \textcolor{comment}{/* Merge ziplists 'first' and 'second' by appending 'second' to 'first'.}
00842 \textcolor{comment}{ *}
00843 \textcolor{comment}{ * NOTE: The larger ziplist is reallocated to contain the new merged ziplist.}
00844 \textcolor{comment}{ * Either 'first' or 'second' can be used for the result.  The parameter not}
00845 \textcolor{comment}{ * used will be free'd and set to NULL.}
00846 \textcolor{comment}{ *}
00847 \textcolor{comment}{ * After calling this function, the input parameters are no longer valid since}
00848 \textcolor{comment}{ * they are changed and free'd in-place.}
00849 \textcolor{comment}{ *}
00850 \textcolor{comment}{ * The result ziplist is the contents of 'first' followed by 'second'.}
00851 \textcolor{comment}{ *}
00852 \textcolor{comment}{ * On failure: returns NULL if the merge is impossible.}
00853 \textcolor{comment}{ * On success: returns the merged ziplist (which is expanded version of either}
00854 \textcolor{comment}{ * 'first' or 'second', also frees the other unused input ziplist, and sets the}
00855 \textcolor{comment}{ * input ziplist argument equal to newly reallocated ziplist return value. */}
00856 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ziplistMerge(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **first, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **second) \{
00857     \textcolor{comment}{/* If any params are null, we can't merge, so NULL. */}
00858     \textcolor{keywordflow}{if} (first == NULL || *first == NULL || second == NULL || *second == NULL)
00859         \textcolor{keywordflow}{return} NULL;
00860 
00861     \textcolor{comment}{/* Can't merge same list into itself. */}
00862     \textcolor{keywordflow}{if} (*first == *second)
00863         \textcolor{keywordflow}{return} NULL;
00864 
00865     size\_t first\_bytes = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{ziplist_8c_a28b9c7884758bc2d52f204903a4bb642}{ZIPLIST\_BYTES}(*first));
00866     size\_t first\_len = \hyperlink{endianconv_8h_a47540b5867d4cb1e322e83eaf2b50b56}{intrev16ifbe}(\hyperlink{ziplist_8c_a6d779e84aca736e354768fcf87393b98}{ZIPLIST\_LENGTH}(*first));
00867 
00868     size\_t second\_bytes = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{ziplist_8c_a28b9c7884758bc2d52f204903a4bb642}{ZIPLIST\_BYTES}(*second));
00869     size\_t second\_len = \hyperlink{endianconv_8h_a47540b5867d4cb1e322e83eaf2b50b56}{intrev16ifbe}(\hyperlink{ziplist_8c_a6d779e84aca736e354768fcf87393b98}{ZIPLIST\_LENGTH}(*second));
00870 
00871     \textcolor{keywordtype}{int} append;
00872     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *source, *target;
00873     size\_t target\_bytes, source\_bytes;
00874     \textcolor{comment}{/* Pick the largest ziplist so we can resize easily in-place.}
00875 \textcolor{comment}{     * We must also track if we are now appending or prepending to}
00876 \textcolor{comment}{     * the target ziplist. */}
00877     \textcolor{keywordflow}{if} (first\_len >= second\_len) \{
00878         \textcolor{comment}{/* retain first, append second to first. */}
00879         target = *first;
00880         target\_bytes = first\_bytes;
00881         source = *second;
00882         source\_bytes = second\_bytes;
00883         append = 1;
00884     \} \textcolor{keywordflow}{else} \{
00885         \textcolor{comment}{/* else, retain second, prepend first to second. */}
00886         target = *second;
00887         target\_bytes = second\_bytes;
00888         source = *first;
00889         source\_bytes = first\_bytes;
00890         append = 0;
00891     \}
00892 
00893     \textcolor{comment}{/* Calculate final bytes (subtract one pair of metadata) */}
00894     size\_t zlbytes = first\_bytes + second\_bytes -
00895                      \hyperlink{ziplist_8c_a3b8ef40d77ce00bcad424d0c07e2de95}{ZIPLIST\_HEADER\_SIZE} - 
      \hyperlink{ziplist_8c_ab15031d20f1d4b1a8b6bc843752958ee}{ZIPLIST\_END\_SIZE};
00896     size\_t zllength = first\_len + second\_len;
00897 
00898     \textcolor{comment}{/* Combined zl length should be limited within UINT16\_MAX */}
00899     zllength = zllength < UINT16\_MAX ? zllength : UINT16\_MAX;
00900 
00901     \textcolor{comment}{/* Save offset positions before we start ripping memory apart. */}
00902     size\_t first\_offset = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{ziplist_8c_adf2235d74c81861c85fb5d2ffa209397}{ZIPLIST\_TAIL\_OFFSET}(*first));
00903     size\_t second\_offset = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{ziplist_8c_adf2235d74c81861c85fb5d2ffa209397}{ZIPLIST\_TAIL\_OFFSET}(*second));
00904 
00905     \textcolor{comment}{/* Extend target to new zlbytes then append or prepend source. */}
00906     target = zrealloc(target, zlbytes);
00907     \textcolor{keywordflow}{if} (append) \{
00908         \textcolor{comment}{/* append == appending to target */}
00909         \textcolor{comment}{/* Copy source after target (copying over original [END]):}
00910 \textcolor{comment}{         *   [TARGET - END, SOURCE - HEADER] */}
00911         memcpy(target + target\_bytes - \hyperlink{ziplist_8c_ab15031d20f1d4b1a8b6bc843752958ee}{ZIPLIST\_END\_SIZE},
00912                source + \hyperlink{ziplist_8c_a3b8ef40d77ce00bcad424d0c07e2de95}{ZIPLIST\_HEADER\_SIZE},
00913                source\_bytes - \hyperlink{ziplist_8c_a3b8ef40d77ce00bcad424d0c07e2de95}{ZIPLIST\_HEADER\_SIZE});
00914     \} \textcolor{keywordflow}{else} \{
00915         \textcolor{comment}{/* !append == prepending to target */}
00916         \textcolor{comment}{/* Move target *contents* exactly size of (source - [END]),}
00917 \textcolor{comment}{         * then copy source into vacataed space (source - [END]):}
00918 \textcolor{comment}{         *   [SOURCE - END, TARGET - HEADER] */}
00919         memmove(target + source\_bytes - \hyperlink{ziplist_8c_ab15031d20f1d4b1a8b6bc843752958ee}{ZIPLIST\_END\_SIZE},
00920                 target + \hyperlink{ziplist_8c_a3b8ef40d77ce00bcad424d0c07e2de95}{ZIPLIST\_HEADER\_SIZE},
00921                 target\_bytes - \hyperlink{ziplist_8c_a3b8ef40d77ce00bcad424d0c07e2de95}{ZIPLIST\_HEADER\_SIZE});
00922         memcpy(target, source, source\_bytes - \hyperlink{ziplist_8c_ab15031d20f1d4b1a8b6bc843752958ee}{ZIPLIST\_END\_SIZE});
00923     \}
00924 
00925     \textcolor{comment}{/* Update header metadata. */}
00926     \hyperlink{ziplist_8c_a28b9c7884758bc2d52f204903a4bb642}{ZIPLIST\_BYTES}(target) = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(zlbytes);
00927     \hyperlink{ziplist_8c_a6d779e84aca736e354768fcf87393b98}{ZIPLIST\_LENGTH}(target) = \hyperlink{endianconv_8h_a47540b5867d4cb1e322e83eaf2b50b56}{intrev16ifbe}(zllength);
00928     \textcolor{comment}{/* New tail offset is:}
00929 \textcolor{comment}{     *   + N bytes of first ziplist}
00930 \textcolor{comment}{     *   - 1 byte for [END] of first ziplist}
00931 \textcolor{comment}{     *   + M bytes for the offset of the original tail of the second ziplist}
00932 \textcolor{comment}{     *   - J bytes for HEADER because second\_offset keeps no header. */}
00933     \hyperlink{ziplist_8c_adf2235d74c81861c85fb5d2ffa209397}{ZIPLIST\_TAIL\_OFFSET}(target) = \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(
00934                                    (first\_bytes - \hyperlink{ziplist_8c_ab15031d20f1d4b1a8b6bc843752958ee}{ZIPLIST\_END\_SIZE}) +
00935                                    (second\_offset - \hyperlink{ziplist_8c_a3b8ef40d77ce00bcad424d0c07e2de95}{ZIPLIST\_HEADER\_SIZE}));
00936 
00937     \textcolor{comment}{/* \_\_ziplistCascadeUpdate just fixes the prev length values until it finds a}
00938 \textcolor{comment}{     * correct prev length value (then it assumes the rest of the list is okay).}
00939 \textcolor{comment}{     * We tell CascadeUpdate to start at the first ziplist's tail element to fix}
00940 \textcolor{comment}{     * the merge seam. */}
00941     target = \_\_ziplistCascadeUpdate(target, target+first\_offset);
00942 
00943     \textcolor{comment}{/* Now free and NULL out what we didn't realloc */}
00944     \textcolor{keywordflow}{if} (append) \{
00945         zfree(*second);
00946         *second = NULL;
00947         *first = target;
00948     \} \textcolor{keywordflow}{else} \{
00949         zfree(*first);
00950         *first = NULL;
00951         *second = target;
00952     \}
00953     \textcolor{keywordflow}{return} target;
00954 \}
00955 
00956 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ziplistPush(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *s, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} slen, \textcolor{keywordtype}{int} where) \{
00957     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p;
00958     p = (where == \hyperlink{ziplist_8h_a88d32e547c509220e1c50cd9306186ba}{ZIPLIST\_HEAD}) ? \hyperlink{ziplist_8c_a4f6c9857a0ae335f2c4b214b63b5a6c8}{ZIPLIST\_ENTRY\_HEAD}(zl) : 
      \hyperlink{ziplist_8c_a6e98a67acf629dd869bb532a1d339ccd}{ZIPLIST\_ENTRY\_END}(zl);
00959     \textcolor{keywordflow}{return} \_\_ziplistInsert(zl,p,s,slen);
00960 \}
00961 
00962 \textcolor{comment}{/* Returns an offset to use for iterating with ziplistNext. When the given}
00963 \textcolor{comment}{ * index is negative, the list is traversed back to front. When the list}
00964 \textcolor{comment}{ * doesn't contain an element at the provided index, NULL is returned. */}
00965 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ziplistIndex(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, \textcolor{keywordtype}{int} index) \{
00966     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p;
00967     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} prevlensize, prevlen = 0;
00968     \textcolor{keywordflow}{if} (index < 0) \{
00969         index = (-index)-1;
00970         p = \hyperlink{ziplist_8c_a13a02cab4315ab94186102584601273e}{ZIPLIST\_ENTRY\_TAIL}(zl);
00971         \textcolor{keywordflow}{if} (p[0] != \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END}) \{
00972             \hyperlink{ziplist_8c_a3e5b2bc4707dc1097db2726494cc3728}{ZIP\_DECODE\_PREVLEN}(p, prevlensize, prevlen);
00973             \textcolor{keywordflow}{while} (prevlen > 0 && index--) \{
00974                 p -= prevlen;
00975                 \hyperlink{ziplist_8c_a3e5b2bc4707dc1097db2726494cc3728}{ZIP\_DECODE\_PREVLEN}(p, prevlensize, prevlen);
00976             \}
00977         \}
00978     \} \textcolor{keywordflow}{else} \{
00979         p = \hyperlink{ziplist_8c_a4f6c9857a0ae335f2c4b214b63b5a6c8}{ZIPLIST\_ENTRY\_HEAD}(zl);
00980         \textcolor{keywordflow}{while} (p[0] != \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END} && index--) \{
00981             p += zipRawEntryLength(p);
00982         \}
00983     \}
00984     \textcolor{keywordflow}{return} (p[0] == \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END} || index > 0) ? NULL : p;
00985 \}
00986 
00987 \textcolor{comment}{/* Return pointer to next entry in ziplist.}
00988 \textcolor{comment}{ *}
00989 \textcolor{comment}{ * zl is the pointer to the ziplist}
00990 \textcolor{comment}{ * p is the pointer to the current element}
00991 \textcolor{comment}{ *}
00992 \textcolor{comment}{ * The element after 'p' is returned, otherwise NULL if we are at the end. */}
00993 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ziplistNext(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p) \{
00994     ((\textcolor{keywordtype}{void}) zl);
00995 
00996     \textcolor{comment}{/* "p" could be equal to ZIP\_END, caused by ziplistDelete,}
00997 \textcolor{comment}{     * and we should return NULL. Otherwise, we should return NULL}
00998 \textcolor{comment}{     * when the *next* element is ZIP\_END (there is no next entry). */}
00999     \textcolor{keywordflow}{if} (p[0] == \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END}) \{
01000         \textcolor{keywordflow}{return} NULL;
01001     \}
01002 
01003     p += zipRawEntryLength(p);
01004     \textcolor{keywordflow}{if} (p[0] == \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END}) \{
01005         \textcolor{keywordflow}{return} NULL;
01006     \}
01007 
01008     \textcolor{keywordflow}{return} p;
01009 \}
01010 
01011 \textcolor{comment}{/* Return pointer to previous entry in ziplist. */}
01012 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ziplistPrev(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p) \{
01013     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} prevlensize, prevlen = 0;
01014 
01015     \textcolor{comment}{/* Iterating backwards from ZIP\_END should return the tail. When "p" is}
01016 \textcolor{comment}{     * equal to the first element of the list, we're already at the head,}
01017 \textcolor{comment}{     * and should return NULL. */}
01018     \textcolor{keywordflow}{if} (p[0] == \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END}) \{
01019         p = \hyperlink{ziplist_8c_a13a02cab4315ab94186102584601273e}{ZIPLIST\_ENTRY\_TAIL}(zl);
01020         \textcolor{keywordflow}{return} (p[0] == \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END}) ? NULL : p;
01021     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (p == \hyperlink{ziplist_8c_a4f6c9857a0ae335f2c4b214b63b5a6c8}{ZIPLIST\_ENTRY\_HEAD}(zl)) \{
01022         \textcolor{keywordflow}{return} NULL;
01023     \} \textcolor{keywordflow}{else} \{
01024         \hyperlink{ziplist_8c_a3e5b2bc4707dc1097db2726494cc3728}{ZIP\_DECODE\_PREVLEN}(p, prevlensize, prevlen);
01025         \hyperlink{redisassert_8h_a993abaa2c168852c1592879472938781}{assert}(prevlen > 0);
01026         \textcolor{keywordflow}{return} p-prevlen;
01027     \}
01028 \}
01029 
01030 \textcolor{comment}{/* Get entry pointed to by 'p' and store in either '*sstr' or 'sval' depending}
01031 \textcolor{comment}{ * on the encoding of the entry. '*sstr' is always set to NULL to be able}
01032 \textcolor{comment}{ * to find out whether the string pointer or the integer value was set.}
01033 \textcolor{comment}{ * Return 0 if 'p' points to the end of the ziplist, 1 otherwise. */}
01034 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} ziplistGet(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **sstr, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *slen, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} *sval) \{
01035     zlentry entry;
01036     \textcolor{keywordflow}{if} (p == NULL || p[0] == \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END}) \textcolor{keywordflow}{return} 0;
01037     \textcolor{keywordflow}{if} (sstr) *sstr = NULL;
01038 
01039     zipEntry(p, &entry);
01040     \textcolor{keywordflow}{if} (\hyperlink{ziplist_8c_a2cb79e478d5bda74592c92230cfd6761}{ZIP\_IS\_STR}(entry.encoding)) \{
01041         \textcolor{keywordflow}{if} (sstr) \{
01042             *slen = entry.len;
01043             *sstr = p+entry.headersize;
01044         \}
01045     \} \textcolor{keywordflow}{else} \{
01046         \textcolor{keywordflow}{if} (sval) \{
01047             *sval = zipLoadInteger(p+entry.headersize,entry.encoding);
01048         \}
01049     \}
01050     \textcolor{keywordflow}{return} 1;
01051 \}
01052 
01053 \textcolor{comment}{/* Insert an entry at "p". */}
01054 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ziplistInsert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *s, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} slen)
       \{
01055     \textcolor{keywordflow}{return} \_\_ziplistInsert(zl,p,s,slen);
01056 \}
01057 
01058 \textcolor{comment}{/* Delete a single entry from the ziplist, pointed to by *p.}
01059 \textcolor{comment}{ * Also update *p in place, to be able to iterate over the}
01060 \textcolor{comment}{ * ziplist, while deleting entries. */}
01061 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ziplistDelete(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **p) \{
01062     size\_t offset = *p-zl;
01063     zl = \_\_ziplistDelete(zl,*p,1);
01064 
01065     \textcolor{comment}{/* Store pointer to current element in p, because ziplistDelete will}
01066 \textcolor{comment}{     * do a realloc which might result in a different "zl"-pointer.}
01067 \textcolor{comment}{     * When the delete direction is back to front, we might delete the last}
01068 \textcolor{comment}{     * entry and end up with "p" pointing to ZIP\_END, so check this. */}
01069     *p = zl+offset;
01070     \textcolor{keywordflow}{return} zl;
01071 \}
01072 
01073 \textcolor{comment}{/* Delete a range of entries from the ziplist. */}
01074 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ziplistDeleteRange(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, \textcolor{keywordtype}{int} index, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} num) \{
01075     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p = ziplistIndex(zl,index);
01076     \textcolor{keywordflow}{return} (p == NULL) ? zl : \_\_ziplistDelete(zl,p,num);
01077 \}
01078 
01079 \textcolor{comment}{/* Compare entry pointer to by 'p' with 'sstr' of length 'slen'. */}
01080 \textcolor{comment}{/* Return 1 if equal. */}
01081 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} ziplistCompare(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *sstr, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} slen) \{
01082     zlentry entry;
01083     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} sencoding;
01084     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} zval, sval;
01085     \textcolor{keywordflow}{if} (p[0] == \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END}) \textcolor{keywordflow}{return} 0;
01086 
01087     zipEntry(p, &entry);
01088     \textcolor{keywordflow}{if} (\hyperlink{ziplist_8c_a2cb79e478d5bda74592c92230cfd6761}{ZIP\_IS\_STR}(entry.encoding)) \{
01089         \textcolor{comment}{/* Raw compare */}
01090         \textcolor{keywordflow}{if} (entry.len == slen) \{
01091             \textcolor{keywordflow}{return} memcmp(p+entry.headersize,sstr,slen) == 0;
01092         \} \textcolor{keywordflow}{else} \{
01093             \textcolor{keywordflow}{return} 0;
01094         \}
01095     \} \textcolor{keywordflow}{else} \{
01096         \textcolor{comment}{/* Try to compare encoded values. Don't compare encoding because}
01097 \textcolor{comment}{         * different implementations may encoded integers differently. */}
01098         \textcolor{keywordflow}{if} (zipTryEncoding(sstr,slen,&sval,&sencoding)) \{
01099           zval = zipLoadInteger(p+entry.headersize,entry.encoding);
01100           \textcolor{keywordflow}{return} zval == sval;
01101         \}
01102     \}
01103     \textcolor{keywordflow}{return} 0;
01104 \}
01105 
01106 \textcolor{comment}{/* Find pointer to the entry equal to the specified entry. Skip 'skip' entries}
01107 \textcolor{comment}{ * between every comparison. Returns NULL when the field could not be found. */}
01108 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ziplistFind(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *vstr, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} skip
      ) \{
01109     \textcolor{keywordtype}{int} skipcnt = 0;
01110     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} vencoding = 0;
01111     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} vll = 0;
01112 
01113     \textcolor{keywordflow}{while} (p[0] != \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END}) \{
01114         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} prevlensize, encoding, lensize, len;
01115         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *q;
01116 
01117         \hyperlink{ziplist_8c_a0bae94c4c67cbd6a27ea3e2f17fb0210}{ZIP\_DECODE\_PREVLENSIZE}(p, prevlensize);
01118         \hyperlink{ziplist_8c_acdddca374b430c930d4b2d08f5de7a62}{ZIP\_DECODE\_LENGTH}(p + prevlensize, encoding, lensize, len);
01119         q = p + prevlensize + lensize;
01120 
01121         \textcolor{keywordflow}{if} (skipcnt == 0) \{
01122             \textcolor{comment}{/* Compare current entry with specified entry */}
01123             \textcolor{keywordflow}{if} (\hyperlink{ziplist_8c_a2cb79e478d5bda74592c92230cfd6761}{ZIP\_IS\_STR}(encoding)) \{
01124                 \textcolor{keywordflow}{if} (len == vlen && memcmp(q, vstr, vlen) == 0) \{
01125                     \textcolor{keywordflow}{return} p;
01126                 \}
01127             \} \textcolor{keywordflow}{else} \{
01128                 \textcolor{comment}{/* Find out if the searched field can be encoded. Note that}
01129 \textcolor{comment}{                 * we do it only the first time, once done vencoding is set}
01130 \textcolor{comment}{                 * to non-zero and vll is set to the integer value. */}
01131                 \textcolor{keywordflow}{if} (vencoding == 0) \{
01132                     \textcolor{keywordflow}{if} (!zipTryEncoding(vstr, vlen, &vll, &vencoding)) \{
01133                         \textcolor{comment}{/* If the entry can't be encoded we set it to}
01134 \textcolor{comment}{                         * UCHAR\_MAX so that we don't retry again the next}
01135 \textcolor{comment}{                         * time. */}
01136                         vencoding = UCHAR\_MAX;
01137                     \}
01138                     \textcolor{comment}{/* Must be non-zero by now */}
01139                     \hyperlink{redisassert_8h_a993abaa2c168852c1592879472938781}{assert}(vencoding);
01140                 \}
01141 
01142                 \textcolor{comment}{/* Compare current entry with specified entry, do it only}
01143 \textcolor{comment}{                 * if vencoding != UCHAR\_MAX because if there is no encoding}
01144 \textcolor{comment}{                 * possible for the field it can't be a valid integer. */}
01145                 \textcolor{keywordflow}{if} (vencoding != UCHAR\_MAX) \{
01146                     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ll = zipLoadInteger(q, encoding);
01147                     \textcolor{keywordflow}{if} (ll == vll) \{
01148                         \textcolor{keywordflow}{return} p;
01149                     \}
01150                 \}
01151             \}
01152 
01153             \textcolor{comment}{/* Reset skip count */}
01154             skipcnt = skip;
01155         \} \textcolor{keywordflow}{else} \{
01156             \textcolor{comment}{/* Skip entry */}
01157             skipcnt--;
01158         \}
01159 
01160         \textcolor{comment}{/* Move to next entry */}
01161         p = q + len;
01162     \}
01163 
01164     \textcolor{keywordflow}{return} NULL;
01165 \}
01166 
01167 \textcolor{comment}{/* Return length of ziplist. */}
01168 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} ziplistLen(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl) \{
01169     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len = 0;
01170     \textcolor{keywordflow}{if} (\hyperlink{endianconv_8h_a47540b5867d4cb1e322e83eaf2b50b56}{intrev16ifbe}(\hyperlink{ziplist_8c_a6d779e84aca736e354768fcf87393b98}{ZIPLIST\_LENGTH}(zl)) < UINT16\_MAX) \{
01171         len = \hyperlink{endianconv_8h_a47540b5867d4cb1e322e83eaf2b50b56}{intrev16ifbe}(\hyperlink{ziplist_8c_a6d779e84aca736e354768fcf87393b98}{ZIPLIST\_LENGTH}(zl));
01172     \} \textcolor{keywordflow}{else} \{
01173         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p = zl+\hyperlink{ziplist_8c_a3b8ef40d77ce00bcad424d0c07e2de95}{ZIPLIST\_HEADER\_SIZE};
01174         \textcolor{keywordflow}{while} (*p != \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END}) \{
01175             p += zipRawEntryLength(p);
01176             len++;
01177         \}
01178 
01179         \textcolor{comment}{/* Re-store length if small enough */}
01180         \textcolor{keywordflow}{if} (len < UINT16\_MAX) \hyperlink{ziplist_8c_a6d779e84aca736e354768fcf87393b98}{ZIPLIST\_LENGTH}(zl) = 
      \hyperlink{endianconv_8h_a47540b5867d4cb1e322e83eaf2b50b56}{intrev16ifbe}(len);
01181     \}
01182     \textcolor{keywordflow}{return} len;
01183 \}
01184 
01185 \textcolor{comment}{/* Return ziplist blob size in bytes. */}
01186 size\_t ziplistBlobLen(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl) \{
01187     \textcolor{keywordflow}{return} \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{ziplist_8c_a28b9c7884758bc2d52f204903a4bb642}{ZIPLIST\_BYTES}(zl));
01188 \}
01189 
01190 \textcolor{keywordtype}{void} ziplistRepr(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl) \{
01191     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p;
01192     \textcolor{keywordtype}{int} index = 0;
01193     zlentry entry;
01194 
01195     printf(
01196         \textcolor{stringliteral}{"\{total bytes %d\} "}
01197         \textcolor{stringliteral}{"\{num entries %u\}\(\backslash\)n"}
01198         \textcolor{stringliteral}{"\{tail offset %u\}\(\backslash\)n"},
01199         \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{ziplist_8c_a28b9c7884758bc2d52f204903a4bb642}{ZIPLIST\_BYTES}(zl)),
01200         \hyperlink{endianconv_8h_a47540b5867d4cb1e322e83eaf2b50b56}{intrev16ifbe}(\hyperlink{ziplist_8c_a6d779e84aca736e354768fcf87393b98}{ZIPLIST\_LENGTH}(zl)),
01201         \hyperlink{endianconv_8h_a4e85d9ae58a3b1e6ceaabfd4689002c7}{intrev32ifbe}(\hyperlink{ziplist_8c_adf2235d74c81861c85fb5d2ffa209397}{ZIPLIST\_TAIL\_OFFSET}(zl)));
01202     p = \hyperlink{ziplist_8c_a4f6c9857a0ae335f2c4b214b63b5a6c8}{ZIPLIST\_ENTRY\_HEAD}(zl);
01203     \textcolor{keywordflow}{while}(*p != \hyperlink{ziplist_8c_a31a8f9d5b5bad75318741cfca5de5ea8}{ZIP\_END}) \{
01204         zipEntry(p, &entry);
01205         printf(
01206             \textcolor{stringliteral}{"\{\(\backslash\)n"}
01207                 \textcolor{stringliteral}{"\(\backslash\)taddr 0x%08lx,\(\backslash\)n"}
01208                 \textcolor{stringliteral}{"\(\backslash\)tindex %2d,\(\backslash\)n"}
01209                 \textcolor{stringliteral}{"\(\backslash\)toffset %5ld,\(\backslash\)n"}
01210                 \textcolor{stringliteral}{"\(\backslash\)thdr+entry len: %5u,\(\backslash\)n"}
01211                 \textcolor{stringliteral}{"\(\backslash\)thdr len%2u,\(\backslash\)n"}
01212                 \textcolor{stringliteral}{"\(\backslash\)tprevrawlen: %5u,\(\backslash\)n"}
01213                 \textcolor{stringliteral}{"\(\backslash\)tprevrawlensize: %2u,\(\backslash\)n"}
01214                 \textcolor{stringliteral}{"\(\backslash\)tpayload %5u\(\backslash\)n"},
01215             (\textcolor{keywordtype}{long} \textcolor{keywordtype}{unsigned})p,
01216             index,
01217             (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}) (p-zl),
01218             entry.headersize+entry.len,
01219             entry.headersize,
01220             entry.prevrawlen,
01221             entry.prevrawlensize,
01222             entry.len);
01223         printf(\textcolor{stringliteral}{"\(\backslash\)tbytes: "});
01224         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; i < entry.headersize+entry.len; i++) \{
01225             printf(\textcolor{stringliteral}{"%02x|"},p[i]);
01226         \}
01227         printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01228         p += entry.headersize;
01229         \textcolor{keywordflow}{if} (\hyperlink{ziplist_8c_a2cb79e478d5bda74592c92230cfd6761}{ZIP\_IS\_STR}(entry.encoding)) \{
01230             printf(\textcolor{stringliteral}{"\(\backslash\)t[str]"});
01231             \textcolor{keywordflow}{if} (entry.len > 40) \{
01232                 \textcolor{keywordflow}{if} (fwrite(p,40,1,stdout) == 0) perror(\textcolor{stringliteral}{"fwrite"});
01233                 printf(\textcolor{stringliteral}{"..."});
01234             \} \textcolor{keywordflow}{else} \{
01235                 \textcolor{keywordflow}{if} (entry.len &&
01236                     fwrite(p,entry.len,1,stdout) == 0) perror(\textcolor{stringliteral}{"fwrite"});
01237             \}
01238         \} \textcolor{keywordflow}{else} \{
01239             printf(\textcolor{stringliteral}{"\(\backslash\)t[int]%lld"}, (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) zipLoadInteger(p,entry.encoding));
01240         \}
01241         printf(\textcolor{stringliteral}{"\(\backslash\)n\}\(\backslash\)n"});
01242         p += entry.len;
01243         index++;
01244     \}
01245     printf(\textcolor{stringliteral}{"\{end\}\(\backslash\)n\(\backslash\)n"});
01246 \}
01247 
01248 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \textcolor{preprocessor}{REDIS\_TEST}
01249 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{time}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
01250 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{stringliteral}{"adlist.h"}
01251 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{stringliteral}{"sds.h"}
01252 
01253 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{debug}\textcolor{preprocessor}{(}\textcolor{preprocessor}{f}\textcolor{preprocessor}{,} \textcolor{preprocessor}{...}\textcolor{preprocessor}{)} \textcolor{preprocessor}{\{} \textcolor{preprocessor}{if} \textcolor{preprocessor}{(}\textcolor{preprocessor}{DEBUG}\textcolor{preprocessor}{)} \textcolor{preprocessor}{printf}\textcolor{preprocessor}{(}\textcolor{preprocessor}{f}\textcolor{preprocessor}{,} \textcolor{preprocessor}{\_\_VA\_ARGS\_\_}\textcolor{preprocessor}{)}\textcolor{preprocessor}{;} \textcolor{preprocessor}{\}}
01254 
01255 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *createList() \{
01256     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl = ziplistNew();
01257     zl = ziplistPush(zl, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"foo"}, 3, ZIPLIST\_TAIL);
01258     zl = ziplistPush(zl, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"quux"}, 4, ZIPLIST\_TAIL);
01259     zl = ziplistPush(zl, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"hello"}, 5, ZIPLIST\_HEAD);
01260     zl = ziplistPush(zl, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"1024"}, 4, ZIPLIST\_TAIL);
01261     \textcolor{keywordflow}{return} zl;
01262 \}
01263 
01264 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *createIntList() \{
01265     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl = ziplistNew();
01266     \textcolor{keywordtype}{char} buf[32];
01267 
01268     sprintf(buf, \textcolor{stringliteral}{"100"});
01269     zl = ziplistPush(zl, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)buf, strlen(buf), ZIPLIST\_TAIL);
01270     sprintf(buf, \textcolor{stringliteral}{"128000"});
01271     zl = ziplistPush(zl, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)buf, strlen(buf), ZIPLIST\_TAIL);
01272     sprintf(buf, \textcolor{stringliteral}{"-100"});
01273     zl = ziplistPush(zl, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)buf, strlen(buf), ZIPLIST\_HEAD);
01274     sprintf(buf, \textcolor{stringliteral}{"4294967296"});
01275     zl = ziplistPush(zl, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)buf, strlen(buf), ZIPLIST\_HEAD);
01276     sprintf(buf, \textcolor{stringliteral}{"non integer"});
01277     zl = ziplistPush(zl, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)buf, strlen(buf), ZIPLIST\_TAIL);
01278     sprintf(buf, \textcolor{stringliteral}{"much much longer non integer"});
01279     zl = ziplistPush(zl, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)buf, strlen(buf), ZIPLIST\_TAIL);
01280     \textcolor{keywordflow}{return} zl;
01281 \}
01282 
01283 \textcolor{keyword}{static} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} usec(\textcolor{keywordtype}{void}) \{
01284     \textcolor{keyword}{struct} timeval tv;
01285     gettimeofday(&tv,NULL);
01286     \textcolor{keywordflow}{return} (((\textcolor{keywordtype}{long} \textcolor{keywordtype}{long})tv.tv\_sec)*1000000)+tv.tv\_usec;
01287 \}
01288 
01289 \textcolor{keyword}{static} \textcolor{keywordtype}{void} stress(\textcolor{keywordtype}{int} pos, \textcolor{keywordtype}{int} num, \textcolor{keywordtype}{int} maxsize, \textcolor{keywordtype}{int} dnum) \{
01290     \textcolor{keywordtype}{int} i,j,k;
01291     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl;
01292     \textcolor{keywordtype}{char} posstr[2][5] = \{ \textcolor{stringliteral}{"HEAD"}, \textcolor{stringliteral}{"TAIL"} \};
01293     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} start;
01294     \textcolor{keywordflow}{for} (i = 0; i < maxsize; i+=dnum) \{
01295         zl = ziplistNew();
01296         \textcolor{keywordflow}{for} (j = 0; j < i; j++) \{
01297             zl = ziplistPush(zl,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"quux"},4,ZIPLIST\_TAIL);
01298         \}
01299 
01300         \textcolor{comment}{/* Do num times a push+pop from pos */}
01301         start = usec();
01302         \textcolor{keywordflow}{for} (k = 0; k < num; k++) \{
01303             zl = ziplistPush(zl,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"quux"},4,pos);
01304             zl = ziplistDeleteRange(zl,0,1);
01305         \}
01306         printf(\textcolor{stringliteral}{"List size: %8d, bytes: %8d, %dx push+pop (%s): %6lld usec\(\backslash\)n"},
01307             i,intrev32ifbe(ZIPLIST\_BYTES(zl)),num,posstr[pos],usec()-start);
01308         zfree(zl);
01309     \}
01310 \}
01311 
01312 \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *pop(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, \textcolor{keywordtype}{int} where) \{
01313     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, *vstr;
01314     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} vlen;
01315     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} vlong;
01316 
01317     p = ziplistIndex(zl,where == ZIPLIST\_HEAD ? 0 : -1);
01318     \textcolor{keywordflow}{if} (ziplistGet(p,&vstr,&vlen,&vlong)) \{
01319         \textcolor{keywordflow}{if} (where == ZIPLIST\_HEAD)
01320             printf(\textcolor{stringliteral}{"Pop head: "});
01321         \textcolor{keywordflow}{else}
01322             printf(\textcolor{stringliteral}{"Pop tail: "});
01323 
01324         \textcolor{keywordflow}{if} (vstr) \{
01325             \textcolor{keywordflow}{if} (vlen && fwrite(vstr,vlen,1,stdout) == 0) perror(\textcolor{stringliteral}{"fwrite"});
01326         \}
01327         \textcolor{keywordflow}{else} \{
01328             printf(\textcolor{stringliteral}{"%lld"}, vlong);
01329         \}
01330 
01331         printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01332         \textcolor{keywordflow}{return} ziplistDelete(zl,&p);
01333     \} \textcolor{keywordflow}{else} \{
01334         printf(\textcolor{stringliteral}{"ERROR: Could not pop\(\backslash\)n"});
01335         exit(1);
01336     \}
01337 \}
01338 
01339 \textcolor{keyword}{static} \textcolor{keywordtype}{int} randstring(\textcolor{keywordtype}{char} *target, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} min, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} max) \{
01340     \textcolor{keywordtype}{int} p = 0;
01341     \textcolor{keywordtype}{int} len = min+rand()%(max-min+1);
01342     \textcolor{keywordtype}{int} minval, maxval;
01343     \textcolor{keywordflow}{switch}(rand() % 3) \{
01344     \textcolor{keywordflow}{case} 0:
01345         minval = 0;
01346         maxval = 255;
01347     \textcolor{keywordflow}{break};
01348     \textcolor{keywordflow}{case} 1:
01349         minval = 48;
01350         maxval = 122;
01351     \textcolor{keywordflow}{break};
01352     \textcolor{keywordflow}{case} 2:
01353         minval = 48;
01354         maxval = 52;
01355     \textcolor{keywordflow}{break};
01356     \textcolor{keywordflow}{default}:
01357         assert(NULL);
01358     \}
01359 
01360     \textcolor{keywordflow}{while}(p < len)
01361         target[p++] = minval+rand()%(maxval-minval+1);
01362     \textcolor{keywordflow}{return} len;
01363 \}
01364 
01365 \textcolor{keyword}{static} \textcolor{keywordtype}{void} verify(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, zlentry *e) \{
01366     \textcolor{keywordtype}{int} len = ziplistLen(zl);
01367     zlentry \_e;
01368 
01369     ZIPLIST\_ENTRY\_ZERO(&\_e);
01370 
01371     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < len; i++) \{
01372         memset(&e[i], 0, \textcolor{keyword}{sizeof}(zlentry));
01373         zipEntry(ziplistIndex(zl, i), &e[i]);
01374 
01375         memset(&\_e, 0, \textcolor{keyword}{sizeof}(zlentry));
01376         zipEntry(ziplistIndex(zl, -len+i), &\_e);
01377 
01378         assert(memcmp(&e[i], &\_e, \textcolor{keyword}{sizeof}(zlentry)) == 0);
01379     \}
01380 \}
01381 
01382 \textcolor{keywordtype}{int} ziplistTest(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
01383     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl, *p;
01384     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *entry;
01385     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} elen;
01386     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value;
01387 
01388     \textcolor{comment}{/* If an argument is given, use it as the random seed. */}
01389     \textcolor{keywordflow}{if} (argc == 2)
01390         srand(atoi(argv[1]));
01391 
01392     zl = createIntList();
01393     ziplistRepr(zl);
01394 
01395     zfree(zl);
01396 
01397     zl = createList();
01398     ziplistRepr(zl);
01399 
01400     zl = pop(zl,ZIPLIST\_TAIL);
01401     ziplistRepr(zl);
01402 
01403     zl = pop(zl,ZIPLIST\_HEAD);
01404     ziplistRepr(zl);
01405 
01406     zl = pop(zl,ZIPLIST\_TAIL);
01407     ziplistRepr(zl);
01408 
01409     zl = pop(zl,ZIPLIST\_TAIL);
01410     ziplistRepr(zl);
01411 
01412     zfree(zl);
01413 
01414     printf(\textcolor{stringliteral}{"Get element at index 3:\(\backslash\)n"});
01415     \{
01416         zl = createList();
01417         p = ziplistIndex(zl, 3);
01418         \textcolor{keywordflow}{if} (!ziplistGet(p, &entry, &elen, &value)) \{
01419             printf(\textcolor{stringliteral}{"ERROR: Could not access index 3\(\backslash\)n"});
01420             \textcolor{keywordflow}{return} 1;
01421         \}
01422         \textcolor{keywordflow}{if} (entry) \{
01423             \textcolor{keywordflow}{if} (elen && fwrite(entry,elen,1,stdout) == 0) perror(\textcolor{stringliteral}{"fwrite"});
01424             printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01425         \} \textcolor{keywordflow}{else} \{
01426             printf(\textcolor{stringliteral}{"%lld\(\backslash\)n"}, value);
01427         \}
01428         printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01429         zfree(zl);
01430     \}
01431 
01432     printf(\textcolor{stringliteral}{"Get element at index 4 (out of range):\(\backslash\)n"});
01433     \{
01434         zl = createList();
01435         p = ziplistIndex(zl, 4);
01436         \textcolor{keywordflow}{if} (p == NULL) \{
01437             printf(\textcolor{stringliteral}{"No entry\(\backslash\)n"});
01438         \} \textcolor{keywordflow}{else} \{
01439             printf(\textcolor{stringliteral}{"ERROR: Out of range index should return NULL, returned offset: %ld\(\backslash\)n"}, p-zl);
01440             \textcolor{keywordflow}{return} 1;
01441         \}
01442         printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01443         zfree(zl);
01444     \}
01445 
01446     printf(\textcolor{stringliteral}{"Get element at index -1 (last element):\(\backslash\)n"});
01447     \{
01448         zl = createList();
01449         p = ziplistIndex(zl, -1);
01450         \textcolor{keywordflow}{if} (!ziplistGet(p, &entry, &elen, &value)) \{
01451             printf(\textcolor{stringliteral}{"ERROR: Could not access index -1\(\backslash\)n"});
01452             \textcolor{keywordflow}{return} 1;
01453         \}
01454         \textcolor{keywordflow}{if} (entry) \{
01455             \textcolor{keywordflow}{if} (elen && fwrite(entry,elen,1,stdout) == 0) perror(\textcolor{stringliteral}{"fwrite"});
01456             printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01457         \} \textcolor{keywordflow}{else} \{
01458             printf(\textcolor{stringliteral}{"%lld\(\backslash\)n"}, value);
01459         \}
01460         printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01461         zfree(zl);
01462     \}
01463 
01464     printf(\textcolor{stringliteral}{"Get element at index -4 (first element):\(\backslash\)n"});
01465     \{
01466         zl = createList();
01467         p = ziplistIndex(zl, -4);
01468         \textcolor{keywordflow}{if} (!ziplistGet(p, &entry, &elen, &value)) \{
01469             printf(\textcolor{stringliteral}{"ERROR: Could not access index -4\(\backslash\)n"});
01470             \textcolor{keywordflow}{return} 1;
01471         \}
01472         \textcolor{keywordflow}{if} (entry) \{
01473             \textcolor{keywordflow}{if} (elen && fwrite(entry,elen,1,stdout) == 0) perror(\textcolor{stringliteral}{"fwrite"});
01474             printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01475         \} \textcolor{keywordflow}{else} \{
01476             printf(\textcolor{stringliteral}{"%lld\(\backslash\)n"}, value);
01477         \}
01478         printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01479         zfree(zl);
01480     \}
01481 
01482     printf(\textcolor{stringliteral}{"Get element at index -5 (reverse out of range):\(\backslash\)n"});
01483     \{
01484         zl = createList();
01485         p = ziplistIndex(zl, -5);
01486         \textcolor{keywordflow}{if} (p == NULL) \{
01487             printf(\textcolor{stringliteral}{"No entry\(\backslash\)n"});
01488         \} \textcolor{keywordflow}{else} \{
01489             printf(\textcolor{stringliteral}{"ERROR: Out of range index should return NULL, returned offset: %ld\(\backslash\)n"}, p-zl);
01490             \textcolor{keywordflow}{return} 1;
01491         \}
01492         printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01493         zfree(zl);
01494     \}
01495 
01496     printf(\textcolor{stringliteral}{"Iterate list from 0 to end:\(\backslash\)n"});
01497     \{
01498         zl = createList();
01499         p = ziplistIndex(zl, 0);
01500         \textcolor{keywordflow}{while} (ziplistGet(p, &entry, &elen, &value)) \{
01501             printf(\textcolor{stringliteral}{"Entry: "});
01502             \textcolor{keywordflow}{if} (entry) \{
01503                 \textcolor{keywordflow}{if} (elen && fwrite(entry,elen,1,stdout) == 0) perror(\textcolor{stringliteral}{"fwrite"});
01504             \} \textcolor{keywordflow}{else} \{
01505                 printf(\textcolor{stringliteral}{"%lld"}, value);
01506             \}
01507             p = ziplistNext(zl,p);
01508             printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01509         \}
01510         printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01511         zfree(zl);
01512     \}
01513 
01514     printf(\textcolor{stringliteral}{"Iterate list from 1 to end:\(\backslash\)n"});
01515     \{
01516         zl = createList();
01517         p = ziplistIndex(zl, 1);
01518         \textcolor{keywordflow}{while} (ziplistGet(p, &entry, &elen, &value)) \{
01519             printf(\textcolor{stringliteral}{"Entry: "});
01520             \textcolor{keywordflow}{if} (entry) \{
01521                 \textcolor{keywordflow}{if} (elen && fwrite(entry,elen,1,stdout) == 0) perror(\textcolor{stringliteral}{"fwrite"});
01522             \} \textcolor{keywordflow}{else} \{
01523                 printf(\textcolor{stringliteral}{"%lld"}, value);
01524             \}
01525             p = ziplistNext(zl,p);
01526             printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01527         \}
01528         printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01529         zfree(zl);
01530     \}
01531 
01532     printf(\textcolor{stringliteral}{"Iterate list from 2 to end:\(\backslash\)n"});
01533     \{
01534         zl = createList();
01535         p = ziplistIndex(zl, 2);
01536         \textcolor{keywordflow}{while} (ziplistGet(p, &entry, &elen, &value)) \{
01537             printf(\textcolor{stringliteral}{"Entry: "});
01538             \textcolor{keywordflow}{if} (entry) \{
01539                 \textcolor{keywordflow}{if} (elen && fwrite(entry,elen,1,stdout) == 0) perror(\textcolor{stringliteral}{"fwrite"});
01540             \} \textcolor{keywordflow}{else} \{
01541                 printf(\textcolor{stringliteral}{"%lld"}, value);
01542             \}
01543             p = ziplistNext(zl,p);
01544             printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01545         \}
01546         printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01547         zfree(zl);
01548     \}
01549 
01550     printf(\textcolor{stringliteral}{"Iterate starting out of range:\(\backslash\)n"});
01551     \{
01552         zl = createList();
01553         p = ziplistIndex(zl, 4);
01554         \textcolor{keywordflow}{if} (!ziplistGet(p, &entry, &elen, &value)) \{
01555             printf(\textcolor{stringliteral}{"No entry\(\backslash\)n"});
01556         \} \textcolor{keywordflow}{else} \{
01557             printf(\textcolor{stringliteral}{"ERROR\(\backslash\)n"});
01558         \}
01559         printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01560         zfree(zl);
01561     \}
01562 
01563     printf(\textcolor{stringliteral}{"Iterate from back to front:\(\backslash\)n"});
01564     \{
01565         zl = createList();
01566         p = ziplistIndex(zl, -1);
01567         \textcolor{keywordflow}{while} (ziplistGet(p, &entry, &elen, &value)) \{
01568             printf(\textcolor{stringliteral}{"Entry: "});
01569             \textcolor{keywordflow}{if} (entry) \{
01570                 \textcolor{keywordflow}{if} (elen && fwrite(entry,elen,1,stdout) == 0) perror(\textcolor{stringliteral}{"fwrite"});
01571             \} \textcolor{keywordflow}{else} \{
01572                 printf(\textcolor{stringliteral}{"%lld"}, value);
01573             \}
01574             p = ziplistPrev(zl,p);
01575             printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01576         \}
01577         printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01578         zfree(zl);
01579     \}
01580 
01581     printf(\textcolor{stringliteral}{"Iterate from back to front, deleting all items:\(\backslash\)n"});
01582     \{
01583         zl = createList();
01584         p = ziplistIndex(zl, -1);
01585         \textcolor{keywordflow}{while} (ziplistGet(p, &entry, &elen, &value)) \{
01586             printf(\textcolor{stringliteral}{"Entry: "});
01587             \textcolor{keywordflow}{if} (entry) \{
01588                 \textcolor{keywordflow}{if} (elen && fwrite(entry,elen,1,stdout) == 0) perror(\textcolor{stringliteral}{"fwrite"});
01589             \} \textcolor{keywordflow}{else} \{
01590                 printf(\textcolor{stringliteral}{"%lld"}, value);
01591             \}
01592             zl = ziplistDelete(zl,&p);
01593             p = ziplistPrev(zl,p);
01594             printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01595         \}
01596         printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01597         zfree(zl);
01598     \}
01599 
01600     printf(\textcolor{stringliteral}{"Delete inclusive range 0,0:\(\backslash\)n"});
01601     \{
01602         zl = createList();
01603         zl = ziplistDeleteRange(zl, 0, 1);
01604         ziplistRepr(zl);
01605         zfree(zl);
01606     \}
01607 
01608     printf(\textcolor{stringliteral}{"Delete inclusive range 0,1:\(\backslash\)n"});
01609     \{
01610         zl = createList();
01611         zl = ziplistDeleteRange(zl, 0, 2);
01612         ziplistRepr(zl);
01613         zfree(zl);
01614     \}
01615 
01616     printf(\textcolor{stringliteral}{"Delete inclusive range 1,2:\(\backslash\)n"});
01617     \{
01618         zl = createList();
01619         zl = ziplistDeleteRange(zl, 1, 2);
01620         ziplistRepr(zl);
01621         zfree(zl);
01622     \}
01623 
01624     printf(\textcolor{stringliteral}{"Delete with start index out of range:\(\backslash\)n"});
01625     \{
01626         zl = createList();
01627         zl = ziplistDeleteRange(zl, 5, 1);
01628         ziplistRepr(zl);
01629         zfree(zl);
01630     \}
01631 
01632     printf(\textcolor{stringliteral}{"Delete with num overflow:\(\backslash\)n"});
01633     \{
01634         zl = createList();
01635         zl = ziplistDeleteRange(zl, 1, 5);
01636         ziplistRepr(zl);
01637         zfree(zl);
01638     \}
01639 
01640     printf(\textcolor{stringliteral}{"Delete foo while iterating:\(\backslash\)n"});
01641     \{
01642         zl = createList();
01643         p = ziplistIndex(zl,0);
01644         \textcolor{keywordflow}{while} (ziplistGet(p,&entry,&elen,&value)) \{
01645             \textcolor{keywordflow}{if} (entry && strncmp(\textcolor{stringliteral}{"foo"},(\textcolor{keywordtype}{char}*)entry,elen) == 0) \{
01646                 printf(\textcolor{stringliteral}{"Delete foo\(\backslash\)n"});
01647                 zl = ziplistDelete(zl,&p);
01648             \} \textcolor{keywordflow}{else} \{
01649                 printf(\textcolor{stringliteral}{"Entry: "});
01650                 \textcolor{keywordflow}{if} (entry) \{
01651                     \textcolor{keywordflow}{if} (elen && fwrite(entry,elen,1,stdout) == 0)
01652                         perror(\textcolor{stringliteral}{"fwrite"});
01653                 \} \textcolor{keywordflow}{else} \{
01654                     printf(\textcolor{stringliteral}{"%lld"},value);
01655                 \}
01656                 p = ziplistNext(zl,p);
01657                 printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01658             \}
01659         \}
01660         printf(\textcolor{stringliteral}{"\(\backslash\)n"});
01661         ziplistRepr(zl);
01662         zfree(zl);
01663     \}
01664 
01665     printf(\textcolor{stringliteral}{"Regression test for >255 byte strings:\(\backslash\)n"});
01666     \{
01667         \textcolor{keywordtype}{char} v1[257] = \{0\}, v2[257] = \{0\};
01668         memset(v1,\textcolor{stringliteral}{'x'},256);
01669         memset(v2,\textcolor{stringliteral}{'y'},256);
01670         zl = ziplistNew();
01671         zl = ziplistPush(zl,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)v1,strlen(v1),ZIPLIST\_TAIL);
01672         zl = ziplistPush(zl,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)v2,strlen(v2),ZIPLIST\_TAIL);
01673 
01674         \textcolor{comment}{/* Pop values again and compare their value. */}
01675         p = ziplistIndex(zl,0);
01676         assert(ziplistGet(p,&entry,&elen,&value));
01677         assert(strncmp(v1,(\textcolor{keywordtype}{char}*)entry,elen) == 0);
01678         p = ziplistIndex(zl,1);
01679         assert(ziplistGet(p,&entry,&elen,&value));
01680         assert(strncmp(v2,(\textcolor{keywordtype}{char}*)entry,elen) == 0);
01681         printf(\textcolor{stringliteral}{"SUCCESS\(\backslash\)n\(\backslash\)n"});
01682         zfree(zl);
01683     \}
01684 
01685     printf(\textcolor{stringliteral}{"Regression test deleting next to last entries:\(\backslash\)n"});
01686     \{
01687         \textcolor{keywordtype}{char} v[3][257] = \{\{0\}\};
01688         zlentry e[3] = \{\{.prevrawlensize = 0, .prevrawlen = 0, .lensize = 0,
01689                          .len = 0, .headersize = 0, .encoding = 0, .p = NULL\}\};
01690         size\_t i;
01691 
01692         \textcolor{keywordflow}{for} (i = 0; i < (\textcolor{keyword}{sizeof}(v)/\textcolor{keyword}{sizeof}(v[0])); i++) \{
01693             memset(v[i], \textcolor{stringliteral}{'a'} + i, \textcolor{keyword}{sizeof}(v[0]));
01694         \}
01695 
01696         v[0][256] = \textcolor{stringliteral}{'\(\backslash\)0'};
01697         v[1][  1] = \textcolor{stringliteral}{'\(\backslash\)0'};
01698         v[2][256] = \textcolor{stringliteral}{'\(\backslash\)0'};
01699 
01700         zl = ziplistNew();
01701         \textcolor{keywordflow}{for} (i = 0; i < (\textcolor{keyword}{sizeof}(v)/\textcolor{keyword}{sizeof}(v[0])); i++) \{
01702             zl = ziplistPush(zl, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *) v[i], strlen(v[i]), ZIPLIST\_TAIL);
01703         \}
01704 
01705         verify(zl, e);
01706 
01707         assert(e[0].prevrawlensize == 1);
01708         assert(e[1].prevrawlensize == 5);
01709         assert(e[2].prevrawlensize == 1);
01710 
01711         \textcolor{comment}{/* Deleting entry 1 will increase `prevrawlensize` for entry 2 */}
01712         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p = e[1].p;
01713         zl = ziplistDelete(zl, &p);
01714 
01715         verify(zl, e);
01716 
01717         assert(e[0].prevrawlensize == 1);
01718         assert(e[1].prevrawlensize == 5);
01719 
01720         printf(\textcolor{stringliteral}{"SUCCESS\(\backslash\)n\(\backslash\)n"});
01721         zfree(zl);
01722     \}
01723 
01724     printf(\textcolor{stringliteral}{"Create long list and check indices:\(\backslash\)n"});
01725     \{
01726         zl = ziplistNew();
01727         \textcolor{keywordtype}{char} buf[32];
01728         \textcolor{keywordtype}{int} i,len;
01729         \textcolor{keywordflow}{for} (i = 0; i < 1000; i++) \{
01730             len = sprintf(buf,\textcolor{stringliteral}{"%d"},i);
01731             zl = ziplistPush(zl,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)buf,len,ZIPLIST\_TAIL);
01732         \}
01733         \textcolor{keywordflow}{for} (i = 0; i < 1000; i++) \{
01734             p = ziplistIndex(zl,i);
01735             assert(ziplistGet(p,NULL,NULL,&value));
01736             assert(i == value);
01737 
01738             p = ziplistIndex(zl,-i-1);
01739             assert(ziplistGet(p,NULL,NULL,&value));
01740             assert(999-i == value);
01741         \}
01742         printf(\textcolor{stringliteral}{"SUCCESS\(\backslash\)n\(\backslash\)n"});
01743         zfree(zl);
01744     \}
01745 
01746     printf(\textcolor{stringliteral}{"Compare strings with ziplist entries:\(\backslash\)n"});
01747     \{
01748         zl = createList();
01749         p = ziplistIndex(zl,0);
01750         \textcolor{keywordflow}{if} (!ziplistCompare(p,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"hello"},5)) \{
01751             printf(\textcolor{stringliteral}{"ERROR: not \(\backslash\)"hello\(\backslash\)"\(\backslash\)n"});
01752             \textcolor{keywordflow}{return} 1;
01753         \}
01754         \textcolor{keywordflow}{if} (ziplistCompare(p,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"hella"},5)) \{
01755             printf(\textcolor{stringliteral}{"ERROR: \(\backslash\)"hella\(\backslash\)"\(\backslash\)n"});
01756             \textcolor{keywordflow}{return} 1;
01757         \}
01758 
01759         p = ziplistIndex(zl,3);
01760         \textcolor{keywordflow}{if} (!ziplistCompare(p,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"1024"},4)) \{
01761             printf(\textcolor{stringliteral}{"ERROR: not \(\backslash\)"1024\(\backslash\)"\(\backslash\)n"});
01762             \textcolor{keywordflow}{return} 1;
01763         \}
01764         \textcolor{keywordflow}{if} (ziplistCompare(p,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"1025"},4)) \{
01765             printf(\textcolor{stringliteral}{"ERROR: \(\backslash\)"1025\(\backslash\)"\(\backslash\)n"});
01766             \textcolor{keywordflow}{return} 1;
01767         \}
01768         printf(\textcolor{stringliteral}{"SUCCESS\(\backslash\)n\(\backslash\)n"});
01769         zfree(zl);
01770     \}
01771 
01772     printf(\textcolor{stringliteral}{"Merge test:\(\backslash\)n"});
01773     \{
01774         \textcolor{comment}{/* create list gives us: [hello, foo, quux, 1024] */}
01775         zl = createList();
01776         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl2 = createList();
01777 
01778         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl3 = ziplistNew();
01779         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl4 = ziplistNew();
01780 
01781         \textcolor{keywordflow}{if} (ziplistMerge(&zl4, &zl4)) \{
01782             printf(\textcolor{stringliteral}{"ERROR: Allowed merging of one ziplist into itself.\(\backslash\)n"});
01783             \textcolor{keywordflow}{return} 1;
01784         \}
01785 
01786         \textcolor{comment}{/* Merge two empty ziplists, get empty result back. */}
01787         zl4 = ziplistMerge(&zl3, &zl4);
01788         ziplistRepr(zl4);
01789         \textcolor{keywordflow}{if} (ziplistLen(zl4)) \{
01790             printf(\textcolor{stringliteral}{"ERROR: Merging two empty ziplists created entries.\(\backslash\)n"});
01791             \textcolor{keywordflow}{return} 1;
01792         \}
01793         zfree(zl4);
01794 
01795         zl2 = ziplistMerge(&zl, &zl2);
01796         \textcolor{comment}{/* merge gives us: [hello, foo, quux, 1024, hello, foo, quux, 1024] */}
01797         ziplistRepr(zl2);
01798 
01799         \textcolor{keywordflow}{if} (ziplistLen(zl2) != 8) \{
01800             printf(\textcolor{stringliteral}{"ERROR: Merged length not 8, but: %u\(\backslash\)n"}, ziplistLen(zl2));
01801             \textcolor{keywordflow}{return} 1;
01802         \}
01803 
01804         p = ziplistIndex(zl2,0);
01805         \textcolor{keywordflow}{if} (!ziplistCompare(p,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"hello"},5)) \{
01806             printf(\textcolor{stringliteral}{"ERROR: not \(\backslash\)"hello\(\backslash\)"\(\backslash\)n"});
01807             \textcolor{keywordflow}{return} 1;
01808         \}
01809         \textcolor{keywordflow}{if} (ziplistCompare(p,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"hella"},5)) \{
01810             printf(\textcolor{stringliteral}{"ERROR: \(\backslash\)"hella\(\backslash\)"\(\backslash\)n"});
01811             \textcolor{keywordflow}{return} 1;
01812         \}
01813 
01814         p = ziplistIndex(zl2,3);
01815         \textcolor{keywordflow}{if} (!ziplistCompare(p,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"1024"},4)) \{
01816             printf(\textcolor{stringliteral}{"ERROR: not \(\backslash\)"1024\(\backslash\)"\(\backslash\)n"});
01817             \textcolor{keywordflow}{return} 1;
01818         \}
01819         \textcolor{keywordflow}{if} (ziplistCompare(p,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"1025"},4)) \{
01820             printf(\textcolor{stringliteral}{"ERROR: \(\backslash\)"1025\(\backslash\)"\(\backslash\)n"});
01821             \textcolor{keywordflow}{return} 1;
01822         \}
01823 
01824         p = ziplistIndex(zl2,4);
01825         \textcolor{keywordflow}{if} (!ziplistCompare(p,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"hello"},5)) \{
01826             printf(\textcolor{stringliteral}{"ERROR: not \(\backslash\)"hello\(\backslash\)"\(\backslash\)n"});
01827             \textcolor{keywordflow}{return} 1;
01828         \}
01829         \textcolor{keywordflow}{if} (ziplistCompare(p,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"hella"},5)) \{
01830             printf(\textcolor{stringliteral}{"ERROR: \(\backslash\)"hella\(\backslash\)"\(\backslash\)n"});
01831             \textcolor{keywordflow}{return} 1;
01832         \}
01833 
01834         p = ziplistIndex(zl2,7);
01835         \textcolor{keywordflow}{if} (!ziplistCompare(p,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"1024"},4)) \{
01836             printf(\textcolor{stringliteral}{"ERROR: not \(\backslash\)"1024\(\backslash\)"\(\backslash\)n"});
01837             \textcolor{keywordflow}{return} 1;
01838         \}
01839         \textcolor{keywordflow}{if} (ziplistCompare(p,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"1025"},4)) \{
01840             printf(\textcolor{stringliteral}{"ERROR: \(\backslash\)"1025\(\backslash\)"\(\backslash\)n"});
01841             \textcolor{keywordflow}{return} 1;
01842         \}
01843         printf(\textcolor{stringliteral}{"SUCCESS\(\backslash\)n\(\backslash\)n"});
01844         zfree(zl);
01845     \}
01846 
01847     printf(\textcolor{stringliteral}{"Stress with random payloads of different encoding:\(\backslash\)n"});
01848     \{
01849         \textcolor{keywordtype}{int} i,j,len,where;
01850         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p;
01851         \textcolor{keywordtype}{char} buf[1024];
01852         \textcolor{keywordtype}{int} buflen;
01853         list *ref;
01854         listNode *refnode;
01855 
01856         \textcolor{comment}{/* Hold temp vars from ziplist */}
01857         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *sstr;
01858         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} slen;
01859         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} sval;
01860 
01861         \textcolor{keywordflow}{for} (i = 0; i < 20000; i++) \{
01862             zl = ziplistNew();
01863             ref = listCreate();
01864             listSetFreeMethod(ref,(\textcolor{keywordtype}{void} (*)(\textcolor{keywordtype}{void}*))sdsfree);
01865             len = rand() % 256;
01866 
01867             \textcolor{comment}{/* Create lists */}
01868             \textcolor{keywordflow}{for} (j = 0; j < len; j++) \{
01869                 where = (rand() & 1) ? ZIPLIST\_HEAD : ZIPLIST\_TAIL;
01870                 \textcolor{keywordflow}{if} (rand() % 2) \{
01871                     buflen = randstring(buf,1,\textcolor{keyword}{sizeof}(buf)-1);
01872                 \} \textcolor{keywordflow}{else} \{
01873                     \textcolor{keywordflow}{switch}(rand() % 3) \{
01874                     \textcolor{keywordflow}{case} 0:
01875                         buflen = sprintf(buf,\textcolor{stringliteral}{"%lld"},(0LL + rand()) >> 20);
01876                         \textcolor{keywordflow}{break};
01877                     \textcolor{keywordflow}{case} 1:
01878                         buflen = sprintf(buf,\textcolor{stringliteral}{"%lld"},(0LL + rand()));
01879                         \textcolor{keywordflow}{break};
01880                     \textcolor{keywordflow}{case} 2:
01881                         buflen = sprintf(buf,\textcolor{stringliteral}{"%lld"},(0LL + rand()) << 20);
01882                         \textcolor{keywordflow}{break};
01883                     \textcolor{keywordflow}{default}:
01884                         assert(NULL);
01885                     \}
01886                 \}
01887 
01888                 \textcolor{comment}{/* Add to ziplist */}
01889                 zl = ziplistPush(zl, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)buf, buflen, where);
01890 
01891                 \textcolor{comment}{/* Add to reference list */}
01892                 \textcolor{keywordflow}{if} (where == ZIPLIST\_HEAD) \{
01893                     listAddNodeHead(ref,sdsnewlen(buf, buflen));
01894                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (where == ZIPLIST\_TAIL) \{
01895                     listAddNodeTail(ref,sdsnewlen(buf, buflen));
01896                 \} \textcolor{keywordflow}{else} \{
01897                     assert(NULL);
01898                 \}
01899             \}
01900 
01901             assert(listLength(ref) == ziplistLen(zl));
01902             \textcolor{keywordflow}{for} (j = 0; j < len; j++) \{
01903                 \textcolor{comment}{/* Naive way to get elements, but similar to the stresser}
01904 \textcolor{comment}{                 * executed from the Tcl test suite. */}
01905                 p = ziplistIndex(zl,j);
01906                 refnode = listIndex(ref,j);
01907 
01908                 assert(ziplistGet(p,&sstr,&slen,&sval));
01909                 \textcolor{keywordflow}{if} (sstr == NULL) \{
01910                     buflen = sprintf(buf,\textcolor{stringliteral}{"%lld"},sval);
01911                 \} \textcolor{keywordflow}{else} \{
01912                     buflen = slen;
01913                     memcpy(buf,sstr,buflen);
01914                     buf[buflen] = \textcolor{stringliteral}{'\(\backslash\)0'};
01915                 \}
01916                 assert(memcmp(buf,listNodeValue(refnode),buflen) == 0);
01917             \}
01918             zfree(zl);
01919             listRelease(ref);
01920         \}
01921         printf(\textcolor{stringliteral}{"SUCCESS\(\backslash\)n\(\backslash\)n"});
01922     \}
01923 
01924     printf(\textcolor{stringliteral}{"Stress with variable ziplist size:\(\backslash\)n"});
01925     \{
01926         stress(ZIPLIST\_HEAD,100000,16384,256);
01927         stress(ZIPLIST\_TAIL,100000,16384,256);
01928     \}
01929 
01930     \textcolor{keywordflow}{return} 0;
01931 \}
01932 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
\end{DoxyCode}
