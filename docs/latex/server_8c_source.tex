\hypertarget{server_8c_source}{}\section{server.\+c}
\label{server_8c_source}\index{src/server.\+c@{src/server.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ * Copyright (c) 2009-2016, Salvatore Sanfilippo <antirez at gmail dot com>}
00003 \textcolor{comment}{ * All rights reserved.}
00004 \textcolor{comment}{ *}
00005 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00006 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00007 \textcolor{comment}{ *}
00008 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00009 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00010 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00011 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00012 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00013 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00014 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00015 \textcolor{comment}{ *     specific prior written permission.}
00016 \textcolor{comment}{ *}
00017 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00018 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00019 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00020 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00021 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00022 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00023 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00024 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00025 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00026 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00027 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00028 \textcolor{comment}{ */}
00029 
00030 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{server_8h}{"server.h"}
00031 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{cluster_8h}{"cluster.h"}
00032 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{slowlog_8h}{"slowlog.h"}
00033 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{bio_8h}{"bio.h"}
00034 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{latency_8h}{"latency.h"}
00035 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{atomicvar_8h}{"atomicvar.h"}
00036 
00037 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{time}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00038 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{signal}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00039 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{wait}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00040 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{errno}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00041 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{assert}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00042 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{ctype}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00043 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{stdarg}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00044 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{arpa}\textcolor{preprocessor}{/}\textcolor{preprocessor}{inet}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00045 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{stat}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00046 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{fcntl}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00047 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{time}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00048 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{resource}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00049 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{uio}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00050 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{un}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00051 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{limits}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00052 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{keywordtype}{float}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00053 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{math}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00054 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{resource}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00055 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{utsname}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00056 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{locale}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00057 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{socket}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00058 
00059 \textcolor{comment}{/* Our shared "common" objects */}
00060 
00061 \textcolor{keyword}{struct} \hyperlink{structsharedObjectsStruct}{sharedObjectsStruct} shared;
00062 
00063 \textcolor{comment}{/* Global vars that are actually used as constants. The following double}
00064 \textcolor{comment}{ * values are used for double on-disk serialization, and are initialized}
00065 \textcolor{comment}{ * at runtime to avoid strange compiler optimizations. */}
00066 
00067 \textcolor{keywordtype}{double} R\_Zero, R\_PosInf, R\_NegInf, R\_Nan;
00068 
00069 \textcolor{comment}{/*================================= Globals ================================= */}
00070 
00071 \textcolor{comment}{/* Global vars */}
00072 \textcolor{keyword}{struct} \hyperlink{structredisServer}{redisServer} server; \textcolor{comment}{/* Server global state */}
00073 \textcolor{keyword}{volatile} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} lru\_clock; \textcolor{comment}{/* Server global current LRU time. */}
00074 
00075 \textcolor{comment}{/* Our command table.}
00076 \textcolor{comment}{ *}
00077 \textcolor{comment}{ * Every entry is composed of the following fields:}
00078 \textcolor{comment}{ *}
00079 \textcolor{comment}{ * name: a string representing the command name.}
00080 \textcolor{comment}{ * function: pointer to the C function implementing the command.}
00081 \textcolor{comment}{ * arity: number of arguments, it is possible to use -N to say >= N}
00082 \textcolor{comment}{ * sflags: command flags as string. See below for a table of flags.}
00083 \textcolor{comment}{ * flags: flags as bitmask. Computed by Redis using the 'sflags' field.}
00084 \textcolor{comment}{ * get\_keys\_proc: an optional function to get key arguments from a command.}
00085 \textcolor{comment}{ *                This is only used when the following three fields are not}
00086 \textcolor{comment}{ *                enough to specify what arguments are keys.}
00087 \textcolor{comment}{ * first\_key\_index: first argument that is a key}
00088 \textcolor{comment}{ * last\_key\_index: last argument that is a key}
00089 \textcolor{comment}{ * key\_step: step to get all the keys from first to last argument. For instance}
00090 \textcolor{comment}{ *           in MSET the step is two since arguments are key,val,key,val,...}
00091 \textcolor{comment}{ * microseconds: microseconds of total execution time for this command.}
00092 \textcolor{comment}{ * calls: total number of calls of this command.}
00093 \textcolor{comment}{ *}
00094 \textcolor{comment}{ * The flags, microseconds and calls fields are computed by Redis and should}
00095 \textcolor{comment}{ * always be set to zero.}
00096 \textcolor{comment}{ *}
00097 \textcolor{comment}{ * Command flags are expressed using strings where every character represents}
00098 \textcolor{comment}{ * a flag. Later the populateCommandTable() function will take care of}
00099 \textcolor{comment}{ * populating the real 'flags' field using this characters.}
00100 \textcolor{comment}{ *}
00101 \textcolor{comment}{ * This is the meaning of the flags:}
00102 \textcolor{comment}{ *}
00103 \textcolor{comment}{ * w: write command (may modify the key space).}
00104 \textcolor{comment}{ * r: read command  (will never modify the key space).}
00105 \textcolor{comment}{ * m: may increase memory usage once called. Don't allow if out of memory.}
00106 \textcolor{comment}{ * a: admin command, like SAVE or SHUTDOWN.}
00107 \textcolor{comment}{ * p: Pub/Sub related command.}
00108 \textcolor{comment}{ * f: force replication of this command, regardless of server.dirty.}
00109 \textcolor{comment}{ * s: command not allowed in scripts.}
00110 \textcolor{comment}{ * R: random command. Command is not deterministic, that is, the same command}
00111 \textcolor{comment}{ *    with the same arguments, with the same key space, may have different}
00112 \textcolor{comment}{ *    results. For instance SPOP and RANDOMKEY are two random commands.}
00113 \textcolor{comment}{ * S: Sort command output array if called from script, so that the output}
00114 \textcolor{comment}{ *    is deterministic.}
00115 \textcolor{comment}{ * l: Allow command while loading the database.}
00116 \textcolor{comment}{ * t: Allow command while a slave has stale data but is not allowed to}
00117 \textcolor{comment}{ *    server this data. Normally no command is accepted in this condition}
00118 \textcolor{comment}{ *    but just a few.}
00119 \textcolor{comment}{ * M: Do not automatically propagate the command on MONITOR.}
00120 \textcolor{comment}{ * k: Perform an implicit ASKING for this command, so the command will be}
00121 \textcolor{comment}{ *    accepted in cluster mode if the slot is marked as 'importing'.}
00122 \textcolor{comment}{ * F: Fast command: O(1) or O(log(N)) command that should never delay}
00123 \textcolor{comment}{ *    its execution as long as the kernel scheduler is giving us time.}
00124 \textcolor{comment}{ *    Note that commands that may trigger a DEL as a side effect (like SET)}
00125 \textcolor{comment}{ *    are not fast commands.}
00126 \textcolor{comment}{ */}
00127 \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} redisCommandTable[] = \{
00128     \{\textcolor{stringliteral}{"module"},moduleCommand,-2,\textcolor{stringliteral}{"as"},0,NULL,1,1,1,0,0\},
00129     \{\textcolor{stringliteral}{"get"},getCommand,2,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00130     \{\textcolor{stringliteral}{"set"},setCommand,-3,\textcolor{stringliteral}{"wm"},0,NULL,1,1,1,0,0\},
00131     \{\textcolor{stringliteral}{"setnx"},setnxCommand,3,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00132     \{\textcolor{stringliteral}{"setex"},setexCommand,4,\textcolor{stringliteral}{"wm"},0,NULL,1,1,1,0,0\},
00133     \{\textcolor{stringliteral}{"psetex"},psetexCommand,4,\textcolor{stringliteral}{"wm"},0,NULL,1,1,1,0,0\},
00134     \{\textcolor{stringliteral}{"append"},appendCommand,3,\textcolor{stringliteral}{"wm"},0,NULL,1,1,1,0,0\},
00135     \{\textcolor{stringliteral}{"strlen"},strlenCommand,2,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00136     \{\textcolor{stringliteral}{"del"},delCommand,-2,\textcolor{stringliteral}{"w"},0,NULL,1,-1,1,0,0\},
00137     \{\textcolor{stringliteral}{"unlink"},unlinkCommand,-2,\textcolor{stringliteral}{"wF"},0,NULL,1,-1,1,0,0\},
00138     \{\textcolor{stringliteral}{"exists"},existsCommand,-2,\textcolor{stringliteral}{"rF"},0,NULL,1,-1,1,0,0\},
00139     \{\textcolor{stringliteral}{"setbit"},setbitCommand,4,\textcolor{stringliteral}{"wm"},0,NULL,1,1,1,0,0\},
00140     \{\textcolor{stringliteral}{"getbit"},getbitCommand,3,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00141     \{\textcolor{stringliteral}{"bitfield"},bitfieldCommand,-2,\textcolor{stringliteral}{"wm"},0,NULL,1,1,1,0,0\},
00142     \{\textcolor{stringliteral}{"setrange"},setrangeCommand,4,\textcolor{stringliteral}{"wm"},0,NULL,1,1,1,0,0\},
00143     \{\textcolor{stringliteral}{"getrange"},getrangeCommand,4,\textcolor{stringliteral}{"r"},0,NULL,1,1,1,0,0\},
00144     \{\textcolor{stringliteral}{"substr"},getrangeCommand,4,\textcolor{stringliteral}{"r"},0,NULL,1,1,1,0,0\},
00145     \{\textcolor{stringliteral}{"incr"},incrCommand,2,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00146     \{\textcolor{stringliteral}{"decr"},decrCommand,2,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00147     \{\textcolor{stringliteral}{"mget"},mgetCommand,-2,\textcolor{stringliteral}{"rF"},0,NULL,1,-1,1,0,0\},
00148     \{\textcolor{stringliteral}{"rpush"},rpushCommand,-3,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00149     \{\textcolor{stringliteral}{"lpush"},lpushCommand,-3,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00150     \{\textcolor{stringliteral}{"rpushx"},rpushxCommand,-3,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00151     \{\textcolor{stringliteral}{"lpushx"},lpushxCommand,-3,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00152     \{\textcolor{stringliteral}{"linsert"},linsertCommand,5,\textcolor{stringliteral}{"wm"},0,NULL,1,1,1,0,0\},
00153     \{\textcolor{stringliteral}{"rpop"},rpopCommand,2,\textcolor{stringliteral}{"wF"},0,NULL,1,1,1,0,0\},
00154     \{\textcolor{stringliteral}{"lpop"},lpopCommand,2,\textcolor{stringliteral}{"wF"},0,NULL,1,1,1,0,0\},
00155     \{\textcolor{stringliteral}{"brpop"},brpopCommand,-3,\textcolor{stringliteral}{"ws"},0,NULL,1,-2,1,0,0\},
00156     \{\textcolor{stringliteral}{"brpoplpush"},brpoplpushCommand,4,\textcolor{stringliteral}{"wms"},0,NULL,1,2,1,0,0\},
00157     \{\textcolor{stringliteral}{"blpop"},blpopCommand,-3,\textcolor{stringliteral}{"ws"},0,NULL,1,-2,1,0,0\},
00158     \{\textcolor{stringliteral}{"llen"},llenCommand,2,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00159     \{\textcolor{stringliteral}{"lindex"},lindexCommand,3,\textcolor{stringliteral}{"r"},0,NULL,1,1,1,0,0\},
00160     \{\textcolor{stringliteral}{"lset"},lsetCommand,4,\textcolor{stringliteral}{"wm"},0,NULL,1,1,1,0,0\},
00161     \{\textcolor{stringliteral}{"lrange"},lrangeCommand,4,\textcolor{stringliteral}{"r"},0,NULL,1,1,1,0,0\},
00162     \{\textcolor{stringliteral}{"ltrim"},ltrimCommand,4,\textcolor{stringliteral}{"w"},0,NULL,1,1,1,0,0\},
00163     \{\textcolor{stringliteral}{"lrem"},lremCommand,4,\textcolor{stringliteral}{"w"},0,NULL,1,1,1,0,0\},
00164     \{\textcolor{stringliteral}{"rpoplpush"},rpoplpushCommand,3,\textcolor{stringliteral}{"wm"},0,NULL,1,2,1,0,0\},
00165     \{\textcolor{stringliteral}{"sadd"},saddCommand,-3,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00166     \{\textcolor{stringliteral}{"srem"},sremCommand,-3,\textcolor{stringliteral}{"wF"},0,NULL,1,1,1,0,0\},
00167     \{\textcolor{stringliteral}{"smove"},smoveCommand,4,\textcolor{stringliteral}{"wF"},0,NULL,1,2,1,0,0\},
00168     \{\textcolor{stringliteral}{"sismember"},sismemberCommand,3,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00169     \{\textcolor{stringliteral}{"scard"},scardCommand,2,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00170     \{\textcolor{stringliteral}{"spop"},spopCommand,-2,\textcolor{stringliteral}{"wRF"},0,NULL,1,1,1,0,0\},
00171     \{\textcolor{stringliteral}{"srandmember"},srandmemberCommand,-2,\textcolor{stringliteral}{"rR"},0,NULL,1,1,1,0,0\},
00172     \{\textcolor{stringliteral}{"sinter"},sinterCommand,-2,\textcolor{stringliteral}{"rS"},0,NULL,1,-1,1,0,0\},
00173     \{\textcolor{stringliteral}{"sinterstore"},sinterstoreCommand,-3,\textcolor{stringliteral}{"wm"},0,NULL,1,-1,1,0,0\},
00174     \{\textcolor{stringliteral}{"sunion"},sunionCommand,-2,\textcolor{stringliteral}{"rS"},0,NULL,1,-1,1,0,0\},
00175     \{\textcolor{stringliteral}{"sunionstore"},sunionstoreCommand,-3,\textcolor{stringliteral}{"wm"},0,NULL,1,-1,1,0,0\},
00176     \{\textcolor{stringliteral}{"sdiff"},sdiffCommand,-2,\textcolor{stringliteral}{"rS"},0,NULL,1,-1,1,0,0\},
00177     \{\textcolor{stringliteral}{"sdiffstore"},sdiffstoreCommand,-3,\textcolor{stringliteral}{"wm"},0,NULL,1,-1,1,0,0\},
00178     \{\textcolor{stringliteral}{"smembers"},sinterCommand,2,\textcolor{stringliteral}{"rS"},0,NULL,1,1,1,0,0\},
00179     \{\textcolor{stringliteral}{"sscan"},sscanCommand,-3,\textcolor{stringliteral}{"rR"},0,NULL,1,1,1,0,0\},
00180     \{\textcolor{stringliteral}{"zadd"},zaddCommand,-4,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00181     \{\textcolor{stringliteral}{"zincrby"},zincrbyCommand,4,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00182     \{\textcolor{stringliteral}{"zrem"},zremCommand,-3,\textcolor{stringliteral}{"wF"},0,NULL,1,1,1,0,0\},
00183     \{\textcolor{stringliteral}{"zremrangebyscore"},zremrangebyscoreCommand,4,\textcolor{stringliteral}{"w"},0,NULL,1,1,1,0,0\},
00184     \{\textcolor{stringliteral}{"zremrangebyrank"},zremrangebyrankCommand,4,\textcolor{stringliteral}{"w"},0,NULL,1,1,1,0,0\},
00185     \{\textcolor{stringliteral}{"zremrangebylex"},zremrangebylexCommand,4,\textcolor{stringliteral}{"w"},0,NULL,1,1,1,0,0\},
00186     \{\textcolor{stringliteral}{"zunionstore"},zunionstoreCommand,-4,\textcolor{stringliteral}{"wm"},0,zunionInterGetKeys,0,0,0,0,0\},
00187     \{\textcolor{stringliteral}{"zinterstore"},zinterstoreCommand,-4,\textcolor{stringliteral}{"wm"},0,zunionInterGetKeys,0,0,0,0,0\},
00188     \{\textcolor{stringliteral}{"zrange"},zrangeCommand,-4,\textcolor{stringliteral}{"r"},0,NULL,1,1,1,0,0\},
00189     \{\textcolor{stringliteral}{"zrangebyscore"},zrangebyscoreCommand,-4,\textcolor{stringliteral}{"r"},0,NULL,1,1,1,0,0\},
00190     \{\textcolor{stringliteral}{"zrevrangebyscore"},zrevrangebyscoreCommand,-4,\textcolor{stringliteral}{"r"},0,NULL,1,1,1,0,0\},
00191     \{\textcolor{stringliteral}{"zrangebylex"},zrangebylexCommand,-4,\textcolor{stringliteral}{"r"},0,NULL,1,1,1,0,0\},
00192     \{\textcolor{stringliteral}{"zrevrangebylex"},zrevrangebylexCommand,-4,\textcolor{stringliteral}{"r"},0,NULL,1,1,1,0,0\},
00193     \{\textcolor{stringliteral}{"zcount"},zcountCommand,4,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00194     \{\textcolor{stringliteral}{"zlexcount"},zlexcountCommand,4,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00195     \{\textcolor{stringliteral}{"zrevrange"},zrevrangeCommand,-4,\textcolor{stringliteral}{"r"},0,NULL,1,1,1,0,0\},
00196     \{\textcolor{stringliteral}{"zcard"},zcardCommand,2,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00197     \{\textcolor{stringliteral}{"zscore"},zscoreCommand,3,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00198     \{\textcolor{stringliteral}{"zrank"},zrankCommand,3,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00199     \{\textcolor{stringliteral}{"zrevrank"},zrevrankCommand,3,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00200     \{\textcolor{stringliteral}{"zscan"},zscanCommand,-3,\textcolor{stringliteral}{"rR"},0,NULL,1,1,1,0,0\},
00201     \{\textcolor{stringliteral}{"hset"},hsetCommand,-4,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00202     \{\textcolor{stringliteral}{"hsetnx"},hsetnxCommand,4,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00203     \{\textcolor{stringliteral}{"hget"},hgetCommand,3,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00204     \{\textcolor{stringliteral}{"hmset"},hsetCommand,-4,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00205     \{\textcolor{stringliteral}{"hmget"},hmgetCommand,-3,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00206     \{\textcolor{stringliteral}{"hincrby"},hincrbyCommand,4,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00207     \{\textcolor{stringliteral}{"hincrbyfloat"},hincrbyfloatCommand,4,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00208     \{\textcolor{stringliteral}{"hdel"},hdelCommand,-3,\textcolor{stringliteral}{"wF"},0,NULL,1,1,1,0,0\},
00209     \{\textcolor{stringliteral}{"hlen"},hlenCommand,2,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00210     \{\textcolor{stringliteral}{"hstrlen"},hstrlenCommand,3,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00211     \{\textcolor{stringliteral}{"hkeys"},hkeysCommand,2,\textcolor{stringliteral}{"rS"},0,NULL,1,1,1,0,0\},
00212     \{\textcolor{stringliteral}{"hvals"},hvalsCommand,2,\textcolor{stringliteral}{"rS"},0,NULL,1,1,1,0,0\},
00213     \{\textcolor{stringliteral}{"hgetall"},hgetallCommand,2,\textcolor{stringliteral}{"r"},0,NULL,1,1,1,0,0\},
00214     \{\textcolor{stringliteral}{"hexists"},hexistsCommand,3,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00215     \{\textcolor{stringliteral}{"hscan"},hscanCommand,-3,\textcolor{stringliteral}{"rR"},0,NULL,1,1,1,0,0\},
00216     \{\textcolor{stringliteral}{"incrby"},incrbyCommand,3,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00217     \{\textcolor{stringliteral}{"decrby"},decrbyCommand,3,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00218     \{\textcolor{stringliteral}{"incrbyfloat"},incrbyfloatCommand,3,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00219     \{\textcolor{stringliteral}{"getset"},getsetCommand,3,\textcolor{stringliteral}{"wm"},0,NULL,1,1,1,0,0\},
00220     \{\textcolor{stringliteral}{"mset"},msetCommand,-3,\textcolor{stringliteral}{"wm"},0,NULL,1,-1,2,0,0\},
00221     \{\textcolor{stringliteral}{"msetnx"},msetnxCommand,-3,\textcolor{stringliteral}{"wm"},0,NULL,1,-1,2,0,0\},
00222     \{\textcolor{stringliteral}{"randomkey"},randomkeyCommand,1,\textcolor{stringliteral}{"rR"},0,NULL,0,0,0,0,0\},
00223     \{\textcolor{stringliteral}{"select"},selectCommand,2,\textcolor{stringliteral}{"lF"},0,NULL,0,0,0,0,0\},
00224     \{\textcolor{stringliteral}{"swapdb"},swapdbCommand,3,\textcolor{stringliteral}{"wF"},0,NULL,0,0,0,0,0\},
00225     \{\textcolor{stringliteral}{"move"},moveCommand,3,\textcolor{stringliteral}{"wF"},0,NULL,1,1,1,0,0\},
00226     \{\textcolor{stringliteral}{"rename"},renameCommand,3,\textcolor{stringliteral}{"w"},0,NULL,1,2,1,0,0\},
00227     \{\textcolor{stringliteral}{"renamenx"},renamenxCommand,3,\textcolor{stringliteral}{"wF"},0,NULL,1,2,1,0,0\},
00228     \{\textcolor{stringliteral}{"expire"},expireCommand,3,\textcolor{stringliteral}{"wF"},0,NULL,1,1,1,0,0\},
00229     \{\textcolor{stringliteral}{"expireat"},expireatCommand,3,\textcolor{stringliteral}{"wF"},0,NULL,1,1,1,0,0\},
00230     \{\textcolor{stringliteral}{"pexpire"},pexpireCommand,3,\textcolor{stringliteral}{"wF"},0,NULL,1,1,1,0,0\},
00231     \{\textcolor{stringliteral}{"pexpireat"},pexpireatCommand,3,\textcolor{stringliteral}{"wF"},0,NULL,1,1,1,0,0\},
00232     \{\textcolor{stringliteral}{"keys"},keysCommand,2,\textcolor{stringliteral}{"rS"},0,NULL,0,0,0,0,0\},
00233     \{\textcolor{stringliteral}{"scan"},scanCommand,-2,\textcolor{stringliteral}{"rR"},0,NULL,0,0,0,0,0\},
00234     \{\textcolor{stringliteral}{"dbsize"},dbsizeCommand,1,\textcolor{stringliteral}{"rF"},0,NULL,0,0,0,0,0\},
00235     \{\textcolor{stringliteral}{"auth"},authCommand,2,\textcolor{stringliteral}{"sltF"},0,NULL,0,0,0,0,0\},
00236     \{\textcolor{stringliteral}{"ping"},pingCommand,-1,\textcolor{stringliteral}{"tF"},0,NULL,0,0,0,0,0\},
00237     \{\textcolor{stringliteral}{"echo"},echoCommand,2,\textcolor{stringliteral}{"F"},0,NULL,0,0,0,0,0\},
00238     \{\textcolor{stringliteral}{"save"},saveCommand,1,\textcolor{stringliteral}{"as"},0,NULL,0,0,0,0,0\},
00239     \{\textcolor{stringliteral}{"bgsave"},bgsaveCommand,-1,\textcolor{stringliteral}{"a"},0,NULL,0,0,0,0,0\},
00240     \{\textcolor{stringliteral}{"bgrewriteaof"},bgrewriteaofCommand,1,\textcolor{stringliteral}{"a"},0,NULL,0,0,0,0,0\},
00241     \{\textcolor{stringliteral}{"shutdown"},shutdownCommand,-1,\textcolor{stringliteral}{"alt"},0,NULL,0,0,0,0,0\},
00242     \{\textcolor{stringliteral}{"lastsave"},lastsaveCommand,1,\textcolor{stringliteral}{"RF"},0,NULL,0,0,0,0,0\},
00243     \{\textcolor{stringliteral}{"type"},typeCommand,2,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00244     \{\textcolor{stringliteral}{"multi"},multiCommand,1,\textcolor{stringliteral}{"sF"},0,NULL,0,0,0,0,0\},
00245     \{\textcolor{stringliteral}{"exec"},execCommand,1,\textcolor{stringliteral}{"sM"},0,NULL,0,0,0,0,0\},
00246     \{\textcolor{stringliteral}{"discard"},discardCommand,1,\textcolor{stringliteral}{"sF"},0,NULL,0,0,0,0,0\},
00247     \{\textcolor{stringliteral}{"sync"},syncCommand,1,\textcolor{stringliteral}{"ars"},0,NULL,0,0,0,0,0\},
00248     \{\textcolor{stringliteral}{"psync"},syncCommand,3,\textcolor{stringliteral}{"ars"},0,NULL,0,0,0,0,0\},
00249     \{\textcolor{stringliteral}{"replconf"},replconfCommand,-1,\textcolor{stringliteral}{"aslt"},0,NULL,0,0,0,0,0\},
00250     \{\textcolor{stringliteral}{"flushdb"},flushdbCommand,-1,\textcolor{stringliteral}{"w"},0,NULL,0,0,0,0,0\},
00251     \{\textcolor{stringliteral}{"flushall"},flushallCommand,-1,\textcolor{stringliteral}{"w"},0,NULL,0,0,0,0,0\},
00252     \{\textcolor{stringliteral}{"sort"},sortCommand,-2,\textcolor{stringliteral}{"wm"},0,sortGetKeys,1,1,1,0,0\},
00253     \{\textcolor{stringliteral}{"info"},infoCommand,-1,\textcolor{stringliteral}{"lt"},0,NULL,0,0,0,0,0\},
00254     \{\textcolor{stringliteral}{"monitor"},monitorCommand,1,\textcolor{stringliteral}{"as"},0,NULL,0,0,0,0,0\},
00255     \{\textcolor{stringliteral}{"ttl"},ttlCommand,2,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00256     \{\textcolor{stringliteral}{"touch"},touchCommand,-2,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00257     \{\textcolor{stringliteral}{"pttl"},pttlCommand,2,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00258     \{\textcolor{stringliteral}{"persist"},persistCommand,2,\textcolor{stringliteral}{"wF"},0,NULL,1,1,1,0,0\},
00259     \{\textcolor{stringliteral}{"slaveof"},slaveofCommand,3,\textcolor{stringliteral}{"ast"},0,NULL,0,0,0,0,0\},
00260     \{\textcolor{stringliteral}{"role"},roleCommand,1,\textcolor{stringliteral}{"lst"},0,NULL,0,0,0,0,0\},
00261     \{\textcolor{stringliteral}{"debug"},debugCommand,-2,\textcolor{stringliteral}{"as"},0,NULL,0,0,0,0,0\},
00262     \{\textcolor{stringliteral}{"config"},configCommand,-2,\textcolor{stringliteral}{"lat"},0,NULL,0,0,0,0,0\},
00263     \{\textcolor{stringliteral}{"subscribe"},subscribeCommand,-2,\textcolor{stringliteral}{"pslt"},0,NULL,0,0,0,0,0\},
00264     \{\textcolor{stringliteral}{"unsubscribe"},unsubscribeCommand,-1,\textcolor{stringliteral}{"pslt"},0,NULL,0,0,0,0,0\},
00265     \{\textcolor{stringliteral}{"psubscribe"},psubscribeCommand,-2,\textcolor{stringliteral}{"pslt"},0,NULL,0,0,0,0,0\},
00266     \{\textcolor{stringliteral}{"punsubscribe"},punsubscribeCommand,-1,\textcolor{stringliteral}{"pslt"},0,NULL,0,0,0,0,0\},
00267     \{\textcolor{stringliteral}{"publish"},publishCommand,3,\textcolor{stringliteral}{"pltF"},0,NULL,0,0,0,0,0\},
00268     \{\textcolor{stringliteral}{"pubsub"},pubsubCommand,-2,\textcolor{stringliteral}{"pltR"},0,NULL,0,0,0,0,0\},
00269     \{\textcolor{stringliteral}{"watch"},watchCommand,-2,\textcolor{stringliteral}{"sF"},0,NULL,1,-1,1,0,0\},
00270     \{\textcolor{stringliteral}{"unwatch"},unwatchCommand,1,\textcolor{stringliteral}{"sF"},0,NULL,0,0,0,0,0\},
00271     \{\textcolor{stringliteral}{"cluster"},clusterCommand,-2,\textcolor{stringliteral}{"a"},0,NULL,0,0,0,0,0\},
00272     \{\textcolor{stringliteral}{"restore"},restoreCommand,-4,\textcolor{stringliteral}{"wm"},0,NULL,1,1,1,0,0\},
00273     \{\textcolor{stringliteral}{"restore-asking"},restoreCommand,-4,\textcolor{stringliteral}{"wmk"},0,NULL,1,1,1,0,0\},
00274     \{\textcolor{stringliteral}{"migrate"},migrateCommand,-6,\textcolor{stringliteral}{"w"},0,migrateGetKeys,0,0,0,0,0\},
00275     \{\textcolor{stringliteral}{"asking"},askingCommand,1,\textcolor{stringliteral}{"F"},0,NULL,0,0,0,0,0\},
00276     \{\textcolor{stringliteral}{"readonly"},readonlyCommand,1,\textcolor{stringliteral}{"F"},0,NULL,0,0,0,0,0\},
00277     \{\textcolor{stringliteral}{"readwrite"},readwriteCommand,1,\textcolor{stringliteral}{"F"},0,NULL,0,0,0,0,0\},
00278     \{\textcolor{stringliteral}{"dump"},dumpCommand,2,\textcolor{stringliteral}{"r"},0,NULL,1,1,1,0,0\},
00279     \{\textcolor{stringliteral}{"object"},objectCommand,-2,\textcolor{stringliteral}{"r"},0,NULL,2,2,2,0,0\},
00280     \{\textcolor{stringliteral}{"memory"},memoryCommand,-2,\textcolor{stringliteral}{"r"},0,NULL,0,0,0,0,0\},
00281     \{\textcolor{stringliteral}{"client"},clientCommand,-2,\textcolor{stringliteral}{"as"},0,NULL,0,0,0,0,0\},
00282     \{\textcolor{stringliteral}{"eval"},evalCommand,-3,\textcolor{stringliteral}{"s"},0,evalGetKeys,0,0,0,0,0\},
00283     \{\textcolor{stringliteral}{"evalsha"},evalShaCommand,-3,\textcolor{stringliteral}{"s"},0,evalGetKeys,0,0,0,0,0\},
00284     \{\textcolor{stringliteral}{"slowlog"},slowlogCommand,-2,\textcolor{stringliteral}{"a"},0,NULL,0,0,0,0,0\},
00285     \{\textcolor{stringliteral}{"script"},scriptCommand,-2,\textcolor{stringliteral}{"s"},0,NULL,0,0,0,0,0\},
00286     \{\textcolor{stringliteral}{"time"},timeCommand,1,\textcolor{stringliteral}{"RF"},0,NULL,0,0,0,0,0\},
00287     \{\textcolor{stringliteral}{"bitop"},bitopCommand,-4,\textcolor{stringliteral}{"wm"},0,NULL,2,-1,1,0,0\},
00288     \{\textcolor{stringliteral}{"bitcount"},bitcountCommand,-2,\textcolor{stringliteral}{"r"},0,NULL,1,1,1,0,0\},
00289     \{\textcolor{stringliteral}{"bitpos"},bitposCommand,-3,\textcolor{stringliteral}{"r"},0,NULL,1,1,1,0,0\},
00290     \{\textcolor{stringliteral}{"wait"},waitCommand,3,\textcolor{stringliteral}{"s"},0,NULL,0,0,0,0,0\},
00291     \{\textcolor{stringliteral}{"command"},commandCommand,0,\textcolor{stringliteral}{"lt"},0,NULL,0,0,0,0,0\},
00292     \{\textcolor{stringliteral}{"geoadd"},geoaddCommand,-5,\textcolor{stringliteral}{"wm"},0,NULL,1,1,1,0,0\},
00293     \{\textcolor{stringliteral}{"georadius"},georadiusCommand,-6,\textcolor{stringliteral}{"w"},0,georadiusGetKeys,1,1,1,0,0\},
00294     \{\textcolor{stringliteral}{"georadius\_ro"},georadiusroCommand,-6,\textcolor{stringliteral}{"r"},0,georadiusGetKeys,1,1,1,0,0\},
00295     \{\textcolor{stringliteral}{"georadiusbymember"},georadiusbymemberCommand,-5,\textcolor{stringliteral}{"w"},0,georadiusGetKeys,1,1,1,0,0\},
00296     \{\textcolor{stringliteral}{"georadiusbymember\_ro"},georadiusbymemberroCommand,-5,\textcolor{stringliteral}{"r"},0,georadiusGetKeys,1,1,1,0,0\},
00297     \{\textcolor{stringliteral}{"geohash"},geohashCommand,-2,\textcolor{stringliteral}{"r"},0,NULL,1,1,1,0,0\},
00298     \{\textcolor{stringliteral}{"geopos"},geoposCommand,-2,\textcolor{stringliteral}{"r"},0,NULL,1,1,1,0,0\},
00299     \{\textcolor{stringliteral}{"geodist"},geodistCommand,-4,\textcolor{stringliteral}{"r"},0,NULL,1,1,1,0,0\},
00300     \{\textcolor{stringliteral}{"pfselftest"},pfselftestCommand,1,\textcolor{stringliteral}{"a"},0,NULL,0,0,0,0,0\},
00301     \{\textcolor{stringliteral}{"pfadd"},pfaddCommand,-2,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00302     \{\textcolor{stringliteral}{"pfcount"},pfcountCommand,-2,\textcolor{stringliteral}{"r"},0,NULL,1,-1,1,0,0\},
00303     \{\textcolor{stringliteral}{"pfmerge"},pfmergeCommand,-2,\textcolor{stringliteral}{"wm"},0,NULL,1,-1,1,0,0\},
00304     \{\textcolor{stringliteral}{"pfdebug"},pfdebugCommand,-3,\textcolor{stringliteral}{"w"},0,NULL,0,0,0,0,0\},
00305     \{\textcolor{stringliteral}{"xadd"},xaddCommand,-5,\textcolor{stringliteral}{"wmF"},0,NULL,1,1,1,0,0\},
00306     \{\textcolor{stringliteral}{"xrange"},xrangeCommand,-4,\textcolor{stringliteral}{"r"},0,NULL,1,1,1,0,0\},
00307     \{\textcolor{stringliteral}{"xrevrange"},xrevrangeCommand,-4,\textcolor{stringliteral}{"r"},0,NULL,1,1,1,0,0\},
00308     \{\textcolor{stringliteral}{"xlen"},xlenCommand,2,\textcolor{stringliteral}{"rF"},0,NULL,1,1,1,0,0\},
00309     \{\textcolor{stringliteral}{"xread"},xreadCommand,-3,\textcolor{stringliteral}{"rs"},0,xreadGetKeys,1,1,1,0,0\},
00310     \{\textcolor{stringliteral}{"post"},securityWarningCommand,-1,\textcolor{stringliteral}{"lt"},0,NULL,0,0,0,0,0\},
00311     \{\textcolor{stringliteral}{"host:"},securityWarningCommand,-1,\textcolor{stringliteral}{"lt"},0,NULL,0,0,0,0,0\},
00312     \{\textcolor{stringliteral}{"latency"},latencyCommand,-2,\textcolor{stringliteral}{"aslt"},0,NULL,0,0,0,0,0\}
00313 \};
00314 
00315 \textcolor{comment}{/*============================ Utility functions ============================ */}
00316 
00317 \textcolor{comment}{/* Low level logging. To use only for very big messages, otherwise}
00318 \textcolor{comment}{ * serverLog() is to prefer. */}
00319 \textcolor{keywordtype}{void} serverLogRaw(\textcolor{keywordtype}{int} level, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *msg) \{
00320     \textcolor{keyword}{const} \textcolor{keywordtype}{int} syslogLevelMap[] = \{ LOG\_DEBUG, LOG\_INFO, LOG\_NOTICE, LOG\_WARNING \};
00321     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *c = \textcolor{stringliteral}{".-*#"};
00322     FILE *fp;
00323     \textcolor{keywordtype}{char} buf[64];
00324     \textcolor{keywordtype}{int} rawmode = (level & \hyperlink{server_8h_a6b3768a4d2dfb3ac580b8d999baa9350}{LL\_RAW});
00325     \textcolor{keywordtype}{int} log\_to\_stdout = server.logfile[0] == \textcolor{stringliteral}{'\(\backslash\)0'};
00326 
00327     level &= 0xff; \textcolor{comment}{/* clear flags */}
00328     \textcolor{keywordflow}{if} (level < server.verbosity) \textcolor{keywordflow}{return};
00329 
00330     fp = log\_to\_stdout ? stdout : fopen(server.logfile,\textcolor{stringliteral}{"a"});
00331     \textcolor{keywordflow}{if} (!fp) \textcolor{keywordflow}{return};
00332 
00333     \textcolor{keywordflow}{if} (rawmode) \{
00334         fprintf(fp,\textcolor{stringliteral}{"%s"},msg);
00335     \} \textcolor{keywordflow}{else} \{
00336         \textcolor{keywordtype}{int} off;
00337         \textcolor{keyword}{struct} timeval tv;
00338         \textcolor{keywordtype}{int} role\_char;
00339         pid\_t pid = getpid();
00340 
00341         gettimeofday(&tv,NULL);
00342         off = strftime(buf,\textcolor{keyword}{sizeof}(buf),\textcolor{stringliteral}{"%d %b %H:%M:%S."},localtime(&tv.tv\_sec));
00343         snprintf(buf+off,\textcolor{keyword}{sizeof}(buf)-off,\textcolor{stringliteral}{"%03d"},(\textcolor{keywordtype}{int})tv.tv\_usec/1000);
00344         \textcolor{keywordflow}{if} (server.sentinel\_mode) \{
00345             role\_char = \textcolor{stringliteral}{'X'}; \textcolor{comment}{/* Sentinel. */}
00346         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pid != server.pid) \{
00347             role\_char = \textcolor{stringliteral}{'C'}; \textcolor{comment}{/* RDB / AOF writing child. */}
00348         \} \textcolor{keywordflow}{else} \{
00349             role\_char = (server.masterhost ? \textcolor{stringliteral}{'S'}:\textcolor{stringliteral}{'M'}); \textcolor{comment}{/* Slave or Master. */}
00350         \}
00351         fprintf(fp,\textcolor{stringliteral}{"%d:%c %s %c %s\(\backslash\)n"},
00352             (\textcolor{keywordtype}{int})getpid(),role\_char, buf,c[level],msg);
00353     \}
00354     fflush(fp);
00355 
00356     \textcolor{keywordflow}{if} (!log\_to\_stdout) fclose(fp);
00357     \textcolor{keywordflow}{if} (server.syslog\_enabled) syslog(syslogLevelMap[level], \textcolor{stringliteral}{"%s"}, msg);
00358 \}
00359 
00360 \textcolor{comment}{/* Like serverLogRaw() but with printf-alike support. This is the function that}
00361 \textcolor{comment}{ * is used across the code. The raw version is only used in order to dump}
00362 \textcolor{comment}{ * the INFO output on crash. */}
00363 \textcolor{keywordtype}{void} serverLog(\textcolor{keywordtype}{int} level, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, ...) \{
00364     va\_list ap;
00365     \textcolor{keywordtype}{char} msg[\hyperlink{server_8h_a37cd05cbfd7fb52ad21d3a822cff2ee6}{LOG\_MAX\_LEN}];
00366 
00367     \textcolor{keywordflow}{if} ((level&0xff) < server.verbosity) \textcolor{keywordflow}{return};
00368 
00369     va\_start(ap, fmt);
00370     vsnprintf(msg, \textcolor{keyword}{sizeof}(msg), fmt, ap);
00371     va\_end(ap);
00372 
00373     serverLogRaw(level,msg);
00374 \}
00375 
00376 \textcolor{comment}{/* Log a fixed message without printf-alike capabilities, in a way that is}
00377 \textcolor{comment}{ * safe to call from a signal handler.}
00378 \textcolor{comment}{ *}
00379 \textcolor{comment}{ * We actually use this only for signals that are not fatal from the point}
00380 \textcolor{comment}{ * of view of Redis. Signals that are going to kill the server anyway and}
00381 \textcolor{comment}{ * where we need printf-alike features are served by serverLog(). */}
00382 \textcolor{keywordtype}{void} serverLogFromHandler(\textcolor{keywordtype}{int} level, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *msg) \{
00383     \textcolor{keywordtype}{int} fd;
00384     \textcolor{keywordtype}{int} log\_to\_stdout = server.logfile[0] == \textcolor{stringliteral}{'\(\backslash\)0'};
00385     \textcolor{keywordtype}{char} buf[64];
00386 
00387     \textcolor{keywordflow}{if} ((level&0xff) < server.verbosity || (log\_to\_stdout && server.daemonize))
00388         \textcolor{keywordflow}{return};
00389     fd = log\_to\_stdout ? STDOUT\_FILENO :
00390                          open(server.logfile, O\_APPEND|O\_CREAT|O\_WRONLY, 0644);
00391     \textcolor{keywordflow}{if} (fd == -1) \textcolor{keywordflow}{return};
00392     ll2string(buf,\textcolor{keyword}{sizeof}(buf),getpid());
00393     \textcolor{keywordflow}{if} (write(fd,buf,strlen(buf)) == -1) \textcolor{keywordflow}{goto} err;
00394     \textcolor{keywordflow}{if} (write(fd,\textcolor{stringliteral}{":signal-handler ("},17) == -1) \textcolor{keywordflow}{goto} err;
00395     ll2string(buf,\textcolor{keyword}{sizeof}(buf),time(NULL));
00396     \textcolor{keywordflow}{if} (write(fd,buf,strlen(buf)) == -1) \textcolor{keywordflow}{goto} err;
00397     \textcolor{keywordflow}{if} (write(fd,\textcolor{stringliteral}{") "},2) == -1) \textcolor{keywordflow}{goto} err;
00398     \textcolor{keywordflow}{if} (write(fd,msg,strlen(msg)) == -1) \textcolor{keywordflow}{goto} err;
00399     \textcolor{keywordflow}{if} (write(fd,\textcolor{stringliteral}{"\(\backslash\)n"},1) == -1) \textcolor{keywordflow}{goto} err;
00400 err:
00401     \textcolor{keywordflow}{if} (!log\_to\_stdout) close(fd);
00402 \}
00403 
00404 \textcolor{comment}{/* Return the UNIX time in microseconds */}
00405 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ustime(\textcolor{keywordtype}{void}) \{
00406     \textcolor{keyword}{struct} timeval tv;
00407     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ust;
00408 
00409     gettimeofday(&tv, NULL);
00410     ust = ((\textcolor{keywordtype}{long} \textcolor{keywordtype}{long})tv.tv\_sec)*1000000;
00411     ust += tv.tv\_usec;
00412     \textcolor{keywordflow}{return} ust;
00413 \}
00414 
00415 \textcolor{comment}{/* Return the UNIX time in milliseconds */}
00416 mstime\_t mstime(\textcolor{keywordtype}{void}) \{
00417     \textcolor{keywordflow}{return} ustime()/1000;
00418 \}
00419 
00420 \textcolor{comment}{/* After an RDB dump or AOF rewrite we exit from children using \_exit() instead of}
00421 \textcolor{comment}{ * exit(), because the latter may interact with the same file objects used by}
00422 \textcolor{comment}{ * the parent process. However if we are testing the coverage normal exit() is}
00423 \textcolor{comment}{ * used in order to obtain the right coverage information. */}
00424 \textcolor{keywordtype}{void} exitFromChild(\textcolor{keywordtype}{int} retcode) \{
00425 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \textcolor{preprocessor}{COVERAGE\_TEST}
00426     exit(retcode);
00427 \textcolor{preprocessor}{#}\textcolor{preprocessor}{else}
00428     \_exit(retcode);
00429 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
00430 \}
00431 
00432 \textcolor{comment}{/*====================== Hash table type implementation  ==================== */}
00433 
00434 \textcolor{comment}{/* This is a hash table type that uses the SDS dynamic strings library as}
00435 \textcolor{comment}{ * keys and redis objects as values (objects can hold SDS strings,}
00436 \textcolor{comment}{ * lists, sets). */}
00437 
00438 \textcolor{keywordtype}{void} dictVanillaFree(\textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{void} *val)
00439 \{
00440     \hyperlink{dict_8h_aa077e877a37a7dc65056290a2c9760da}{DICT\_NOTUSED}(privdata);
00441     zfree(val);
00442 \}
00443 
00444 \textcolor{keywordtype}{void} dictListDestructor(\textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{void} *val)
00445 \{
00446     \hyperlink{dict_8h_aa077e877a37a7dc65056290a2c9760da}{DICT\_NOTUSED}(privdata);
00447     listRelease((list*)val);
00448 \}
00449 
00450 \textcolor{keywordtype}{int} dictSdsKeyCompare(\textcolor{keywordtype}{void} *privdata, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key1,
00451         \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key2)
00452 \{
00453     \textcolor{keywordtype}{int} l1,l2;
00454     \hyperlink{dict_8h_aa077e877a37a7dc65056290a2c9760da}{DICT\_NOTUSED}(privdata);
00455 
00456     l1 = sdslen((sds)key1);
00457     l2 = sdslen((sds)key2);
00458     \textcolor{keywordflow}{if} (l1 != l2) \textcolor{keywordflow}{return} 0;
00459     \textcolor{keywordflow}{return} memcmp(key1, key2, l1) == 0;
00460 \}
00461 
00462 \textcolor{comment}{/* A case insensitive version used for the command lookup table and other}
00463 \textcolor{comment}{ * places where case insensitive non binary-safe comparison is needed. */}
00464 \textcolor{keywordtype}{int} dictSdsKeyCaseCompare(\textcolor{keywordtype}{void} *privdata, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key1,
00465         \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key2)
00466 \{
00467     \hyperlink{dict_8h_aa077e877a37a7dc65056290a2c9760da}{DICT\_NOTUSED}(privdata);
00468 
00469     \textcolor{keywordflow}{return} strcasecmp(key1, key2) == 0;
00470 \}
00471 
00472 \textcolor{keywordtype}{void} dictObjectDestructor(\textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{void} *val)
00473 \{
00474     \hyperlink{dict_8h_aa077e877a37a7dc65056290a2c9760da}{DICT\_NOTUSED}(privdata);
00475 
00476     \textcolor{keywordflow}{if} (val == NULL) \textcolor{keywordflow}{return}; \textcolor{comment}{/* Lazy freeing will set value to NULL. */}
00477     decrRefCount(val);
00478 \}
00479 
00480 \textcolor{keywordtype}{void} dictSdsDestructor(\textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{void} *val)
00481 \{
00482     \hyperlink{dict_8h_aa077e877a37a7dc65056290a2c9760da}{DICT\_NOTUSED}(privdata);
00483 
00484     sdsfree(val);
00485 \}
00486 
00487 \textcolor{keywordtype}{int} dictObjKeyCompare(\textcolor{keywordtype}{void} *privdata, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key1,
00488         \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key2)
00489 \{
00490     \textcolor{keyword}{const} robj *o1 = key1, *o2 = key2;
00491     \textcolor{keywordflow}{return} dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);
00492 \}
00493 
00494 uint64\_t dictObjHash(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *key) \{
00495     \textcolor{keyword}{const} robj *o = key;
00496     \textcolor{keywordflow}{return} dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));
00497 \}
00498 
00499 uint64\_t dictSdsHash(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *key) \{
00500     \textcolor{keywordflow}{return} dictGenHashFunction((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)key, sdslen((\textcolor{keywordtype}{char}*)key));
00501 \}
00502 
00503 uint64\_t dictSdsCaseHash(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *key) \{
00504     \textcolor{keywordflow}{return} dictGenCaseHashFunction((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)key, sdslen((\textcolor{keywordtype}{char}*)key));
00505 \}
00506 
00507 \textcolor{keywordtype}{int} dictEncObjKeyCompare(\textcolor{keywordtype}{void} *privdata, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key1,
00508         \textcolor{keyword}{const} \textcolor{keywordtype}{void} *key2)
00509 \{
00510     robj *o1 = (robj*) key1, *o2 = (robj*) key2;
00511     \textcolor{keywordtype}{int} cmp;
00512 
00513     \textcolor{keywordflow}{if} (o1->encoding == \hyperlink{server_8h_ae934cf008a0be0ef009c92c2d006a816}{OBJ\_ENCODING\_INT} &&
00514         o2->encoding == \hyperlink{server_8h_ae934cf008a0be0ef009c92c2d006a816}{OBJ\_ENCODING\_INT})
00515             \textcolor{keywordflow}{return} o1->ptr == o2->ptr;
00516 
00517     o1 = getDecodedObject(o1);
00518     o2 = getDecodedObject(o2);
00519     cmp = dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);
00520     decrRefCount(o1);
00521     decrRefCount(o2);
00522     \textcolor{keywordflow}{return} cmp;
00523 \}
00524 
00525 uint64\_t dictEncObjHash(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *key) \{
00526     robj *o = (robj*) key;
00527 
00528     \textcolor{keywordflow}{if} (\hyperlink{server_8h_afcfb5bd97af52d1dbce331745cae030c}{sdsEncodedObject}(o)) \{
00529         \textcolor{keywordflow}{return} dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));
00530     \} \textcolor{keywordflow}{else} \{
00531         \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_ae934cf008a0be0ef009c92c2d006a816}{OBJ\_ENCODING\_INT}) \{
00532             \textcolor{keywordtype}{char} buf[32];
00533             \textcolor{keywordtype}{int} len;
00534 
00535             len = ll2string(buf,32,(\textcolor{keywordtype}{long})o->ptr);
00536             \textcolor{keywordflow}{return} dictGenHashFunction((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)buf, len);
00537         \} \textcolor{keywordflow}{else} \{
00538             uint64\_t hash;
00539 
00540             o = getDecodedObject(o);
00541             hash = dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));
00542             decrRefCount(o);
00543             \textcolor{keywordflow}{return} hash;
00544         \}
00545     \}
00546 \}
00547 
00548 \textcolor{comment}{/* Generic hash table type where keys are Redis Objects, Values}
00549 \textcolor{comment}{ * dummy pointers. */}
00550 dictType objectKeyPointerValueDictType = \{
00551     dictEncObjHash,            \textcolor{comment}{/* hash function */}
00552     NULL,                      \textcolor{comment}{/* key dup */}
00553     NULL,                      \textcolor{comment}{/* val dup */}
00554     dictEncObjKeyCompare,      \textcolor{comment}{/* key compare */}
00555     dictObjectDestructor,      \textcolor{comment}{/* key destructor */}
00556     NULL                       \textcolor{comment}{/* val destructor */}
00557 \};
00558 
00559 \textcolor{comment}{/* Like objectKeyPointerValueDictType(), but values can be destroyed, if}
00560 \textcolor{comment}{ * not NULL, calling zfree(). */}
00561 dictType objectKeyHeapPointerValueDictType = \{
00562     dictEncObjHash,            \textcolor{comment}{/* hash function */}
00563     NULL,                      \textcolor{comment}{/* key dup */}
00564     NULL,                      \textcolor{comment}{/* val dup */}
00565     dictEncObjKeyCompare,      \textcolor{comment}{/* key compare */}
00566     dictObjectDestructor,      \textcolor{comment}{/* key destructor */}
00567     dictVanillaFree            \textcolor{comment}{/* val destructor */}
00568 \};
00569 
00570 \textcolor{comment}{/* Set dictionary type. Keys are SDS strings, values are ot used. */}
00571 dictType setDictType = \{
00572     dictSdsHash,               \textcolor{comment}{/* hash function */}
00573     NULL,                      \textcolor{comment}{/* key dup */}
00574     NULL,                      \textcolor{comment}{/* val dup */}
00575     dictSdsKeyCompare,         \textcolor{comment}{/* key compare */}
00576     dictSdsDestructor,         \textcolor{comment}{/* key destructor */}
00577     NULL                       \textcolor{comment}{/* val destructor */}
00578 \};
00579 
00580 \textcolor{comment}{/* Sorted sets hash (note: a skiplist is used in addition to the hash table) */}
00581 dictType zsetDictType = \{
00582     dictSdsHash,               \textcolor{comment}{/* hash function */}
00583     NULL,                      \textcolor{comment}{/* key dup */}
00584     NULL,                      \textcolor{comment}{/* val dup */}
00585     dictSdsKeyCompare,         \textcolor{comment}{/* key compare */}
00586     NULL,                      \textcolor{comment}{/* Note: SDS string shared & freed by skiplist */}
00587     NULL                       \textcolor{comment}{/* val destructor */}
00588 \};
00589 
00590 \textcolor{comment}{/* Db->dict, keys are sds strings, vals are Redis objects. */}
00591 dictType dbDictType = \{
00592     dictSdsHash,                \textcolor{comment}{/* hash function */}
00593     NULL,                       \textcolor{comment}{/* key dup */}
00594     NULL,                       \textcolor{comment}{/* val dup */}
00595     dictSdsKeyCompare,          \textcolor{comment}{/* key compare */}
00596     dictSdsDestructor,          \textcolor{comment}{/* key destructor */}
00597     dictObjectDestructor   \textcolor{comment}{/* val destructor */}
00598 \};
00599 
00600 \textcolor{comment}{/* server.lua\_scripts sha (as sds string) -> scripts (as robj) cache. */}
00601 dictType shaScriptObjectDictType = \{
00602     dictSdsCaseHash,            \textcolor{comment}{/* hash function */}
00603     NULL,                       \textcolor{comment}{/* key dup */}
00604     NULL,                       \textcolor{comment}{/* val dup */}
00605     dictSdsKeyCaseCompare,      \textcolor{comment}{/* key compare */}
00606     dictSdsDestructor,          \textcolor{comment}{/* key destructor */}
00607     dictObjectDestructor        \textcolor{comment}{/* val destructor */}
00608 \};
00609 
00610 \textcolor{comment}{/* Db->expires */}
00611 dictType keyptrDictType = \{
00612     dictSdsHash,                \textcolor{comment}{/* hash function */}
00613     NULL,                       \textcolor{comment}{/* key dup */}
00614     NULL,                       \textcolor{comment}{/* val dup */}
00615     dictSdsKeyCompare,          \textcolor{comment}{/* key compare */}
00616     NULL,                       \textcolor{comment}{/* key destructor */}
00617     NULL                        \textcolor{comment}{/* val destructor */}
00618 \};
00619 
00620 \textcolor{comment}{/* Command table. sds string -> command struct pointer. */}
00621 dictType commandTableDictType = \{
00622     dictSdsCaseHash,            \textcolor{comment}{/* hash function */}
00623     NULL,                       \textcolor{comment}{/* key dup */}
00624     NULL,                       \textcolor{comment}{/* val dup */}
00625     dictSdsKeyCaseCompare,      \textcolor{comment}{/* key compare */}
00626     dictSdsDestructor,          \textcolor{comment}{/* key destructor */}
00627     NULL                        \textcolor{comment}{/* val destructor */}
00628 \};
00629 
00630 \textcolor{comment}{/* Hash type hash table (note that small hashes are represented with ziplists) */}
00631 dictType hashDictType = \{
00632     dictSdsHash,                \textcolor{comment}{/* hash function */}
00633     NULL,                       \textcolor{comment}{/* key dup */}
00634     NULL,                       \textcolor{comment}{/* val dup */}
00635     dictSdsKeyCompare,          \textcolor{comment}{/* key compare */}
00636     dictSdsDestructor,          \textcolor{comment}{/* key destructor */}
00637     dictSdsDestructor           \textcolor{comment}{/* val destructor */}
00638 \};
00639 
00640 \textcolor{comment}{/* Keylist hash table type has unencoded redis objects as keys and}
00641 \textcolor{comment}{ * lists as values. It's used for blocking operations (BLPOP) and to}
00642 \textcolor{comment}{ * map swapped keys to a list of clients waiting for this keys to be loaded. */}
00643 dictType keylistDictType = \{
00644     dictObjHash,                \textcolor{comment}{/* hash function */}
00645     NULL,                       \textcolor{comment}{/* key dup */}
00646     NULL,                       \textcolor{comment}{/* val dup */}
00647     dictObjKeyCompare,          \textcolor{comment}{/* key compare */}
00648     dictObjectDestructor,       \textcolor{comment}{/* key destructor */}
00649     dictListDestructor          \textcolor{comment}{/* val destructor */}
00650 \};
00651 
00652 \textcolor{comment}{/* Cluster nodes hash table, mapping nodes addresses 1.2.3.4:6379 to}
00653 \textcolor{comment}{ * clusterNode structures. */}
00654 dictType clusterNodesDictType = \{
00655     dictSdsHash,                \textcolor{comment}{/* hash function */}
00656     NULL,                       \textcolor{comment}{/* key dup */}
00657     NULL,                       \textcolor{comment}{/* val dup */}
00658     dictSdsKeyCompare,          \textcolor{comment}{/* key compare */}
00659     dictSdsDestructor,          \textcolor{comment}{/* key destructor */}
00660     NULL                        \textcolor{comment}{/* val destructor */}
00661 \};
00662 
00663 \textcolor{comment}{/* Cluster re-addition blacklist. This maps node IDs to the time}
00664 \textcolor{comment}{ * we can re-add this node. The goal is to avoid readding a removed}
00665 \textcolor{comment}{ * node for some time. */}
00666 dictType clusterNodesBlackListDictType = \{
00667     dictSdsCaseHash,            \textcolor{comment}{/* hash function */}
00668     NULL,                       \textcolor{comment}{/* key dup */}
00669     NULL,                       \textcolor{comment}{/* val dup */}
00670     dictSdsKeyCaseCompare,      \textcolor{comment}{/* key compare */}
00671     dictSdsDestructor,          \textcolor{comment}{/* key destructor */}
00672     NULL                        \textcolor{comment}{/* val destructor */}
00673 \};
00674 
00675 \textcolor{comment}{/* Cluster re-addition blacklist. This maps node IDs to the time}
00676 \textcolor{comment}{ * we can re-add this node. The goal is to avoid readding a removed}
00677 \textcolor{comment}{ * node for some time. */}
00678 dictType modulesDictType = \{
00679     dictSdsCaseHash,            \textcolor{comment}{/* hash function */}
00680     NULL,                       \textcolor{comment}{/* key dup */}
00681     NULL,                       \textcolor{comment}{/* val dup */}
00682     dictSdsKeyCaseCompare,      \textcolor{comment}{/* key compare */}
00683     dictSdsDestructor,          \textcolor{comment}{/* key destructor */}
00684     NULL                        \textcolor{comment}{/* val destructor */}
00685 \};
00686 
00687 \textcolor{comment}{/* Migrate cache dict type. */}
00688 dictType migrateCacheDictType = \{
00689     dictSdsHash,                \textcolor{comment}{/* hash function */}
00690     NULL,                       \textcolor{comment}{/* key dup */}
00691     NULL,                       \textcolor{comment}{/* val dup */}
00692     dictSdsKeyCompare,          \textcolor{comment}{/* key compare */}
00693     dictSdsDestructor,          \textcolor{comment}{/* key destructor */}
00694     NULL                        \textcolor{comment}{/* val destructor */}
00695 \};
00696 
00697 \textcolor{comment}{/* Replication cached script dict (server.repl\_scriptcache\_dict).}
00698 \textcolor{comment}{ * Keys are sds SHA1 strings, while values are not used at all in the current}
00699 \textcolor{comment}{ * implementation. */}
00700 dictType replScriptCacheDictType = \{
00701     dictSdsCaseHash,            \textcolor{comment}{/* hash function */}
00702     NULL,                       \textcolor{comment}{/* key dup */}
00703     NULL,                       \textcolor{comment}{/* val dup */}
00704     dictSdsKeyCaseCompare,      \textcolor{comment}{/* key compare */}
00705     dictSdsDestructor,          \textcolor{comment}{/* key destructor */}
00706     NULL                        \textcolor{comment}{/* val destructor */}
00707 \};
00708 
00709 \textcolor{keywordtype}{int} htNeedsResize(dict *dict) \{
00710     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} size, used;
00711 
00712     size = \hyperlink{dict_8h_aca9596be4bcc2caa07c17dd8cebcceec}{dictSlots}(dict);
00713     used = \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(dict);
00714     \textcolor{keywordflow}{return} (size > \hyperlink{dict_8h_aff97c19d1616cf2c697573ee3f515692}{DICT\_HT\_INITIAL\_SIZE} &&
00715             (used*100/size < \hyperlink{server_8h_aab8d0fb9427699c23cdbeb524f875562}{HASHTABLE\_MIN\_FILL}));
00716 \}
00717 
00718 \textcolor{comment}{/* If the percentage of used slots in the HT reaches HASHTABLE\_MIN\_FILL}
00719 \textcolor{comment}{ * we resize the hash table to save memory */}
00720 \textcolor{keywordtype}{void} tryResizeHashTables(\textcolor{keywordtype}{int} dbid) \{
00721     \textcolor{keywordflow}{if} (htNeedsResize(server.db[dbid].dict))
00722         dictResize(server.db[dbid].dict);
00723     \textcolor{keywordflow}{if} (htNeedsResize(server.db[dbid].expires))
00724         dictResize(server.db[dbid].expires);
00725 \}
00726 
00727 \textcolor{comment}{/* Our hash table implementation performs rehashing incrementally while}
00728 \textcolor{comment}{ * we write/read from the hash table. Still if the server is idle, the hash}
00729 \textcolor{comment}{ * table will use two tables for a long time. So we try to use 1 millisecond}
00730 \textcolor{comment}{ * of CPU time at every call of this function to perform some rehahsing.}
00731 \textcolor{comment}{ *}
00732 \textcolor{comment}{ * The function returns 1 if some rehashing was performed, otherwise 0}
00733 \textcolor{comment}{ * is returned. */}
00734 \textcolor{keywordtype}{int} incrementallyRehash(\textcolor{keywordtype}{int} dbid) \{
00735     \textcolor{comment}{/* Keys dictionary */}
00736     \textcolor{keywordflow}{if} (\hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(server.db[dbid].dict)) \{
00737         dictRehashMilliseconds(server.db[dbid].dict,1);
00738         \textcolor{keywordflow}{return} 1; \textcolor{comment}{/* already used our millisecond for this loop... */}
00739     \}
00740     \textcolor{comment}{/* Expires */}
00741     \textcolor{keywordflow}{if} (\hyperlink{dict_8h_aa6e4917a6a32fdf47180e03ed8969e02}{dictIsRehashing}(server.db[dbid].expires)) \{
00742         dictRehashMilliseconds(server.db[dbid].expires,1);
00743         \textcolor{keywordflow}{return} 1; \textcolor{comment}{/* already used our millisecond for this loop... */}
00744     \}
00745     \textcolor{keywordflow}{return} 0;
00746 \}
00747 
00748 \textcolor{comment}{/* This function is called once a background process of some kind terminates,}
00749 \textcolor{comment}{ * as we want to avoid resizing the hash tables when there is a child in order}
00750 \textcolor{comment}{ * to play well with copy-on-write (otherwise when a resize happens lots of}
00751 \textcolor{comment}{ * memory pages are copied). The goal of this function is to update the ability}
00752 \textcolor{comment}{ * for dict.c to resize the hash tables accordingly to the fact we have o not}
00753 \textcolor{comment}{ * running childs. */}
00754 \textcolor{keywordtype}{void} updateDictResizePolicy(\textcolor{keywordtype}{void}) \{
00755     \textcolor{keywordflow}{if} (server.rdb\_child\_pid == -1 && server.aof\_child\_pid == -1)
00756         dictEnableResize();
00757     \textcolor{keywordflow}{else}
00758         dictDisableResize();
00759 \}
00760 
00761 \textcolor{comment}{/* ======================= Cron: called every 100 ms ======================== */}
00762 
00763 \textcolor{comment}{/* Add a sample to the operations per second array of samples. */}
00764 \textcolor{keywordtype}{void} trackInstantaneousMetric(\textcolor{keywordtype}{int} metric, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} current\_reading) \{
00765     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} t = mstime() - server.inst\_metric[metric].last\_sample\_time;
00766     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ops = current\_reading -
00767                     server.inst\_metric[metric].last\_sample\_count;
00768     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ops\_sec;
00769 
00770     ops\_sec = t > 0 ? (ops*1000/t) : 0;
00771 
00772     server.inst\_metric[metric].samples[server.inst\_metric[metric].idx] =
00773         ops\_sec;
00774     server.inst\_metric[metric].idx++;
00775     server.inst\_metric[metric].idx %= \hyperlink{server_8h_a225a9e35f2cb8aa663571625bc59a533}{STATS\_METRIC\_SAMPLES};
00776     server.inst\_metric[metric].last\_sample\_time = mstime();
00777     server.inst\_metric[metric].last\_sample\_count = current\_reading;
00778 \}
00779 
00780 \textcolor{comment}{/* Return the mean of all the samples. */}
00781 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} getInstantaneousMetric(\textcolor{keywordtype}{int} metric) \{
00782     \textcolor{keywordtype}{int} j;
00783     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} sum = 0;
00784 
00785     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{server_8h_a225a9e35f2cb8aa663571625bc59a533}{STATS\_METRIC\_SAMPLES}; j++)
00786         sum += server.inst\_metric[metric].samples[j];
00787     \textcolor{keywordflow}{return} sum / \hyperlink{server_8h_a225a9e35f2cb8aa663571625bc59a533}{STATS\_METRIC\_SAMPLES};
00788 \}
00789 
00790 \textcolor{comment}{/* Check for timeouts. Returns non-zero if the client was terminated.}
00791 \textcolor{comment}{ * The function gets the current time in milliseconds as argument since}
00792 \textcolor{comment}{ * it gets called multiple times in a loop, so calling gettimeofday() for}
00793 \textcolor{comment}{ * each iteration would be costly without any actual gain. */}
00794 \textcolor{keywordtype}{int} clientsCronHandleTimeout(\hyperlink{structclient}{client} *c, mstime\_t now\_ms) \{
00795     time\_t now = now\_ms/1000;
00796 
00797     \textcolor{keywordflow}{if} (server.maxidletime &&
00798         !(c->flags & \hyperlink{server_8h_ae9f6995948253652bc9454d79a72f4a7}{CLIENT\_SLAVE}) &&    \textcolor{comment}{/* no timeout for slaves */}
00799         !(c->flags & \hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER}) &&   \textcolor{comment}{/* no timeout for masters */}
00800         !(c->flags & \hyperlink{server_8h_a503ad979164a52f0f5e2a63e4c7da3a0}{CLIENT\_BLOCKED}) &&  \textcolor{comment}{/* no timeout for BLPOP */}
00801         !(c->flags & \hyperlink{server_8h_a20f2f5380db97cd09013118ffc9411cc}{CLIENT\_PUBSUB}) &&   \textcolor{comment}{/* no timeout for Pub/Sub clients */}
00802         (now - c->lastinteraction > server.maxidletime))
00803     \{
00804         serverLog(\hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE},\textcolor{stringliteral}{"Closing idle client"});
00805         freeClient(c);
00806         \textcolor{keywordflow}{return} 1;
00807     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a503ad979164a52f0f5e2a63e4c7da3a0}{CLIENT\_BLOCKED}) \{
00808         \textcolor{comment}{/* Blocked OPS timeout is handled with milliseconds resolution.}
00809 \textcolor{comment}{         * However note that the actual resolution is limited by}
00810 \textcolor{comment}{         * server.hz. */}
00811 
00812         \textcolor{keywordflow}{if} (c->bpop.timeout != 0 && c->bpop.timeout < now\_ms) \{
00813             \textcolor{comment}{/* Handle blocking operation specific timeout. */}
00814             replyToBlockedClientTimedOut(c);
00815             unblockClient(c);
00816         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.cluster\_enabled) \{
00817             \textcolor{comment}{/* Cluster: handle unblock & redirect of clients blocked}
00818 \textcolor{comment}{             * into keys no longer served by this server. */}
00819             \textcolor{keywordflow}{if} (clusterRedirectBlockedClientIfNeeded(c))
00820                 unblockClient(c);
00821         \}
00822     \}
00823     \textcolor{keywordflow}{return} 0;
00824 \}
00825 
00826 \textcolor{comment}{/* The client query buffer is an sds.c string that can end with a lot of}
00827 \textcolor{comment}{ * free space not used, this function reclaims space if needed.}
00828 \textcolor{comment}{ *}
00829 \textcolor{comment}{ * The function always returns 0 as it never terminates the client. */}
00830 \textcolor{keywordtype}{int} clientsCronResizeQueryBuffer(\hyperlink{structclient}{client} *c) \{
00831     size\_t querybuf\_size = sdsAllocSize(c->querybuf);
00832     time\_t idletime = server.unixtime - c->lastinteraction;
00833 
00834     \textcolor{comment}{/* There are two conditions to resize the query buffer:}
00835 \textcolor{comment}{     * 1) Query buffer is > BIG\_ARG and too big for latest peak.}
00836 \textcolor{comment}{     * 2) Client is inactive and the buffer is bigger than 1k. */}
00837     \textcolor{keywordflow}{if} (((querybuf\_size > \hyperlink{server_8h_afb6bccf6f1ac66b1d563330ab499fb32}{PROTO\_MBULK\_BIG\_ARG}) &&
00838          (querybuf\_size/(c->querybuf\_peak+1)) > 2) ||
00839          (querybuf\_size > 1024 && idletime > 2))
00840     \{
00841         \textcolor{comment}{/* Only resize the query buffer if it is actually wasting space. */}
00842         \textcolor{keywordflow}{if} (sdsavail(c->querybuf) > 1024) \{
00843             c->querybuf = sdsRemoveFreeSpace(c->querybuf);
00844         \}
00845     \}
00846     \textcolor{comment}{/* Reset the peak again to capture the peak memory usage in the next}
00847 \textcolor{comment}{     * cycle. */}
00848     c->querybuf\_peak = 0;
00849     \textcolor{keywordflow}{return} 0;
00850 \}
00851 
00852 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLIENTS\_CRON\_MIN\_ITERATIONS} 5
00853 \textcolor{keywordtype}{void} clientsCron(\textcolor{keywordtype}{void}) \{
00854     \textcolor{comment}{/* Make sure to process at least numclients/server.hz of clients}
00855 \textcolor{comment}{     * per call. Since this function is called server.hz times per second}
00856 \textcolor{comment}{     * we are sure that in the worst case we process all the clients in 1}
00857 \textcolor{comment}{     * second. */}
00858     \textcolor{keywordtype}{int} numclients = \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.clients);
00859     \textcolor{keywordtype}{int} iterations = numclients/server.hz;
00860     mstime\_t now = mstime();
00861 
00862     \textcolor{comment}{/* Process at least a few clients while we are at it, even if we need}
00863 \textcolor{comment}{     * to process less than CLIENTS\_CRON\_MIN\_ITERATIONS to meet our contract}
00864 \textcolor{comment}{     * of processing each client once per second. */}
00865     \textcolor{keywordflow}{if} (iterations < \hyperlink{server_8c_a79785342d159d7e8dc4547ffb330835d}{CLIENTS\_CRON\_MIN\_ITERATIONS})
00866         iterations = (numclients < \hyperlink{server_8c_a79785342d159d7e8dc4547ffb330835d}{CLIENTS\_CRON\_MIN\_ITERATIONS}) ?
00867                      numclients : \hyperlink{server_8c_a79785342d159d7e8dc4547ffb330835d}{CLIENTS\_CRON\_MIN\_ITERATIONS};
00868 
00869     \textcolor{keywordflow}{while}(\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.clients) && iterations--) \{
00870         \hyperlink{structclient}{client} *c;
00871         listNode *head;
00872 
00873         \textcolor{comment}{/* Rotate the list, take the current head, process.}
00874 \textcolor{comment}{         * This way if the client must be removed from the list it's the}
00875 \textcolor{comment}{         * first element and we don't incur into O(N) computation. */}
00876         listRotate(server.clients);
00877         head = \hyperlink{adlist_8h_aa8dc514bbe217bb2e87c1c77cfa84690}{listFirst}(server.clients);
00878         c = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(head);
00879         \textcolor{comment}{/* The following functions do different service checks on the client.}
00880 \textcolor{comment}{         * The protocol is that they return non-zero if the client was}
00881 \textcolor{comment}{         * terminated. */}
00882         \textcolor{keywordflow}{if} (clientsCronHandleTimeout(c,now)) \textcolor{keywordflow}{continue};
00883         \textcolor{keywordflow}{if} (clientsCronResizeQueryBuffer(c)) \textcolor{keywordflow}{continue};
00884     \}
00885 \}
00886 
00887 \textcolor{comment}{/* This function handles 'background' operations we are required to do}
00888 \textcolor{comment}{ * incrementally in Redis databases, such as active key expiring, resizing,}
00889 \textcolor{comment}{ * rehashing. */}
00890 \textcolor{keywordtype}{void} databasesCron(\textcolor{keywordtype}{void}) \{
00891     \textcolor{comment}{/* Expire keys by random sampling. Not required for slaves}
00892 \textcolor{comment}{     * as master will synthesize DELs for us. */}
00893     \textcolor{keywordflow}{if} (server.active\_expire\_enabled && server.masterhost == NULL) \{
00894         activeExpireCycle(\hyperlink{server_8h_a62e5b6ba358ddcdef709e107e4d24744}{ACTIVE\_EXPIRE\_CYCLE\_SLOW});
00895     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.masterhost != NULL) \{
00896         expireSlaveKeys();
00897     \}
00898 
00899     \textcolor{comment}{/* Defrag keys gradually. */}
00900     \textcolor{keywordflow}{if} (server.active\_defrag\_enabled)
00901         activeDefragCycle();
00902 
00903     \textcolor{comment}{/* Perform hash tables rehashing if needed, but only if there are no}
00904 \textcolor{comment}{     * other processes saving the DB on disk. Otherwise rehashing is bad}
00905 \textcolor{comment}{     * as will cause a lot of copy-on-write of memory pages. */}
00906     \textcolor{keywordflow}{if} (server.rdb\_child\_pid == -1 && server.aof\_child\_pid == -1) \{
00907         \textcolor{comment}{/* We use global counters so if we stop the computation at a given}
00908 \textcolor{comment}{         * DB we'll be able to start from the successive in the next}
00909 \textcolor{comment}{         * cron loop iteration. */}
00910         \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} resize\_db = 0;
00911         \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rehash\_db = 0;
00912         \textcolor{keywordtype}{int} dbs\_per\_call = \hyperlink{server_8h_aaab0790ee1a625276dce078a9dbbe075}{CRON\_DBS\_PER\_CALL};
00913         \textcolor{keywordtype}{int} j;
00914 
00915         \textcolor{comment}{/* Don't test more DBs than we have. */}
00916         \textcolor{keywordflow}{if} (dbs\_per\_call > server.dbnum) dbs\_per\_call = server.dbnum;
00917 
00918         \textcolor{comment}{/* Resize */}
00919         \textcolor{keywordflow}{for} (j = 0; j < dbs\_per\_call; j++) \{
00920             tryResizeHashTables(resize\_db % server.dbnum);
00921             resize\_db++;
00922         \}
00923 
00924         \textcolor{comment}{/* Rehash */}
00925         \textcolor{keywordflow}{if} (server.activerehashing) \{
00926             \textcolor{keywordflow}{for} (j = 0; j < dbs\_per\_call; j++) \{
00927                 \textcolor{keywordtype}{int} work\_done = incrementallyRehash(rehash\_db);
00928                 \textcolor{keywordflow}{if} (work\_done) \{
00929                     \textcolor{comment}{/* If the function did some work, stop here, we'll do}
00930 \textcolor{comment}{                     * more at the next cron loop. */}
00931                     \textcolor{keywordflow}{break};
00932                 \} \textcolor{keywordflow}{else} \{
00933                     \textcolor{comment}{/* If this db didn't need rehash, we'll try the next one. */}
00934                     rehash\_db++;
00935                     rehash\_db %= server.dbnum;
00936                 \}
00937             \}
00938         \}
00939     \}
00940 \}
00941 
00942 \textcolor{comment}{/* We take a cached value of the unix time in the global state because with}
00943 \textcolor{comment}{ * virtual memory and aging there is to store the current time in objects at}
00944 \textcolor{comment}{ * every object access, and accuracy is not needed. To access a global var is}
00945 \textcolor{comment}{ * a lot faster than calling time(NULL) */}
00946 \textcolor{keywordtype}{void} updateCachedTime(\textcolor{keywordtype}{void}) \{
00947     time\_t unixtime = time(NULL);
00948     \hyperlink{atomicvar_8h_a0f02b5846dcf4ed3669ecf771c512d12}{atomicSet}(server.unixtime,unixtime);
00949     server.mstime = mstime();
00950 \}
00951 
00952 \textcolor{comment}{/* This is our timer interrupt, called server.hz times per second.}
00953 \textcolor{comment}{ * Here is where we do a number of things that need to be done asynchronously.}
00954 \textcolor{comment}{ * For instance:}
00955 \textcolor{comment}{ *}
00956 \textcolor{comment}{ * - Active expired keys collection (it is also performed in a lazy way on}
00957 \textcolor{comment}{ *   lookup).}
00958 \textcolor{comment}{ * - Software watchdog.}
00959 \textcolor{comment}{ * - Update some statistic.}
00960 \textcolor{comment}{ * - Incremental rehashing of the DBs hash tables.}
00961 \textcolor{comment}{ * - Triggering BGSAVE / AOF rewrite, and handling of terminated children.}
00962 \textcolor{comment}{ * - Clients timeout of different kinds.}
00963 \textcolor{comment}{ * - Replication reconnection.}
00964 \textcolor{comment}{ * - Many more...}
00965 \textcolor{comment}{ *}
00966 \textcolor{comment}{ * Everything directly called here will be called server.hz times per second,}
00967 \textcolor{comment}{ * so in order to throttle execution of things we want to do less frequently}
00968 \textcolor{comment}{ * a macro is used: run\_with\_period(milliseconds) \{ .... \}}
00969 \textcolor{comment}{ */}
00970 
00971 \textcolor{keywordtype}{int} serverCron(\textcolor{keyword}{struct} \hyperlink{structaeEventLoop}{aeEventLoop} *eventLoop, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} id, \textcolor{keywordtype}{void} *clientData) \{
00972     \textcolor{keywordtype}{int} j;
00973     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(eventLoop);
00974     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(id);
00975     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(clientData);
00976 
00977     \textcolor{comment}{/* Software watchdog: deliver the SIGALRM that will reach the signal}
00978 \textcolor{comment}{     * handler if we don't return here fast enough. */}
00979     \textcolor{keywordflow}{if} (server.watchdog\_period) watchdogScheduleSignal(server.watchdog\_period);
00980 
00981     \textcolor{comment}{/* Update the time cache. */}
00982     updateCachedTime();
00983 
00984     \hyperlink{server_8h_aeb204872adbaabc0bd56c64f562b7928}{run\_with\_period}(100) \{
00985         trackInstantaneousMetric(\hyperlink{server_8h_ac8d50898802f96b76479bc975e1bbbf3}{STATS\_METRIC\_COMMAND},server.stat\_numcommands);
00986         trackInstantaneousMetric(\hyperlink{server_8h_a6d217560ae714ab8d0cc21832b210e0b}{STATS\_METRIC\_NET\_INPUT},
00987                 server.stat\_net\_input\_bytes);
00988         trackInstantaneousMetric(\hyperlink{server_8h_a3885f356f3a4cef22eb96fbfcc406333}{STATS\_METRIC\_NET\_OUTPUT},
00989                 server.stat\_net\_output\_bytes);
00990     \}
00991 
00992     \textcolor{comment}{/* We have just LRU\_BITS bits per object for LRU information.}
00993 \textcolor{comment}{     * So we use an (eventually wrapping) LRU clock.}
00994 \textcolor{comment}{     *}
00995 \textcolor{comment}{     * Note that even if the counter wraps it's not a big problem,}
00996 \textcolor{comment}{     * everything will still work but some object will appear younger}
00997 \textcolor{comment}{     * to Redis. However for this to happen a given object should never be}
00998 \textcolor{comment}{     * touched for all the time needed to the counter to wrap, which is}
00999 \textcolor{comment}{     * not likely.}
01000 \textcolor{comment}{     *}
01001 \textcolor{comment}{     * Note that you can change the resolution altering the}
01002 \textcolor{comment}{     * LRU\_CLOCK\_RESOLUTION define. */}
01003     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} lruclock = getLRUClock();
01004     \hyperlink{atomicvar_8h_a0f02b5846dcf4ed3669ecf771c512d12}{atomicSet}(server.lruclock,lruclock);
01005 
01006     \textcolor{comment}{/* Record the max memory used since the server was started. */}
01007     \textcolor{keywordflow}{if} (zmalloc\_used\_memory() > server.stat\_peak\_memory)
01008         server.stat\_peak\_memory = zmalloc\_used\_memory();
01009 
01010     \textcolor{comment}{/* Sample the RSS here since this is a relatively slow call. */}
01011     server.resident\_set\_size = zmalloc\_get\_rss();
01012 
01013     \textcolor{comment}{/* We received a SIGTERM, shutting down here in a safe way, as it is}
01014 \textcolor{comment}{     * not ok doing so inside the signal handler. */}
01015     \textcolor{keywordflow}{if} (server.shutdown\_asap) \{
01016         \textcolor{keywordflow}{if} (prepareForShutdown(\hyperlink{server_8h_a077401d3a9f810d535c00725ef6c6532}{SHUTDOWN\_NOFLAGS}) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) exit(0);
01017         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"SIGTERM received but errors trying to shut down the server,
       check the logs for more information"});
01018         server.shutdown\_asap = 0;
01019     \}
01020 
01021     \textcolor{comment}{/* Show some info about non-empty databases */}
01022     \hyperlink{server_8h_aeb204872adbaabc0bd56c64f562b7928}{run\_with\_period}(5000) \{
01023         \textcolor{keywordflow}{for} (j = 0; j < server.dbnum; j++) \{
01024             \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} size, used, vkeys;
01025 
01026             size = \hyperlink{dict_8h_aca9596be4bcc2caa07c17dd8cebcceec}{dictSlots}(server.db[j].dict);
01027             used = \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.db[j].dict);
01028             vkeys = \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.db[j].expires);
01029             \textcolor{keywordflow}{if} (used || vkeys) \{
01030                 serverLog(\hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE},\textcolor{stringliteral}{"DB %d: %lld keys (%lld volatile) in %lld slots HT."},j,
      used,vkeys,size);
01031                 \textcolor{comment}{/* dictPrintStats(server.dict); */}
01032             \}
01033         \}
01034     \}
01035 
01036     \textcolor{comment}{/* Show information about connected clients */}
01037     \textcolor{keywordflow}{if} (!server.sentinel\_mode) \{
01038         \hyperlink{server_8h_aeb204872adbaabc0bd56c64f562b7928}{run\_with\_period}(5000) \{
01039             serverLog(\hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE},
01040                 \textcolor{stringliteral}{"%lu clients connected (%lu slaves), %zu bytes in use"},
01041                 \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.clients)-\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.slaves),
01042                 \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.slaves),
01043                 zmalloc\_used\_memory());
01044         \}
01045     \}
01046 
01047     \textcolor{comment}{/* We need to do a few operations on clients asynchronously. */}
01048     clientsCron();
01049 
01050     \textcolor{comment}{/* Handle background operations on Redis databases. */}
01051     databasesCron();
01052 
01053     \textcolor{comment}{/* Start a scheduled AOF rewrite if this was requested by the user while}
01054 \textcolor{comment}{     * a BGSAVE was in progress. */}
01055     \textcolor{keywordflow}{if} (server.rdb\_child\_pid == -1 && server.aof\_child\_pid == -1 &&
01056         server.aof\_rewrite\_scheduled)
01057     \{
01058         rewriteAppendOnlyFileBackground();
01059     \}
01060 
01061     \textcolor{comment}{/* Check if a background saving or AOF rewrite in progress terminated. */}
01062     \textcolor{keywordflow}{if} (server.rdb\_child\_pid != -1 || server.aof\_child\_pid != -1 ||
01063         ldbPendingChildren())
01064     \{
01065         \textcolor{keywordtype}{int} statloc;
01066         pid\_t pid;
01067 
01068         \textcolor{keywordflow}{if} ((pid = wait3(&statloc,WNOHANG,NULL)) != 0) \{
01069             \textcolor{keywordtype}{int} exitcode = WEXITSTATUS(statloc);
01070             \textcolor{keywordtype}{int} bysignal = 0;
01071 
01072             \textcolor{keywordflow}{if} (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);
01073 
01074             \textcolor{keywordflow}{if} (pid == -1) \{
01075                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"wait3() returned an error: %s. "}
01076                     \textcolor{stringliteral}{"rdb\_child\_pid = %d, aof\_child\_pid = %d"},
01077                     strerror(errno),
01078                     (\textcolor{keywordtype}{int}) server.rdb\_child\_pid,
01079                     (\textcolor{keywordtype}{int}) server.aof\_child\_pid);
01080             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pid == server.rdb\_child\_pid) \{
01081                 backgroundSaveDoneHandler(exitcode,bysignal);
01082                 \textcolor{keywordflow}{if} (!bysignal && exitcode == 0) receiveChildInfo();
01083             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pid == server.aof\_child\_pid) \{
01084                 backgroundRewriteDoneHandler(exitcode,bysignal);
01085                 \textcolor{keywordflow}{if} (!bysignal && exitcode == 0) receiveChildInfo();
01086             \} \textcolor{keywordflow}{else} \{
01087                 \textcolor{keywordflow}{if} (!ldbRemoveChild(pid)) \{
01088                     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01089                         \textcolor{stringliteral}{"Warning, detected child with unmatched pid: %ld"},
01090                         (\textcolor{keywordtype}{long})pid);
01091                 \}
01092             \}
01093             updateDictResizePolicy();
01094             closeChildInfoPipe();
01095         \}
01096     \} \textcolor{keywordflow}{else} \{
01097         \textcolor{comment}{/* If there is not a background saving/rewrite in progress check if}
01098 \textcolor{comment}{         * we have to save/rewrite now */}
01099          \textcolor{keywordflow}{for} (j = 0; j < server.saveparamslen; j++) \{
01100             \textcolor{keyword}{struct} \hyperlink{structsaveparam}{saveparam} *sp = server.saveparams+j;
01101 
01102             \textcolor{comment}{/* Save if we reached the given amount of changes,}
01103 \textcolor{comment}{             * the given amount of seconds, and if the latest bgsave was}
01104 \textcolor{comment}{             * successful or if, in case of an error, at least}
01105 \textcolor{comment}{             * CONFIG\_BGSAVE\_RETRY\_DELAY seconds already elapsed. */}
01106             \textcolor{keywordflow}{if} (server.dirty >= sp->changes &&
01107                 server.unixtime-server.lastsave > sp->seconds &&
01108                 (server.unixtime-server.lastbgsave\_try >
01109                  \hyperlink{server_8h_a27e00ebd25c04beef22fabf61ea0b5ea}{CONFIG\_BGSAVE\_RETRY\_DELAY} ||
01110                  server.lastbgsave\_status == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}))
01111             \{
01112                 serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"%d changes in %d seconds. Saving..."},
01113                     sp->changes, (\textcolor{keywordtype}{int})sp->seconds);
01114                 rdbSaveInfo rsi, *rsiptr;
01115                 rsiptr = rdbPopulateSaveInfo(&rsi);
01116                 rdbSaveBackground(server.rdb\_filename,rsiptr);
01117                 \textcolor{keywordflow}{break};
01118             \}
01119          \}
01120 
01121          \textcolor{comment}{/* Trigger an AOF rewrite if needed */}
01122          \textcolor{keywordflow}{if} (server.rdb\_child\_pid == -1 &&
01123              server.aof\_child\_pid == -1 &&
01124              server.aof\_rewrite\_perc &&
01125              server.aof\_current\_size > server.aof\_rewrite\_min\_size)
01126          \{
01127             \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} base = server.aof\_rewrite\_base\_size ?
01128                             server.aof\_rewrite\_base\_size : 1;
01129             \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} growth = (server.aof\_current\_size*100/base) - 100;
01130             \textcolor{keywordflow}{if} (growth >= server.aof\_rewrite\_perc) \{
01131                 serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Starting automatic rewriting of AOF on %lld%% growth"},
      growth);
01132                 rewriteAppendOnlyFileBackground();
01133             \}
01134          \}
01135     \}
01136 
01137 
01138     \textcolor{comment}{/* AOF postponed flush: Try at every cron cycle if the slow fsync}
01139 \textcolor{comment}{     * completed. */}
01140     \textcolor{keywordflow}{if} (server.aof\_flush\_postponed\_start) flushAppendOnlyFile(0);
01141 
01142     \textcolor{comment}{/* AOF write errors: in this case we have a buffer to flush as well and}
01143 \textcolor{comment}{     * clear the AOF error in case of success to make the DB writable again,}
01144 \textcolor{comment}{     * however to try every second is enough in case of 'hz' is set to}
01145 \textcolor{comment}{     * an higher frequency. */}
01146     \hyperlink{server_8h_aeb204872adbaabc0bd56c64f562b7928}{run\_with\_period}(1000) \{
01147         \textcolor{keywordflow}{if} (server.aof\_last\_write\_status == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR})
01148             flushAppendOnlyFile(0);
01149     \}
01150 
01151     \textcolor{comment}{/* Close clients that need to be closed asynchronous */}
01152     freeClientsInAsyncFreeQueue();
01153 
01154     \textcolor{comment}{/* Clear the paused clients flag if needed. */}
01155     clientsArePaused(); \textcolor{comment}{/* Don't check return value, just use the side effect.*/}
01156 
01157     \textcolor{comment}{/* Replication cron function -- used to reconnect to master,}
01158 \textcolor{comment}{     * detect transfer failures, start background RDB transfers and so forth. */}
01159     \hyperlink{server_8h_aeb204872adbaabc0bd56c64f562b7928}{run\_with\_period}(1000) replicationCron();
01160 
01161     \textcolor{comment}{/* Run the Redis Cluster cron. */}
01162     \hyperlink{server_8h_aeb204872adbaabc0bd56c64f562b7928}{run\_with\_period}(100) \{
01163         \textcolor{keywordflow}{if} (server.cluster\_enabled) clusterCron();
01164     \}
01165 
01166     \textcolor{comment}{/* Run the Sentinel timer if we are in sentinel mode. */}
01167     \hyperlink{server_8h_aeb204872adbaabc0bd56c64f562b7928}{run\_with\_period}(100) \{
01168         \textcolor{keywordflow}{if} (server.sentinel\_mode) sentinelTimer();
01169     \}
01170 
01171     \textcolor{comment}{/* Cleanup expired MIGRATE cached sockets. */}
01172     \hyperlink{server_8h_aeb204872adbaabc0bd56c64f562b7928}{run\_with\_period}(1000) \{
01173         migrateCloseTimedoutSockets();
01174     \}
01175 
01176     \textcolor{comment}{/* Start a scheduled BGSAVE if the corresponding flag is set. This is}
01177 \textcolor{comment}{     * useful when we are forced to postpone a BGSAVE because an AOF}
01178 \textcolor{comment}{     * rewrite is in progress.}
01179 \textcolor{comment}{     *}
01180 \textcolor{comment}{     * Note: this code must be after the replicationCron() call above so}
01181 \textcolor{comment}{     * make sure when refactoring this file to keep this order. This is useful}
01182 \textcolor{comment}{     * because we want to give priority to RDB savings for replication. */}
01183     \textcolor{keywordflow}{if} (server.rdb\_child\_pid == -1 && server.aof\_child\_pid == -1 &&
01184         server.rdb\_bgsave\_scheduled &&
01185         (server.unixtime-server.lastbgsave\_try > \hyperlink{server_8h_a27e00ebd25c04beef22fabf61ea0b5ea}{CONFIG\_BGSAVE\_RETRY\_DELAY} ||
01186          server.lastbgsave\_status == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}))
01187     \{
01188         rdbSaveInfo rsi, *rsiptr;
01189         rsiptr = rdbPopulateSaveInfo(&rsi);
01190         \textcolor{keywordflow}{if} (rdbSaveBackground(server.rdb\_filename,rsiptr) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
01191             server.rdb\_bgsave\_scheduled = 0;
01192     \}
01193 
01194     server.cronloops++;
01195     \textcolor{keywordflow}{return} 1000/server.hz;
01196 \}
01197 
01198 \textcolor{comment}{/* This function gets called every time Redis is entering the}
01199 \textcolor{comment}{ * main loop of the event driven library, that is, before to sleep}
01200 \textcolor{comment}{ * for ready file descriptors. */}
01201 \textcolor{keywordtype}{void} beforeSleep(\textcolor{keyword}{struct} \hyperlink{structaeEventLoop}{aeEventLoop} *eventLoop) \{
01202     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(eventLoop);
01203 
01204     \textcolor{comment}{/* Call the Redis Cluster before sleep function. Note that this function}
01205 \textcolor{comment}{     * may change the state of Redis Cluster (from ok to fail or vice versa),}
01206 \textcolor{comment}{     * so it's a good idea to call it before serving the unblocked clients}
01207 \textcolor{comment}{     * later in this function. */}
01208     \textcolor{keywordflow}{if} (server.cluster\_enabled) clusterBeforeSleep();
01209 
01210     \textcolor{comment}{/* Run a fast expire cycle (the called function will return}
01211 \textcolor{comment}{     * ASAP if a fast cycle is not needed). */}
01212     \textcolor{keywordflow}{if} (server.active\_expire\_enabled && server.masterhost == NULL)
01213         activeExpireCycle(\hyperlink{server_8h_ae265e849da28d7e7793659e45579ee11}{ACTIVE\_EXPIRE\_CYCLE\_FAST});
01214 
01215     \textcolor{comment}{/* Send all the slaves an ACK request if at least one client blocked}
01216 \textcolor{comment}{     * during the previous event loop iteration. */}
01217     \textcolor{keywordflow}{if} (server.get\_ack\_from\_slaves) \{
01218         robj *argv[3];
01219 
01220         argv[0] = createStringObject(\textcolor{stringliteral}{"REPLCONF"},8);
01221         argv[1] = createStringObject(\textcolor{stringliteral}{"GETACK"},6);
01222         argv[2] = createStringObject(\textcolor{stringliteral}{"*"},1); \textcolor{comment}{/* Not used argument. */}
01223         replicationFeedSlaves(server.slaves, server.slaveseldb, argv, 3);
01224         decrRefCount(argv[0]);
01225         decrRefCount(argv[1]);
01226         decrRefCount(argv[2]);
01227         server.get\_ack\_from\_slaves = 0;
01228     \}
01229 
01230     \textcolor{comment}{/* Unblock all the clients blocked for synchronous replication}
01231 \textcolor{comment}{     * in WAIT. */}
01232     \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.clients\_waiting\_acks))
01233         processClientsWaitingReplicas();
01234 
01235     \textcolor{comment}{/* Check if there are clients unblocked by modules that implement}
01236 \textcolor{comment}{     * blocking commands. */}
01237     moduleHandleBlockedClients();
01238 
01239     \textcolor{comment}{/* Try to process pending commands for clients that were just unblocked. */}
01240     \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.unblocked\_clients))
01241         processUnblockedClients();
01242 
01243     \textcolor{comment}{/* Write the AOF buffer on disk */}
01244     flushAppendOnlyFile(0);
01245 
01246     \textcolor{comment}{/* Handle writes with pending output buffers. */}
01247     handleClientsWithPendingWrites();
01248 
01249     \textcolor{comment}{/* Before we are going to sleep, let the threads access the dataset by}
01250 \textcolor{comment}{     * releasing the GIL. Redis main thread will not touch anything at this}
01251 \textcolor{comment}{     * time. */}
01252     \textcolor{keywordflow}{if} (moduleCount()) moduleReleaseGIL();
01253 \}
01254 
01255 \textcolor{comment}{/* This function is called immadiately after the event loop multiplexing}
01256 \textcolor{comment}{ * API returned, and the control is going to soon return to Redis by invoking}
01257 \textcolor{comment}{ * the different events callbacks. */}
01258 \textcolor{keywordtype}{void} afterSleep(\textcolor{keyword}{struct} \hyperlink{structaeEventLoop}{aeEventLoop} *eventLoop) \{
01259     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(eventLoop);
01260     \textcolor{keywordflow}{if} (moduleCount()) moduleAcquireGIL();
01261 \}
01262 
01263 \textcolor{comment}{/* =========================== Server initialization ======================== */}
01264 
01265 \textcolor{keywordtype}{void} createSharedObjects(\textcolor{keywordtype}{void}) \{
01266     \textcolor{keywordtype}{int} j;
01267 
01268     shared.crlf = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"}));
01269     shared.ok = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(\textcolor{stringliteral}{"+OK\(\backslash\)r\(\backslash\)n"}));
01270     shared.err = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(\textcolor{stringliteral}{"-ERR\(\backslash\)r\(\backslash\)n"}));
01271     shared.emptybulk = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(\textcolor{stringliteral}{"$0\(\backslash\)r\(\backslash\)n\(\backslash\)r\(\backslash\)n"}));
01272     shared.czero = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(\textcolor{stringliteral}{":0\(\backslash\)r\(\backslash\)n"}));
01273     shared.cone = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(\textcolor{stringliteral}{":1\(\backslash\)r\(\backslash\)n"}));
01274     shared.cnegone = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(\textcolor{stringliteral}{":-1\(\backslash\)r\(\backslash\)n"}));
01275     shared.nullbulk = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(\textcolor{stringliteral}{"$-1\(\backslash\)r\(\backslash\)n"}));
01276     shared.nullmultibulk = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(\textcolor{stringliteral}{"*-1\(\backslash\)r\(\backslash\)n"}));
01277     shared.emptymultibulk = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(\textcolor{stringliteral}{"*0\(\backslash\)r\(\backslash\)n"}));
01278     shared.pong = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(\textcolor{stringliteral}{"+PONG\(\backslash\)r\(\backslash\)n"}));
01279     shared.queued = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(\textcolor{stringliteral}{"+QUEUED\(\backslash\)r\(\backslash\)n"}));
01280     shared.emptyscan = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(\textcolor{stringliteral}{"*2\(\backslash\)r\(\backslash\)n$1\(\backslash\)r\(\backslash\)n0\(\backslash\)r\(\backslash\)n*0\(\backslash\)r\(\backslash\)n"}));
01281     shared.wrongtypeerr = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(
01282         \textcolor{stringliteral}{"-WRONGTYPE Operation against a key holding the wrong kind of value\(\backslash\)r\(\backslash\)n"}));
01283     shared.nokeyerr = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(
01284         \textcolor{stringliteral}{"-ERR no such key\(\backslash\)r\(\backslash\)n"}));
01285     shared.syntaxerr = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(
01286         \textcolor{stringliteral}{"-ERR syntax error\(\backslash\)r\(\backslash\)n"}));
01287     shared.sameobjecterr = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(
01288         \textcolor{stringliteral}{"-ERR source and destination objects are the same\(\backslash\)r\(\backslash\)n"}));
01289     shared.outofrangeerr = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(
01290         \textcolor{stringliteral}{"-ERR index out of range\(\backslash\)r\(\backslash\)n"}));
01291     shared.noscripterr = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(
01292         \textcolor{stringliteral}{"-NOSCRIPT No matching script. Please use EVAL.\(\backslash\)r\(\backslash\)n"}));
01293     shared.loadingerr = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(
01294         \textcolor{stringliteral}{"-LOADING Redis is loading the dataset in memory\(\backslash\)r\(\backslash\)n"}));
01295     shared.slowscripterr = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(
01296         \textcolor{stringliteral}{"-BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.\(\backslash\)r\(\backslash\)n"})
      );
01297     shared.masterdownerr = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(
01298         \textcolor{stringliteral}{"-MASTERDOWN Link with MASTER is down and slave-serve-stale-data is set to 'no'.\(\backslash\)r\(\backslash\)n"}));
01299     shared.bgsaveerr = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(
01300         \textcolor{stringliteral}{"-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist
       on disk. Commands that may modify the data set are disabled, because this instance is configured to report
       errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis
       logs for details about the RDB error.\(\backslash\)r\(\backslash\)n"}));
01301     shared.roslaveerr = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(
01302         \textcolor{stringliteral}{"-READONLY You can't write against a read only slave.\(\backslash\)r\(\backslash\)n"}));
01303     shared.noautherr = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(
01304         \textcolor{stringliteral}{"-NOAUTH Authentication required.\(\backslash\)r\(\backslash\)n"}));
01305     shared.oomerr = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(
01306         \textcolor{stringliteral}{"-OOM command not allowed when used memory > 'maxmemory'.\(\backslash\)r\(\backslash\)n"}));
01307     shared.execaborterr = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(
01308         \textcolor{stringliteral}{"-EXECABORT Transaction discarded because of previous errors.\(\backslash\)r\(\backslash\)n"}));
01309     shared.noreplicaserr = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(
01310         \textcolor{stringliteral}{"-NOREPLICAS Not enough good slaves to write.\(\backslash\)r\(\backslash\)n"}));
01311     shared.busykeyerr = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(
01312         \textcolor{stringliteral}{"-BUSYKEY Target key name already exists.\(\backslash\)r\(\backslash\)n"}));
01313     shared.space = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(\textcolor{stringliteral}{" "}));
01314     shared.colon = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(\textcolor{stringliteral}{":"}));
01315     shared.plus = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsnew(\textcolor{stringliteral}{"+"}));
01316 
01317     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{server_8h_a950a6acbe9809f9e3dc541e8175b7b44}{PROTO\_SHARED\_SELECT\_CMDS}; j++) \{
01318         \textcolor{keywordtype}{char} dictid\_str[64];
01319         \textcolor{keywordtype}{int} dictid\_len;
01320 
01321         dictid\_len = ll2string(dictid\_str,\textcolor{keyword}{sizeof}(dictid\_str),j);
01322         shared.select[j] = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},
01323             sdscatprintf(sdsempty(),
01324                 \textcolor{stringliteral}{"*2\(\backslash\)r\(\backslash\)n$6\(\backslash\)r\(\backslash\)nSELECT\(\backslash\)r\(\backslash\)n$%d\(\backslash\)r\(\backslash\)n%s\(\backslash\)r\(\backslash\)n"},
01325                 dictid\_len, dictid\_str));
01326     \}
01327     shared.messagebulk = createStringObject(\textcolor{stringliteral}{"$7\(\backslash\)r\(\backslash\)nmessage\(\backslash\)r\(\backslash\)n"},13);
01328     shared.pmessagebulk = createStringObject(\textcolor{stringliteral}{"$8\(\backslash\)r\(\backslash\)npmessage\(\backslash\)r\(\backslash\)n"},14);
01329     shared.subscribebulk = createStringObject(\textcolor{stringliteral}{"$9\(\backslash\)r\(\backslash\)nsubscribe\(\backslash\)r\(\backslash\)n"},15);
01330     shared.unsubscribebulk = createStringObject(\textcolor{stringliteral}{"$11\(\backslash\)r\(\backslash\)nunsubscribe\(\backslash\)r\(\backslash\)n"},18);
01331     shared.psubscribebulk = createStringObject(\textcolor{stringliteral}{"$10\(\backslash\)r\(\backslash\)npsubscribe\(\backslash\)r\(\backslash\)n"},17);
01332     shared.punsubscribebulk = createStringObject(\textcolor{stringliteral}{"$12\(\backslash\)r\(\backslash\)npunsubscribe\(\backslash\)r\(\backslash\)n"},19);
01333     shared.del = createStringObject(\textcolor{stringliteral}{"DEL"},3);
01334     shared.unlink = createStringObject(\textcolor{stringliteral}{"UNLINK"},6);
01335     shared.rpop = createStringObject(\textcolor{stringliteral}{"RPOP"},4);
01336     shared.lpop = createStringObject(\textcolor{stringliteral}{"LPOP"},4);
01337     shared.lpush = createStringObject(\textcolor{stringliteral}{"LPUSH"},5);
01338     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{server_8h_a311fc8b18b93af94e1ad418f1386b519}{OBJ\_SHARED\_INTEGERS}; j++) \{
01339         shared.integers[j] =
01340             makeObjectShared(createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},(\textcolor{keywordtype}{void}*)(\textcolor{keywordtype}{long})j));
01341         shared.integers[j]->encoding = \hyperlink{server_8h_ae934cf008a0be0ef009c92c2d006a816}{OBJ\_ENCODING\_INT};
01342     \}
01343     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{server_8h_aff2f6e62c729d3f8b119d761818be317}{OBJ\_SHARED\_BULKHDR\_LEN}; j++) \{
01344         shared.mbulkhdr[j] = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},
01345             sdscatprintf(sdsempty(),\textcolor{stringliteral}{"*%d\(\backslash\)r\(\backslash\)n"},j));
01346         shared.bulkhdr[j] = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},
01347             sdscatprintf(sdsempty(),\textcolor{stringliteral}{"$%d\(\backslash\)r\(\backslash\)n"},j));
01348     \}
01349     \textcolor{comment}{/* The following two shared objects, minstring and maxstrings, are not}
01350 \textcolor{comment}{     * actually used for their value but as a special object meaning}
01351 \textcolor{comment}{     * respectively the minimum possible string and the maximum possible}
01352 \textcolor{comment}{     * string in string comparisons for the ZRANGEBYLEX command. */}
01353     shared.minstring = sdsnew(\textcolor{stringliteral}{"minstring"});
01354     shared.maxstring = sdsnew(\textcolor{stringliteral}{"maxstring"});
01355 \}
01356 
01357 \textcolor{keywordtype}{void} initServerConfig(\textcolor{keywordtype}{void}) \{
01358     \textcolor{keywordtype}{int} j;
01359 
01360     pthread\_mutex\_init(&server.next\_client\_id\_mutex,NULL);
01361     pthread\_mutex\_init(&server.lruclock\_mutex,NULL);
01362     pthread\_mutex\_init(&server.unixtime\_mutex,NULL);
01363 
01364     getRandomHexChars(server.runid,\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE});
01365     server.runid[\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}] = \textcolor{stringliteral}{'\(\backslash\)0'};
01366     changeReplicationId();
01367     clearReplicationId2();
01368     server.configfile = NULL;
01369     server.executable = NULL;
01370     server.hz = \hyperlink{server_8h_aa5a3b127e21d6bf089025d953c44678a}{CONFIG\_DEFAULT\_HZ};
01371     server.arch\_bits = (\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{long}) == 8) ? 64 : 32;
01372     server.port = \hyperlink{server_8h_afc9f3396e2da1194ef2ccc6ab97d4e3d}{CONFIG\_DEFAULT\_SERVER\_PORT};
01373     server.tcp\_backlog = \hyperlink{server_8h_ab85c155ec2652313a561af139fdb5575}{CONFIG\_DEFAULT\_TCP\_BACKLOG};
01374     server.bindaddr\_count = 0;
01375     server.unixsocket = NULL;
01376     server.unixsocketperm = \hyperlink{server_8h_a486eb6d6b0e44a772877112dbd928494}{CONFIG\_DEFAULT\_UNIX\_SOCKET\_PERM};
01377     server.ipfd\_count = 0;
01378     server.sofd = -1;
01379     server.protected\_mode = \hyperlink{server_8h_aa84cedc4d9e3da82d28324a85626a666}{CONFIG\_DEFAULT\_PROTECTED\_MODE};
01380     server.dbnum = \hyperlink{server_8h_abc5ff12d4e9b662f85d2cb11a0220926}{CONFIG\_DEFAULT\_DBNUM};
01381     server.verbosity = \hyperlink{server_8h_a407337e4d193cc8fc965938b7a247240}{CONFIG\_DEFAULT\_VERBOSITY};
01382     server.maxidletime = \hyperlink{server_8h_a1d6ca2cad092805de3acd7b74876a323}{CONFIG\_DEFAULT\_CLIENT\_TIMEOUT};
01383     server.tcpkeepalive = \hyperlink{server_8h_a2c8d2290c3ac70d63ed2e62b11ab566b}{CONFIG\_DEFAULT\_TCP\_KEEPALIVE};
01384     server.active\_expire\_enabled = 1;
01385     server.active\_defrag\_enabled = \hyperlink{server_8h_a7bc03a080189821c8c88b31027281d4b}{CONFIG\_DEFAULT\_ACTIVE\_DEFRAG};
01386     server.active\_defrag\_ignore\_bytes = \hyperlink{server_8h_aed98ddd341b643d52417b875418b2ecb}{CONFIG\_DEFAULT\_DEFRAG\_IGNORE\_BYTES}
      ;
01387     server.active\_defrag\_threshold\_lower = 
      \hyperlink{server_8h_a9d23ea1ff80f9db5faef6f5aca6f76aa}{CONFIG\_DEFAULT\_DEFRAG\_THRESHOLD\_LOWER};
01388     server.active\_defrag\_threshold\_upper = 
      \hyperlink{server_8h_a75b8ce2fafb93ddeb96f0e5602c2bd0c}{CONFIG\_DEFAULT\_DEFRAG\_THRESHOLD\_UPPER};
01389     server.active\_defrag\_cycle\_min = \hyperlink{server_8h_a5d49d5c9a11564577f7e78d6f52d9db5}{CONFIG\_DEFAULT\_DEFRAG\_CYCLE\_MIN};
01390     server.active\_defrag\_cycle\_max = \hyperlink{server_8h_ac3f69c7e78a189639eab66a2b32753d0}{CONFIG\_DEFAULT\_DEFRAG\_CYCLE\_MAX};
01391     server.client\_max\_querybuf\_len = \hyperlink{server_8h_a395f766c5962e4ee2da01dee43600f7a}{PROTO\_MAX\_QUERYBUF\_LEN};
01392     server.saveparams = NULL;
01393     server.loading = 0;
01394     server.logfile = zstrdup(\hyperlink{server_8h_a0698b50ff7fe51afd74cf20a72b75e1b}{CONFIG\_DEFAULT\_LOGFILE});
01395     server.syslog\_enabled = \hyperlink{server_8h_a22c57e53d530d95ae346f13d6781a549}{CONFIG\_DEFAULT\_SYSLOG\_ENABLED};
01396     server.syslog\_ident = zstrdup(\hyperlink{server_8h_ac7414291a371fd3a2bad4d34e13f0d77}{CONFIG\_DEFAULT\_SYSLOG\_IDENT});
01397     server.syslog\_facility = LOG\_LOCAL0;
01398     server.daemonize = \hyperlink{server_8h_a1783425a4095949ab8b23ae4cbe0e576}{CONFIG\_DEFAULT\_DAEMONIZE};
01399     server.supervised = 0;
01400     server.supervised\_mode = \hyperlink{server_8h_a2a0d6ba64b419357e52a6473f48bc882}{SUPERVISED\_NONE};
01401     server.aof\_state = \hyperlink{server_8h_a5226306fbcebcb6d5d02e0fef3c213c2}{AOF\_OFF};
01402     server.\hyperlink{config_8h_af5994c643c434574580bb7816af82cad}{aof\_fsync} = \hyperlink{server_8h_af07bcc4b15ed4f7aed3f6efcb483b75b}{CONFIG\_DEFAULT\_AOF\_FSYNC};
01403     server.aof\_no\_fsync\_on\_rewrite = \hyperlink{server_8h_a9b588e3803fff7fe515f20d7bc4aa8e6}{CONFIG\_DEFAULT\_AOF\_NO\_FSYNC\_ON\_REWRITE}
      ;
01404     server.aof\_rewrite\_perc = \hyperlink{server_8h_a85f5870a07f58d1679988f7eb84ca995}{AOF\_REWRITE\_PERC};
01405     server.aof\_rewrite\_min\_size = \hyperlink{server_8h_a9b5a91047aa18eb5df52e99c97afab84}{AOF\_REWRITE\_MIN\_SIZE};
01406     server.aof\_rewrite\_base\_size = 0;
01407     server.aof\_rewrite\_scheduled = 0;
01408     server.aof\_last\_fsync = time(NULL);
01409     server.aof\_rewrite\_time\_last = -1;
01410     server.aof\_rewrite\_time\_start = -1;
01411     server.aof\_lastbgrewrite\_status = \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01412     server.aof\_delayed\_fsync = 0;
01413     server.aof\_fd = -1;
01414     server.aof\_selected\_db = -1; \textcolor{comment}{/* Make sure the first time will not match */}
01415     server.aof\_flush\_postponed\_start = 0;
01416     server.aof\_rewrite\_incremental\_fsync = 
      \hyperlink{server_8h_a356d1b1e39a75671cc55fdaf64be3a85}{CONFIG\_DEFAULT\_AOF\_REWRITE\_INCREMENTAL\_FSYNC};
01417     server.aof\_load\_truncated = \hyperlink{server_8h_a35b94be7201c7ad80e43f8aa214867b7}{CONFIG\_DEFAULT\_AOF\_LOAD\_TRUNCATED};
01418     server.aof\_use\_rdb\_preamble = \hyperlink{server_8h_a938328826b94d0e9bd07b225767cad43}{CONFIG\_DEFAULT\_AOF\_USE\_RDB\_PREAMBLE}
      ;
01419     server.pidfile = NULL;
01420     server.rdb\_filename = zstrdup(\hyperlink{server_8h_af563e9454f9a1ef49de787e4fc66c448}{CONFIG\_DEFAULT\_RDB\_FILENAME});
01421     server.aof\_filename = zstrdup(\hyperlink{server_8h_af3bada72076c951a9d5959e73456635a}{CONFIG\_DEFAULT\_AOF\_FILENAME});
01422     server.requirepass = NULL;
01423     server.rdb\_compression = \hyperlink{server_8h_a250e4ab3a143ecbce2603ffaa3a29c0a}{CONFIG\_DEFAULT\_RDB\_COMPRESSION};
01424     server.rdb\_checksum = \hyperlink{server_8h_a549382a72b7490f18a44f03e2dbe5568}{CONFIG\_DEFAULT\_RDB\_CHECKSUM};
01425     server.stop\_writes\_on\_bgsave\_err = 
      \hyperlink{server_8h_a050e337ffdb94f18e190cc6d6d851196}{CONFIG\_DEFAULT\_STOP\_WRITES\_ON\_BGSAVE\_ERROR};
01426     server.activerehashing = \hyperlink{server_8h_a147863f3b338d25f54e026d88a487010}{CONFIG\_DEFAULT\_ACTIVE\_REHASHING};
01427     server.active\_defrag\_running = 0;
01428     server.notify\_keyspace\_events = 0;
01429     server.maxclients = \hyperlink{server_8h_ab24065d7a9205264189681ab4e4d410e}{CONFIG\_DEFAULT\_MAX\_CLIENTS};
01430     server.blocked\_clients = 0;
01431     memset(server.blocked\_clients\_by\_type,0,
01432            \textcolor{keyword}{sizeof}(server.blocked\_clients\_by\_type));
01433     server.maxmemory = \hyperlink{server_8h_a314eacfa28e22254ee8cc05f2b257281}{CONFIG\_DEFAULT\_MAXMEMORY};
01434     server.maxmemory\_policy = \hyperlink{server_8h_a5b8590d1c7aa090e48b9506c0842d206}{CONFIG\_DEFAULT\_MAXMEMORY\_POLICY};
01435     server.maxmemory\_samples = \hyperlink{server_8h_a38e65004c240be8a04ab492731c7da50}{CONFIG\_DEFAULT\_MAXMEMORY\_SAMPLES};
01436     server.lfu\_log\_factor = \hyperlink{server_8h_ab343786c44a1885885a1ac254b724317}{CONFIG\_DEFAULT\_LFU\_LOG\_FACTOR};
01437     server.lfu\_decay\_time = \hyperlink{server_8h_a24a132a96a693133fc057a491080aebf}{CONFIG\_DEFAULT\_LFU\_DECAY\_TIME};
01438     server.hash\_max\_ziplist\_entries = \hyperlink{server_8h_a41a8473748a5eeafbd30b20f22177c51}{OBJ\_HASH\_MAX\_ZIPLIST\_ENTRIES};
01439     server.hash\_max\_ziplist\_value = \hyperlink{server_8h_a63842e277a2ccef80f42cbae07c9f5d8}{OBJ\_HASH\_MAX\_ZIPLIST\_VALUE};
01440     server.list\_max\_ziplist\_size = \hyperlink{server_8h_a27c7e814708df2c7eed37fbc6ac0b7f1}{OBJ\_LIST\_MAX\_ZIPLIST\_SIZE};
01441     server.list\_compress\_depth = \hyperlink{server_8h_a7b811522f7befdc10e69883f360e45b4}{OBJ\_LIST\_COMPRESS\_DEPTH};
01442     server.set\_max\_intset\_entries = \hyperlink{server_8h_a333fe7f520eb6f33cd1c88e4691de3ed}{OBJ\_SET\_MAX\_INTSET\_ENTRIES};
01443     server.zset\_max\_ziplist\_entries = \hyperlink{server_8h_ac29d7218c448fac5b27039cf0d73fde2}{OBJ\_ZSET\_MAX\_ZIPLIST\_ENTRIES};
01444     server.zset\_max\_ziplist\_value = \hyperlink{server_8h_a24b004e72489e83f721bdd334234aa49}{OBJ\_ZSET\_MAX\_ZIPLIST\_VALUE};
01445     server.hll\_sparse\_max\_bytes = \hyperlink{server_8h_a479f69398ffb0f86fdbb4fa03876bc69}{CONFIG\_DEFAULT\_HLL\_SPARSE\_MAX\_BYTES}
      ;
01446     server.shutdown\_asap = 0;
01447     server.cluster\_enabled = 0;
01448     server.cluster\_node\_timeout = \hyperlink{cluster_8h_acb94b0516dcfb9814e13dfe97f3ad6b1}{CLUSTER\_DEFAULT\_NODE\_TIMEOUT};
01449     server.cluster\_migration\_barrier = \hyperlink{cluster_8h_a1895138f4125c5dce77e8fe28c9bd8d1}{CLUSTER\_DEFAULT\_MIGRATION\_BARRIER}
      ;
01450     server.cluster\_slave\_validity\_factor = \hyperlink{cluster_8h_a44b183827017eca27648d5991fc50b13}{CLUSTER\_DEFAULT\_SLAVE\_VALIDITY}
      ;
01451     server.cluster\_require\_full\_coverage = 
      \hyperlink{cluster_8h_aa27e3466414a1464e6f2721b8872827d}{CLUSTER\_DEFAULT\_REQUIRE\_FULL\_COVERAGE};
01452     server.cluster\_configfile = zstrdup(\hyperlink{server_8h_a5b0c46fd63529819e2c0189003d72122}{CONFIG\_DEFAULT\_CLUSTER\_CONFIG\_FILE}
      );
01453     server.cluster\_announce\_ip = \hyperlink{server_8h_a0b8729bdfd537311480f4c3bb3a20905}{CONFIG\_DEFAULT\_CLUSTER\_ANNOUNCE\_IP};
01454     server.cluster\_announce\_port = \hyperlink{server_8h_ac55c8423c202c1f0b4e786eb70adefb3}{CONFIG\_DEFAULT\_CLUSTER\_ANNOUNCE\_PORT}
      ;
01455     server.cluster\_announce\_bus\_port = 
      \hyperlink{server_8h_a86d6a82bc81e718079728c3cb6c8c5b4}{CONFIG\_DEFAULT\_CLUSTER\_ANNOUNCE\_BUS\_PORT};
01456     server.migrate\_cached\_sockets = dictCreate(&migrateCacheDictType,NULL);
01457     server.next\_client\_id = 1; \textcolor{comment}{/* Client IDs, start from 1 .*/}
01458     server.loading\_process\_events\_interval\_bytes = (1024*1024*2);
01459     server.lazyfree\_lazy\_eviction = \hyperlink{server_8h_aa6529c6ba7143b1ec4aa15d8a96b2154}{CONFIG\_DEFAULT\_LAZYFREE\_LAZY\_EVICTION}
      ;
01460     server.lazyfree\_lazy\_expire = \hyperlink{server_8h_a2e6080731ab6e81b19f1bfedf7b298f9}{CONFIG\_DEFAULT\_LAZYFREE\_LAZY\_EXPIRE}
      ;
01461     server.lazyfree\_lazy\_server\_del = 
      \hyperlink{server_8h_ac1f765315b576de4c0ea2beb7e37ae02}{CONFIG\_DEFAULT\_LAZYFREE\_LAZY\_SERVER\_DEL};
01462     server.always\_show\_logo = \hyperlink{server_8h_a0f350070473d6d89bcd365ea4ff361cb}{CONFIG\_DEFAULT\_ALWAYS\_SHOW\_LOGO};
01463     server.lua\_time\_limit = \hyperlink{server_8h_ab72fac70fbc902a7f106f4c710e08271}{LUA\_SCRIPT\_TIME\_LIMIT};
01464 
01465     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} lruclock = getLRUClock();
01466     \hyperlink{atomicvar_8h_a0f02b5846dcf4ed3669ecf771c512d12}{atomicSet}(server.lruclock,lruclock);
01467     resetServerSaveParams();
01468 
01469     appendServerSaveParams(60*60,1);  \textcolor{comment}{/* save after 1 hour and 1 change */}
01470     appendServerSaveParams(300,100);  \textcolor{comment}{/* save after 5 minutes and 100 changes */}
01471     appendServerSaveParams(60,10000); \textcolor{comment}{/* save after 1 minute and 10000 changes */}
01472 
01473     \textcolor{comment}{/* Replication related */}
01474     server.masterauth = NULL;
01475     server.masterhost = NULL;
01476     server.masterport = 6379;
01477     server.master = NULL;
01478     server.cached\_master = NULL;
01479     server.master\_initial\_offset = -1;
01480     server.repl\_state = \hyperlink{server_8h_a256b9506e551eaa7417f75f8fa9ed901}{REPL\_STATE\_NONE};
01481     server.repl\_syncio\_timeout = \hyperlink{server_8h_a68ad9c6e5f817d58fa51c1b2e88e83e0}{CONFIG\_REPL\_SYNCIO\_TIMEOUT};
01482     server.repl\_serve\_stale\_data = \hyperlink{server_8h_ab42b23884952f9887529b6efbf0d4ac6}{CONFIG\_DEFAULT\_SLAVE\_SERVE\_STALE\_DATA}
      ;
01483     server.repl\_slave\_ro = \hyperlink{server_8h_af9b93e225d47183c97bc1f86db1aff2a}{CONFIG\_DEFAULT\_SLAVE\_READ\_ONLY};
01484     server.repl\_slave\_lazy\_flush = \hyperlink{server_8h_ace54c14c3b13acbf1d7a6d6e893cdfd3}{CONFIG\_DEFAULT\_SLAVE\_LAZY\_FLUSH};
01485     server.repl\_down\_since = 0; \textcolor{comment}{/* Never connected, repl is down since EVER. */}
01486     server.repl\_disable\_tcp\_nodelay = 
      \hyperlink{server_8h_a27f51044a8a11ab99366a77bb3ea1e93}{CONFIG\_DEFAULT\_REPL\_DISABLE\_TCP\_NODELAY};
01487     server.repl\_diskless\_sync = \hyperlink{server_8h_a08ebaf972da18ad58c71c615aa26c5cf}{CONFIG\_DEFAULT\_REPL\_DISKLESS\_SYNC};
01488     server.repl\_diskless\_sync\_delay = 
      \hyperlink{server_8h_aee54cf0e2819c8b96136987f0f8ef0b8}{CONFIG\_DEFAULT\_REPL\_DISKLESS\_SYNC\_DELAY};
01489     server.repl\_ping\_slave\_period = \hyperlink{server_8h_a5496312872886690751d1e4a248026e9}{CONFIG\_DEFAULT\_REPL\_PING\_SLAVE\_PERIOD}
      ;
01490     server.repl\_timeout = \hyperlink{server_8h_a7608d2301c8447e2237ba173d8eef88e}{CONFIG\_DEFAULT\_REPL\_TIMEOUT};
01491     server.repl\_min\_slaves\_to\_write = \hyperlink{server_8h_a68661cd596afb7595059264beee63dc7}{CONFIG\_DEFAULT\_MIN\_SLAVES\_TO\_WRITE}
      ;
01492     server.repl\_min\_slaves\_max\_lag = \hyperlink{server_8h_a547664770d2cec2d58d144a2f5afbbd8}{CONFIG\_DEFAULT\_MIN\_SLAVES\_MAX\_LAG}
      ;
01493     server.slave\_priority = \hyperlink{server_8h_a7effaf912f26a1eabe495e899d705fee}{CONFIG\_DEFAULT\_SLAVE\_PRIORITY};
01494     server.slave\_announce\_ip = \hyperlink{server_8h_aca61db3dff4f6e864b3e49d3f087fb51}{CONFIG\_DEFAULT\_SLAVE\_ANNOUNCE\_IP};
01495     server.slave\_announce\_port = \hyperlink{server_8h_ac8ad217da6cfbdf399948aff4d3550ca}{CONFIG\_DEFAULT\_SLAVE\_ANNOUNCE\_PORT};
01496     server.master\_repl\_offset = 0;
01497 
01498     \textcolor{comment}{/* Replication partial resync backlog */}
01499     server.repl\_backlog = NULL;
01500     server.repl\_backlog\_size = \hyperlink{server_8h_a6ac2fd3dd83df43a6b262bab091bc371}{CONFIG\_DEFAULT\_REPL\_BACKLOG\_SIZE};
01501     server.repl\_backlog\_histlen = 0;
01502     server.repl\_backlog\_idx = 0;
01503     server.repl\_backlog\_off = 0;
01504     server.repl\_backlog\_time\_limit = \hyperlink{server_8h_ac5c5c62f45277671484daad919338b5e}{CONFIG\_DEFAULT\_REPL\_BACKLOG\_TIME\_LIMIT}
      ;
01505     server.repl\_no\_slaves\_since = time(NULL);
01506 
01507     \textcolor{comment}{/* Client output buffer limits */}
01508     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{server_8h_aea8f6f3fac3a68e35807eba109dbc501}{CLIENT\_TYPE\_OBUF\_COUNT}; j++)
01509         server.client\_obuf\_limits[j] = clientBufferLimitsDefaults[j];
01510 
01511     \textcolor{comment}{/* Double constants initialization */}
01512     R\_Zero = 0.0;
01513     R\_PosInf = 1.0/R\_Zero;
01514     R\_NegInf = -1.0/R\_Zero;
01515     R\_Nan = R\_Zero/R\_Zero;
01516 
01517     \textcolor{comment}{/* Command table -- we initiialize it here as it is part of the}
01518 \textcolor{comment}{     * initial configuration, since command names may be changed via}
01519 \textcolor{comment}{     * redis.conf using the rename-command directive. */}
01520     server.commands = dictCreate(&commandTableDictType,NULL);
01521     server.orig\_commands = dictCreate(&commandTableDictType,NULL);
01522     populateCommandTable();
01523     server.delCommand = lookupCommandByCString(\textcolor{stringliteral}{"del"});
01524     server.multiCommand = lookupCommandByCString(\textcolor{stringliteral}{"multi"});
01525     server.lpushCommand = lookupCommandByCString(\textcolor{stringliteral}{"lpush"});
01526     server.lpopCommand = lookupCommandByCString(\textcolor{stringliteral}{"lpop"});
01527     server.rpopCommand = lookupCommandByCString(\textcolor{stringliteral}{"rpop"});
01528     server.sremCommand = lookupCommandByCString(\textcolor{stringliteral}{"srem"});
01529     server.execCommand = lookupCommandByCString(\textcolor{stringliteral}{"exec"});
01530     server.expireCommand = lookupCommandByCString(\textcolor{stringliteral}{"expire"});
01531     server.pexpireCommand = lookupCommandByCString(\textcolor{stringliteral}{"pexpire"});
01532 
01533     \textcolor{comment}{/* Slow log */}
01534     server.slowlog\_log\_slower\_than = \hyperlink{server_8h_a3cf317db9aeeba99be3654b11d3d0580}{CONFIG\_DEFAULT\_SLOWLOG\_LOG\_SLOWER\_THAN}
      ;
01535     server.slowlog\_max\_len = \hyperlink{server_8h_ada65a939812527070ed001e451d9bc54}{CONFIG\_DEFAULT\_SLOWLOG\_MAX\_LEN};
01536 
01537     \textcolor{comment}{/* Latency monitor */}
01538     server.latency\_monitor\_threshold = 
      \hyperlink{server_8h_a20a7f934b2eceae8fdbb1ac112a783c3}{CONFIG\_DEFAULT\_LATENCY\_MONITOR\_THRESHOLD};
01539 
01540     \textcolor{comment}{/* Debugging */}
01541     server.assert\_failed = \textcolor{stringliteral}{"<no assertion failed>"};
01542     server.assert\_file = \textcolor{stringliteral}{"<no file>"};
01543     server.assert\_line = 0;
01544     server.bug\_report\_start = 0;
01545     server.watchdog\_period = 0;
01546 \}
01547 
01548 \textcolor{keyword}{extern} \textcolor{keywordtype}{char} **environ;
01549 
01550 \textcolor{comment}{/* Restart the server, executing the same executable that started this}
01551 \textcolor{comment}{ * instance, with the same arguments and configuration file.}
01552 \textcolor{comment}{ *}
01553 \textcolor{comment}{ * The function is designed to directly call execve() so that the new}
01554 \textcolor{comment}{ * server instance will retain the PID of the previous one.}
01555 \textcolor{comment}{ *}
01556 \textcolor{comment}{ * The list of flags, that may be bitwise ORed together, alter the}
01557 \textcolor{comment}{ * behavior of this function:}
01558 \textcolor{comment}{ *}
01559 \textcolor{comment}{ * RESTART\_SERVER\_NONE              No flags.}
01560 \textcolor{comment}{ * RESTART\_SERVER\_GRACEFULLY        Do a proper shutdown before restarting.}
01561 \textcolor{comment}{ * RESTART\_SERVER\_CONFIG\_REWRITE    Rewrite the config file before restarting.}
01562 \textcolor{comment}{ *}
01563 \textcolor{comment}{ * On success the function does not return, because the process turns into}
01564 \textcolor{comment}{ * a different process. On error C\_ERR is returned. */}
01565 \textcolor{keywordtype}{int} restartServer(\textcolor{keywordtype}{int} flags, mstime\_t delay) \{
01566     \textcolor{keywordtype}{int} j;
01567 
01568     \textcolor{comment}{/* Check if we still have accesses to the executable that started this}
01569 \textcolor{comment}{     * server instance. */}
01570     \textcolor{keywordflow}{if} (access(server.executable,X\_OK) == -1) \{
01571         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Can't restart: this process has no "}
01572                              \textcolor{stringliteral}{"permissions to execute %s"}, server.executable);
01573         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01574     \}
01575 
01576     \textcolor{comment}{/* Config rewriting. */}
01577     \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_a57b24bdd0dc4a156941789096e9e1f44}{RESTART\_SERVER\_CONFIG\_REWRITE} &&
01578         server.configfile &&
01579         rewriteConfig(server.configfile) == -1)
01580     \{
01581         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Can't restart: configuration rewrite process "}
01582                              \textcolor{stringliteral}{"failed"});
01583         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01584     \}
01585 
01586     \textcolor{comment}{/* Perform a proper shutdown. */}
01587     \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_af951fdb3aa8efbce7cde83e8a31fff6a}{RESTART\_SERVER\_GRACEFULLY} &&
01588         prepareForShutdown(\hyperlink{server_8h_a077401d3a9f810d535c00725ef6c6532}{SHUTDOWN\_NOFLAGS}) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
01589     \{
01590         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Can't restart: error preparing for shutdown"});
01591         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01592     \}
01593 
01594     \textcolor{comment}{/* Close all file descriptors, with the exception of stdin, stdout, strerr}
01595 \textcolor{comment}{     * which are useful if we restart a Redis server which is not daemonized. */}
01596     \textcolor{keywordflow}{for} (j = 3; j < (\textcolor{keywordtype}{int})server.maxclients + 1024; j++) \{
01597         \textcolor{comment}{/* Test the descriptor validity before closing it, otherwise}
01598 \textcolor{comment}{         * Valgrind issues a warning on close(). */}
01599         \textcolor{keywordflow}{if} (fcntl(j,F\_GETFD) != -1) close(j);
01600     \}
01601 
01602     \textcolor{comment}{/* Execute the server with the original command line. */}
01603     \textcolor{keywordflow}{if} (delay) usleep(delay*1000);
01604     zfree(server.exec\_argv[0]);
01605     server.exec\_argv[0] = zstrdup(server.executable);
01606     execve(server.executable,server.exec\_argv,environ);
01607 
01608     \textcolor{comment}{/* If an error occurred here, there is nothing we can do, but exit. */}
01609     \_exit(1);
01610 
01611     \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}; \textcolor{comment}{/* Never reached. */}
01612 \}
01613 
01614 \textcolor{comment}{/* This function will try to raise the max number of open files accordingly to}
01615 \textcolor{comment}{ * the configured max number of clients. It also reserves a number of file}
01616 \textcolor{comment}{ * descriptors (CONFIG\_MIN\_RESERVED\_FDS) for extra operations of}
01617 \textcolor{comment}{ * persistence, listening sockets, log files and so forth.}
01618 \textcolor{comment}{ *}
01619 \textcolor{comment}{ * If it will not be possible to set the limit accordingly to the configured}
01620 \textcolor{comment}{ * max number of clients, the function will do the reverse setting}
01621 \textcolor{comment}{ * server.maxclients to the value that we can actually handle. */}
01622 \textcolor{keywordtype}{void} adjustOpenFilesLimit(\textcolor{keywordtype}{void}) \{
01623     rlim\_t maxfiles = server.maxclients+\hyperlink{server_8h_abcea50457e3de849eab11d0ba5d81d08}{CONFIG\_MIN\_RESERVED\_FDS};
01624     \textcolor{keyword}{struct} rlimit limit;
01625 
01626     \textcolor{keywordflow}{if} (getrlimit(RLIMIT\_NOFILE,&limit) == -1) \{
01627         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Unable to obtain the current NOFILE limit (%s), assuming 1024
       and setting the max clients configuration accordingly."},
01628             strerror(errno));
01629         server.maxclients = 1024-\hyperlink{server_8h_abcea50457e3de849eab11d0ba5d81d08}{CONFIG\_MIN\_RESERVED\_FDS};
01630     \} \textcolor{keywordflow}{else} \{
01631         rlim\_t oldlimit = limit.rlim\_cur;
01632 
01633         \textcolor{comment}{/* Set the max number of files if the current limit is not enough}
01634 \textcolor{comment}{         * for our needs. */}
01635         \textcolor{keywordflow}{if} (oldlimit < maxfiles) \{
01636             rlim\_t bestlimit;
01637             \textcolor{keywordtype}{int} setrlimit\_error = 0;
01638 
01639             \textcolor{comment}{/* Try to set the file limit to match 'maxfiles' or at least}
01640 \textcolor{comment}{             * to the higher value supported less than maxfiles. */}
01641             bestlimit = maxfiles;
01642             \textcolor{keywordflow}{while}(bestlimit > oldlimit) \{
01643                 rlim\_t decr\_step = 16;
01644 
01645                 limit.rlim\_cur = bestlimit;
01646                 limit.rlim\_max = bestlimit;
01647                 \textcolor{keywordflow}{if} (setrlimit(RLIMIT\_NOFILE,&limit) != -1) \textcolor{keywordflow}{break};
01648                 setrlimit\_error = errno;
01649 
01650                 \textcolor{comment}{/* We failed to set file limit to 'bestlimit'. Try with a}
01651 \textcolor{comment}{                 * smaller limit decrementing by a few FDs per iteration. */}
01652                 \textcolor{keywordflow}{if} (bestlimit < decr\_step) \textcolor{keywordflow}{break};
01653                 bestlimit -= decr\_step;
01654             \}
01655 
01656             \textcolor{comment}{/* Assume that the limit we get initially is still valid if}
01657 \textcolor{comment}{             * our last try was even lower. */}
01658             \textcolor{keywordflow}{if} (bestlimit < oldlimit) bestlimit = oldlimit;
01659 
01660             \textcolor{keywordflow}{if} (bestlimit < maxfiles) \{
01661                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} old\_maxclients = server.maxclients;
01662                 server.maxclients = bestlimit-\hyperlink{server_8h_abcea50457e3de849eab11d0ba5d81d08}{CONFIG\_MIN\_RESERVED\_FDS};
01663                 \textcolor{comment}{/* maxclients is unsigned so may overflow: in order}
01664 \textcolor{comment}{                 * to check if maxclients is now logically less than 1}
01665 \textcolor{comment}{                 * we test indirectly via bestlimit. */}
01666                 \textcolor{keywordflow}{if} (bestlimit <= \hyperlink{server_8h_abcea50457e3de849eab11d0ba5d81d08}{CONFIG\_MIN\_RESERVED\_FDS}) \{
01667                     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Your current 'ulimit -n' "}
01668                         \textcolor{stringliteral}{"of %llu is not enough for the server to start. "}
01669                         \textcolor{stringliteral}{"Please increase your open file limit to at least "}
01670                         \textcolor{stringliteral}{"%llu. Exiting."},
01671                         (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) oldlimit,
01672                         (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) maxfiles);
01673                     exit(1);
01674                 \}
01675                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"You requested maxclients of %d "}
01676                     \textcolor{stringliteral}{"requiring at least %llu max file descriptors."},
01677                     old\_maxclients,
01678                     (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) maxfiles);
01679                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Server can't set maximum open files "}
01680                     \textcolor{stringliteral}{"to %llu because of OS error: %s."},
01681                     (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) maxfiles, strerror(setrlimit\_error));
01682                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Current maximum open files is %llu. "}
01683                     \textcolor{stringliteral}{"maxclients has been reduced to %d to compensate for "}
01684                     \textcolor{stringliteral}{"low ulimit. "}
01685                     \textcolor{stringliteral}{"If you need higher maxclients increase 'ulimit -n'."},
01686                     (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) bestlimit, server.maxclients);
01687             \} \textcolor{keywordflow}{else} \{
01688                 serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Increased maximum number of open files "}
01689                     \textcolor{stringliteral}{"to %llu (it was originally set to %llu)."},
01690                     (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) maxfiles,
01691                     (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) oldlimit);
01692             \}
01693         \}
01694     \}
01695 \}
01696 
01697 \textcolor{comment}{/* Check that server.tcp\_backlog can be actually enforced in Linux according}
01698 \textcolor{comment}{ * to the value of /proc/sys/net/core/somaxconn, or warn about it. */}
01699 \textcolor{keywordtype}{void} checkTcpBacklogSettings(\textcolor{keywordtype}{void}) \{
01700 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} HAVE\_PROC\_SOMAXCONN
01701     FILE *fp = fopen(\textcolor{stringliteral}{"/proc/sys/net/core/somaxconn"},\textcolor{stringliteral}{"r"});
01702     \textcolor{keywordtype}{char} buf[1024];
01703     \textcolor{keywordflow}{if} (!fp) \textcolor{keywordflow}{return};
01704     \textcolor{keywordflow}{if} (fgets(buf,\textcolor{keyword}{sizeof}(buf),fp) != NULL) \{
01705         \textcolor{keywordtype}{int} somaxconn = atoi(buf);
01706         \textcolor{keywordflow}{if} (somaxconn > 0 && somaxconn < server.tcp\_backlog) \{
01707             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"WARNING: The TCP backlog setting of %d cannot be enforced
       because /proc/sys/net/core/somaxconn is set to the lower value of %d."}, server.tcp\_backlog, somaxconn);
01708         \}
01709     \}
01710     fclose(fp);
01711 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
01712 \}
01713 
01714 \textcolor{comment}{/* Initialize a set of file descriptors to listen to the specified 'port'}
01715 \textcolor{comment}{ * binding the addresses specified in the Redis server configuration.}
01716 \textcolor{comment}{ *}
01717 \textcolor{comment}{ * The listening file descriptors are stored in the integer array 'fds'}
01718 \textcolor{comment}{ * and their number is set in '*count'.}
01719 \textcolor{comment}{ *}
01720 \textcolor{comment}{ * The addresses to bind are specified in the global server.bindaddr array}
01721 \textcolor{comment}{ * and their number is server.bindaddr\_count. If the server configuration}
01722 \textcolor{comment}{ * contains no specific addresses to bind, this function will try to}
01723 \textcolor{comment}{ * bind * (all addresses) for both the IPv4 and IPv6 protocols.}
01724 \textcolor{comment}{ *}
01725 \textcolor{comment}{ * On success the function returns C\_OK.}
01726 \textcolor{comment}{ *}
01727 \textcolor{comment}{ * On error the function returns C\_ERR. For the function to be on}
01728 \textcolor{comment}{ * error, at least one of the server.bindaddr addresses was}
01729 \textcolor{comment}{ * impossible to bind, or no bind addresses were specified in the server}
01730 \textcolor{comment}{ * configuration but the function is not able to bind * for at least}
01731 \textcolor{comment}{ * one of the IPv4 or IPv6 protocols. */}
01732 \textcolor{keywordtype}{int} listenToPort(\textcolor{keywordtype}{int} port, \textcolor{keywordtype}{int} *fds, \textcolor{keywordtype}{int} *count) \{
01733     \textcolor{keywordtype}{int} j;
01734 
01735     \textcolor{comment}{/* Force binding of 0.0.0.0 if no bind address is specified, always}
01736 \textcolor{comment}{     * entering the loop if j == 0. */}
01737     \textcolor{keywordflow}{if} (server.bindaddr\_count == 0) server.bindaddr[0] = NULL;
01738     \textcolor{keywordflow}{for} (j = 0; j < server.bindaddr\_count || j == 0; j++) \{
01739         \textcolor{keywordflow}{if} (server.bindaddr[j] == NULL) \{
01740             \textcolor{keywordtype}{int} unsupported = 0;
01741             \textcolor{comment}{/* Bind * for both IPv6 and IPv4, we enter here only if}
01742 \textcolor{comment}{             * server.bindaddr\_count == 0. */}
01743             fds[*count] = anetTcp6Server(server.neterr,port,NULL,
01744                 server.tcp\_backlog);
01745             \textcolor{keywordflow}{if} (fds[*count] != \hyperlink{anet_8h_a0697b7774a7e0f4ef141839fe93536fe}{ANET\_ERR}) \{
01746                 anetNonBlock(NULL,fds[*count]);
01747                 (*count)++;
01748             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (errno == EAFNOSUPPORT) \{
01749                 unsupported++;
01750                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Not listening to IPv6: unsupproted"});
01751             \}
01752 
01753             \textcolor{keywordflow}{if} (*count == 1 || unsupported) \{
01754                 \textcolor{comment}{/* Bind the IPv4 address as well. */}
01755                 fds[*count] = anetTcpServer(server.neterr,port,NULL,
01756                     server.tcp\_backlog);
01757                 \textcolor{keywordflow}{if} (fds[*count] != \hyperlink{anet_8h_a0697b7774a7e0f4ef141839fe93536fe}{ANET\_ERR}) \{
01758                     anetNonBlock(NULL,fds[*count]);
01759                     (*count)++;
01760                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (errno == EAFNOSUPPORT) \{
01761                     unsupported++;
01762                     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Not listening to IPv4: unsupproted"});
01763                 \}
01764             \}
01765             \textcolor{comment}{/* Exit the loop if we were able to bind * on IPv4 and IPv6,}
01766 \textcolor{comment}{             * otherwise fds[*count] will be ANET\_ERR and we'll print an}
01767 \textcolor{comment}{             * error and return to the caller with an error. */}
01768             \textcolor{keywordflow}{if} (*count + unsupported == 2) \textcolor{keywordflow}{break};
01769         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (strchr(server.bindaddr[j],\textcolor{stringliteral}{':'})) \{
01770             \textcolor{comment}{/* Bind IPv6 address. */}
01771             fds[*count] = anetTcp6Server(server.neterr,port,server.bindaddr[j],
01772                 server.tcp\_backlog);
01773         \} \textcolor{keywordflow}{else} \{
01774             \textcolor{comment}{/* Bind IPv4 address. */}
01775             fds[*count] = anetTcpServer(server.neterr,port,server.bindaddr[j],
01776                 server.tcp\_backlog);
01777         \}
01778         \textcolor{keywordflow}{if} (fds[*count] == \hyperlink{anet_8h_a0697b7774a7e0f4ef141839fe93536fe}{ANET\_ERR}) \{
01779             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01780                 \textcolor{stringliteral}{"Creating Server TCP listening socket %s:%d: %s"},
01781                 server.bindaddr[j] ? server.bindaddr[j] : \textcolor{stringliteral}{"*"},
01782                 port, server.neterr);
01783             \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01784         \}
01785         anetNonBlock(NULL,fds[*count]);
01786         (*count)++;
01787     \}
01788     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01789 \}
01790 
01791 \textcolor{comment}{/* Resets the stats that we expose via INFO or other means that we want}
01792 \textcolor{comment}{ * to reset via CONFIG RESETSTAT. The function is also used in order to}
01793 \textcolor{comment}{ * initialize these fields in initServer() at server startup. */}
01794 \textcolor{keywordtype}{void} resetServerStats(\textcolor{keywordtype}{void}) \{
01795     \textcolor{keywordtype}{int} j;
01796 
01797     server.stat\_numcommands = 0;
01798     server.stat\_numconnections = 0;
01799     server.stat\_expiredkeys = 0;
01800     server.stat\_evictedkeys = 0;
01801     server.stat\_keyspace\_misses = 0;
01802     server.stat\_keyspace\_hits = 0;
01803     server.stat\_active\_defrag\_hits = 0;
01804     server.stat\_active\_defrag\_misses = 0;
01805     server.stat\_active\_defrag\_key\_hits = 0;
01806     server.stat\_active\_defrag\_key\_misses = 0;
01807     server.stat\_fork\_time = 0;
01808     server.stat\_fork\_rate = 0;
01809     server.stat\_rejected\_conn = 0;
01810     server.stat\_sync\_full = 0;
01811     server.stat\_sync\_partial\_ok = 0;
01812     server.stat\_sync\_partial\_err = 0;
01813     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{server_8h_ad9e350cb5eeb396592d0d80f70e6e040}{STATS\_METRIC\_COUNT}; j++) \{
01814         server.inst\_metric[j].idx = 0;
01815         server.inst\_metric[j].last\_sample\_time = mstime();
01816         server.inst\_metric[j].last\_sample\_count = 0;
01817         memset(server.inst\_metric[j].samples,0,
01818             \textcolor{keyword}{sizeof}(server.inst\_metric[j].samples));
01819     \}
01820     server.stat\_net\_input\_bytes = 0;
01821     server.stat\_net\_output\_bytes = 0;
01822     server.aof\_delayed\_fsync = 0;
01823 \}
01824 
01825 \textcolor{keywordtype}{void} initServer(\textcolor{keywordtype}{void}) \{
01826     \textcolor{keywordtype}{int} j;
01827 
01828     signal(SIGHUP, SIG\_IGN);
01829     signal(SIGPIPE, SIG\_IGN);
01830     setupSignalHandlers();
01831 
01832     \textcolor{keywordflow}{if} (server.syslog\_enabled) \{
01833         openlog(server.syslog\_ident, LOG\_PID | LOG\_NDELAY | LOG\_NOWAIT,
01834             server.syslog\_facility);
01835     \}
01836 
01837     server.pid = getpid();
01838     server.current\_client = NULL;
01839     server.clients = listCreate();
01840     server.clients\_to\_close = listCreate();
01841     server.slaves = listCreate();
01842     server.monitors = listCreate();
01843     server.clients\_pending\_write = listCreate();
01844     server.slaveseldb = -1; \textcolor{comment}{/* Force to emit the first SELECT command. */}
01845     server.unblocked\_clients = listCreate();
01846     server.ready\_keys = listCreate();
01847     server.clients\_waiting\_acks = listCreate();
01848     server.get\_ack\_from\_slaves = 0;
01849     server.clients\_paused = 0;
01850     server.system\_memory\_size = zmalloc\_get\_memory\_size();
01851 
01852     createSharedObjects();
01853     adjustOpenFilesLimit();
01854     server.el = aeCreateEventLoop(server.maxclients+\hyperlink{server_8h_a6725c1ff5b6a17f930627263f484d107}{CONFIG\_FDSET\_INCR});
01855     \textcolor{keywordflow}{if} (server.el == NULL) \{
01856         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01857             \textcolor{stringliteral}{"Failed creating the event loop. Error message: '%s'"},
01858             strerror(errno));
01859         exit(1);
01860     \}
01861     server.db = zmalloc(\textcolor{keyword}{sizeof}(redisDb)*server.dbnum);
01862 
01863     \textcolor{comment}{/* Open the TCP listening socket for the user commands. */}
01864     \textcolor{keywordflow}{if} (server.port != 0 &&
01865         listenToPort(server.port,server.ipfd,&server.ipfd\_count) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR})
01866         exit(1);
01867 
01868     \textcolor{comment}{/* Open the listening Unix domain socket. */}
01869     \textcolor{keywordflow}{if} (server.unixsocket != NULL) \{
01870         unlink(server.unixsocket); \textcolor{comment}{/* don't care if this fails */}
01871         server.sofd = anetUnixServer(server.neterr,server.unixsocket,
01872             server.unixsocketperm, server.tcp\_backlog);
01873         \textcolor{keywordflow}{if} (server.sofd == \hyperlink{anet_8h_a0697b7774a7e0f4ef141839fe93536fe}{ANET\_ERR}) \{
01874             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"Opening Unix socket: %s"}, server.neterr);
01875             exit(1);
01876         \}
01877         anetNonBlock(NULL,server.sofd);
01878     \}
01879 
01880     \textcolor{comment}{/* Abort if there are no listening sockets at all. */}
01881     \textcolor{keywordflow}{if} (server.ipfd\_count == 0 && server.sofd < 0) \{
01882         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"Configured to not listen anywhere, exiting."});
01883         exit(1);
01884     \}
01885 
01886     \textcolor{comment}{/* Create the Redis databases, and initialize other internal state. */}
01887     \textcolor{keywordflow}{for} (j = 0; j < server.dbnum; j++) \{
01888         server.db[j].dict = dictCreate(&dbDictType,NULL);
01889         server.db[j].expires = dictCreate(&keyptrDictType,NULL);
01890         server.db[j].blocking\_keys = dictCreate(&keylistDictType,NULL);
01891         server.db[j].ready\_keys = dictCreate(&objectKeyPointerValueDictType,NULL);
01892         server.db[j].watched\_keys = dictCreate(&keylistDictType,NULL);
01893         server.db[j].id = j;
01894         server.db[j].avg\_ttl = 0;
01895     \}
01896     evictionPoolAlloc(); \textcolor{comment}{/* Initialize the LRU keys pool. */}
01897     server.pubsub\_channels = dictCreate(&keylistDictType,NULL);
01898     server.pubsub\_patterns = listCreate();
01899     \hyperlink{adlist_8h_a648e4a2d20decff3182a72a608b0b8f2}{listSetFreeMethod}(server.pubsub\_patterns,freePubsubPattern);
01900     \hyperlink{adlist_8h_a3dac429a545f8def9a2bf9077eb66ddc}{listSetMatchMethod}(server.pubsub\_patterns,listMatchPubsubPattern);
01901     server.cronloops = 0;
01902     server.rdb\_child\_pid = -1;
01903     server.aof\_child\_pid = -1;
01904     server.rdb\_child\_type = \hyperlink{server_8h_acfd6e0670ac08e8f4c13f33c8a2c6b5e}{RDB\_CHILD\_TYPE\_NONE};
01905     server.rdb\_bgsave\_scheduled = 0;
01906     server.child\_info\_pipe[0] = -1;
01907     server.child\_info\_pipe[1] = -1;
01908     server.child\_info\_data.magic = 0;
01909     aofRewriteBufferReset();
01910     server.aof\_buf = sdsempty();
01911     server.lastsave = time(NULL); \textcolor{comment}{/* At startup we consider the DB saved. */}
01912     server.lastbgsave\_try = 0;    \textcolor{comment}{/* At startup we never tried to BGSAVE. */}
01913     server.rdb\_save\_time\_last = -1;
01914     server.rdb\_save\_time\_start = -1;
01915     server.dirty = 0;
01916     resetServerStats();
01917     \textcolor{comment}{/* A few stats we don't want to reset: server startup time, and peak mem. */}
01918     server.stat\_starttime = time(NULL);
01919     server.stat\_peak\_memory = 0;
01920     server.stat\_rdb\_cow\_bytes = 0;
01921     server.stat\_aof\_cow\_bytes = 0;
01922     server.resident\_set\_size = 0;
01923     server.lastbgsave\_status = \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01924     server.aof\_last\_write\_status = \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01925     server.aof\_last\_write\_errno = 0;
01926     server.repl\_good\_slaves\_count = 0;
01927     updateCachedTime();
01928 
01929     \textcolor{comment}{/* Create the timer callback, this is our way to process many background}
01930 \textcolor{comment}{     * operations incrementally, like clients timeout, eviction of unaccessed}
01931 \textcolor{comment}{     * expired keys and so forth. */}
01932     \textcolor{keywordflow}{if} (aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == \hyperlink{ae_8h_aa16dcf7effdf8f8df97f51b1cb51a9df}{AE\_ERR}) \{
01933         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Can't create event loop timers."});
01934         exit(1);
01935     \}
01936 
01937     \textcolor{comment}{/* Create an event handler for accepting new connections in TCP and Unix}
01938 \textcolor{comment}{     * domain sockets. */}
01939     \textcolor{keywordflow}{for} (j = 0; j < server.ipfd\_count; j++) \{
01940         \textcolor{keywordflow}{if} (aeCreateFileEvent(server.el, server.ipfd[j], \hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE},
01941             acceptTcpHandler,NULL) == \hyperlink{ae_8h_aa16dcf7effdf8f8df97f51b1cb51a9df}{AE\_ERR})
01942             \{
01943                 \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(
01944                     \textcolor{stringliteral}{"Unrecoverable error creating server.ipfd file event."});
01945             \}
01946     \}
01947     \textcolor{keywordflow}{if} (server.sofd > 0 && aeCreateFileEvent(server.el,server.sofd,
      \hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE},
01948         acceptUnixHandler,NULL) == \hyperlink{ae_8h_aa16dcf7effdf8f8df97f51b1cb51a9df}{AE\_ERR}) \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unrecoverable error creating
       server.sofd file event."});
01949 
01950 
01951     \textcolor{comment}{/* Register a readable event for the pipe used to awake the event loop}
01952 \textcolor{comment}{     * when a blocked client in a module needs attention. */}
01953     \textcolor{keywordflow}{if} (aeCreateFileEvent(server.el, server.module\_blocked\_pipe[0], 
      \hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE},
01954         moduleBlockedClientPipeReadable,NULL) == \hyperlink{ae_8h_aa16dcf7effdf8f8df97f51b1cb51a9df}{AE\_ERR}) \{
01955             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(
01956                 \textcolor{stringliteral}{"Error registering the readable event for the module "}
01957                 \textcolor{stringliteral}{"blocked clients subsystem."});
01958     \}
01959 
01960     \textcolor{comment}{/* Open the AOF file if needed. */}
01961     \textcolor{keywordflow}{if} (server.aof\_state == \hyperlink{server_8h_af6b151c9dced28e94c19479197113a83}{AOF\_ON}) \{
01962         server.aof\_fd = open(server.aof\_filename,
01963                                O\_WRONLY|O\_APPEND|O\_CREAT,0644);
01964         \textcolor{keywordflow}{if} (server.aof\_fd == -1) \{
01965             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"Can't open the append-only file: %s"},
01966                 strerror(errno));
01967             exit(1);
01968         \}
01969     \}
01970 
01971     \textcolor{comment}{/* 32 bit instances are limited to 4GB of address space, so if there is}
01972 \textcolor{comment}{     * no explicit limit in the user provided configuration we set a limit}
01973 \textcolor{comment}{     * at 3 GB using maxmemory with 'noeviction' policy'. This avoids}
01974 \textcolor{comment}{     * useless crashes of the Redis instance for out of memory. */}
01975     \textcolor{keywordflow}{if} (server.arch\_bits == 32 && server.maxmemory == 0) \{
01976         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Warning: 32 bit instance detected but no memory limit set.
       Setting 3 GB maxmemory limit with 'noeviction' policy now."});
01977         server.maxmemory = 3072LL*(1024*1024); \textcolor{comment}{/* 3 GB */}
01978         server.maxmemory\_policy = \hyperlink{server_8h_a418e5a222cf659c003df77830f1ae343}{MAXMEMORY\_NO\_EVICTION};
01979     \}
01980 
01981     \textcolor{keywordflow}{if} (server.cluster\_enabled) clusterInit();
01982     replicationScriptCacheInit();
01983     scriptingInit(1);
01984     slowlogInit();
01985     latencyMonitorInit();
01986     bioInit();
01987     server.initial\_memory\_usage = zmalloc\_used\_memory();
01988 \}
01989 
01990 \textcolor{comment}{/* Populates the Redis Command Table starting from the hard coded list}
01991 \textcolor{comment}{ * we have on top of redis.c file. */}
01992 \textcolor{keywordtype}{void} populateCommandTable(\textcolor{keywordtype}{void}) \{
01993     \textcolor{keywordtype}{int} j;
01994     \textcolor{keywordtype}{int} numcommands = \textcolor{keyword}{sizeof}(redisCommandTable)/\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand});
01995 
01996     \textcolor{keywordflow}{for} (j = 0; j < numcommands; j++) \{
01997         \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *c = redisCommandTable+j;
01998         \textcolor{keywordtype}{char} *f = c->sflags;
01999         \textcolor{keywordtype}{int} retval1, retval2;
02000 
02001         \textcolor{keywordflow}{while}(*f != \textcolor{stringliteral}{'\(\backslash\)0'}) \{
02002             \textcolor{keywordflow}{switch}(*f) \{
02003             \textcolor{keywordflow}{case} \textcolor{stringliteral}{'w'}: c->flags |= \hyperlink{server_8h_a7391deb9c3a262ded3e186e94eb884e2}{CMD\_WRITE}; \textcolor{keywordflow}{break};
02004             \textcolor{keywordflow}{case} \textcolor{stringliteral}{'r'}: c->flags |= \hyperlink{server_8h_a7e9c728f228e1c82ae1e22173375abcf}{CMD\_READONLY}; \textcolor{keywordflow}{break};
02005             \textcolor{keywordflow}{case} \textcolor{stringliteral}{'m'}: c->flags |= \hyperlink{server_8h_aef97c640ad8dfdaca21eb67d4c37e447}{CMD\_DENYOOM}; \textcolor{keywordflow}{break};
02006             \textcolor{keywordflow}{case} \textcolor{stringliteral}{'a'}: c->flags |= \hyperlink{server_8h_a1917805ea3942a4784ec806c33bc6033}{CMD\_ADMIN}; \textcolor{keywordflow}{break};
02007             \textcolor{keywordflow}{case} \textcolor{stringliteral}{'p'}: c->flags |= \hyperlink{server_8h_a201d97fc457fe5bd58cb863b4ac7a0cc}{CMD\_PUBSUB}; \textcolor{keywordflow}{break};
02008             \textcolor{keywordflow}{case} \textcolor{stringliteral}{'s'}: c->flags |= \hyperlink{server_8h_aaf26ba9b59589bc7701e36fb440a0fbe}{CMD\_NOSCRIPT}; \textcolor{keywordflow}{break};
02009             \textcolor{keywordflow}{case} \textcolor{stringliteral}{'R'}: c->flags |= \hyperlink{server_8h_a9f6608fefa355981c2a865ef3d44f196}{CMD\_RANDOM}; \textcolor{keywordflow}{break};
02010             \textcolor{keywordflow}{case} \textcolor{stringliteral}{'S'}: c->flags |= \hyperlink{server_8h_a819ad39aa4aef302c4421c3cd910252d}{CMD\_SORT\_FOR\_SCRIPT}; \textcolor{keywordflow}{break};
02011             \textcolor{keywordflow}{case} \textcolor{stringliteral}{'l'}: c->flags |= \hyperlink{server_8h_a5327d118cf467e77d8bb0cebdce3c0ce}{CMD\_LOADING}; \textcolor{keywordflow}{break};
02012             \textcolor{keywordflow}{case} \textcolor{stringliteral}{'t'}: c->flags |= \hyperlink{server_8h_acf1f58ff0b6790cd8d0e3edf1a7e599f}{CMD\_STALE}; \textcolor{keywordflow}{break};
02013             \textcolor{keywordflow}{case} \textcolor{stringliteral}{'M'}: c->flags |= \hyperlink{server_8h_a43e2aecb49a88a6cd4e56bfa971bdc71}{CMD\_SKIP\_MONITOR}; \textcolor{keywordflow}{break};
02014             \textcolor{keywordflow}{case} \textcolor{stringliteral}{'k'}: c->flags |= \hyperlink{server_8h_af0b13ef0f1dabe404fd7d904cb66b548}{CMD\_ASKING}; \textcolor{keywordflow}{break};
02015             \textcolor{keywordflow}{case} \textcolor{stringliteral}{'F'}: c->flags |= \hyperlink{server_8h_ae21dc0d9c0dcdefa14ca1054c48f252f}{CMD\_FAST}; \textcolor{keywordflow}{break};
02016             \textcolor{keywordflow}{default}: \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unsupported command flag"}); \textcolor{keywordflow}{break};
02017             \}
02018             f++;
02019         \}
02020 
02021         retval1 = dictAdd(server.commands, sdsnew(c->name), c);
02022         \textcolor{comment}{/* Populate an additional dictionary that will be unaffected}
02023 \textcolor{comment}{         * by rename-command statements in redis.conf. */}
02024         retval2 = dictAdd(server.orig\_commands, sdsnew(c->name), c);
02025         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(retval1 == \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK} && retval2 == 
      \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK});
02026     \}
02027 \}
02028 
02029 \textcolor{keywordtype}{void} resetCommandTableStats(\textcolor{keywordtype}{void}) \{
02030     \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *c;
02031     dictEntry *de;
02032     dictIterator *di;
02033 
02034     di = dictGetSafeIterator(server.commands);
02035     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
02036         c = (\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *) \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
02037         c->microseconds = 0;
02038         c->calls = 0;
02039     \}
02040     dictReleaseIterator(di);
02041 
02042 \}
02043 
02044 \textcolor{comment}{/* ========================== Redis OP Array API ============================ */}
02045 
02046 \textcolor{keywordtype}{void} redisOpArrayInit(redisOpArray *oa) \{
02047     oa->ops = NULL;
02048     oa->numops = 0;
02049 \}
02050 
02051 \textcolor{keywordtype}{int} redisOpArrayAppend(redisOpArray *oa, \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, \textcolor{keywordtype}{int} dbid,
02052                        robj **argv, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{int} target)
02053 \{
02054     redisOp *op;
02055 
02056     oa->ops = zrealloc(oa->ops,\textcolor{keyword}{sizeof}(redisOp)*(oa->numops+1));
02057     op = oa->ops+oa->numops;
02058     op->cmd = cmd;
02059     op->dbid = dbid;
02060     op->argv = argv;
02061     op->argc = argc;
02062     op->target = target;
02063     oa->numops++;
02064     \textcolor{keywordflow}{return} oa->numops;
02065 \}
02066 
02067 \textcolor{keywordtype}{void} redisOpArrayFree(redisOpArray *oa) \{
02068     \textcolor{keywordflow}{while}(oa->numops) \{
02069         \textcolor{keywordtype}{int} j;
02070         redisOp *op;
02071 
02072         oa->numops--;
02073         op = oa->ops+oa->numops;
02074         \textcolor{keywordflow}{for} (j = 0; j < op->argc; j++)
02075             decrRefCount(op->argv[j]);
02076         zfree(op->argv);
02077     \}
02078     zfree(oa->ops);
02079 \}
02080 
02081 \textcolor{comment}{/* ====================== Commands lookup and execution ===================== */}
02082 
02083 \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *lookupCommand(sds name) \{
02084     \textcolor{keywordflow}{return} dictFetchValue(server.commands, name);
02085 \}
02086 
02087 \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *lookupCommandByCString(\textcolor{keywordtype}{char} *s) \{
02088     \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd;
02089     sds name = sdsnew(s);
02090 
02091     cmd = dictFetchValue(server.commands, name);
02092     sdsfree(name);
02093     \textcolor{keywordflow}{return} cmd;
02094 \}
02095 
02096 \textcolor{comment}{/* Lookup the command in the current table, if not found also check in}
02097 \textcolor{comment}{ * the original table containing the original command names unaffected by}
02098 \textcolor{comment}{ * redis.conf rename-command statement.}
02099 \textcolor{comment}{ *}
02100 \textcolor{comment}{ * This is used by functions rewriting the argument vector such as}
02101 \textcolor{comment}{ * rewriteClientCommandVector() in order to set client->cmd pointer}
02102 \textcolor{comment}{ * correctly even if the command was renamed. */}
02103 \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *lookupCommandOrOriginal(sds name) \{
02104     \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd = dictFetchValue(server.commands, name);
02105 
02106     \textcolor{keywordflow}{if} (!cmd) cmd = dictFetchValue(server.orig\_commands,name);
02107     \textcolor{keywordflow}{return} cmd;
02108 \}
02109 
02110 \textcolor{comment}{/* Propagate the specified command (in the context of the specified database id)}
02111 \textcolor{comment}{ * to AOF and Slaves.}
02112 \textcolor{comment}{ *}
02113 \textcolor{comment}{ * flags are an xor between:}
02114 \textcolor{comment}{ * + PROPAGATE\_NONE (no propagation of command at all)}
02115 \textcolor{comment}{ * + PROPAGATE\_AOF (propagate into the AOF file if is enabled)}
02116 \textcolor{comment}{ * + PROPAGATE\_REPL (propagate into the replication link)}
02117 \textcolor{comment}{ *}
02118 \textcolor{comment}{ * This should not be used inside commands implementation. Use instead}
02119 \textcolor{comment}{ * alsoPropagate(), preventCommandPropagation(), forceCommandPropagation().}
02120 \textcolor{comment}{ */}
02121 \textcolor{keywordtype}{void} propagate(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, \textcolor{keywordtype}{int} dbid, robj **argv, \textcolor{keywordtype}{int} argc,
02122                \textcolor{keywordtype}{int} flags)
02123 \{
02124     \textcolor{keywordflow}{if} (server.aof\_state != \hyperlink{server_8h_a5226306fbcebcb6d5d02e0fef3c213c2}{AOF\_OFF} && flags & \hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF})
02125         feedAppendOnlyFile(cmd,dbid,argv,argc);
02126     \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL})
02127         replicationFeedSlaves(server.slaves,dbid,argv,argc);
02128 \}
02129 
02130 \textcolor{comment}{/* Used inside commands to schedule the propagation of additional commands}
02131 \textcolor{comment}{ * after the current command is propagated to AOF / Replication.}
02132 \textcolor{comment}{ *}
02133 \textcolor{comment}{ * 'cmd' must be a pointer to the Redis command to replicate, dbid is the}
02134 \textcolor{comment}{ * database ID the command should be propagated into.}
02135 \textcolor{comment}{ * Arguments of the command to propagte are passed as an array of redis}
02136 \textcolor{comment}{ * objects pointers of len 'argc', using the 'argv' vector.}
02137 \textcolor{comment}{ *}
02138 \textcolor{comment}{ * The function does not take a reference to the passed 'argv' vector,}
02139 \textcolor{comment}{ * so it is up to the caller to release the passed argv (but it is usually}
02140 \textcolor{comment}{ * stack allocated).  The function autoamtically increments ref count of}
02141 \textcolor{comment}{ * passed objects, so the caller does not need to. */}
02142 \textcolor{keywordtype}{void} alsoPropagate(\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, \textcolor{keywordtype}{int} dbid, robj **argv, \textcolor{keywordtype}{int} argc,
02143                    \textcolor{keywordtype}{int} target)
02144 \{
02145     robj **argvcopy;
02146     \textcolor{keywordtype}{int} j;
02147 
02148     \textcolor{keywordflow}{if} (server.loading) \textcolor{keywordflow}{return}; \textcolor{comment}{/* No propagation during loading. */}
02149 
02150     argvcopy = zmalloc(\textcolor{keyword}{sizeof}(robj*)*argc);
02151     \textcolor{keywordflow}{for} (j = 0; j < argc; j++) \{
02152         argvcopy[j] = argv[j];
02153         incrRefCount(argv[j]);
02154     \}
02155     redisOpArrayAppend(&server.also\_propagate,cmd,dbid,argvcopy,argc,target);
02156 \}
02157 
02158 \textcolor{comment}{/* It is possible to call the function forceCommandPropagation() inside a}
02159 \textcolor{comment}{ * Redis command implementation in order to to force the propagation of a}
02160 \textcolor{comment}{ * specific command execution into AOF / Replication. */}
02161 \textcolor{keywordtype}{void} forceCommandPropagation(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} flags) \{
02162     \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL}) c->flags |= \hyperlink{server_8h_a9f89484284fb0956374bd7b6fa639602}{CLIENT\_FORCE\_REPL};
02163     \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF}) c->flags |= \hyperlink{server_8h_a451c1542a74f0181600d043df3f1b19a}{CLIENT\_FORCE\_AOF};
02164 \}
02165 
02166 \textcolor{comment}{/* Avoid that the executed command is propagated at all. This way we}
02167 \textcolor{comment}{ * are free to just propagate what we want using the alsoPropagate()}
02168 \textcolor{comment}{ * API. */}
02169 \textcolor{keywordtype}{void} preventCommandPropagation(\hyperlink{structclient}{client} *c) \{
02170     c->flags |= \hyperlink{server_8h_aea3bfee2e140aed0fc93bf087026f9a3}{CLIENT\_PREVENT\_PROP};
02171 \}
02172 
02173 \textcolor{comment}{/* AOF specific version of preventCommandPropagation(). */}
02174 \textcolor{keywordtype}{void} preventCommandAOF(\hyperlink{structclient}{client} *c) \{
02175     c->flags |= \hyperlink{server_8h_a9948ae3a2778b5a06b704231b921e7fa}{CLIENT\_PREVENT\_AOF\_PROP};
02176 \}
02177 
02178 \textcolor{comment}{/* Replication specific version of preventCommandPropagation(). */}
02179 \textcolor{keywordtype}{void} preventCommandReplication(\hyperlink{structclient}{client} *c) \{
02180     c->flags |= \hyperlink{server_8h_a01c18c16bc758787b5cfc287eb7b089e}{CLIENT\_PREVENT\_REPL\_PROP};
02181 \}
02182 
02183 \textcolor{comment}{/* Call() is the core of Redis execution of a command.}
02184 \textcolor{comment}{ *}
02185 \textcolor{comment}{ * The following flags can be passed:}
02186 \textcolor{comment}{ * CMD\_CALL\_NONE        No flags.}
02187 \textcolor{comment}{ * CMD\_CALL\_SLOWLOG     Check command speed and log in the slow log if needed.}
02188 \textcolor{comment}{ * CMD\_CALL\_STATS       Populate command stats.}
02189 \textcolor{comment}{ * CMD\_CALL\_PROPAGATE\_AOF   Append command to AOF if it modified the dataset}
02190 \textcolor{comment}{ *                          or if the client flags are forcing propagation.}
02191 \textcolor{comment}{ * CMD\_CALL\_PROPAGATE\_REPL  Send command to salves if it modified the dataset}
02192 \textcolor{comment}{ *                          or if the client flags are forcing propagation.}
02193 \textcolor{comment}{ * CMD\_CALL\_PROPAGATE   Alias for PROPAGATE\_AOF|PROPAGATE\_REPL.}
02194 \textcolor{comment}{ * CMD\_CALL\_FULL        Alias for SLOWLOG|STATS|PROPAGATE.}
02195 \textcolor{comment}{ *}
02196 \textcolor{comment}{ * The exact propagation behavior depends on the client flags.}
02197 \textcolor{comment}{ * Specifically:}
02198 \textcolor{comment}{ *}
02199 \textcolor{comment}{ * 1. If the client flags CLIENT\_FORCE\_AOF or CLIENT\_FORCE\_REPL are set}
02200 \textcolor{comment}{ *    and assuming the corresponding CMD\_CALL\_PROPAGATE\_AOF/REPL is set}
02201 \textcolor{comment}{ *    in the call flags, then the command is propagated even if the}
02202 \textcolor{comment}{ *    dataset was not affected by the command.}
02203 \textcolor{comment}{ * 2. If the client flags CLIENT\_PREVENT\_REPL\_PROP or CLIENT\_PREVENT\_AOF\_PROP}
02204 \textcolor{comment}{ *    are set, the propagation into AOF or to slaves is not performed even}
02205 \textcolor{comment}{ *    if the command modified the dataset.}
02206 \textcolor{comment}{ *}
02207 \textcolor{comment}{ * Note that regardless of the client flags, if CMD\_CALL\_PROPAGATE\_AOF}
02208 \textcolor{comment}{ * or CMD\_CALL\_PROPAGATE\_REPL are not set, then respectively AOF or}
02209 \textcolor{comment}{ * slaves propagation will never occur.}
02210 \textcolor{comment}{ *}
02211 \textcolor{comment}{ * Client flags are modified by the implementation of a given command}
02212 \textcolor{comment}{ * using the following API:}
02213 \textcolor{comment}{ *}
02214 \textcolor{comment}{ * forceCommandPropagation(client *c, int flags);}
02215 \textcolor{comment}{ * preventCommandPropagation(client *c);}
02216 \textcolor{comment}{ * preventCommandAOF(client *c);}
02217 \textcolor{comment}{ * preventCommandReplication(client *c);}
02218 \textcolor{comment}{ *}
02219 \textcolor{comment}{ */}
02220 \textcolor{keywordtype}{void} call(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} flags) \{
02221     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} dirty, start, duration;
02222     \textcolor{keywordtype}{int} client\_old\_flags = c->flags;
02223 
02224     \textcolor{comment}{/* Sent the command to clients in MONITOR mode, only if the commands are}
02225 \textcolor{comment}{     * not generated from reading an AOF. */}
02226     \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.monitors) &&
02227         !server.loading &&
02228         !(c->cmd->flags & (\hyperlink{server_8h_a43e2aecb49a88a6cd4e56bfa971bdc71}{CMD\_SKIP\_MONITOR}|\hyperlink{server_8h_a1917805ea3942a4784ec806c33bc6033}{CMD\_ADMIN})))
02229     \{
02230         replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);
02231     \}
02232 
02233     \textcolor{comment}{/* Initialization: clear the flags that must be set by the command on}
02234 \textcolor{comment}{     * demand, and initialize the array for additional commands propagation. */}
02235     c->flags &= ~(\hyperlink{server_8h_a451c1542a74f0181600d043df3f1b19a}{CLIENT\_FORCE\_AOF}|\hyperlink{server_8h_a9f89484284fb0956374bd7b6fa639602}{CLIENT\_FORCE\_REPL}|
      \hyperlink{server_8h_aea3bfee2e140aed0fc93bf087026f9a3}{CLIENT\_PREVENT\_PROP});
02236     redisOpArray prev\_also\_propagate = server.also\_propagate;
02237     redisOpArrayInit(&server.also\_propagate);
02238 
02239     \textcolor{comment}{/* Call the command. */}
02240     dirty = server.dirty;
02241     start = ustime();
02242     c->cmd->proc(c);
02243     duration = ustime()-start;
02244     dirty = server.dirty-dirty;
02245     \textcolor{keywordflow}{if} (dirty < 0) dirty = 0;
02246 
02247     \textcolor{comment}{/* When EVAL is called loading the AOF we don't want commands called}
02248 \textcolor{comment}{     * from Lua to go into the slowlog or to populate statistics. */}
02249     \textcolor{keywordflow}{if} (server.loading && c->flags & \hyperlink{server_8h_af9d0b0f45ef2c1fd29ac714a300de706}{CLIENT\_LUA})
02250         flags &= ~(\hyperlink{server_8h_a934cea7b13db05a29264146cd5b14064}{CMD\_CALL\_SLOWLOG} | \hyperlink{server_8h_a7b1d9cf5be21e4808da0c16f03155973}{CMD\_CALL\_STATS});
02251 
02252     \textcolor{comment}{/* If the caller is Lua, we want to force the EVAL caller to propagate}
02253 \textcolor{comment}{     * the script if the command flag or client flag are forcing the}
02254 \textcolor{comment}{     * propagation. */}
02255     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_af9d0b0f45ef2c1fd29ac714a300de706}{CLIENT\_LUA} && server.lua\_caller) \{
02256         \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a9f89484284fb0956374bd7b6fa639602}{CLIENT\_FORCE\_REPL})
02257             server.lua\_caller->flags |= \hyperlink{server_8h_a9f89484284fb0956374bd7b6fa639602}{CLIENT\_FORCE\_REPL};
02258         \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a451c1542a74f0181600d043df3f1b19a}{CLIENT\_FORCE\_AOF})
02259             server.lua\_caller->flags |= \hyperlink{server_8h_a451c1542a74f0181600d043df3f1b19a}{CLIENT\_FORCE\_AOF};
02260     \}
02261 
02262     \textcolor{comment}{/* Log the command into the Slow log if needed, and populate the}
02263 \textcolor{comment}{     * per-command statistics that we show in INFO commandstats. */}
02264     \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_a934cea7b13db05a29264146cd5b14064}{CMD\_CALL\_SLOWLOG} && c->cmd->proc != execCommand) \{
02265         \textcolor{keywordtype}{char} *latency\_event = (c->cmd->flags & \hyperlink{server_8h_ae21dc0d9c0dcdefa14ca1054c48f252f}{CMD\_FAST}) ?
02266                               \textcolor{stringliteral}{"fast-command"} : \textcolor{stringliteral}{"command"};
02267         \hyperlink{latency_8h_a77922ab34035890c90f98831a9071359}{latencyAddSampleIfNeeded}(latency\_event,duration/1000);
02268         slowlogPushEntryIfNeeded(c,c->argv,c->argc,duration);
02269     \}
02270     \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_a7b1d9cf5be21e4808da0c16f03155973}{CMD\_CALL\_STATS}) \{
02271         c->lastcmd->microseconds += duration;
02272         c->lastcmd->calls++;
02273     \}
02274 
02275     \textcolor{comment}{/* Propagate the command into the AOF and replication link */}
02276     \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_a6ee9ed603f975d0d2b6ae44f1907565f}{CMD\_CALL\_PROPAGATE} &&
02277         (c->flags & \hyperlink{server_8h_aea3bfee2e140aed0fc93bf087026f9a3}{CLIENT\_PREVENT\_PROP}) != 
      \hyperlink{server_8h_aea3bfee2e140aed0fc93bf087026f9a3}{CLIENT\_PREVENT\_PROP})
02278     \{
02279         \textcolor{keywordtype}{int} propagate\_flags = \hyperlink{server_8h_a0c7409da047d754c0adeb001025acc03}{PROPAGATE\_NONE};
02280 
02281         \textcolor{comment}{/* Check if the command operated changes in the data set. If so}
02282 \textcolor{comment}{         * set for replication / AOF propagation. */}
02283         \textcolor{keywordflow}{if} (dirty) propagate\_flags |= (\hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF}|
      \hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL});
02284 
02285         \textcolor{comment}{/* If the client forced AOF / replication of the command, set}
02286 \textcolor{comment}{         * the flags regardless of the command effects on the data set. */}
02287         \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a9f89484284fb0956374bd7b6fa639602}{CLIENT\_FORCE\_REPL}) propagate\_flags |= 
      \hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL};
02288         \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a451c1542a74f0181600d043df3f1b19a}{CLIENT\_FORCE\_AOF}) propagate\_flags |= 
      \hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF};
02289 
02290         \textcolor{comment}{/* However prevent AOF / replication propagation if the command}
02291 \textcolor{comment}{         * implementatino called preventCommandPropagation() or similar,}
02292 \textcolor{comment}{         * or if we don't have the call() flags to do so. */}
02293         \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a01c18c16bc758787b5cfc287eb7b089e}{CLIENT\_PREVENT\_REPL\_PROP} ||
02294             !(flags & \hyperlink{server_8h_a69e4a8fdb26588e1028deb20fd51424a}{CMD\_CALL\_PROPAGATE\_REPL}))
02295                 propagate\_flags &= ~\hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL};
02296         \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a9948ae3a2778b5a06b704231b921e7fa}{CLIENT\_PREVENT\_AOF\_PROP} ||
02297             !(flags & \hyperlink{server_8h_a3ca848c94df18641ac372c58fca0e236}{CMD\_CALL\_PROPAGATE\_AOF}))
02298                 propagate\_flags &= ~\hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF};
02299 
02300         \textcolor{comment}{/* Call propagate() only if at least one of AOF / replication}
02301 \textcolor{comment}{         * propagation is needed. Note that modules commands handle replication}
02302 \textcolor{comment}{         * in an explicit way, so we never replicate them automatically. */}
02303         \textcolor{keywordflow}{if} (propagate\_flags != \hyperlink{server_8h_a0c7409da047d754c0adeb001025acc03}{PROPAGATE\_NONE} && !(c->cmd->flags & 
      \hyperlink{server_8h_accabd32f20281543986166c219124f9e}{CMD\_MODULE}))
02304             propagate(c->cmd,c->db->id,c->argv,c->argc,propagate\_flags);
02305     \}
02306 
02307     \textcolor{comment}{/* Restore the old replication flags, since call() can be executed}
02308 \textcolor{comment}{     * recursively. */}
02309     c->flags &= ~(\hyperlink{server_8h_a451c1542a74f0181600d043df3f1b19a}{CLIENT\_FORCE\_AOF}|\hyperlink{server_8h_a9f89484284fb0956374bd7b6fa639602}{CLIENT\_FORCE\_REPL}|
      \hyperlink{server_8h_aea3bfee2e140aed0fc93bf087026f9a3}{CLIENT\_PREVENT\_PROP});
02310     c->flags |= client\_old\_flags &
02311         (\hyperlink{server_8h_a451c1542a74f0181600d043df3f1b19a}{CLIENT\_FORCE\_AOF}|\hyperlink{server_8h_a9f89484284fb0956374bd7b6fa639602}{CLIENT\_FORCE\_REPL}|
      \hyperlink{server_8h_aea3bfee2e140aed0fc93bf087026f9a3}{CLIENT\_PREVENT\_PROP});
02312 
02313     \textcolor{comment}{/* Handle the alsoPropagate() API to handle commands that want to propagate}
02314 \textcolor{comment}{     * multiple separated commands. Note that alsoPropagate() is not affected}
02315 \textcolor{comment}{     * by CLIENT\_PREVENT\_PROP flag. */}
02316     \textcolor{keywordflow}{if} (server.also\_propagate.numops) \{
02317         \textcolor{keywordtype}{int} j;
02318         redisOp *rop;
02319 
02320         \textcolor{keywordflow}{if} (flags & \hyperlink{server_8h_a6ee9ed603f975d0d2b6ae44f1907565f}{CMD\_CALL\_PROPAGATE}) \{
02321             \textcolor{keywordflow}{for} (j = 0; j < server.also\_propagate.numops; j++) \{
02322                 rop = &server.also\_propagate.ops[j];
02323                 \textcolor{keywordtype}{int} target = rop->target;
02324                 \textcolor{comment}{/* Whatever the command wish is, we honor the call() flags. */}
02325                 \textcolor{keywordflow}{if} (!(flags&\hyperlink{server_8h_a3ca848c94df18641ac372c58fca0e236}{CMD\_CALL\_PROPAGATE\_AOF})) target &= ~
      \hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF};
02326                 \textcolor{keywordflow}{if} (!(flags&\hyperlink{server_8h_a69e4a8fdb26588e1028deb20fd51424a}{CMD\_CALL\_PROPAGATE\_REPL})) target &= ~
      \hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL};
02327                 \textcolor{keywordflow}{if} (target)
02328                     propagate(rop->cmd,rop->dbid,rop->argv,rop->argc,target);
02329             \}
02330         \}
02331         redisOpArrayFree(&server.also\_propagate);
02332     \}
02333     server.also\_propagate = prev\_also\_propagate;
02334     server.stat\_numcommands++;
02335 \}
02336 
02337 \textcolor{comment}{/* If this function gets called we already read a whole}
02338 \textcolor{comment}{ * command, arguments are in the client argv/argc fields.}
02339 \textcolor{comment}{ * processCommand() execute the command or prepare the}
02340 \textcolor{comment}{ * server for a bulk read from the client.}
02341 \textcolor{comment}{ *}
02342 \textcolor{comment}{ * If C\_OK is returned the client is still alive and valid and}
02343 \textcolor{comment}{ * other operations can be performed by the caller. Otherwise}
02344 \textcolor{comment}{ * if C\_ERR is returned the client was destroyed (i.e. after QUIT). */}
02345 \textcolor{keywordtype}{int} processCommand(\hyperlink{structclient}{client} *c) \{
02346     \textcolor{comment}{/* The QUIT command is handled separately. Normal command procs will}
02347 \textcolor{comment}{     * go through checking for replication and QUIT will cause trouble}
02348 \textcolor{comment}{     * when FORCE\_REPLICATION is enabled and would be implemented in}
02349 \textcolor{comment}{     * a regular command proc. */}
02350     \textcolor{keywordflow}{if} (!strcasecmp(c->argv[0]->ptr,\textcolor{stringliteral}{"quit"})) \{
02351         addReply(c,shared.ok);
02352         c->flags |= \hyperlink{server_8h_a8cff2154afcc2e87ac85bdbbe2814091}{CLIENT\_CLOSE\_AFTER\_REPLY};
02353         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
02354     \}
02355 
02356     \textcolor{comment}{/* Now lookup the command and check ASAP about trivial error conditions}
02357 \textcolor{comment}{     * such as wrong arity, bad command name and so forth. */}
02358     c->cmd = c->lastcmd = lookupCommand(c->argv[0]->ptr);
02359     \textcolor{keywordflow}{if} (!c->cmd) \{
02360         flagTransaction(c);
02361         addReplyErrorFormat(c,\textcolor{stringliteral}{"unknown command '%s'"},
02362             (\textcolor{keywordtype}{char}*)c->argv[0]->ptr);
02363         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
02364     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||
02365                (c->argc < -c->cmd->arity)) \{
02366         flagTransaction(c);
02367         addReplyErrorFormat(c,\textcolor{stringliteral}{"wrong number of arguments for '%s' command"},
02368             c->cmd->name);
02369         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
02370     \}
02371 
02372     \textcolor{comment}{/* Check if the user is authenticated */}
02373     \textcolor{keywordflow}{if} (server.requirepass && !c->authenticated && c->cmd->proc != authCommand)
02374     \{
02375         flagTransaction(c);
02376         addReply(c,shared.noautherr);
02377         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
02378     \}
02379 
02380     \textcolor{comment}{/* If cluster is enabled perform the cluster redirection here.}
02381 \textcolor{comment}{     * However we don't perform the redirection if:}
02382 \textcolor{comment}{     * 1) The sender of this command is our master.}
02383 \textcolor{comment}{     * 2) The command has no key arguments. */}
02384     \textcolor{keywordflow}{if} (server.cluster\_enabled &&
02385         !(c->flags & \hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER}) &&
02386         !(c->flags & \hyperlink{server_8h_af9d0b0f45ef2c1fd29ac714a300de706}{CLIENT\_LUA} &&
02387           server.lua\_caller->flags & \hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER}) &&
02388         !(c->cmd->getkeys\_proc == NULL && c->cmd->firstkey == 0 &&
02389           c->cmd->proc != execCommand))
02390     \{
02391         \textcolor{keywordtype}{int} hashslot;
02392         \textcolor{keywordtype}{int} error\_code;
02393         clusterNode *n = getNodeByQuery(c,c->cmd,c->argv,c->argc,
02394                                         &hashslot,&error\_code);
02395         \textcolor{keywordflow}{if} (n == NULL || n != server.cluster->myself) \{
02396             \textcolor{keywordflow}{if} (c->cmd->proc == execCommand) \{
02397                 discardTransaction(c);
02398             \} \textcolor{keywordflow}{else} \{
02399                 flagTransaction(c);
02400             \}
02401             clusterRedirectClient(c,n,hashslot,error\_code);
02402             \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
02403         \}
02404     \}
02405 
02406     \textcolor{comment}{/* Handle the maxmemory directive.}
02407 \textcolor{comment}{     *}
02408 \textcolor{comment}{     * First we try to free some memory if possible (if there are volatile}
02409 \textcolor{comment}{     * keys in the dataset). If there are not the only thing we can do}
02410 \textcolor{comment}{     * is returning an error. */}
02411     \textcolor{keywordflow}{if} (server.maxmemory) \{
02412         \textcolor{keywordtype}{int} retval = freeMemoryIfNeeded();
02413         \textcolor{comment}{/* freeMemoryIfNeeded may flush slave output buffers. This may result}
02414 \textcolor{comment}{         * into a slave, that may be the active client, to be freed. */}
02415         \textcolor{keywordflow}{if} (server.current\_client == NULL) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
02416 
02417         \textcolor{comment}{/* It was impossible to free enough memory, and the command the client}
02418 \textcolor{comment}{         * is trying to execute is denied during OOM conditions? Error. */}
02419         \textcolor{keywordflow}{if} ((c->cmd->flags & \hyperlink{server_8h_aef97c640ad8dfdaca21eb67d4c37e447}{CMD\_DENYOOM}) && retval == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
02420             flagTransaction(c);
02421             addReply(c, shared.oomerr);
02422             \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
02423         \}
02424     \}
02425 
02426     \textcolor{comment}{/* Don't accept write commands if there are problems persisting on disk}
02427 \textcolor{comment}{     * and if this is a master instance. */}
02428     \textcolor{keywordflow}{if} (((server.stop\_writes\_on\_bgsave\_err &&
02429           server.saveparamslen > 0 &&
02430           server.lastbgsave\_status == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) ||
02431           server.aof\_last\_write\_status == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) &&
02432         server.masterhost == NULL &&
02433         (c->cmd->flags & \hyperlink{server_8h_a7391deb9c3a262ded3e186e94eb884e2}{CMD\_WRITE} ||
02434          c->cmd->proc == pingCommand))
02435     \{
02436         flagTransaction(c);
02437         \textcolor{keywordflow}{if} (server.aof\_last\_write\_status == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
02438             addReply(c, shared.bgsaveerr);
02439         \textcolor{keywordflow}{else}
02440             addReplySds(c,
02441                 sdscatprintf(sdsempty(),
02442                 \textcolor{stringliteral}{"-MISCONF Errors writing to the AOF file: %s\(\backslash\)r\(\backslash\)n"},
02443                 strerror(server.aof\_last\_write\_errno)));
02444         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
02445     \}
02446 
02447     \textcolor{comment}{/* Don't accept write commands if there are not enough good slaves and}
02448 \textcolor{comment}{     * user configured the min-slaves-to-write option. */}
02449     \textcolor{keywordflow}{if} (server.masterhost == NULL &&
02450         server.repl\_min\_slaves\_to\_write &&
02451         server.repl\_min\_slaves\_max\_lag &&
02452         c->cmd->flags & \hyperlink{server_8h_a7391deb9c3a262ded3e186e94eb884e2}{CMD\_WRITE} &&
02453         server.repl\_good\_slaves\_count < server.repl\_min\_slaves\_to\_write)
02454     \{
02455         flagTransaction(c);
02456         addReply(c, shared.noreplicaserr);
02457         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
02458     \}
02459 
02460     \textcolor{comment}{/* Don't accept write commands if this is a read only slave. But}
02461 \textcolor{comment}{     * accept write commands if this is our master. */}
02462     \textcolor{keywordflow}{if} (server.masterhost && server.repl\_slave\_ro &&
02463         !(c->flags & \hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER}) &&
02464         c->cmd->flags & \hyperlink{server_8h_a7391deb9c3a262ded3e186e94eb884e2}{CMD\_WRITE})
02465     \{
02466         addReply(c, shared.roslaveerr);
02467         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
02468     \}
02469 
02470     \textcolor{comment}{/* Only allow SUBSCRIBE and UNSUBSCRIBE in the context of Pub/Sub */}
02471     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a20f2f5380db97cd09013118ffc9411cc}{CLIENT\_PUBSUB} &&
02472         c->cmd->proc != pingCommand &&
02473         c->cmd->proc != subscribeCommand &&
02474         c->cmd->proc != unsubscribeCommand &&
02475         c->cmd->proc != psubscribeCommand &&
02476         c->cmd->proc != punsubscribeCommand) \{
02477         addReplyError(c,\textcolor{stringliteral}{"only (P)SUBSCRIBE / (P)UNSUBSCRIBE / PING / QUIT allowed in this context"});
02478         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
02479     \}
02480 
02481     \textcolor{comment}{/* Only allow commands with flag "t", such as INFO, SLAVEOF and so on,}
02482 \textcolor{comment}{     * when slave-serve-stale-data is no and we are a slave with a broken}
02483 \textcolor{comment}{     * link with master. */}
02484     \textcolor{keywordflow}{if} (server.masterhost && server.repl\_state != \hyperlink{server_8h_aed693b3a9cdfc05cf5ab7551a8c86fbe}{REPL\_STATE\_CONNECTED} &&
02485         server.repl\_serve\_stale\_data == 0 &&
02486         !(c->cmd->flags & \hyperlink{server_8h_acf1f58ff0b6790cd8d0e3edf1a7e599f}{CMD\_STALE}))
02487     \{
02488         flagTransaction(c);
02489         addReply(c, shared.masterdownerr);
02490         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
02491     \}
02492 
02493     \textcolor{comment}{/* Loading DB? Return an error if the command has not the}
02494 \textcolor{comment}{     * CMD\_LOADING flag. */}
02495     \textcolor{keywordflow}{if} (server.loading && !(c->cmd->flags & \hyperlink{server_8h_a5327d118cf467e77d8bb0cebdce3c0ce}{CMD\_LOADING})) \{
02496         addReply(c, shared.loadingerr);
02497         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
02498     \}
02499 
02500     \textcolor{comment}{/* Lua script too slow? Only allow a limited number of commands. */}
02501     \textcolor{keywordflow}{if} (server.lua\_timedout &&
02502           c->cmd->proc != authCommand &&
02503           c->cmd->proc != replconfCommand &&
02504         !(c->cmd->proc == shutdownCommand &&
02505           c->argc == 2 &&
02506           tolower(((\textcolor{keywordtype}{char}*)c->argv[1]->ptr)[0]) == \textcolor{stringliteral}{'n'}) &&
02507         !(c->cmd->proc == scriptCommand &&
02508           c->argc == 2 &&
02509           tolower(((\textcolor{keywordtype}{char}*)c->argv[1]->ptr)[0]) == \textcolor{stringliteral}{'k'}))
02510     \{
02511         flagTransaction(c);
02512         addReply(c, shared.slowscripterr);
02513         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
02514     \}
02515 
02516     \textcolor{comment}{/* Exec the command */}
02517     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI} &&
02518         c->cmd->proc != execCommand && c->cmd->proc != discardCommand &&
02519         c->cmd->proc != multiCommand && c->cmd->proc != watchCommand)
02520     \{
02521         queueMultiCommand(c);
02522         addReply(c,shared.queued);
02523     \} \textcolor{keywordflow}{else} \{
02524         call(c,\hyperlink{server_8h_a7e92e38a9fe5f713cace24d63184273e}{CMD\_CALL\_FULL});
02525         c->woff = server.master\_repl\_offset;
02526         \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.ready\_keys))
02527             handleClientsBlockedOnKeys();
02528     \}
02529     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
02530 \}
02531 
02532 \textcolor{comment}{/*================================== Shutdown =============================== */}
02533 
02534 \textcolor{comment}{/* Close listening sockets. Also unlink the unix domain socket if}
02535 \textcolor{comment}{ * unlink\_unix\_socket is non-zero. */}
02536 \textcolor{keywordtype}{void} closeListeningSockets(\textcolor{keywordtype}{int} unlink\_unix\_socket) \{
02537     \textcolor{keywordtype}{int} j;
02538 
02539     \textcolor{keywordflow}{for} (j = 0; j < server.ipfd\_count; j++) close(server.ipfd[j]);
02540     \textcolor{keywordflow}{if} (server.sofd != -1) close(server.sofd);
02541     \textcolor{keywordflow}{if} (server.cluster\_enabled)
02542         \textcolor{keywordflow}{for} (j = 0; j < server.cfd\_count; j++) close(server.cfd[j]);
02543     \textcolor{keywordflow}{if} (unlink\_unix\_socket && server.unixsocket) \{
02544         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Removing the unix socket file."});
02545         unlink(server.unixsocket); \textcolor{comment}{/* don't care if this fails */}
02546     \}
02547 \}
02548 
02549 \textcolor{keywordtype}{int} prepareForShutdown(\textcolor{keywordtype}{int} flags) \{
02550     \textcolor{keywordtype}{int} save = flags & \hyperlink{server_8h_ada761b94960fa20ff86d56b403b26861}{SHUTDOWN\_SAVE};
02551     \textcolor{keywordtype}{int} nosave = flags & \hyperlink{server_8h_a834b7e50f783a1eeaa1feea05fce199e}{SHUTDOWN\_NOSAVE};
02552 
02553     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"User requested shutdown..."});
02554 
02555     \textcolor{comment}{/* Kill all the Lua debugger forked sessions. */}
02556     ldbKillForkedSessions();
02557 
02558     \textcolor{comment}{/* Kill the saving child if there is a background saving in progress.}
02559 \textcolor{comment}{       We want to avoid race conditions, for instance our saving child may}
02560 \textcolor{comment}{       overwrite the synchronous saving did by SHUTDOWN. */}
02561     \textcolor{keywordflow}{if} (server.rdb\_child\_pid != -1) \{
02562         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"There is a child saving an .rdb. Killing it!"});
02563         kill(server.rdb\_child\_pid,SIGUSR1);
02564         rdbRemoveTempFile(server.rdb\_child\_pid);
02565     \}
02566 
02567     \textcolor{keywordflow}{if} (server.aof\_state != \hyperlink{server_8h_a5226306fbcebcb6d5d02e0fef3c213c2}{AOF\_OFF}) \{
02568         \textcolor{comment}{/* Kill the AOF saving child as the AOF we already have may be longer}
02569 \textcolor{comment}{         * but contains the full dataset anyway. */}
02570         \textcolor{keywordflow}{if} (server.aof\_child\_pid != -1) \{
02571             \textcolor{comment}{/* If we have AOF enabled but haven't written the AOF yet, don't}
02572 \textcolor{comment}{             * shutdown or else the dataset will be lost. */}
02573             \textcolor{keywordflow}{if} (server.aof\_state == \hyperlink{server_8h_a7d4b86c89be4d951fbf048130431a16a}{AOF\_WAIT\_REWRITE}) \{
02574                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"Writing initial AOF, can't exit."});
02575                 \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
02576             \}
02577             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
02578                 \textcolor{stringliteral}{"There is a child rewriting the AOF. Killing it!"});
02579             kill(server.aof\_child\_pid,SIGUSR1);
02580         \}
02581         \textcolor{comment}{/* Append only file: flush buffers and fsync() the AOF at exit */}
02582         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Calling fsync() on the AOF file."});
02583         flushAppendOnlyFile(1);
02584         \hyperlink{config_8h_af5994c643c434574580bb7816af82cad}{aof\_fsync}(server.aof\_fd);
02585     \}
02586 
02587     \textcolor{comment}{/* Create a new RDB file before exiting. */}
02588     \textcolor{keywordflow}{if} ((server.saveparamslen > 0 && !nosave) || save) \{
02589         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Saving the final RDB snapshot before exiting."});
02590         \textcolor{comment}{/* Snapshotting. Perform a SYNC SAVE and exit */}
02591         rdbSaveInfo rsi, *rsiptr;
02592         rsiptr = rdbPopulateSaveInfo(&rsi);
02593         \textcolor{keywordflow}{if} (rdbSave(server.rdb\_filename,rsiptr) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
02594             \textcolor{comment}{/* Ooops.. error saving! The best we can do is to continue}
02595 \textcolor{comment}{             * operating. Note that if there was a background saving process,}
02596 \textcolor{comment}{             * in the next cron() Redis will be notified that the background}
02597 \textcolor{comment}{             * saving aborted, handling special stuff like slaves pending for}
02598 \textcolor{comment}{             * synchronization... */}
02599             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Error trying to save the DB, can't exit."});
02600             \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
02601         \}
02602     \}
02603 
02604     \textcolor{comment}{/* Remove the pid file if possible and needed. */}
02605     \textcolor{keywordflow}{if} (server.daemonize || server.pidfile) \{
02606         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Removing the pid file."});
02607         unlink(server.pidfile);
02608     \}
02609 
02610     \textcolor{comment}{/* Best effort flush of slave output buffers, so that we hopefully}
02611 \textcolor{comment}{     * send them pending writes. */}
02612     flushSlavesOutputBuffers();
02613 
02614     \textcolor{comment}{/* Close the listening sockets. Apparently this allows faster restarts. */}
02615     closeListeningSockets(1);
02616     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"%s is now ready to exit, bye bye..."},
02617         server.sentinel\_mode ? \textcolor{stringliteral}{"Sentinel"} : \textcolor{stringliteral}{"Redis"});
02618     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
02619 \}
02620 
02621 \textcolor{comment}{/*================================== Commands =============================== */}
02622 
02623 \textcolor{comment}{/* Return zero if strings are the same, non-zero if they are not.}
02624 \textcolor{comment}{ * The comparison is performed in a way that prevents an attacker to obtain}
02625 \textcolor{comment}{ * information about the nature of the strings just monitoring the execution}
02626 \textcolor{comment}{ * time of the function.}
02627 \textcolor{comment}{ *}
02628 \textcolor{comment}{ * Note that limiting the comparison length to strings up to 512 bytes we}
02629 \textcolor{comment}{ * can avoid leaking any information about the password length and any}
02630 \textcolor{comment}{ * possible branch misprediction related leak.}
02631 \textcolor{comment}{ */}
02632 \textcolor{keywordtype}{int} time\_independent\_strcmp(\textcolor{keywordtype}{char} *a, \textcolor{keywordtype}{char} *b) \{
02633     \textcolor{keywordtype}{char} bufa[\hyperlink{server_8h_a8e9d7cd814b95c2cbd17701efe1374f2}{CONFIG\_AUTHPASS\_MAX\_LEN}], bufb[
      \hyperlink{server_8h_a8e9d7cd814b95c2cbd17701efe1374f2}{CONFIG\_AUTHPASS\_MAX\_LEN}];
02634     \textcolor{comment}{/* The above two strlen perform len(a) + len(b) operations where either}
02635 \textcolor{comment}{     * a or b are fixed (our password) length, and the difference is only}
02636 \textcolor{comment}{     * relative to the length of the user provided string, so no information}
02637 \textcolor{comment}{     * leak is possible in the following two lines of code. */}
02638     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} alen = strlen(a);
02639     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} blen = strlen(b);
02640     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j;
02641     \textcolor{keywordtype}{int} diff = 0;
02642 
02643     \textcolor{comment}{/* We can't compare strings longer than our static buffers.}
02644 \textcolor{comment}{     * Note that this will never pass the first test in practical circumstances}
02645 \textcolor{comment}{     * so there is no info leak. */}
02646     \textcolor{keywordflow}{if} (alen > \textcolor{keyword}{sizeof}(bufa) || blen > \textcolor{keyword}{sizeof}(bufb)) \textcolor{keywordflow}{return} 1;
02647 
02648     memset(bufa,0,\textcolor{keyword}{sizeof}(bufa));        \textcolor{comment}{/* Constant time. */}
02649     memset(bufb,0,\textcolor{keyword}{sizeof}(bufb));        \textcolor{comment}{/* Constant time. */}
02650     \textcolor{comment}{/* Again the time of the following two copies is proportional to}
02651 \textcolor{comment}{     * len(a) + len(b) so no info is leaked. */}
02652     memcpy(bufa,a,alen);
02653     memcpy(bufb,b,blen);
02654 
02655     \textcolor{comment}{/* Always compare all the chars in the two buffers without}
02656 \textcolor{comment}{     * conditional expressions. */}
02657     \textcolor{keywordflow}{for} (j = 0; j < \textcolor{keyword}{sizeof}(bufa); j++) \{
02658         diff |= (bufa[j] ^ bufb[j]);
02659     \}
02660     \textcolor{comment}{/* Length must be equal as well. */}
02661     diff |= alen ^ blen;
02662     \textcolor{keywordflow}{return} diff; \textcolor{comment}{/* If zero strings are the same. */}
02663 \}
02664 
02665 \textcolor{keywordtype}{void} authCommand(\hyperlink{structclient}{client} *c) \{
02666     \textcolor{keywordflow}{if} (!server.requirepass) \{
02667         addReplyError(c,\textcolor{stringliteral}{"Client sent AUTH, but no password is set"});
02668     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!time\_independent\_strcmp(c->argv[1]->ptr, server.requirepass)) \{
02669       c->authenticated = 1;
02670       addReply(c,shared.ok);
02671     \} \textcolor{keywordflow}{else} \{
02672       c->authenticated = 0;
02673       addReplyError(c,\textcolor{stringliteral}{"invalid password"});
02674     \}
02675 \}
02676 
02677 \textcolor{comment}{/* The PING command. It works in a different way if the client is in}
02678 \textcolor{comment}{ * in Pub/Sub mode. */}
02679 \textcolor{keywordtype}{void} pingCommand(\hyperlink{structclient}{client} *c) \{
02680     \textcolor{comment}{/* The command takes zero or one arguments. */}
02681     \textcolor{keywordflow}{if} (c->argc > 2) \{
02682         addReplyErrorFormat(c,\textcolor{stringliteral}{"wrong number of arguments for '%s' command"},
02683             c->cmd->name);
02684         \textcolor{keywordflow}{return};
02685     \}
02686 
02687     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a20f2f5380db97cd09013118ffc9411cc}{CLIENT\_PUBSUB}) \{
02688         addReply(c,shared.mbulkhdr[2]);
02689         addReplyBulkCBuffer(c,\textcolor{stringliteral}{"pong"},4);
02690         \textcolor{keywordflow}{if} (c->argc == 1)
02691             addReplyBulkCBuffer(c,\textcolor{stringliteral}{""},0);
02692         \textcolor{keywordflow}{else}
02693             addReplyBulk(c,c->argv[1]);
02694     \} \textcolor{keywordflow}{else} \{
02695         \textcolor{keywordflow}{if} (c->argc == 1)
02696             addReply(c,shared.pong);
02697         \textcolor{keywordflow}{else}
02698             addReplyBulk(c,c->argv[1]);
02699     \}
02700 \}
02701 
02702 \textcolor{keywordtype}{void} echoCommand(\hyperlink{structclient}{client} *c) \{
02703     addReplyBulk(c,c->argv[1]);
02704 \}
02705 
02706 \textcolor{keywordtype}{void} timeCommand(\hyperlink{structclient}{client} *c) \{
02707     \textcolor{keyword}{struct} timeval tv;
02708 
02709     \textcolor{comment}{/* gettimeofday() can only fail if &tv is a bad address so we}
02710 \textcolor{comment}{     * don't check for errors. */}
02711     gettimeofday(&tv,NULL);
02712     addReplyMultiBulkLen(c,2);
02713     addReplyBulkLongLong(c,tv.tv\_sec);
02714     addReplyBulkLongLong(c,tv.tv\_usec);
02715 \}
02716 
02717 \textcolor{comment}{/* Helper function for addReplyCommand() to output flags. */}
02718 \textcolor{keywordtype}{int} addReplyCommandFlag(\hyperlink{structclient}{client} *c, \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, \textcolor{keywordtype}{int} f, \textcolor{keywordtype}{char} *reply) \{
02719     \textcolor{keywordflow}{if} (cmd->flags & f) \{
02720         addReplyStatus(c, reply);
02721         \textcolor{keywordflow}{return} 1;
02722     \}
02723     \textcolor{keywordflow}{return} 0;
02724 \}
02725 
02726 \textcolor{comment}{/* Output the representation of a Redis command. Used by the COMMAND command. */}
02727 \textcolor{keywordtype}{void} addReplyCommand(\hyperlink{structclient}{client} *c, \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd) \{
02728     \textcolor{keywordflow}{if} (!cmd) \{
02729         addReply(c, shared.nullbulk);
02730     \} \textcolor{keywordflow}{else} \{
02731         \textcolor{comment}{/* We are adding: command name, arg count, flags, first, last, offset */}
02732         addReplyMultiBulkLen(c, 6);
02733         addReplyBulkCString(c, cmd->name);
02734         addReplyLongLong(c, cmd->arity);
02735 
02736         \textcolor{keywordtype}{int} flagcount = 0;
02737         \textcolor{keywordtype}{void} *flaglen = addDeferredMultiBulkLength(c);
02738         flagcount += addReplyCommandFlag(c,cmd,\hyperlink{server_8h_a7391deb9c3a262ded3e186e94eb884e2}{CMD\_WRITE}, \textcolor{stringliteral}{"write"});
02739         flagcount += addReplyCommandFlag(c,cmd,\hyperlink{server_8h_a7e9c728f228e1c82ae1e22173375abcf}{CMD\_READONLY}, \textcolor{stringliteral}{"readonly"});
02740         flagcount += addReplyCommandFlag(c,cmd,\hyperlink{server_8h_aef97c640ad8dfdaca21eb67d4c37e447}{CMD\_DENYOOM}, \textcolor{stringliteral}{"denyoom"});
02741         flagcount += addReplyCommandFlag(c,cmd,\hyperlink{server_8h_a1917805ea3942a4784ec806c33bc6033}{CMD\_ADMIN}, \textcolor{stringliteral}{"admin"});
02742         flagcount += addReplyCommandFlag(c,cmd,\hyperlink{server_8h_a201d97fc457fe5bd58cb863b4ac7a0cc}{CMD\_PUBSUB}, \textcolor{stringliteral}{"pubsub"});
02743         flagcount += addReplyCommandFlag(c,cmd,\hyperlink{server_8h_aaf26ba9b59589bc7701e36fb440a0fbe}{CMD\_NOSCRIPT}, \textcolor{stringliteral}{"noscript"});
02744         flagcount += addReplyCommandFlag(c,cmd,\hyperlink{server_8h_a9f6608fefa355981c2a865ef3d44f196}{CMD\_RANDOM}, \textcolor{stringliteral}{"random"});
02745         flagcount += addReplyCommandFlag(c,cmd,\hyperlink{server_8h_a819ad39aa4aef302c4421c3cd910252d}{CMD\_SORT\_FOR\_SCRIPT},\textcolor{stringliteral}{
      "sort\_for\_script"});
02746         flagcount += addReplyCommandFlag(c,cmd,\hyperlink{server_8h_a5327d118cf467e77d8bb0cebdce3c0ce}{CMD\_LOADING}, \textcolor{stringliteral}{"loading"});
02747         flagcount += addReplyCommandFlag(c,cmd,\hyperlink{server_8h_acf1f58ff0b6790cd8d0e3edf1a7e599f}{CMD\_STALE}, \textcolor{stringliteral}{"stale"});
02748         flagcount += addReplyCommandFlag(c,cmd,\hyperlink{server_8h_a43e2aecb49a88a6cd4e56bfa971bdc71}{CMD\_SKIP\_MONITOR}, \textcolor{stringliteral}{"skip\_monitor"});
02749         flagcount += addReplyCommandFlag(c,cmd,\hyperlink{server_8h_af0b13ef0f1dabe404fd7d904cb66b548}{CMD\_ASKING}, \textcolor{stringliteral}{"asking"});
02750         flagcount += addReplyCommandFlag(c,cmd,\hyperlink{server_8h_ae21dc0d9c0dcdefa14ca1054c48f252f}{CMD\_FAST}, \textcolor{stringliteral}{"fast"});
02751         \textcolor{keywordflow}{if} ((cmd->getkeys\_proc && !(cmd->flags & \hyperlink{server_8h_accabd32f20281543986166c219124f9e}{CMD\_MODULE})) ||
02752             cmd->flags & \hyperlink{server_8h_a612a8681d1a25cd86faf4139d161316a}{CMD\_MODULE\_GETKEYS})
02753         \{
02754             addReplyStatus(c, \textcolor{stringliteral}{"movablekeys"});
02755             flagcount += 1;
02756         \}
02757         setDeferredMultiBulkLength(c, flaglen, flagcount);
02758 
02759         addReplyLongLong(c, cmd->firstkey);
02760         addReplyLongLong(c, cmd->lastkey);
02761         addReplyLongLong(c, cmd->keystep);
02762     \}
02763 \}
02764 
02765 \textcolor{comment}{/* COMMAND <subcommand> <args> */}
02766 \textcolor{keywordtype}{void} commandCommand(\hyperlink{structclient}{client} *c) \{
02767     dictIterator *di;
02768     dictEntry *de;
02769 
02770     \textcolor{keywordflow}{if} (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"help"})) \{
02771         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *help[] = \{
02772 \textcolor{stringliteral}{"(no subcommand) -- Return details about all Redis commands."},
02773 \textcolor{stringliteral}{"count -- Return the total number of commands in this Redis server."},
02774 \textcolor{stringliteral}{"getkeys <full-command> -- Return the keys from a full Redis command."},
02775 \textcolor{stringliteral}{"info [command-name ...] -- Return details about multiple Redis commands."},
02776 NULL
02777         \};
02778         addReplyHelp(c, help);
02779     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->argc == 1) \{
02780         addReplyMultiBulkLen(c, \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.commands));
02781         di = dictGetIterator(server.commands);
02782         \textcolor{keywordflow}{while} ((de = dictNext(di)) != NULL) \{
02783             addReplyCommand(c, \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de));
02784         \}
02785         dictReleaseIterator(di);
02786     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr, \textcolor{stringliteral}{"info"})) \{
02787         \textcolor{keywordtype}{int} i;
02788         addReplyMultiBulkLen(c, c->argc-2);
02789         \textcolor{keywordflow}{for} (i = 2; i < c->argc; i++) \{
02790             addReplyCommand(c, dictFetchValue(server.commands, c->argv[i]->ptr));
02791         \}
02792     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr, \textcolor{stringliteral}{"count"}) && c->argc == 2) \{
02793         addReplyLongLong(c, \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.commands));
02794     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"getkeys"}) && c->argc >= 3) \{
02795         \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd = lookupCommand(c->argv[2]->ptr);
02796         \textcolor{keywordtype}{int} *keys, numkeys, j;
02797 
02798         \textcolor{keywordflow}{if} (!cmd) \{
02799             addReplyErrorFormat(c,\textcolor{stringliteral}{"Invalid command specified"});
02800             \textcolor{keywordflow}{return};
02801         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((cmd->arity > 0 && cmd->arity != c->argc-2) ||
02802                    ((c->argc-2) < -cmd->arity))
02803         \{
02804             addReplyError(c,\textcolor{stringliteral}{"Invalid number of arguments specified for command"});
02805             \textcolor{keywordflow}{return};
02806         \}
02807 
02808         keys = getKeysFromCommand(cmd,c->argv+2,c->argc-2,&numkeys);
02809         addReplyMultiBulkLen(c,numkeys);
02810         \textcolor{keywordflow}{for} (j = 0; j < numkeys; j++) addReplyBulk(c,c->argv[keys[j]+2]);
02811         getKeysFreeResult(keys);
02812     \} \textcolor{keywordflow}{else} \{
02813         addReplyErrorFormat(c, \textcolor{stringliteral}{"Unknown subcommand or wrong number of arguments for '%s'. Try COMMAND
       HELP"}, (\textcolor{keywordtype}{char}*)c->argv[1]->ptr);
02814     \}
02815 \}
02816 
02817 \textcolor{comment}{/* Convert an amount of bytes into a human readable string in the form}
02818 \textcolor{comment}{ * of 100B, 2G, 100M, 4K, and so forth. */}
02819 \textcolor{keywordtype}{void} bytesToHuman(\textcolor{keywordtype}{char} *s, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} n) \{
02820     \textcolor{keywordtype}{double} d;
02821 
02822     \textcolor{keywordflow}{if} (n < 1024) \{
02823         \textcolor{comment}{/* Bytes */}
02824         sprintf(s,\textcolor{stringliteral}{"%lluB"},n);
02825         \textcolor{keywordflow}{return};
02826     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n < (1024*1024)) \{
02827         d = (\textcolor{keywordtype}{double})n/(1024);
02828         sprintf(s,\textcolor{stringliteral}{"%.2fK"},d);
02829     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n < (1024LL*1024*1024)) \{
02830         d = (\textcolor{keywordtype}{double})n/(1024*1024);
02831         sprintf(s,\textcolor{stringliteral}{"%.2fM"},d);
02832     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n < (1024LL*1024*1024*1024)) \{
02833         d = (\textcolor{keywordtype}{double})n/(1024LL*1024*1024);
02834         sprintf(s,\textcolor{stringliteral}{"%.2fG"},d);
02835     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n < (1024LL*1024*1024*1024*1024)) \{
02836         d = (\textcolor{keywordtype}{double})n/(1024LL*1024*1024*1024);
02837         sprintf(s,\textcolor{stringliteral}{"%.2fT"},d);
02838     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n < (1024LL*1024*1024*1024*1024*1024)) \{
02839         d = (\textcolor{keywordtype}{double})n/(1024LL*1024*1024*1024*1024);
02840         sprintf(s,\textcolor{stringliteral}{"%.2fP"},d);
02841     \} \textcolor{keywordflow}{else} \{
02842         \textcolor{comment}{/* Let's hope we never need this */}
02843         sprintf(s,\textcolor{stringliteral}{"%lluB"},n);
02844     \}
02845 \}
02846 
02847 \textcolor{comment}{/* Create the string returned by the INFO command. This is decoupled}
02848 \textcolor{comment}{ * by the INFO command itself as we need to report the same information}
02849 \textcolor{comment}{ * on memory corruption problems. */}
02850 sds genRedisInfoString(\textcolor{keywordtype}{char} *section) \{
02851     sds info = sdsempty();
02852     time\_t uptime = server.unixtime-server.stat\_starttime;
02853     \textcolor{keywordtype}{int} j;
02854     \textcolor{keyword}{struct} rusage self\_ru, c\_ru;
02855     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} lol, bib;
02856     \textcolor{keywordtype}{int} allsections = 0, defsections = 0;
02857     \textcolor{keywordtype}{int} sections = 0;
02858 
02859     \textcolor{keywordflow}{if} (section == NULL) section = \textcolor{stringliteral}{"default"};
02860     allsections = strcasecmp(section,\textcolor{stringliteral}{"all"}) == 0;
02861     defsections = strcasecmp(section,\textcolor{stringliteral}{"default"}) == 0;
02862 
02863     getrusage(RUSAGE\_SELF, &self\_ru);
02864     getrusage(RUSAGE\_CHILDREN, &c\_ru);
02865     getClientsMaxBuffers(&lol,&bib);
02866 
02867     \textcolor{comment}{/* Server */}
02868     \textcolor{keywordflow}{if} (allsections || defsections || !strcasecmp(section,\textcolor{stringliteral}{"server"})) \{
02869         \textcolor{keyword}{static} \textcolor{keywordtype}{int} call\_uname = 1;
02870         \textcolor{keyword}{static} \textcolor{keyword}{struct} utsname name;
02871         \textcolor{keywordtype}{char} *mode;
02872 
02873         \textcolor{keywordflow}{if} (server.cluster\_enabled) mode = \textcolor{stringliteral}{"cluster"};
02874         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.sentinel\_mode) mode = \textcolor{stringliteral}{"sentinel"};
02875         \textcolor{keywordflow}{else} mode = \textcolor{stringliteral}{"standalone"};
02876 
02877         \textcolor{keywordflow}{if} (sections++) info = sdscat(info,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"});
02878 
02879         \textcolor{keywordflow}{if} (call\_uname) \{
02880             \textcolor{comment}{/* Uname can be slow and is always the same output. Cache it. */}
02881             uname(&name);
02882             call\_uname = 0;
02883         \}
02884 
02885         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} lruclock;
02886         \hyperlink{atomicvar_8h_a57b17e058ecff6871debb3d1d4f3031a}{atomicGet}(server.lruclock,lruclock);
02887         info = sdscatprintf(info,
02888             \textcolor{stringliteral}{"# Server\(\backslash\)r\(\backslash\)n"}
02889             \textcolor{stringliteral}{"redis\_version:%s\(\backslash\)r\(\backslash\)n"}
02890             \textcolor{stringliteral}{"redis\_git\_sha1:%s\(\backslash\)r\(\backslash\)n"}
02891             \textcolor{stringliteral}{"redis\_git\_dirty:%d\(\backslash\)r\(\backslash\)n"}
02892             \textcolor{stringliteral}{"redis\_build\_id:%llx\(\backslash\)r\(\backslash\)n"}
02893             \textcolor{stringliteral}{"redis\_mode:%s\(\backslash\)r\(\backslash\)n"}
02894             \textcolor{stringliteral}{"os:%s %s %s\(\backslash\)r\(\backslash\)n"}
02895             \textcolor{stringliteral}{"arch\_bits:%d\(\backslash\)r\(\backslash\)n"}
02896             \textcolor{stringliteral}{"multiplexing\_api:%s\(\backslash\)r\(\backslash\)n"}
02897             \textcolor{stringliteral}{"atomicvar\_api:%s\(\backslash\)r\(\backslash\)n"}
02898             \textcolor{stringliteral}{"gcc\_version:%d.%d.%d\(\backslash\)r\(\backslash\)n"}
02899             \textcolor{stringliteral}{"process\_id:%ld\(\backslash\)r\(\backslash\)n"}
02900             \textcolor{stringliteral}{"run\_id:%s\(\backslash\)r\(\backslash\)n"}
02901             \textcolor{stringliteral}{"tcp\_port:%d\(\backslash\)r\(\backslash\)n"}
02902             \textcolor{stringliteral}{"uptime\_in\_seconds:%jd\(\backslash\)r\(\backslash\)n"}
02903             \textcolor{stringliteral}{"uptime\_in\_days:%jd\(\backslash\)r\(\backslash\)n"}
02904             \textcolor{stringliteral}{"hz:%d\(\backslash\)r\(\backslash\)n"}
02905             \textcolor{stringliteral}{"lru\_clock:%ld\(\backslash\)r\(\backslash\)n"}
02906             \textcolor{stringliteral}{"executable:%s\(\backslash\)r\(\backslash\)n"}
02907             \textcolor{stringliteral}{"config\_file:%s\(\backslash\)r\(\backslash\)n"},
02908             \hyperlink{version_8h_a357a0d302ef7fbb42bf2db0632b9f7fe}{REDIS\_VERSION},
02909             redisGitSHA1(),
02910             strtol(redisGitDirty(),NULL,10) > 0,
02911             (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) redisBuildId(),
02912             mode,
02913             name.sysname, name.release, name.machine,
02914             server.arch\_bits,
02915             aeGetApiName(),
02916             \hyperlink{atomicvar_8h_ae3aa976bb329a4a554a853c5770c3e3d}{REDIS\_ATOMIC\_API},
02917 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \_\_GNUC\_\_
02918             \_\_GNUC\_\_,\_\_GNUC\_MINOR\_\_,\_\_GNUC\_PATCHLEVEL\_\_,
02919 \textcolor{preprocessor}{#}\textcolor{preprocessor}{else}
02920             0,0,0,
02921 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
02922             (\textcolor{keywordtype}{long}) getpid(),
02923             server.runid,
02924             server.port,
02925             (intmax\_t)uptime,
02926             (intmax\_t)(uptime/(3600*24)),
02927             server.hz,
02928             (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}) lruclock,
02929             server.executable ? server.executable : \textcolor{stringliteral}{""},
02930             server.configfile ? server.configfile : \textcolor{stringliteral}{""});
02931     \}
02932 
02933     \textcolor{comment}{/* Clients */}
02934     \textcolor{keywordflow}{if} (allsections || defsections || !strcasecmp(section,\textcolor{stringliteral}{"clients"})) \{
02935         \textcolor{keywordflow}{if} (sections++) info = sdscat(info,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"});
02936         info = sdscatprintf(info,
02937             \textcolor{stringliteral}{"# Clients\(\backslash\)r\(\backslash\)n"}
02938             \textcolor{stringliteral}{"connected\_clients:%lu\(\backslash\)r\(\backslash\)n"}
02939             \textcolor{stringliteral}{"client\_longest\_output\_list:%lu\(\backslash\)r\(\backslash\)n"}
02940             \textcolor{stringliteral}{"client\_biggest\_input\_buf:%lu\(\backslash\)r\(\backslash\)n"}
02941             \textcolor{stringliteral}{"blocked\_clients:%d\(\backslash\)r\(\backslash\)n"},
02942             \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.clients)-\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.slaves),
02943             lol, bib,
02944             server.blocked\_clients);
02945     \}
02946 
02947     \textcolor{comment}{/* Memory */}
02948     \textcolor{keywordflow}{if} (allsections || defsections || !strcasecmp(section,\textcolor{stringliteral}{"memory"})) \{
02949         \textcolor{keywordtype}{char} hmem[64];
02950         \textcolor{keywordtype}{char} peak\_hmem[64];
02951         \textcolor{keywordtype}{char} total\_system\_hmem[64];
02952         \textcolor{keywordtype}{char} used\_memory\_lua\_hmem[64];
02953         \textcolor{keywordtype}{char} used\_memory\_rss\_hmem[64];
02954         \textcolor{keywordtype}{char} maxmemory\_hmem[64];
02955         size\_t zmalloc\_used = zmalloc\_used\_memory();
02956         size\_t total\_system\_mem = server.system\_memory\_size;
02957         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *evict\_policy = evictPolicyToString();
02958         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} memory\_lua = (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long})lua\_gc(server.lua,LUA\_GCCOUNT,0)*1024;
02959         \textcolor{keyword}{struct} \hyperlink{structredisMemOverhead}{redisMemOverhead} *mh = getMemoryOverheadData();
02960 
02961         \textcolor{comment}{/* Peak memory is updated from time to time by serverCron() so it}
02962 \textcolor{comment}{         * may happen that the instantaneous value is slightly bigger than}
02963 \textcolor{comment}{         * the peak value. This may confuse users, so we update the peak}
02964 \textcolor{comment}{         * if found smaller than the current memory usage. */}
02965         \textcolor{keywordflow}{if} (zmalloc\_used > server.stat\_peak\_memory)
02966             server.stat\_peak\_memory = zmalloc\_used;
02967 
02968         bytesToHuman(hmem,zmalloc\_used);
02969         bytesToHuman(peak\_hmem,server.stat\_peak\_memory);
02970         bytesToHuman(total\_system\_hmem,total\_system\_mem);
02971         bytesToHuman(used\_memory\_lua\_hmem,memory\_lua);
02972         bytesToHuman(used\_memory\_rss\_hmem,server.resident\_set\_size);
02973         bytesToHuman(maxmemory\_hmem,server.maxmemory);
02974 
02975         \textcolor{keywordflow}{if} (sections++) info = sdscat(info,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"});
02976         info = sdscatprintf(info,
02977             \textcolor{stringliteral}{"# Memory\(\backslash\)r\(\backslash\)n"}
02978             \textcolor{stringliteral}{"used\_memory:%zu\(\backslash\)r\(\backslash\)n"}
02979             \textcolor{stringliteral}{"used\_memory\_human:%s\(\backslash\)r\(\backslash\)n"}
02980             \textcolor{stringliteral}{"used\_memory\_rss:%zu\(\backslash\)r\(\backslash\)n"}
02981             \textcolor{stringliteral}{"used\_memory\_rss\_human:%s\(\backslash\)r\(\backslash\)n"}
02982             \textcolor{stringliteral}{"used\_memory\_peak:%zu\(\backslash\)r\(\backslash\)n"}
02983             \textcolor{stringliteral}{"used\_memory\_peak\_human:%s\(\backslash\)r\(\backslash\)n"}
02984             \textcolor{stringliteral}{"used\_memory\_peak\_perc:%.2f%%\(\backslash\)r\(\backslash\)n"}
02985             \textcolor{stringliteral}{"used\_memory\_overhead:%zu\(\backslash\)r\(\backslash\)n"}
02986             \textcolor{stringliteral}{"used\_memory\_startup:%zu\(\backslash\)r\(\backslash\)n"}
02987             \textcolor{stringliteral}{"used\_memory\_dataset:%zu\(\backslash\)r\(\backslash\)n"}
02988             \textcolor{stringliteral}{"used\_memory\_dataset\_perc:%.2f%%\(\backslash\)r\(\backslash\)n"}
02989             \textcolor{stringliteral}{"total\_system\_memory:%lu\(\backslash\)r\(\backslash\)n"}
02990             \textcolor{stringliteral}{"total\_system\_memory\_human:%s\(\backslash\)r\(\backslash\)n"}
02991             \textcolor{stringliteral}{"used\_memory\_lua:%lld\(\backslash\)r\(\backslash\)n"}
02992             \textcolor{stringliteral}{"used\_memory\_lua\_human:%s\(\backslash\)r\(\backslash\)n"}
02993             \textcolor{stringliteral}{"maxmemory:%lld\(\backslash\)r\(\backslash\)n"}
02994             \textcolor{stringliteral}{"maxmemory\_human:%s\(\backslash\)r\(\backslash\)n"}
02995             \textcolor{stringliteral}{"maxmemory\_policy:%s\(\backslash\)r\(\backslash\)n"}
02996             \textcolor{stringliteral}{"mem\_fragmentation\_ratio:%.2f\(\backslash\)r\(\backslash\)n"}
02997             \textcolor{stringliteral}{"mem\_allocator:%s\(\backslash\)r\(\backslash\)n"}
02998             \textcolor{stringliteral}{"active\_defrag\_running:%d\(\backslash\)r\(\backslash\)n"}
02999             \textcolor{stringliteral}{"lazyfree\_pending\_objects:%zu\(\backslash\)r\(\backslash\)n"},
03000             zmalloc\_used,
03001             hmem,
03002             server.resident\_set\_size,
03003             used\_memory\_rss\_hmem,
03004             server.stat\_peak\_memory,
03005             peak\_hmem,
03006             mh->peak\_perc,
03007             mh->overhead\_total,
03008             mh->startup\_allocated,
03009             mh->dataset,
03010             mh->dataset\_perc,
03011             (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})total\_system\_mem,
03012             total\_system\_hmem,
03013             memory\_lua,
03014             used\_memory\_lua\_hmem,
03015             server.maxmemory,
03016             maxmemory\_hmem,
03017             evict\_policy,
03018             mh->fragmentation,
03019             \hyperlink{zmalloc_8h_a374c6d7cf6c9817e1243093e03df7319}{ZMALLOC\_LIB},
03020             server.active\_defrag\_running,
03021             lazyfreeGetPendingObjectsCount()
03022         );
03023         freeMemoryOverheadData(mh);
03024     \}
03025 
03026     \textcolor{comment}{/* Persistence */}
03027     \textcolor{keywordflow}{if} (allsections || defsections || !strcasecmp(section,\textcolor{stringliteral}{"persistence"})) \{
03028         \textcolor{keywordflow}{if} (sections++) info = sdscat(info,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"});
03029         info = sdscatprintf(info,
03030             \textcolor{stringliteral}{"# Persistence\(\backslash\)r\(\backslash\)n"}
03031             \textcolor{stringliteral}{"loading:%d\(\backslash\)r\(\backslash\)n"}
03032             \textcolor{stringliteral}{"rdb\_changes\_since\_last\_save:%lld\(\backslash\)r\(\backslash\)n"}
03033             \textcolor{stringliteral}{"rdb\_bgsave\_in\_progress:%d\(\backslash\)r\(\backslash\)n"}
03034             \textcolor{stringliteral}{"rdb\_last\_save\_time:%jd\(\backslash\)r\(\backslash\)n"}
03035             \textcolor{stringliteral}{"rdb\_last\_bgsave\_status:%s\(\backslash\)r\(\backslash\)n"}
03036             \textcolor{stringliteral}{"rdb\_last\_bgsave\_time\_sec:%jd\(\backslash\)r\(\backslash\)n"}
03037             \textcolor{stringliteral}{"rdb\_current\_bgsave\_time\_sec:%jd\(\backslash\)r\(\backslash\)n"}
03038             \textcolor{stringliteral}{"rdb\_last\_cow\_size:%zu\(\backslash\)r\(\backslash\)n"}
03039             \textcolor{stringliteral}{"aof\_enabled:%d\(\backslash\)r\(\backslash\)n"}
03040             \textcolor{stringliteral}{"aof\_rewrite\_in\_progress:%d\(\backslash\)r\(\backslash\)n"}
03041             \textcolor{stringliteral}{"aof\_rewrite\_scheduled:%d\(\backslash\)r\(\backslash\)n"}
03042             \textcolor{stringliteral}{"aof\_last\_rewrite\_time\_sec:%jd\(\backslash\)r\(\backslash\)n"}
03043             \textcolor{stringliteral}{"aof\_current\_rewrite\_time\_sec:%jd\(\backslash\)r\(\backslash\)n"}
03044             \textcolor{stringliteral}{"aof\_last\_bgrewrite\_status:%s\(\backslash\)r\(\backslash\)n"}
03045             \textcolor{stringliteral}{"aof\_last\_write\_status:%s\(\backslash\)r\(\backslash\)n"}
03046             \textcolor{stringliteral}{"aof\_last\_cow\_size:%zu\(\backslash\)r\(\backslash\)n"},
03047             server.loading,
03048             server.dirty,
03049             server.rdb\_child\_pid != -1,
03050             (intmax\_t)server.lastsave,
03051             (server.lastbgsave\_status == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) ? \textcolor{stringliteral}{"ok"} : \textcolor{stringliteral}{"err"},
03052             (intmax\_t)server.rdb\_save\_time\_last,
03053             (intmax\_t)((server.rdb\_child\_pid == -1) ?
03054                 -1 : time(NULL)-server.rdb\_save\_time\_start),
03055             server.stat\_rdb\_cow\_bytes,
03056             server.aof\_state != \hyperlink{server_8h_a5226306fbcebcb6d5d02e0fef3c213c2}{AOF\_OFF},
03057             server.aof\_child\_pid != -1,
03058             server.aof\_rewrite\_scheduled,
03059             (intmax\_t)server.aof\_rewrite\_time\_last,
03060             (intmax\_t)((server.aof\_child\_pid == -1) ?
03061                 -1 : time(NULL)-server.aof\_rewrite\_time\_start),
03062             (server.aof\_lastbgrewrite\_status == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) ? \textcolor{stringliteral}{"ok"} : \textcolor{stringliteral}{"err"},
03063             (server.aof\_last\_write\_status == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) ? \textcolor{stringliteral}{"ok"} : \textcolor{stringliteral}{"err"},
03064             server.stat\_aof\_cow\_bytes);
03065 
03066         \textcolor{keywordflow}{if} (server.aof\_state != \hyperlink{server_8h_a5226306fbcebcb6d5d02e0fef3c213c2}{AOF\_OFF}) \{
03067             info = sdscatprintf(info,
03068                 \textcolor{stringliteral}{"aof\_current\_size:%lld\(\backslash\)r\(\backslash\)n"}
03069                 \textcolor{stringliteral}{"aof\_base\_size:%lld\(\backslash\)r\(\backslash\)n"}
03070                 \textcolor{stringliteral}{"aof\_pending\_rewrite:%d\(\backslash\)r\(\backslash\)n"}
03071                 \textcolor{stringliteral}{"aof\_buffer\_length:%zu\(\backslash\)r\(\backslash\)n"}
03072                 \textcolor{stringliteral}{"aof\_rewrite\_buffer\_length:%lu\(\backslash\)r\(\backslash\)n"}
03073                 \textcolor{stringliteral}{"aof\_pending\_bio\_fsync:%llu\(\backslash\)r\(\backslash\)n"}
03074                 \textcolor{stringliteral}{"aof\_delayed\_fsync:%lu\(\backslash\)r\(\backslash\)n"},
03075                 (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) server.aof\_current\_size,
03076                 (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) server.aof\_rewrite\_base\_size,
03077                 server.aof\_rewrite\_scheduled,
03078                 sdslen(server.aof\_buf),
03079                 aofRewriteBufferSize(),
03080                 bioPendingJobsOfType(\hyperlink{bio_8h_a5d03c967316addafc61b7ed5d957984f}{BIO\_AOF\_FSYNC}),
03081                 server.aof\_delayed\_fsync);
03082         \}
03083 
03084         \textcolor{keywordflow}{if} (server.loading) \{
03085             \textcolor{keywordtype}{double} perc;
03086             time\_t eta, elapsed;
03087             off\_t remaining\_bytes = server.loading\_total\_bytes-
03088                                     server.loading\_loaded\_bytes;
03089 
03090             perc = ((\textcolor{keywordtype}{double})server.loading\_loaded\_bytes /
03091                    (server.loading\_total\_bytes+1)) * 100;
03092 
03093             elapsed = time(NULL)-server.loading\_start\_time;
03094             \textcolor{keywordflow}{if} (elapsed == 0) \{
03095                 eta = 1; \textcolor{comment}{/* A fake 1 second figure if we don't have}
03096 \textcolor{comment}{                            enough info */}
03097             \} \textcolor{keywordflow}{else} \{
03098                 eta = (elapsed*remaining\_bytes)/(server.loading\_loaded\_bytes+1);
03099             \}
03100 
03101             info = sdscatprintf(info,
03102                 \textcolor{stringliteral}{"loading\_start\_time:%jd\(\backslash\)r\(\backslash\)n"}
03103                 \textcolor{stringliteral}{"loading\_total\_bytes:%llu\(\backslash\)r\(\backslash\)n"}
03104                 \textcolor{stringliteral}{"loading\_loaded\_bytes:%llu\(\backslash\)r\(\backslash\)n"}
03105                 \textcolor{stringliteral}{"loading\_loaded\_perc:%.2f\(\backslash\)r\(\backslash\)n"}
03106                 \textcolor{stringliteral}{"loading\_eta\_seconds:%jd\(\backslash\)r\(\backslash\)n"},
03107                 (intmax\_t) server.loading\_start\_time,
03108                 (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) server.loading\_total\_bytes,
03109                 (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) server.loading\_loaded\_bytes,
03110                 perc,
03111                 (intmax\_t)eta
03112             );
03113         \}
03114     \}
03115 
03116     \textcolor{comment}{/* Stats */}
03117     \textcolor{keywordflow}{if} (allsections || defsections || !strcasecmp(section,\textcolor{stringliteral}{"stats"})) \{
03118         \textcolor{keywordflow}{if} (sections++) info = sdscat(info,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"});
03119         info = sdscatprintf(info,
03120             \textcolor{stringliteral}{"# Stats\(\backslash\)r\(\backslash\)n"}
03121             \textcolor{stringliteral}{"total\_connections\_received:%lld\(\backslash\)r\(\backslash\)n"}
03122             \textcolor{stringliteral}{"total\_commands\_processed:%lld\(\backslash\)r\(\backslash\)n"}
03123             \textcolor{stringliteral}{"instantaneous\_ops\_per\_sec:%lld\(\backslash\)r\(\backslash\)n"}
03124             \textcolor{stringliteral}{"total\_net\_input\_bytes:%lld\(\backslash\)r\(\backslash\)n"}
03125             \textcolor{stringliteral}{"total\_net\_output\_bytes:%lld\(\backslash\)r\(\backslash\)n"}
03126             \textcolor{stringliteral}{"instantaneous\_input\_kbps:%.2f\(\backslash\)r\(\backslash\)n"}
03127             \textcolor{stringliteral}{"instantaneous\_output\_kbps:%.2f\(\backslash\)r\(\backslash\)n"}
03128             \textcolor{stringliteral}{"rejected\_connections:%lld\(\backslash\)r\(\backslash\)n"}
03129             \textcolor{stringliteral}{"sync\_full:%lld\(\backslash\)r\(\backslash\)n"}
03130             \textcolor{stringliteral}{"sync\_partial\_ok:%lld\(\backslash\)r\(\backslash\)n"}
03131             \textcolor{stringliteral}{"sync\_partial\_err:%lld\(\backslash\)r\(\backslash\)n"}
03132             \textcolor{stringliteral}{"expired\_keys:%lld\(\backslash\)r\(\backslash\)n"}
03133             \textcolor{stringliteral}{"evicted\_keys:%lld\(\backslash\)r\(\backslash\)n"}
03134             \textcolor{stringliteral}{"keyspace\_hits:%lld\(\backslash\)r\(\backslash\)n"}
03135             \textcolor{stringliteral}{"keyspace\_misses:%lld\(\backslash\)r\(\backslash\)n"}
03136             \textcolor{stringliteral}{"pubsub\_channels:%ld\(\backslash\)r\(\backslash\)n"}
03137             \textcolor{stringliteral}{"pubsub\_patterns:%lu\(\backslash\)r\(\backslash\)n"}
03138             \textcolor{stringliteral}{"latest\_fork\_usec:%lld\(\backslash\)r\(\backslash\)n"}
03139             \textcolor{stringliteral}{"migrate\_cached\_sockets:%ld\(\backslash\)r\(\backslash\)n"}
03140             \textcolor{stringliteral}{"slave\_expires\_tracked\_keys:%zu\(\backslash\)r\(\backslash\)n"}
03141             \textcolor{stringliteral}{"active\_defrag\_hits:%lld\(\backslash\)r\(\backslash\)n"}
03142             \textcolor{stringliteral}{"active\_defrag\_misses:%lld\(\backslash\)r\(\backslash\)n"}
03143             \textcolor{stringliteral}{"active\_defrag\_key\_hits:%lld\(\backslash\)r\(\backslash\)n"}
03144             \textcolor{stringliteral}{"active\_defrag\_key\_misses:%lld\(\backslash\)r\(\backslash\)n"},
03145             server.stat\_numconnections,
03146             server.stat\_numcommands,
03147             getInstantaneousMetric(\hyperlink{server_8h_ac8d50898802f96b76479bc975e1bbbf3}{STATS\_METRIC\_COMMAND}),
03148             server.stat\_net\_input\_bytes,
03149             server.stat\_net\_output\_bytes,
03150             (\textcolor{keywordtype}{float})getInstantaneousMetric(\hyperlink{server_8h_a6d217560ae714ab8d0cc21832b210e0b}{STATS\_METRIC\_NET\_INPUT})/1024,
03151             (\textcolor{keywordtype}{float})getInstantaneousMetric(\hyperlink{server_8h_a3885f356f3a4cef22eb96fbfcc406333}{STATS\_METRIC\_NET\_OUTPUT})/1024,
03152             server.stat\_rejected\_conn,
03153             server.stat\_sync\_full,
03154             server.stat\_sync\_partial\_ok,
03155             server.stat\_sync\_partial\_err,
03156             server.stat\_expiredkeys,
03157             server.stat\_evictedkeys,
03158             server.stat\_keyspace\_hits,
03159             server.stat\_keyspace\_misses,
03160             \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.pubsub\_channels),
03161             \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.pubsub\_patterns),
03162             server.stat\_fork\_time,
03163             \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.migrate\_cached\_sockets),
03164             getSlaveKeyWithExpireCount(),
03165             server.stat\_active\_defrag\_hits,
03166             server.stat\_active\_defrag\_misses,
03167             server.stat\_active\_defrag\_key\_hits,
03168             server.stat\_active\_defrag\_key\_misses);
03169     \}
03170 
03171     \textcolor{comment}{/* Replication */}
03172     \textcolor{keywordflow}{if} (allsections || defsections || !strcasecmp(section,\textcolor{stringliteral}{"replication"})) \{
03173         \textcolor{keywordflow}{if} (sections++) info = sdscat(info,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"});
03174         info = sdscatprintf(info,
03175             \textcolor{stringliteral}{"# Replication\(\backslash\)r\(\backslash\)n"}
03176             \textcolor{stringliteral}{"role:%s\(\backslash\)r\(\backslash\)n"},
03177             server.masterhost == NULL ? \textcolor{stringliteral}{"master"} : \textcolor{stringliteral}{"slave"});
03178         \textcolor{keywordflow}{if} (server.masterhost) \{
03179             \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} slave\_repl\_offset = 1;
03180 
03181             \textcolor{keywordflow}{if} (server.master)
03182                 slave\_repl\_offset = server.master->reploff;
03183             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.cached\_master)
03184                 slave\_repl\_offset = server.cached\_master->reploff;
03185 
03186             info = sdscatprintf(info,
03187                 \textcolor{stringliteral}{"master\_host:%s\(\backslash\)r\(\backslash\)n"}
03188                 \textcolor{stringliteral}{"master\_port:%d\(\backslash\)r\(\backslash\)n"}
03189                 \textcolor{stringliteral}{"master\_link\_status:%s\(\backslash\)r\(\backslash\)n"}
03190                 \textcolor{stringliteral}{"master\_last\_io\_seconds\_ago:%d\(\backslash\)r\(\backslash\)n"}
03191                 \textcolor{stringliteral}{"master\_sync\_in\_progress:%d\(\backslash\)r\(\backslash\)n"}
03192                 \textcolor{stringliteral}{"slave\_repl\_offset:%lld\(\backslash\)r\(\backslash\)n"}
03193                 ,server.masterhost,
03194                 server.masterport,
03195                 (server.repl\_state == \hyperlink{server_8h_aed693b3a9cdfc05cf5ab7551a8c86fbe}{REPL\_STATE\_CONNECTED}) ?
03196                     \textcolor{stringliteral}{"up"} : \textcolor{stringliteral}{"down"},
03197                 server.master ?
03198                 ((\textcolor{keywordtype}{int})(server.unixtime-server.master->lastinteraction)) : -1,
03199                 server.repl\_state == \hyperlink{server_8h_a1d27594a2d9c8d24e4ed5a2e88d1113e}{REPL\_STATE\_TRANSFER},
03200                 slave\_repl\_offset
03201             );
03202 
03203             \textcolor{keywordflow}{if} (server.repl\_state == \hyperlink{server_8h_a1d27594a2d9c8d24e4ed5a2e88d1113e}{REPL\_STATE\_TRANSFER}) \{
03204                 info = sdscatprintf(info,
03205                     \textcolor{stringliteral}{"master\_sync\_left\_bytes:%lld\(\backslash\)r\(\backslash\)n"}
03206                     \textcolor{stringliteral}{"master\_sync\_last\_io\_seconds\_ago:%d\(\backslash\)r\(\backslash\)n"}
03207                     , (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long})
03208                         (server.repl\_transfer\_size - server.repl\_transfer\_read),
03209                     (\textcolor{keywordtype}{int})(server.unixtime-server.repl\_transfer\_lastio)
03210                 );
03211             \}
03212 
03213             \textcolor{keywordflow}{if} (server.repl\_state != \hyperlink{server_8h_aed693b3a9cdfc05cf5ab7551a8c86fbe}{REPL\_STATE\_CONNECTED}) \{
03214                 info = sdscatprintf(info,
03215                     \textcolor{stringliteral}{"master\_link\_down\_since\_seconds:%jd\(\backslash\)r\(\backslash\)n"},
03216                     (intmax\_t)server.unixtime-server.repl\_down\_since);
03217             \}
03218             info = sdscatprintf(info,
03219                 \textcolor{stringliteral}{"slave\_priority:%d\(\backslash\)r\(\backslash\)n"}
03220                 \textcolor{stringliteral}{"slave\_read\_only:%d\(\backslash\)r\(\backslash\)n"},
03221                 server.slave\_priority,
03222                 server.repl\_slave\_ro);
03223         \}
03224 
03225         info = sdscatprintf(info,
03226             \textcolor{stringliteral}{"connected\_slaves:%lu\(\backslash\)r\(\backslash\)n"},
03227             \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.slaves));
03228 
03229         \textcolor{comment}{/* If min-slaves-to-write is active, write the number of slaves}
03230 \textcolor{comment}{         * currently considered 'good'. */}
03231         \textcolor{keywordflow}{if} (server.repl\_min\_slaves\_to\_write &&
03232             server.repl\_min\_slaves\_max\_lag) \{
03233             info = sdscatprintf(info,
03234                 \textcolor{stringliteral}{"min\_slaves\_good\_slaves:%d\(\backslash\)r\(\backslash\)n"},
03235                 server.repl\_good\_slaves\_count);
03236         \}
03237 
03238         \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.slaves)) \{
03239             \textcolor{keywordtype}{int} slaveid = 0;
03240             listNode *ln;
03241             listIter li;
03242 
03243             listRewind(server.slaves,&li);
03244             \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
03245                 \hyperlink{structclient}{client} *slave = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
03246                 \textcolor{keywordtype}{char} *state = NULL;
03247                 \textcolor{keywordtype}{char} ip[\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN}], *slaveip = slave->slave\_ip;
03248                 \textcolor{keywordtype}{int} port;
03249                 \textcolor{keywordtype}{long} lag = 0;
03250 
03251                 \textcolor{keywordflow}{if} (slaveip[0] == \textcolor{stringliteral}{'\(\backslash\)0'}) \{
03252                     \textcolor{keywordflow}{if} (anetPeerToString(slave->fd,ip,\textcolor{keyword}{sizeof}(ip),&port) == -1)
03253                         \textcolor{keywordflow}{continue};
03254                     slaveip = ip;
03255                 \}
03256                 \textcolor{keywordflow}{switch}(slave->replstate) \{
03257                 \textcolor{keywordflow}{case} \hyperlink{server_8h_a170ee2dd8cfefaf0d112edcc3152f8d7}{SLAVE\_STATE\_WAIT\_BGSAVE\_START}:
03258                 \textcolor{keywordflow}{case} \hyperlink{server_8h_a2a1b586e8f326f831f6ab466c8c3f38a}{SLAVE\_STATE\_WAIT\_BGSAVE\_END}:
03259                     state = \textcolor{stringliteral}{"wait\_bgsave"};
03260                     \textcolor{keywordflow}{break};
03261                 \textcolor{keywordflow}{case} \hyperlink{server_8h_ada38427ad2d0c09875081868a53cc51f}{SLAVE\_STATE\_SEND\_BULK}:
03262                     state = \textcolor{stringliteral}{"send\_bulk"};
03263                     \textcolor{keywordflow}{break};
03264                 \textcolor{keywordflow}{case} \hyperlink{server_8h_ad895fdf16e5ed5275d19ddf8578b900f}{SLAVE\_STATE\_ONLINE}:
03265                     state = \textcolor{stringliteral}{"online"};
03266                     \textcolor{keywordflow}{break};
03267                 \}
03268                 \textcolor{keywordflow}{if} (state == NULL) \textcolor{keywordflow}{continue};
03269                 \textcolor{keywordflow}{if} (slave->replstate == \hyperlink{server_8h_ad895fdf16e5ed5275d19ddf8578b900f}{SLAVE\_STATE\_ONLINE})
03270                     lag = time(NULL) - slave->repl\_ack\_time;
03271 
03272                 info = sdscatprintf(info,
03273                     \textcolor{stringliteral}{"slave%d:ip=%s,port=%d,state=%s,"}
03274                     \textcolor{stringliteral}{"offset=%lld,lag=%ld\(\backslash\)r\(\backslash\)n"},
03275                     slaveid,slaveip,slave->slave\_listening\_port,state,
03276                     slave->repl\_ack\_off, lag);
03277                 slaveid++;
03278             \}
03279         \}
03280         info = sdscatprintf(info,
03281             \textcolor{stringliteral}{"master\_replid:%s\(\backslash\)r\(\backslash\)n"}
03282             \textcolor{stringliteral}{"master\_replid2:%s\(\backslash\)r\(\backslash\)n"}
03283             \textcolor{stringliteral}{"master\_repl\_offset:%lld\(\backslash\)r\(\backslash\)n"}
03284             \textcolor{stringliteral}{"second\_repl\_offset:%lld\(\backslash\)r\(\backslash\)n"}
03285             \textcolor{stringliteral}{"repl\_backlog\_active:%d\(\backslash\)r\(\backslash\)n"}
03286             \textcolor{stringliteral}{"repl\_backlog\_size:%lld\(\backslash\)r\(\backslash\)n"}
03287             \textcolor{stringliteral}{"repl\_backlog\_first\_byte\_offset:%lld\(\backslash\)r\(\backslash\)n"}
03288             \textcolor{stringliteral}{"repl\_backlog\_histlen:%lld\(\backslash\)r\(\backslash\)n"},
03289             server.replid,
03290             server.replid2,
03291             server.master\_repl\_offset,
03292             server.second\_replid\_offset,
03293             server.repl\_backlog != NULL,
03294             server.repl\_backlog\_size,
03295             server.repl\_backlog\_off,
03296             server.repl\_backlog\_histlen);
03297     \}
03298 
03299     \textcolor{comment}{/* CPU */}
03300     \textcolor{keywordflow}{if} (allsections || defsections || !strcasecmp(section,\textcolor{stringliteral}{"cpu"})) \{
03301         \textcolor{keywordflow}{if} (sections++) info = sdscat(info,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"});
03302         info = sdscatprintf(info,
03303         \textcolor{stringliteral}{"# CPU\(\backslash\)r\(\backslash\)n"}
03304         \textcolor{stringliteral}{"used\_cpu\_sys:%.2f\(\backslash\)r\(\backslash\)n"}
03305         \textcolor{stringliteral}{"used\_cpu\_user:%.2f\(\backslash\)r\(\backslash\)n"}
03306         \textcolor{stringliteral}{"used\_cpu\_sys\_children:%.2f\(\backslash\)r\(\backslash\)n"}
03307         \textcolor{stringliteral}{"used\_cpu\_user\_children:%.2f\(\backslash\)r\(\backslash\)n"},
03308         (\textcolor{keywordtype}{float})self\_ru.ru\_stime.tv\_sec+(\textcolor{keywordtype}{float})self\_ru.ru\_stime.tv\_usec/1000000,
03309         (\textcolor{keywordtype}{float})self\_ru.ru\_utime.tv\_sec+(\textcolor{keywordtype}{float})self\_ru.ru\_utime.tv\_usec/1000000,
03310         (\textcolor{keywordtype}{float})c\_ru.ru\_stime.tv\_sec+(\textcolor{keywordtype}{float})c\_ru.ru\_stime.tv\_usec/1000000,
03311         (\textcolor{keywordtype}{float})c\_ru.ru\_utime.tv\_sec+(\textcolor{keywordtype}{float})c\_ru.ru\_utime.tv\_usec/1000000);
03312     \}
03313 
03314     \textcolor{comment}{/* Command statistics */}
03315     \textcolor{keywordflow}{if} (allsections || !strcasecmp(section,\textcolor{stringliteral}{"commandstats"})) \{
03316         \textcolor{keywordflow}{if} (sections++) info = sdscat(info,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"});
03317         info = sdscatprintf(info, \textcolor{stringliteral}{"# Commandstats\(\backslash\)r\(\backslash\)n"});
03318 
03319         \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *c;
03320         dictEntry *de;
03321         dictIterator *di;
03322         di = dictGetSafeIterator(server.commands);
03323         \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
03324             c = (\textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *) \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
03325             \textcolor{keywordflow}{if} (!c->calls) \textcolor{keywordflow}{continue};
03326             info = sdscatprintf(info,
03327                 \textcolor{stringliteral}{"cmdstat\_%s:calls=%lld,usec=%lld,usec\_per\_call=%.2f\(\backslash\)r\(\backslash\)n"},
03328                 c->name, c->calls, c->microseconds,
03329                 (c->calls == 0) ? 0 : ((\textcolor{keywordtype}{float})c->microseconds/c->calls));
03330         \}
03331         dictReleaseIterator(di);
03332     \}
03333 
03334     \textcolor{comment}{/* Cluster */}
03335     \textcolor{keywordflow}{if} (allsections || defsections || !strcasecmp(section,\textcolor{stringliteral}{"cluster"})) \{
03336         \textcolor{keywordflow}{if} (sections++) info = sdscat(info,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"});
03337         info = sdscatprintf(info,
03338         \textcolor{stringliteral}{"# Cluster\(\backslash\)r\(\backslash\)n"}
03339         \textcolor{stringliteral}{"cluster\_enabled:%d\(\backslash\)r\(\backslash\)n"},
03340         server.cluster\_enabled);
03341     \}
03342 
03343     \textcolor{comment}{/* Key space */}
03344     \textcolor{keywordflow}{if} (allsections || defsections || !strcasecmp(section,\textcolor{stringliteral}{"keyspace"})) \{
03345         \textcolor{keywordflow}{if} (sections++) info = sdscat(info,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"});
03346         info = sdscatprintf(info, \textcolor{stringliteral}{"# Keyspace\(\backslash\)r\(\backslash\)n"});
03347         \textcolor{keywordflow}{for} (j = 0; j < server.dbnum; j++) \{
03348             \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} keys, vkeys;
03349 
03350             keys = \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.db[j].dict);
03351             vkeys = \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.db[j].expires);
03352             \textcolor{keywordflow}{if} (keys || vkeys) \{
03353                 info = sdscatprintf(info,
03354                     \textcolor{stringliteral}{"db%d:keys=%lld,expires=%lld,avg\_ttl=%lld\(\backslash\)r\(\backslash\)n"},
03355                     j, keys, vkeys, server.db[j].avg\_ttl);
03356             \}
03357         \}
03358     \}
03359     \textcolor{keywordflow}{return} info;
03360 \}
03361 
03362 \textcolor{keywordtype}{void} infoCommand(\hyperlink{structclient}{client} *c) \{
03363     \textcolor{keywordtype}{char} *section = c->argc == 2 ? c->argv[1]->ptr : \textcolor{stringliteral}{"default"};
03364 
03365     \textcolor{keywordflow}{if} (c->argc > 2) \{
03366         addReply(c,shared.syntaxerr);
03367         \textcolor{keywordflow}{return};
03368     \}
03369     addReplyBulkSds(c, genRedisInfoString(section));
03370 \}
03371 
03372 \textcolor{keywordtype}{void} monitorCommand(\hyperlink{structclient}{client} *c) \{
03373     \textcolor{comment}{/* ignore MONITOR if already slave or in monitor mode */}
03374     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_ae9f6995948253652bc9454d79a72f4a7}{CLIENT\_SLAVE}) \textcolor{keywordflow}{return};
03375 
03376     c->flags |= (\hyperlink{server_8h_ae9f6995948253652bc9454d79a72f4a7}{CLIENT\_SLAVE}|\hyperlink{server_8h_a7724350e4f0ddbf1c80740699fac78be}{CLIENT\_MONITOR});
03377     listAddNodeTail(server.monitors,c);
03378     addReply(c,shared.ok);
03379 \}
03380 
03381 \textcolor{comment}{/* =================================== Main! ================================ */}
03382 
03383 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \_\_linux\_\_
03384 \textcolor{keywordtype}{int} linuxOvercommitMemoryValue(\textcolor{keywordtype}{void}) \{
03385     FILE *fp = fopen(\textcolor{stringliteral}{"/proc/sys/vm/overcommit\_memory"},\textcolor{stringliteral}{"r"});
03386     \textcolor{keywordtype}{char} buf[64];
03387 
03388     \textcolor{keywordflow}{if} (!fp) \textcolor{keywordflow}{return} -1;
03389     \textcolor{keywordflow}{if} (fgets(buf,64,fp) == NULL) \{
03390         fclose(fp);
03391         \textcolor{keywordflow}{return} -1;
03392     \}
03393     fclose(fp);
03394 
03395     \textcolor{keywordflow}{return} atoi(buf);
03396 \}
03397 
03398 \textcolor{keywordtype}{void} linuxMemoryWarnings(\textcolor{keywordtype}{void}) \{
03399     \textcolor{keywordflow}{if} (linuxOvercommitMemoryValue() == 0) \{
03400         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"WARNING overcommit\_memory is set to 0! Background save may
       fail under low memory condition. To fix this issue add 'vm.overcommit\_memory = 1' to /etc/sysctl.conf and then
       reboot or run the command 'sysctl vm.overcommit\_memory=1' for this to take effect."});
03401     \}
03402     \textcolor{keywordflow}{if} (THPIsEnabled()) \{
03403         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"WARNING you have Transparent Huge Pages (THP) support enabled
       in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the
       command 'echo never > /sys/kernel/mm/transparent\_hugepage/enabled' as root, and add it to your /etc/rc.local in
       order to retain the setting after a reboot. Redis must be restarted after THP is disabled."});
03404     \}
03405 \}
03406 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif} \textcolor{comment}{/* \_\_linux\_\_ */}
03407 
03408 \textcolor{keywordtype}{void} createPidFile(\textcolor{keywordtype}{void}) \{
03409     \textcolor{comment}{/* If pidfile requested, but no pidfile defined, use}
03410 \textcolor{comment}{     * default pidfile path */}
03411     \textcolor{keywordflow}{if} (!server.pidfile) server.pidfile = zstrdup(\hyperlink{server_8h_ad0a549a4ce81a4436199706f3513bbc2}{CONFIG\_DEFAULT\_PID\_FILE});
03412 
03413     \textcolor{comment}{/* Try to write the pid file in a best-effort way. */}
03414     FILE *fp = fopen(server.pidfile,\textcolor{stringliteral}{"w"});
03415     \textcolor{keywordflow}{if} (fp) \{
03416         fprintf(fp,\textcolor{stringliteral}{"%d\(\backslash\)n"},(\textcolor{keywordtype}{int})getpid());
03417         fclose(fp);
03418     \}
03419 \}
03420 
03421 \textcolor{keywordtype}{void} daemonize(\textcolor{keywordtype}{void}) \{
03422     \textcolor{keywordtype}{int} fd;
03423 
03424     \textcolor{keywordflow}{if} (fork() != 0) exit(0); \textcolor{comment}{/* parent exits */}
03425     setsid(); \textcolor{comment}{/* create a new session */}
03426 
03427     \textcolor{comment}{/* Every output goes to /dev/null. If Redis is daemonized but}
03428 \textcolor{comment}{     * the 'logfile' is set to 'stdout' in the configuration file}
03429 \textcolor{comment}{     * it will not log at all. */}
03430     \textcolor{keywordflow}{if} ((fd = open(\textcolor{stringliteral}{"/dev/null"}, O\_RDWR, 0)) != -1) \{
03431         dup2(fd, STDIN\_FILENO);
03432         dup2(fd, STDOUT\_FILENO);
03433         dup2(fd, STDERR\_FILENO);
03434         \textcolor{keywordflow}{if} (fd > STDERR\_FILENO) close(fd);
03435     \}
03436 \}
03437 
03438 \textcolor{keywordtype}{void} version(\textcolor{keywordtype}{void}) \{
03439     printf(\textcolor{stringliteral}{"Redis server v=%s sha=%s:%d malloc=%s bits=%d build=%llx\(\backslash\)n"},
03440         \hyperlink{version_8h_a357a0d302ef7fbb42bf2db0632b9f7fe}{REDIS\_VERSION},
03441         redisGitSHA1(),
03442         atoi(redisGitDirty()) > 0,
03443         \hyperlink{zmalloc_8h_a374c6d7cf6c9817e1243093e03df7319}{ZMALLOC\_LIB},
03444         \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{long}) == 4 ? 32 : 64,
03445         (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) redisBuildId());
03446     exit(0);
03447 \}
03448 
03449 \textcolor{keywordtype}{void} usage(\textcolor{keywordtype}{void}) \{
03450     fprintf(stderr,\textcolor{stringliteral}{"Usage: ./redis-server [/path/to/redis.conf] [options]\(\backslash\)n"});
03451     fprintf(stderr,\textcolor{stringliteral}{"       ./redis-server - (read config from stdin)\(\backslash\)n"});
03452     fprintf(stderr,\textcolor{stringliteral}{"       ./redis-server -v or --version\(\backslash\)n"});
03453     fprintf(stderr,\textcolor{stringliteral}{"       ./redis-server -h or --help\(\backslash\)n"});
03454     fprintf(stderr,\textcolor{stringliteral}{"       ./redis-server --test-memory <megabytes>\(\backslash\)n\(\backslash\)n"});
03455     fprintf(stderr,\textcolor{stringliteral}{"Examples:\(\backslash\)n"});
03456     fprintf(stderr,\textcolor{stringliteral}{"       ./redis-server (run the server with default conf)\(\backslash\)n"});
03457     fprintf(stderr,\textcolor{stringliteral}{"       ./redis-server /etc/redis/6379.conf\(\backslash\)n"});
03458     fprintf(stderr,\textcolor{stringliteral}{"       ./redis-server --port 7777\(\backslash\)n"});
03459     fprintf(stderr,\textcolor{stringliteral}{"       ./redis-server --port 7777 --slaveof 127.0.0.1 8888\(\backslash\)n"});
03460     fprintf(stderr,\textcolor{stringliteral}{"       ./redis-server /etc/myredis.conf --loglevel verbose\(\backslash\)n\(\backslash\)n"});
03461     fprintf(stderr,\textcolor{stringliteral}{"Sentinel mode:\(\backslash\)n"});
03462     fprintf(stderr,\textcolor{stringliteral}{"       ./redis-server /etc/sentinel.conf --sentinel\(\backslash\)n"});
03463     exit(1);
03464 \}
03465 
03466 \textcolor{keywordtype}{void} redisAsciiArt(\textcolor{keywordtype}{void}) \{
03467 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{asciilogo_8h}{"asciilogo.h"}
03468     \textcolor{keywordtype}{char} *buf = zmalloc(1024*16);
03469     \textcolor{keywordtype}{char} *mode;
03470 
03471     \textcolor{keywordflow}{if} (server.cluster\_enabled) mode = \textcolor{stringliteral}{"cluster"};
03472     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.sentinel\_mode) mode = \textcolor{stringliteral}{"sentinel"};
03473     \textcolor{keywordflow}{else} mode = \textcolor{stringliteral}{"standalone"};
03474 
03475     \textcolor{comment}{/* Show the ASCII logo if: log file is stdout AND stdout is a}
03476 \textcolor{comment}{     * tty AND syslog logging is disabled. Also show logo if the user}
03477 \textcolor{comment}{     * forced us to do so via redis.conf. */}
03478     \textcolor{keywordtype}{int} show\_logo = ((!server.syslog\_enabled &&
03479                       server.logfile[0] == \textcolor{stringliteral}{'\(\backslash\)0'} &&
03480                       isatty(fileno(stdout))) ||
03481                      server.always\_show\_logo);
03482 
03483     \textcolor{keywordflow}{if} (!show\_logo) \{
03484         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
03485             \textcolor{stringliteral}{"Running mode=%s, port=%d."},
03486             mode, server.port
03487         );
03488     \} \textcolor{keywordflow}{else} \{
03489         snprintf(buf,1024*16,ascii\_logo,
03490             \hyperlink{version_8h_a357a0d302ef7fbb42bf2db0632b9f7fe}{REDIS\_VERSION},
03491             redisGitSHA1(),
03492             strtol(redisGitDirty(),NULL,10) > 0,
03493             (\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{long}) == 8) ? \textcolor{stringliteral}{"64"} : \textcolor{stringliteral}{"32"},
03494             mode, server.port,
03495             (\textcolor{keywordtype}{long}) getpid()
03496         );
03497         serverLogRaw(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE}|\hyperlink{server_8h_a6b3768a4d2dfb3ac580b8d999baa9350}{LL\_RAW},buf);
03498     \}
03499     zfree(buf);
03500 \}
03501 
03502 \textcolor{keyword}{static} \textcolor{keywordtype}{void} sigShutdownHandler(\textcolor{keywordtype}{int} sig) \{
03503     \textcolor{keywordtype}{char} *msg;
03504 
03505     \textcolor{keywordflow}{switch} (sig) \{
03506     \textcolor{keywordflow}{case} SIGINT:
03507         msg = \textcolor{stringliteral}{"Received SIGINT scheduling shutdown..."};
03508         \textcolor{keywordflow}{break};
03509     \textcolor{keywordflow}{case} SIGTERM:
03510         msg = \textcolor{stringliteral}{"Received SIGTERM scheduling shutdown..."};
03511         \textcolor{keywordflow}{break};
03512     \textcolor{keywordflow}{default}:
03513         msg = \textcolor{stringliteral}{"Received shutdown signal, scheduling shutdown..."};
03514     \};
03515 
03516     \textcolor{comment}{/* SIGINT is often delivered via Ctrl+C in an interactive session.}
03517 \textcolor{comment}{     * If we receive the signal the second time, we interpret this as}
03518 \textcolor{comment}{     * the user really wanting to quit ASAP without waiting to persist}
03519 \textcolor{comment}{     * on disk. */}
03520     \textcolor{keywordflow}{if} (server.shutdown\_asap && sig == SIGINT) \{
03521         serverLogFromHandler(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"You insist... exiting now."});
03522         rdbRemoveTempFile(getpid());
03523         exit(1); \textcolor{comment}{/* Exit with an error since this was not a clean shutdown. */}
03524     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.loading) \{
03525         exit(0);
03526     \}
03527 
03528     serverLogFromHandler(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, msg);
03529     server.shutdown\_asap = 1;
03530 \}
03531 
03532 \textcolor{keywordtype}{void} setupSignalHandlers(\textcolor{keywordtype}{void}) \{
03533     \textcolor{keyword}{struct} sigaction act;
03534 
03535     \textcolor{comment}{/* When the SA\_SIGINFO flag is set in sa\_flags then sa\_sigaction is used.}
03536 \textcolor{comment}{     * Otherwise, sa\_handler is used. */}
03537     sigemptyset(&act.sa\_mask);
03538     act.sa\_flags = 0;
03539     act.sa\_handler = sigShutdownHandler;
03540     sigaction(SIGTERM, &act, NULL);
03541     sigaction(SIGINT, &act, NULL);
03542 
03543 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} HAVE\_BACKTRACE
03544     sigemptyset(&act.sa\_mask);
03545     act.sa\_flags = SA\_NODEFER | SA\_RESETHAND | SA\_SIGINFO;
03546     act.sa\_sigaction = sigsegvHandler;
03547     sigaction(SIGSEGV, &act, NULL);
03548     sigaction(SIGBUS, &act, NULL);
03549     sigaction(SIGFPE, &act, NULL);
03550     sigaction(SIGILL, &act, NULL);
03551 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
03552     \textcolor{keywordflow}{return};
03553 \}
03554 
03555 \textcolor{keywordtype}{void} memtest(size\_t megabytes, \textcolor{keywordtype}{int} passes);
03556 
03557 \textcolor{comment}{/* Returns 1 if there is --sentinel among the arguments or if}
03558 \textcolor{comment}{ * argv[0] contains "redis-sentinel". */}
03559 \textcolor{keywordtype}{int} checkForSentinelMode(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
03560     \textcolor{keywordtype}{int} j;
03561 
03562     \textcolor{keywordflow}{if} (strstr(argv[0],\textcolor{stringliteral}{"redis-sentinel"}) != NULL) \textcolor{keywordflow}{return} 1;
03563     \textcolor{keywordflow}{for} (j = 1; j < argc; j++)
03564         \textcolor{keywordflow}{if} (!strcmp(argv[j],\textcolor{stringliteral}{"--sentinel"})) \textcolor{keywordflow}{return} 1;
03565     \textcolor{keywordflow}{return} 0;
03566 \}
03567 
03568 \textcolor{comment}{/* Function called at startup to load RDB or AOF file in memory. */}
03569 \textcolor{keywordtype}{void} loadDataFromDisk(\textcolor{keywordtype}{void}) \{
03570     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} start = ustime();
03571     \textcolor{keywordflow}{if} (server.aof\_state == \hyperlink{server_8h_af6b151c9dced28e94c19479197113a83}{AOF\_ON}) \{
03572         \textcolor{keywordflow}{if} (loadAppendOnlyFile(server.aof\_filename) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
03573             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"DB loaded from append only file: %.3f seconds"},(\textcolor{keywordtype}{float})(
      ustime()-start)/1000000);
03574     \} \textcolor{keywordflow}{else} \{
03575         rdbSaveInfo rsi = \hyperlink{server_8h_a694b5ed5268bee8c50cc5b38fbec99ce}{RDB\_SAVE\_INFO\_INIT};
03576         \textcolor{keywordflow}{if} (rdbLoad(server.rdb\_filename,&rsi) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
03577             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"DB loaded from disk: %.3f seconds"},
03578                 (\textcolor{keywordtype}{float})(ustime()-start)/1000000);
03579 
03580             \textcolor{comment}{/* Restore the replication ID / offset from the RDB file. */}
03581             \textcolor{keywordflow}{if} (server.masterhost &&
03582                 rsi.repl\_id\_is\_set &&
03583                 rsi.repl\_offset != -1 &&
03584                 \textcolor{comment}{/* Note that older implementations may save a repl\_stream\_db}
03585 \textcolor{comment}{                 * of -1 inside the RDB file in a wrong way, see more information}
03586 \textcolor{comment}{                 * in function rdbPopulateSaveInfo. */}
03587                 rsi.repl\_stream\_db != -1)
03588             \{
03589                 memcpy(server.replid,rsi.repl\_id,\textcolor{keyword}{sizeof}(server.replid));
03590                 server.master\_repl\_offset = rsi.repl\_offset;
03591                 \textcolor{comment}{/* If we are a slave, create a cached master from this}
03592 \textcolor{comment}{                 * information, in order to allow partial resynchronizations}
03593 \textcolor{comment}{                 * with masters. */}
03594                 replicationCacheMasterUsingMyself();
03595                 selectDb(server.cached\_master,rsi.repl\_stream\_db);
03596             \}
03597         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (errno != ENOENT) \{
03598             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Fatal error loading the DB: %s. Exiting."},strerror(errno))
      ;
03599             exit(1);
03600         \}
03601     \}
03602 \}
03603 
03604 \textcolor{keywordtype}{void} redisOutOfMemoryHandler(size\_t allocation\_size) \{
03605     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Out Of Memory allocating %zu bytes!"},
03606         allocation\_size);
03607     \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Redis aborting for OUT OF MEMORY"});
03608 \}
03609 
03610 \textcolor{keywordtype}{void} redisSetProcTitle(\textcolor{keywordtype}{char} *title) \{
03611 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} USE\_SETPROCTITLE
03612     \textcolor{keywordtype}{char} *server\_mode = \textcolor{stringliteral}{""};
03613     \textcolor{keywordflow}{if} (server.cluster\_enabled) server\_mode = \textcolor{stringliteral}{" [cluster]"};
03614     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.sentinel\_mode) server\_mode = \textcolor{stringliteral}{" [sentinel]"};
03615 
03616     setproctitle(\textcolor{stringliteral}{"%s %s:%d%s"},
03617         title,
03618         server.bindaddr\_count ? server.bindaddr[0] : \textcolor{stringliteral}{"*"},
03619         server.port,
03620         server\_mode);
03621 \textcolor{preprocessor}{#}\textcolor{preprocessor}{else}
03622     UNUSED(title);
03623 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
03624 \}
03625 
03626 \textcolor{comment}{/*}
03627 \textcolor{comment}{ * Check whether systemd or upstart have been used to start redis.}
03628 \textcolor{comment}{ */}
03629 
03630 \textcolor{keywordtype}{int} redisSupervisedUpstart(\textcolor{keywordtype}{void}) \{
03631     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *upstart\_job = getenv(\textcolor{stringliteral}{"UPSTART\_JOB"});
03632 
03633     \textcolor{keywordflow}{if} (!upstart\_job) \{
03634         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
03635                 \textcolor{stringliteral}{"upstart supervision requested, but UPSTART\_JOB not found"});
03636         \textcolor{keywordflow}{return} 0;
03637     \}
03638 
03639     serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE}, \textcolor{stringliteral}{"supervised by upstart, will stop to signal readiness"});
03640     raise(SIGSTOP);
03641     unsetenv(\textcolor{stringliteral}{"UPSTART\_JOB"});
03642     \textcolor{keywordflow}{return} 1;
03643 \}
03644 
03645 \textcolor{keywordtype}{int} redisSupervisedSystemd(\textcolor{keywordtype}{void}) \{
03646     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *notify\_socket = getenv(\textcolor{stringliteral}{"NOTIFY\_SOCKET"});
03647     \textcolor{keywordtype}{int} fd = 1;
03648     \textcolor{keyword}{struct} sockaddr\_un su;
03649     \textcolor{keyword}{struct} iovec iov;
03650     \textcolor{keyword}{struct} msghdr hdr;
03651     \textcolor{keywordtype}{int} sendto\_flags = 0;
03652 
03653     \textcolor{keywordflow}{if} (!notify\_socket) \{
03654         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
03655                 \textcolor{stringliteral}{"systemd supervision requested, but NOTIFY\_SOCKET not found"});
03656         \textcolor{keywordflow}{return} 0;
03657     \}
03658 
03659     \textcolor{keywordflow}{if} ((strchr(\textcolor{stringliteral}{"@/"}, notify\_socket[0])) == NULL || strlen(notify\_socket) < 2) \{
03660         \textcolor{keywordflow}{return} 0;
03661     \}
03662 
03663     serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE}, \textcolor{stringliteral}{"supervised by systemd, will signal readiness"});
03664     \textcolor{keywordflow}{if} ((fd = socket(AF\_UNIX, SOCK\_DGRAM, 0)) == -1) \{
03665         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
03666                 \textcolor{stringliteral}{"Can't connect to systemd socket %s"}, notify\_socket);
03667         \textcolor{keywordflow}{return} 0;
03668     \}
03669 
03670     memset(&su, 0, \textcolor{keyword}{sizeof}(su));
03671     su.sun\_family = AF\_UNIX;
03672     strncpy (su.sun\_path, notify\_socket, \textcolor{keyword}{sizeof}(su.sun\_path) -1);
03673     su.sun\_path[\textcolor{keyword}{sizeof}(su.sun\_path) - 1] = \textcolor{stringliteral}{'\(\backslash\)0'};
03674 
03675     \textcolor{keywordflow}{if} (notify\_socket[0] == \textcolor{stringliteral}{'@'})
03676         su.sun\_path[0] = \textcolor{stringliteral}{'\(\backslash\)0'};
03677 
03678     memset(&iov, 0, \textcolor{keyword}{sizeof}(iov));
03679     iov.iov\_base = \textcolor{stringliteral}{"READY=1"};
03680     iov.iov\_len = strlen(\textcolor{stringliteral}{"READY=1"});
03681 
03682     memset(&hdr, 0, \textcolor{keyword}{sizeof}(hdr));
03683     hdr.msg\_name = &su;
03684     hdr.msg\_namelen = offsetof(\textcolor{keyword}{struct} sockaddr\_un, sun\_path) +
03685         strlen(notify\_socket);
03686     hdr.msg\_iov = &iov;
03687     hdr.msg\_iovlen = 1;
03688 
03689     unsetenv(\textcolor{stringliteral}{"NOTIFY\_SOCKET"});
03690 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} HAVE\_MSG\_NOSIGNAL
03691     sendto\_flags |= MSG\_NOSIGNAL;
03692 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
03693     \textcolor{keywordflow}{if} (sendmsg(fd, &hdr, sendto\_flags) < 0) \{
03694         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"Can't send notification to systemd"});
03695         close(fd);
03696         \textcolor{keywordflow}{return} 0;
03697     \}
03698     close(fd);
03699     \textcolor{keywordflow}{return} 1;
03700 \}
03701 
03702 \textcolor{keywordtype}{int} redisIsSupervised(\textcolor{keywordtype}{int} mode) \{
03703     \textcolor{keywordflow}{if} (mode == \hyperlink{server_8h_a7b2b1d1fd04a4f2c1a141e0976dd479b}{SUPERVISED\_AUTODETECT}) \{
03704         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *upstart\_job = getenv(\textcolor{stringliteral}{"UPSTART\_JOB"});
03705         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *notify\_socket = getenv(\textcolor{stringliteral}{"NOTIFY\_SOCKET"});
03706 
03707         \textcolor{keywordflow}{if} (upstart\_job) \{
03708             redisSupervisedUpstart();
03709         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (notify\_socket) \{
03710             redisSupervisedSystemd();
03711         \}
03712     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (mode == \hyperlink{server_8h_ae34bdafb8c6d3cc58fc6b319e623b604}{SUPERVISED\_UPSTART}) \{
03713         \textcolor{keywordflow}{return} redisSupervisedUpstart();
03714     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (mode == \hyperlink{server_8h_aea7b4966d78f67f5ab89f38f0e1bde74}{SUPERVISED\_SYSTEMD}) \{
03715         \textcolor{keywordflow}{return} redisSupervisedSystemd();
03716     \}
03717 
03718     \textcolor{keywordflow}{return} 0;
03719 \}
03720 
03721 
03722 \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv) \{
03723     \textcolor{keyword}{struct} timeval tv;
03724     \textcolor{keywordtype}{int} j;
03725 
03726 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \textcolor{preprocessor}{REDIS\_TEST}
03727     \textcolor{keywordflow}{if} (argc == 3 && !strcasecmp(argv[1], \textcolor{stringliteral}{"test"})) \{
03728         \textcolor{keywordflow}{if} (!strcasecmp(argv[2], \textcolor{stringliteral}{"ziplist"})) \{
03729             \textcolor{keywordflow}{return} ziplistTest(argc, argv);
03730         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(argv[2], \textcolor{stringliteral}{"quicklist"})) \{
03731             quicklistTest(argc, argv);
03732         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(argv[2], \textcolor{stringliteral}{"intset"})) \{
03733             \textcolor{keywordflow}{return} intsetTest(argc, argv);
03734         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(argv[2], \textcolor{stringliteral}{"zipmap"})) \{
03735             \textcolor{keywordflow}{return} zipmapTest(argc, argv);
03736         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(argv[2], \textcolor{stringliteral}{"sha1test"})) \{
03737             \textcolor{keywordflow}{return} sha1Test(argc, argv);
03738         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(argv[2], \textcolor{stringliteral}{"util"})) \{
03739             \textcolor{keywordflow}{return} utilTest(argc, argv);
03740         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(argv[2], \textcolor{stringliteral}{"sds"})) \{
03741             \textcolor{keywordflow}{return} sdsTest(argc, argv);
03742         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(argv[2], \textcolor{stringliteral}{"endianconv"})) \{
03743             \textcolor{keywordflow}{return} endianconvTest(argc, argv);
03744         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(argv[2], \textcolor{stringliteral}{"crc64"})) \{
03745             \textcolor{keywordflow}{return} crc64Test(argc, argv);
03746         \}
03747 
03748         \textcolor{keywordflow}{return} -1; \textcolor{comment}{/* test not found */}
03749     \}
03750 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
03751 
03752     \textcolor{comment}{/* We need to initialize our libraries, and the server configuration. */}
03753 \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} INIT\_SETPROCTITLE\_REPLACEMENT
03754     spt\_init(argc, argv);
03755 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
03756     setlocale(LC\_COLLATE,\textcolor{stringliteral}{""});
03757     zmalloc\_set\_oom\_handler(redisOutOfMemoryHandler);
03758     srand(time(NULL)^getpid());
03759     gettimeofday(&tv,NULL);
03760     \textcolor{keywordtype}{char} hashseed[16];
03761     getRandomHexChars(hashseed,\textcolor{keyword}{sizeof}(hashseed));
03762     dictSetHashFunctionSeed((uint8\_t*)hashseed);
03763     server.sentinel\_mode = checkForSentinelMode(argc,argv);
03764     initServerConfig();
03765     moduleInitModulesSystem();
03766 
03767     \textcolor{comment}{/* Store the executable path and arguments in a safe place in order}
03768 \textcolor{comment}{     * to be able to restart the server later. */}
03769     server.executable = getAbsolutePath(argv[0]);
03770     server.exec\_argv = zmalloc(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char}*)*(argc+1));
03771     server.exec\_argv[argc] = NULL;
03772     \textcolor{keywordflow}{for} (j = 0; j < argc; j++) server.exec\_argv[j] = zstrdup(argv[j]);
03773 
03774     \textcolor{comment}{/* We need to init sentinel right now as parsing the configuration file}
03775 \textcolor{comment}{     * in sentinel mode will have the effect of populating the sentinel}
03776 \textcolor{comment}{     * data structures with master nodes to monitor. */}
03777     \textcolor{keywordflow}{if} (server.sentinel\_mode) \{
03778         initSentinelConfig();
03779         initSentinel();
03780     \}
03781 
03782     \textcolor{comment}{/* Check if we need to start in redis-check-rdb/aof mode. We just execute}
03783 \textcolor{comment}{     * the program main. However the program is part of the Redis executable}
03784 \textcolor{comment}{     * so that we can easily execute an RDB check on loading errors. */}
03785     \textcolor{keywordflow}{if} (strstr(argv[0],\textcolor{stringliteral}{"redis-check-rdb"}) != NULL)
03786         redis\_check\_rdb\_main(argc,argv,NULL);
03787     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (strstr(argv[0],\textcolor{stringliteral}{"redis-check-aof"}) != NULL)
03788         redis\_check\_aof\_main(argc,argv);
03789 
03790     \textcolor{keywordflow}{if} (argc >= 2) \{
03791         j = 1; \textcolor{comment}{/* First option to parse in argv[] */}
03792         sds options = sdsempty();
03793         \textcolor{keywordtype}{char} *configfile = NULL;
03794 
03795         \textcolor{comment}{/* Handle special options --help and --version */}
03796         \textcolor{keywordflow}{if} (strcmp(argv[1], \textcolor{stringliteral}{"-v"}) == 0 ||
03797             strcmp(argv[1], \textcolor{stringliteral}{"--version"}) == 0) version();
03798         \textcolor{keywordflow}{if} (strcmp(argv[1], \textcolor{stringliteral}{"--help"}) == 0 ||
03799             strcmp(argv[1], \textcolor{stringliteral}{"-h"}) == 0) usage();
03800         \textcolor{keywordflow}{if} (strcmp(argv[1], \textcolor{stringliteral}{"--test-memory"}) == 0) \{
03801             \textcolor{keywordflow}{if} (argc == 3) \{
03802                 memtest(atoi(argv[2]),50);
03803                 exit(0);
03804             \} \textcolor{keywordflow}{else} \{
03805                 fprintf(stderr,\textcolor{stringliteral}{"Please specify the amount of memory to test in megabytes.\(\backslash\)n"});
03806                 fprintf(stderr,\textcolor{stringliteral}{"Example: ./redis-server --test-memory 4096\(\backslash\)n\(\backslash\)n"});
03807                 exit(1);
03808             \}
03809         \}
03810 
03811         \textcolor{comment}{/* First argument is the config file name? */}
03812         \textcolor{keywordflow}{if} (argv[j][0] != \textcolor{stringliteral}{'-'} || argv[j][1] != \textcolor{stringliteral}{'-'}) \{
03813             configfile = argv[j];
03814             server.configfile = getAbsolutePath(configfile);
03815             \textcolor{comment}{/* Replace the config file in server.exec\_argv with}
03816 \textcolor{comment}{             * its absoulte path. */}
03817             zfree(server.exec\_argv[j]);
03818             server.exec\_argv[j] = zstrdup(server.configfile);
03819             j++;
03820         \}
03821 
03822         \textcolor{comment}{/* All the other options are parsed and conceptually appended to the}
03823 \textcolor{comment}{         * configuration file. For instance --port 6380 will generate the}
03824 \textcolor{comment}{         * string "port 6380\(\backslash\)n" to be parsed after the actual file name}
03825 \textcolor{comment}{         * is parsed, if any. */}
03826         \textcolor{keywordflow}{while}(j != argc) \{
03827             \textcolor{keywordflow}{if} (argv[j][0] == \textcolor{stringliteral}{'-'} && argv[j][1] == \textcolor{stringliteral}{'-'}) \{
03828                 \textcolor{comment}{/* Option name */}
03829                 \textcolor{keywordflow}{if} (!strcmp(argv[j], \textcolor{stringliteral}{"--check-rdb"})) \{
03830                     \textcolor{comment}{/* Argument has no options, need to skip for parsing. */}
03831                     j++;
03832                     \textcolor{keywordflow}{continue};
03833                 \}
03834                 \textcolor{keywordflow}{if} (sdslen(options)) options = sdscat(options,\textcolor{stringliteral}{"\(\backslash\)n"});
03835                 options = sdscat(options,argv[j]+2);
03836                 options = sdscat(options,\textcolor{stringliteral}{" "});
03837             \} \textcolor{keywordflow}{else} \{
03838                 \textcolor{comment}{/* Option argument */}
03839                 options = sdscatrepr(options,argv[j],strlen(argv[j]));
03840                 options = sdscat(options,\textcolor{stringliteral}{" "});
03841             \}
03842             j++;
03843         \}
03844         \textcolor{keywordflow}{if} (server.sentinel\_mode && configfile && *configfile == \textcolor{stringliteral}{'-'}) \{
03845             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
03846                 \textcolor{stringliteral}{"Sentinel config from STDIN not allowed."});
03847             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
03848                 \textcolor{stringliteral}{"Sentinel needs config file on disk to save state.  Exiting..."});
03849             exit(1);
03850         \}
03851         resetServerSaveParams();
03852         loadServerConfig(configfile,options);
03853         sdsfree(options);
03854     \}
03855 
03856     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo"});
03857     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
03858         \textcolor{stringliteral}{"Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started"},
03859             \hyperlink{version_8h_a357a0d302ef7fbb42bf2db0632b9f7fe}{REDIS\_VERSION},
03860             (\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{long}) == 8) ? 64 : 32,
03861             redisGitSHA1(),
03862             strtol(redisGitDirty(),NULL,10) > 0,
03863             (\textcolor{keywordtype}{int})getpid());
03864 
03865     \textcolor{keywordflow}{if} (argc == 1) \{
03866         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"Warning: no config file specified, using the default config.
       In order to specify a config file use %s /path/to/%s.conf"}, argv[0], server.sentinel\_mode ? \textcolor{stringliteral}{"sentinel"} : \textcolor{stringliteral}{
      "redis"});
03867     \} \textcolor{keywordflow}{else} \{
03868         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"Configuration loaded"});
03869     \}
03870 
03871     server.supervised = redisIsSupervised(server.supervised\_mode);
03872     \textcolor{keywordtype}{int} background = server.daemonize && !server.supervised;
03873     \textcolor{keywordflow}{if} (background) daemonize();
03874 
03875     initServer();
03876     \textcolor{keywordflow}{if} (background || server.pidfile) createPidFile();
03877     redisSetProcTitle(argv[0]);
03878     redisAsciiArt();
03879     checkTcpBacklogSettings();
03880 
03881     \textcolor{keywordflow}{if} (!server.sentinel\_mode) \{
03882         \textcolor{comment}{/* Things not needed when running in Sentinel mode. */}
03883         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Server initialized"});
03884     \textcolor{preprocessor}{#}\textcolor{preprocessor}{ifdef} \_\_linux\_\_
03885         linuxMemoryWarnings();
03886     \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
03887         moduleLoadFromQueue();
03888         loadDataFromDisk();
03889         \textcolor{keywordflow}{if} (server.cluster\_enabled) \{
03890             \textcolor{keywordflow}{if} (verifyClusterConfigWithData() == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
03891                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
03892                     \textcolor{stringliteral}{"You can't have keys in a DB different than DB 0 when in "}
03893                     \textcolor{stringliteral}{"Cluster mode. Exiting."});
03894                 exit(1);
03895             \}
03896         \}
03897         \textcolor{keywordflow}{if} (server.ipfd\_count > 0)
03898             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Ready to accept connections"});
03899         \textcolor{keywordflow}{if} (server.sofd > 0)
03900             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"The server is now ready to accept connections at %s"}, server
      .unixsocket);
03901     \} \textcolor{keywordflow}{else} \{
03902         sentinelIsRunning();
03903     \}
03904 
03905     \textcolor{comment}{/* Warning the user about suspicious maxmemory setting. */}
03906     \textcolor{keywordflow}{if} (server.maxmemory > 0 && server.maxmemory < 1024*1024) \{
03907         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"WARNING: You specified a maxmemory value that is less than 1MB
       (current value is %llu bytes). Are you sure this is what you really want?"}, server.maxmemory);
03908     \}
03909 
03910     aeSetBeforeSleepProc(server.el,beforeSleep);
03911     aeSetAfterSleepProc(server.el,afterSleep);
03912     aeMain(server.el);
03913     aeDeleteEventLoop(server.el);
03914     \textcolor{keywordflow}{return} 0;
03915 \}
03916 
03917 \textcolor{comment}{/* The End */}
\end{DoxyCode}
