\hypertarget{multi_8c_source}{}\section{multi.\+c}
\label{multi_8c_source}\index{src/multi.\+c@{src/multi.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>}
00003 \textcolor{comment}{ * All rights reserved.}
00004 \textcolor{comment}{ *}
00005 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00006 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00007 \textcolor{comment}{ *}
00008 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00009 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00010 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00011 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00012 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00013 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00014 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00015 \textcolor{comment}{ *     specific prior written permission.}
00016 \textcolor{comment}{ *}
00017 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00018 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00019 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00020 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00021 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00022 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00023 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00024 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00025 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00026 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00027 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00028 \textcolor{comment}{ */}
00029 
00030 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{server_8h}{"server.h"}
00031 
00032 \textcolor{comment}{/* ================================ MULTI/EXEC ============================== */}
00033 
00034 \textcolor{comment}{/* Client state initialization for MULTI/EXEC */}
00035 \textcolor{keywordtype}{void} initClientMultiState(\hyperlink{structclient}{client} *c) \{
00036     c->mstate.commands = NULL;
00037     c->mstate.count = 0;
00038 \}
00039 
00040 \textcolor{comment}{/* Release all the resources associated with MULTI/EXEC state */}
00041 \textcolor{keywordtype}{void} freeClientMultiState(\hyperlink{structclient}{client} *c) \{
00042     \textcolor{keywordtype}{int} j;
00043 
00044     \textcolor{keywordflow}{for} (j = 0; j < c->mstate.count; j++) \{
00045         \textcolor{keywordtype}{int} i;
00046         multiCmd *mc = c->mstate.commands+j;
00047 
00048         \textcolor{keywordflow}{for} (i = 0; i < mc->argc; i++)
00049             decrRefCount(mc->argv[i]);
00050         zfree(mc->argv);
00051     \}
00052     zfree(c->mstate.commands);
00053 \}
00054 
00055 \textcolor{comment}{/* Add a new command into the MULTI commands queue */}
00056 \textcolor{keywordtype}{void} queueMultiCommand(\hyperlink{structclient}{client} *c) \{
00057     multiCmd *mc;
00058     \textcolor{keywordtype}{int} j;
00059 
00060     c->mstate.commands = zrealloc(c->mstate.commands,
00061             \textcolor{keyword}{sizeof}(multiCmd)*(c->mstate.count+1));
00062     mc = c->mstate.commands+c->mstate.count;
00063     mc->cmd = c->cmd;
00064     mc->argc = c->argc;
00065     mc->argv = zmalloc(\textcolor{keyword}{sizeof}(robj*)*c->argc);
00066     memcpy(mc->argv,c->argv,\textcolor{keyword}{sizeof}(robj*)*c->argc);
00067     \textcolor{keywordflow}{for} (j = 0; j < c->argc; j++)
00068         incrRefCount(mc->argv[j]);
00069     c->mstate.count++;
00070 \}
00071 
00072 \textcolor{keywordtype}{void} discardTransaction(\hyperlink{structclient}{client} *c) \{
00073     freeClientMultiState(c);
00074     initClientMultiState(c);
00075     c->flags &= ~(\hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI}|\hyperlink{server_8h_a0f4df645d72b6b3e9a0d07afbe502a51}{CLIENT\_DIRTY\_CAS}|
      \hyperlink{server_8h_a7c203dc3aba692e212393d08530bdb97}{CLIENT\_DIRTY\_EXEC});
00076     unwatchAllKeys(c);
00077 \}
00078 
00079 \textcolor{comment}{/* Flag the transacation as DIRTY\_EXEC so that EXEC will fail.}
00080 \textcolor{comment}{ * Should be called every time there is an error while queueing a command. */}
00081 \textcolor{keywordtype}{void} flagTransaction(\hyperlink{structclient}{client} *c) \{
00082     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI})
00083         c->flags |= \hyperlink{server_8h_a7c203dc3aba692e212393d08530bdb97}{CLIENT\_DIRTY\_EXEC};
00084 \}
00085 
00086 \textcolor{keywordtype}{void} multiCommand(\hyperlink{structclient}{client} *c) \{
00087     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI}) \{
00088         addReplyError(c,\textcolor{stringliteral}{"MULTI calls can not be nested"});
00089         \textcolor{keywordflow}{return};
00090     \}
00091     c->flags |= \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI};
00092     addReply(c,shared.ok);
00093 \}
00094 
00095 \textcolor{keywordtype}{void} discardCommand(\hyperlink{structclient}{client} *c) \{
00096     \textcolor{keywordflow}{if} (!(c->flags & \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI})) \{
00097         addReplyError(c,\textcolor{stringliteral}{"DISCARD without MULTI"});
00098         \textcolor{keywordflow}{return};
00099     \}
00100     discardTransaction(c);
00101     addReply(c,shared.ok);
00102 \}
00103 
00104 \textcolor{comment}{/* Send a MULTI command to all the slaves and AOF file. Check the execCommand}
00105 \textcolor{comment}{ * implementation for more information. */}
00106 \textcolor{keywordtype}{void} execCommandPropagateMulti(\hyperlink{structclient}{client} *c) \{
00107     robj *multistring = createStringObject(\textcolor{stringliteral}{"MULTI"},5);
00108 
00109     propagate(server.multiCommand,c->db->id,&multistring,1,
00110               \hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF}|\hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL});
00111     decrRefCount(multistring);
00112 \}
00113 
00114 \textcolor{keywordtype}{void} execCommand(\hyperlink{structclient}{client} *c) \{
00115     \textcolor{keywordtype}{int} j;
00116     robj **orig\_argv;
00117     \textcolor{keywordtype}{int} orig\_argc;
00118     \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *orig\_cmd;
00119     \textcolor{keywordtype}{int} must\_propagate = 0; \textcolor{comment}{/* Need to propagate MULTI/EXEC to AOF / slaves? */}
00120     \textcolor{keywordtype}{int} was\_master = server.masterhost == NULL;
00121 
00122     \textcolor{keywordflow}{if} (!(c->flags & \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI})) \{
00123         addReplyError(c,\textcolor{stringliteral}{"EXEC without MULTI"});
00124         \textcolor{keywordflow}{return};
00125     \}
00126 
00127     \textcolor{comment}{/* Check if we need to abort the EXEC because:}
00128 \textcolor{comment}{     * 1) Some WATCHed key was touched.}
00129 \textcolor{comment}{     * 2) There was a previous error while queueing commands.}
00130 \textcolor{comment}{     * A failed EXEC in the first case returns a multi bulk nil object}
00131 \textcolor{comment}{     * (technically it is not an error but a special behavior), while}
00132 \textcolor{comment}{     * in the second an EXECABORT error is returned. */}
00133     \textcolor{keywordflow}{if} (c->flags & (\hyperlink{server_8h_a0f4df645d72b6b3e9a0d07afbe502a51}{CLIENT\_DIRTY\_CAS}|\hyperlink{server_8h_a7c203dc3aba692e212393d08530bdb97}{CLIENT\_DIRTY\_EXEC})) \{
00134         addReply(c, c->flags & \hyperlink{server_8h_a7c203dc3aba692e212393d08530bdb97}{CLIENT\_DIRTY\_EXEC} ? shared.execaborterr :
00135                                                   shared.nullmultibulk);
00136         discardTransaction(c);
00137         \textcolor{keywordflow}{goto} handle\_monitor;
00138     \}
00139 
00140     \textcolor{comment}{/* Exec all the queued commands */}
00141     unwatchAllKeys(c); \textcolor{comment}{/* Unwatch ASAP otherwise we'll waste CPU cycles */}
00142     orig\_argv = c->argv;
00143     orig\_argc = c->argc;
00144     orig\_cmd = c->cmd;
00145     addReplyMultiBulkLen(c,c->mstate.count);
00146     \textcolor{keywordflow}{for} (j = 0; j < c->mstate.count; j++) \{
00147         c->argc = c->mstate.commands[j].argc;
00148         c->argv = c->mstate.commands[j].argv;
00149         c->cmd = c->mstate.commands[j].cmd;
00150 
00151         \textcolor{comment}{/* Propagate a MULTI request once we encounter the first command which}
00152 \textcolor{comment}{         * is not readonly nor an administrative one.}
00153 \textcolor{comment}{         * This way we'll deliver the MULTI/..../EXEC block as a whole and}
00154 \textcolor{comment}{         * both the AOF and the replication link will have the same consistency}
00155 \textcolor{comment}{         * and atomicity guarantees. */}
00156         \textcolor{keywordflow}{if} (!must\_propagate && !(c->cmd->flags & (\hyperlink{server_8h_a7e9c728f228e1c82ae1e22173375abcf}{CMD\_READONLY}|
      \hyperlink{server_8h_a1917805ea3942a4784ec806c33bc6033}{CMD\_ADMIN}))) \{
00157             execCommandPropagateMulti(c);
00158             must\_propagate = 1;
00159         \}
00160 
00161         call(c,\hyperlink{server_8h_a7e92e38a9fe5f713cace24d63184273e}{CMD\_CALL\_FULL});
00162 
00163         \textcolor{comment}{/* Commands may alter argc/argv, restore mstate. */}
00164         c->mstate.commands[j].argc = c->argc;
00165         c->mstate.commands[j].argv = c->argv;
00166         c->mstate.commands[j].cmd = c->cmd;
00167     \}
00168     c->argv = orig\_argv;
00169     c->argc = orig\_argc;
00170     c->cmd = orig\_cmd;
00171     discardTransaction(c);
00172 
00173     \textcolor{comment}{/* Make sure the EXEC command will be propagated as well if MULTI}
00174 \textcolor{comment}{     * was already propagated. */}
00175     \textcolor{keywordflow}{if} (must\_propagate) \{
00176         \textcolor{keywordtype}{int} is\_master = server.masterhost == NULL;
00177         server.dirty++;
00178         \textcolor{comment}{/* If inside the MULTI/EXEC block this instance was suddenly}
00179 \textcolor{comment}{         * switched from master to slave (using the SLAVEOF command), the}
00180 \textcolor{comment}{         * initial MULTI was propagated into the replication backlog, but the}
00181 \textcolor{comment}{         * rest was not. We need to make sure to at least terminate the}
00182 \textcolor{comment}{         * backlog with the final EXEC. */}
00183         \textcolor{keywordflow}{if} (server.repl\_backlog && was\_master && !is\_master) \{
00184             \textcolor{keywordtype}{char} *execcmd = \textcolor{stringliteral}{"*1\(\backslash\)r\(\backslash\)n$4\(\backslash\)r\(\backslash\)nEXEC\(\backslash\)r\(\backslash\)n"};
00185             feedReplicationBacklog(execcmd,strlen(execcmd));
00186         \}
00187     \}
00188 
00189 handle\_monitor:
00190     \textcolor{comment}{/* Send EXEC to clients waiting data from MONITOR. We do it here}
00191 \textcolor{comment}{     * since the natural order of commands execution is actually:}
00192 \textcolor{comment}{     * MUTLI, EXEC, ... commands inside transaction ...}
00193 \textcolor{comment}{     * Instead EXEC is flagged as CMD\_SKIP\_MONITOR in the command}
00194 \textcolor{comment}{     * table, and we do it here with correct ordering. */}
00195     \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.monitors) && !server.loading)
00196         replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);
00197 \}
00198 
00199 \textcolor{comment}{/* ===================== WATCH (CAS alike for MULTI/EXEC) ===================}
00200 \textcolor{comment}{ *}
00201 \textcolor{comment}{ * The implementation uses a per-DB hash table mapping keys to list of clients}
00202 \textcolor{comment}{ * WATCHing those keys, so that given a key that is going to be modified}
00203 \textcolor{comment}{ * we can mark all the associated clients as dirty.}
00204 \textcolor{comment}{ *}
00205 \textcolor{comment}{ * Also every client contains a list of WATCHed keys so that's possible to}
00206 \textcolor{comment}{ * un-watch such keys when the client is freed or when UNWATCH is called. */}
00207 
00208 \textcolor{comment}{/* In the client->watched\_keys list we need to use watchedKey structures}
00209 \textcolor{comment}{ * as in order to identify a key in Redis we need both the key name and the}
00210 \textcolor{comment}{ * DB */}
\Hypertarget{multi_8c_source_l00211}\hyperlink{structwatchedKey}{00211} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structwatchedKey}{watchedKey} \{
00212     robj *key;
00213     redisDb *db;
00214 \} watchedKey;
00215 
00216 \textcolor{comment}{/* Watch for the specified key */}
00217 \textcolor{keywordtype}{void} watchForKey(\hyperlink{structclient}{client} *c, robj *key) \{
00218     list *clients = NULL;
00219     listIter li;
00220     listNode *ln;
00221     watchedKey *wk;
00222 
00223     \textcolor{comment}{/* Check if we are already watching for this key */}
00224     listRewind(c->watched\_keys,&li);
00225     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
00226         wk = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
00227         \textcolor{keywordflow}{if} (wk->db == c->db && equalStringObjects(key,wk->key))
00228             \textcolor{keywordflow}{return}; \textcolor{comment}{/* Key already watched */}
00229     \}
00230     \textcolor{comment}{/* This key is not already watched in this DB. Let's add it */}
00231     clients = dictFetchValue(c->db->watched\_keys,key);
00232     \textcolor{keywordflow}{if} (!clients) \{
00233         clients = listCreate();
00234         dictAdd(c->db->watched\_keys,key,clients);
00235         incrRefCount(key);
00236     \}
00237     listAddNodeTail(clients,c);
00238     \textcolor{comment}{/* Add the new key to the list of keys watched by this client */}
00239     wk = zmalloc(\textcolor{keyword}{sizeof}(*wk));
00240     wk->key = key;
00241     wk->db = c->db;
00242     incrRefCount(key);
00243     listAddNodeTail(c->watched\_keys,wk);
00244 \}
00245 
00246 \textcolor{comment}{/* Unwatch all the keys watched by this client. To clean the EXEC dirty}
00247 \textcolor{comment}{ * flag is up to the caller. */}
00248 \textcolor{keywordtype}{void} unwatchAllKeys(\hyperlink{structclient}{client} *c) \{
00249     listIter li;
00250     listNode *ln;
00251 
00252     \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(c->watched\_keys) == 0) \textcolor{keywordflow}{return};
00253     listRewind(c->watched\_keys,&li);
00254     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
00255         list *clients;
00256         watchedKey *wk;
00257 
00258         \textcolor{comment}{/* Lookup the watched key -> clients list and remove the client}
00259 \textcolor{comment}{         * from the list */}
00260         wk = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
00261         clients = dictFetchValue(wk->db->watched\_keys, wk->key);
00262         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,clients != NULL);
00263         listDelNode(clients,listSearchKey(clients,c));
00264         \textcolor{comment}{/* Kill the entry at all if this was the only client */}
00265         \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(clients) == 0)
00266             dictDelete(wk->db->watched\_keys, wk->key);
00267         \textcolor{comment}{/* Remove this watched key from the client->watched list */}
00268         listDelNode(c->watched\_keys,ln);
00269         decrRefCount(wk->key);
00270         zfree(wk);
00271     \}
00272 \}
00273 
00274 \textcolor{comment}{/* "Touch" a key, so that if this key is being WATCHed by some client the}
00275 \textcolor{comment}{ * next EXEC will fail. */}
00276 \textcolor{keywordtype}{void} touchWatchedKey(redisDb *db, robj *key) \{
00277     list *clients;
00278     listIter li;
00279     listNode *ln;
00280 
00281     \textcolor{keywordflow}{if} (\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(db->watched\_keys) == 0) \textcolor{keywordflow}{return};
00282     clients = dictFetchValue(db->watched\_keys, key);
00283     \textcolor{keywordflow}{if} (!clients) \textcolor{keywordflow}{return};
00284 
00285     \textcolor{comment}{/* Mark all the clients watching this key as CLIENT\_DIRTY\_CAS */}
00286     \textcolor{comment}{/* Check if we are already watching for this key */}
00287     listRewind(clients,&li);
00288     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
00289         \hyperlink{structclient}{client} *c = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
00290 
00291         c->flags |= \hyperlink{server_8h_a0f4df645d72b6b3e9a0d07afbe502a51}{CLIENT\_DIRTY\_CAS};
00292     \}
00293 \}
00294 
00295 \textcolor{comment}{/* On FLUSHDB or FLUSHALL all the watched keys that are present before the}
00296 \textcolor{comment}{ * flush but will be deleted as effect of the flushing operation should}
00297 \textcolor{comment}{ * be touched. "dbid" is the DB that's getting the flush. -1 if it is}
00298 \textcolor{comment}{ * a FLUSHALL operation (all the DBs flushed). */}
00299 \textcolor{keywordtype}{void} touchWatchedKeysOnFlush(\textcolor{keywordtype}{int} dbid) \{
00300     listIter li1, li2;
00301     listNode *ln;
00302 
00303     \textcolor{comment}{/* For every client, check all the waited keys */}
00304     listRewind(server.clients,&li1);
00305     \textcolor{keywordflow}{while}((ln = listNext(&li1))) \{
00306         \hyperlink{structclient}{client} *c = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
00307         listRewind(c->watched\_keys,&li2);
00308         \textcolor{keywordflow}{while}((ln = listNext(&li2))) \{
00309             watchedKey *wk = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(ln);
00310 
00311             \textcolor{comment}{/* For every watched key matching the specified DB, if the}
00312 \textcolor{comment}{             * key exists, mark the client as dirty, as the key will be}
00313 \textcolor{comment}{             * removed. */}
00314             \textcolor{keywordflow}{if} (dbid == -1 || wk->db->id == dbid) \{
00315                 \textcolor{keywordflow}{if} (dictFind(wk->db->dict, wk->key->ptr) != NULL)
00316                     c->flags |= \hyperlink{server_8h_a0f4df645d72b6b3e9a0d07afbe502a51}{CLIENT\_DIRTY\_CAS};
00317             \}
00318         \}
00319     \}
00320 \}
00321 
00322 \textcolor{keywordtype}{void} watchCommand(\hyperlink{structclient}{client} *c) \{
00323     \textcolor{keywordtype}{int} j;
00324 
00325     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI}) \{
00326         addReplyError(c,\textcolor{stringliteral}{"WATCH inside MULTI is not allowed"});
00327         \textcolor{keywordflow}{return};
00328     \}
00329     \textcolor{keywordflow}{for} (j = 1; j < c->argc; j++)
00330         watchForKey(c,c->argv[j]);
00331     addReply(c,shared.ok);
00332 \}
00333 
00334 \textcolor{keywordtype}{void} unwatchCommand(\hyperlink{structclient}{client} *c) \{
00335     unwatchAllKeys(c);
00336     c->flags &= (~\hyperlink{server_8h_a0f4df645d72b6b3e9a0d07afbe502a51}{CLIENT\_DIRTY\_CAS});
00337     addReply(c,shared.ok);
00338 \}
\end{DoxyCode}
