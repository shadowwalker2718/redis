\hypertarget{scripting_8c_source}{}\section{scripting.\+c}
\label{scripting_8c_source}\index{src/scripting.\+c@{src/scripting.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>}
00003 \textcolor{comment}{ * All rights reserved.}
00004 \textcolor{comment}{ *}
00005 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00006 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00007 \textcolor{comment}{ *}
00008 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00009 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00010 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00011 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00012 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00013 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00014 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00015 \textcolor{comment}{ *     specific prior written permission.}
00016 \textcolor{comment}{ *}
00017 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00018 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00019 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00020 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00021 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00022 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00023 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00024 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00025 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00026 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00027 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00028 \textcolor{comment}{ */}
00029 
00030 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{server_8h}{"server.h"}
00031 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{sha1_8h}{"sha1.h"}
00032 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{rand_8h}{"rand.h"}
00033 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{cluster_8h}{"cluster.h"}
00034 
00035 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{lua}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00036 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{lauxlib}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00037 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{lualib}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00038 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{ctype}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00039 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{math}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00040 
00041 \textcolor{keywordtype}{char} *redisProtocolToLuaType\_Int(lua\_State *lua, \textcolor{keywordtype}{char} *reply);
00042 \textcolor{keywordtype}{char} *redisProtocolToLuaType\_Bulk(lua\_State *lua, \textcolor{keywordtype}{char} *reply);
00043 \textcolor{keywordtype}{char} *redisProtocolToLuaType\_Status(lua\_State *lua, \textcolor{keywordtype}{char} *reply);
00044 \textcolor{keywordtype}{char} *redisProtocolToLuaType\_Error(lua\_State *lua, \textcolor{keywordtype}{char} *reply);
00045 \textcolor{keywordtype}{char} *redisProtocolToLuaType\_MultiBulk(lua\_State *lua, \textcolor{keywordtype}{char} *reply);
00046 \textcolor{keywordtype}{int} redis\_math\_random (lua\_State *L);
00047 \textcolor{keywordtype}{int} redis\_math\_randomseed (lua\_State *L);
00048 \textcolor{keywordtype}{void} ldbInit(\textcolor{keywordtype}{void});
00049 \textcolor{keywordtype}{void} ldbDisable(\hyperlink{structclient}{client} *c);
00050 \textcolor{keywordtype}{void} ldbEnable(\hyperlink{structclient}{client} *c);
00051 \textcolor{keywordtype}{void} evalGenericCommandWithDebugging(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} evalsha);
00052 \textcolor{keywordtype}{void} luaLdbLineHook(lua\_State *lua, lua\_Debug *ar);
00053 \textcolor{keywordtype}{void} ldbLog(sds entry);
00054 \textcolor{keywordtype}{void} ldbLogRedisReply(\textcolor{keywordtype}{char} *reply);
00055 sds ldbCatStackValue(sds s, lua\_State *lua, \textcolor{keywordtype}{int} idx);
00056 
00057 \textcolor{comment}{/* Debugger shared state is stored inside this global structure. */}
00058 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LDB\_BREAKPOINTS\_MAX} 64  \textcolor{comment}{/* Max number of breakpoints. */}
00059 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LDB\_MAX\_LEN\_DEFAULT} 256 \textcolor{comment}{/* Default len limit for replies / var dumps. */}
\Hypertarget{scripting_8c_source_l00060}\hyperlink{structldbState}{00060} \textcolor{keyword}{struct} \hyperlink{structldbState}{ldbState} \{
00061     \textcolor{keywordtype}{int} fd;     \textcolor{comment}{/* Socket of the debugging client. */}
00062     \textcolor{keywordtype}{int} active; \textcolor{comment}{/* Are we debugging EVAL right now? */}
00063     \textcolor{keywordtype}{int} forked; \textcolor{comment}{/* Is this a fork()ed debugging session? */}
00064     list *logs; \textcolor{comment}{/* List of messages to send to the client. */}
00065     list *traces; \textcolor{comment}{/* Messages about Redis commands executed since last stop.*/}
00066     list *children; \textcolor{comment}{/* All forked debugging sessions pids. */}
00067     \textcolor{keywordtype}{int} bp[\hyperlink{scripting_8c_a4f3000cf3b5955f8134bfcd2fa340db3}{LDB\_BREAKPOINTS\_MAX}]; \textcolor{comment}{/* An array of breakpoints line numbers. */}
00068     \textcolor{keywordtype}{int} bpcount; \textcolor{comment}{/* Number of valid entries inside bp. */}
00069     \textcolor{keywordtype}{int} step;   \textcolor{comment}{/* Stop at next line ragardless of breakpoints. */}
00070     \textcolor{keywordtype}{int} luabp;  \textcolor{comment}{/* Stop at next line because redis.breakpoint() was called. */}
00071     sds *src;   \textcolor{comment}{/* Lua script source code split by line. */}
00072     \textcolor{keywordtype}{int} lines;  \textcolor{comment}{/* Number of lines in 'src'. */}
00073     \textcolor{keywordtype}{int} currentline;    \textcolor{comment}{/* Current line number. */}
00074     sds cbuf;   \textcolor{comment}{/* Debugger client command buffer. */}
00075     size\_t maxlen;  \textcolor{comment}{/* Max var dump / reply length. */}
00076     \textcolor{keywordtype}{int} maxlen\_hint\_sent; \textcolor{comment}{/* Did we already hint about "set maxlen"? */}
00077 \} ldb;
00078 
00079 \textcolor{comment}{/* ---------------------------------------------------------------------------}
00080 \textcolor{comment}{ * Utility functions.}
00081 \textcolor{comment}{ * ------------------------------------------------------------------------- */}
00082 
00083 \textcolor{comment}{/* Perform the SHA1 of the input string. We use this both for hashing script}
00084 \textcolor{comment}{ * bodies in order to obtain the Lua function name, and in the implementation}
00085 \textcolor{comment}{ * of redis.sha1().}
00086 \textcolor{comment}{ *}
00087 \textcolor{comment}{ * 'digest' should point to a 41 bytes buffer: 40 for SHA1 converted into an}
00088 \textcolor{comment}{ * hexadecimal number, plus 1 byte for null term. */}
00089 \textcolor{keywordtype}{void} sha1hex(\textcolor{keywordtype}{char} *digest, \textcolor{keywordtype}{char} *script, size\_t len) \{
00090     SHA1\_CTX ctx;
00091     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} hash[20];
00092     \textcolor{keywordtype}{char} *cset = \textcolor{stringliteral}{"0123456789abcdef"};
00093     \textcolor{keywordtype}{int} j;
00094 
00095     SHA1Init(&ctx);
00096     SHA1Update(&ctx,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)script,len);
00097     SHA1Final(hash,&ctx);
00098 
00099     \textcolor{keywordflow}{for} (j = 0; j < 20; j++) \{
00100         digest[j*2] = cset[((hash[j]&0xF0)>>4)];
00101         digest[j*2+1] = cset[(hash[j]&0xF)];
00102     \}
00103     digest[40] = \textcolor{stringliteral}{'\(\backslash\)0'};
00104 \}
00105 
00106 \textcolor{comment}{/* ---------------------------------------------------------------------------}
00107 \textcolor{comment}{ * Redis reply to Lua type conversion functions.}
00108 \textcolor{comment}{ * ------------------------------------------------------------------------- */}
00109 
00110 \textcolor{comment}{/* Take a Redis reply in the Redis protocol format and convert it into a}
00111 \textcolor{comment}{ * Lua type. Thanks to this function, and the introduction of not connected}
00112 \textcolor{comment}{ * clients, it is trivial to implement the redis() lua function.}
00113 \textcolor{comment}{ *}
00114 \textcolor{comment}{ * Basically we take the arguments, execute the Redis command in the context}
00115 \textcolor{comment}{ * of a non connected client, then take the generated reply and convert it}
00116 \textcolor{comment}{ * into a suitable Lua type. With this trick the scripting feature does not}
00117 \textcolor{comment}{ * need the introduction of a full Redis internals API. The script}
00118 \textcolor{comment}{ * is like a normal client that bypasses all the slow I/O paths.}
00119 \textcolor{comment}{ *}
00120 \textcolor{comment}{ * Note: in this function we do not do any sanity check as the reply is}
00121 \textcolor{comment}{ * generated by Redis directly. This allows us to go faster.}
00122 \textcolor{comment}{ *}
00123 \textcolor{comment}{ * Errors are returned as a table with a single 'err' field set to the}
00124 \textcolor{comment}{ * error string.}
00125 \textcolor{comment}{ */}
00126 
00127 \textcolor{keywordtype}{char} *redisProtocolToLuaType(lua\_State *lua, \textcolor{keywordtype}{char}* reply) \{
00128     \textcolor{keywordtype}{char} *p = reply;
00129 
00130     \textcolor{keywordflow}{switch}(*p) \{
00131     \textcolor{keywordflow}{case} \textcolor{stringliteral}{':'}: p = redisProtocolToLuaType\_Int(lua,reply); \textcolor{keywordflow}{break};
00132     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'$'}: p = redisProtocolToLuaType\_Bulk(lua,reply); \textcolor{keywordflow}{break};
00133     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'+'}: p = redisProtocolToLuaType\_Status(lua,reply); \textcolor{keywordflow}{break};
00134     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'-'}: p = redisProtocolToLuaType\_Error(lua,reply); \textcolor{keywordflow}{break};
00135     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'*'}: p = redisProtocolToLuaType\_MultiBulk(lua,reply); \textcolor{keywordflow}{break};
00136     \}
00137     \textcolor{keywordflow}{return} p;
00138 \}
00139 
00140 \textcolor{keywordtype}{char} *redisProtocolToLuaType\_Int(lua\_State *lua, \textcolor{keywordtype}{char} *reply) \{
00141     \textcolor{keywordtype}{char} *p = strchr(reply+1,\textcolor{stringliteral}{'\(\backslash\)r'});
00142     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value;
00143 
00144     string2ll(reply+1,p-reply-1,&value);
00145     lua\_pushnumber(lua,(lua\_Number)value);
00146     \textcolor{keywordflow}{return} p+2;
00147 \}
00148 
00149 \textcolor{keywordtype}{char} *redisProtocolToLuaType\_Bulk(lua\_State *lua, \textcolor{keywordtype}{char} *reply) \{
00150     \textcolor{keywordtype}{char} *p = strchr(reply+1,\textcolor{stringliteral}{'\(\backslash\)r'});
00151     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} bulklen;
00152 
00153     string2ll(reply+1,p-reply-1,&bulklen);
00154     \textcolor{keywordflow}{if} (bulklen == -1) \{
00155         lua\_pushboolean(lua,0);
00156         \textcolor{keywordflow}{return} p+2;
00157     \} \textcolor{keywordflow}{else} \{
00158         lua\_pushlstring(lua,p+2,bulklen);
00159         \textcolor{keywordflow}{return} p+2+bulklen+2;
00160     \}
00161 \}
00162 
00163 \textcolor{keywordtype}{char} *redisProtocolToLuaType\_Status(lua\_State *lua, \textcolor{keywordtype}{char} *reply) \{
00164     \textcolor{keywordtype}{char} *p = strchr(reply+1,\textcolor{stringliteral}{'\(\backslash\)r'});
00165 
00166     lua\_newtable(lua);
00167     lua\_pushstring(lua,\textcolor{stringliteral}{"ok"});
00168     lua\_pushlstring(lua,reply+1,p-reply-1);
00169     lua\_settable(lua,-3);
00170     \textcolor{keywordflow}{return} p+2;
00171 \}
00172 
00173 \textcolor{keywordtype}{char} *redisProtocolToLuaType\_Error(lua\_State *lua, \textcolor{keywordtype}{char} *reply) \{
00174     \textcolor{keywordtype}{char} *p = strchr(reply+1,\textcolor{stringliteral}{'\(\backslash\)r'});
00175 
00176     lua\_newtable(lua);
00177     lua\_pushstring(lua,\textcolor{stringliteral}{"err"});
00178     lua\_pushlstring(lua,reply+1,p-reply-1);
00179     lua\_settable(lua,-3);
00180     \textcolor{keywordflow}{return} p+2;
00181 \}
00182 
00183 \textcolor{keywordtype}{char} *redisProtocolToLuaType\_MultiBulk(lua\_State *lua, \textcolor{keywordtype}{char} *reply) \{
00184     \textcolor{keywordtype}{char} *p = strchr(reply+1,\textcolor{stringliteral}{'\(\backslash\)r'});
00185     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} mbulklen;
00186     \textcolor{keywordtype}{int} j = 0;
00187 
00188     string2ll(reply+1,p-reply-1,&mbulklen);
00189     p += 2;
00190     \textcolor{keywordflow}{if} (mbulklen == -1) \{
00191         lua\_pushboolean(lua,0);
00192         \textcolor{keywordflow}{return} p;
00193     \}
00194     lua\_newtable(lua);
00195     \textcolor{keywordflow}{for} (j = 0; j < mbulklen; j++) \{
00196         lua\_pushnumber(lua,j+1);
00197         p = redisProtocolToLuaType(lua,p);
00198         lua\_settable(lua,-3);
00199     \}
00200     \textcolor{keywordflow}{return} p;
00201 \}
00202 
00203 \textcolor{comment}{/* This function is used in order to push an error on the Lua stack in the}
00204 \textcolor{comment}{ * format used by redis.pcall to return errors, which is a lua table}
00205 \textcolor{comment}{ * with a single "err" field set to the error string. Note that this}
00206 \textcolor{comment}{ * table is never a valid reply by proper commands, since the returned}
00207 \textcolor{comment}{ * tables are otherwise always indexed by integers, never by strings. */}
00208 \textcolor{keywordtype}{void} luaPushError(lua\_State *lua, \textcolor{keywordtype}{char} *error) \{
00209     lua\_Debug dbg;
00210 
00211     \textcolor{comment}{/* If debugging is active and in step mode, log errors resulting from}
00212 \textcolor{comment}{     * Redis commands. */}
00213     \textcolor{keywordflow}{if} (ldb.active && ldb.step) \{
00214         ldbLog(sdscatprintf(sdsempty(),\textcolor{stringliteral}{"<error> %s"},error));
00215     \}
00216 
00217     lua\_newtable(lua);
00218     lua\_pushstring(lua,\textcolor{stringliteral}{"err"});
00219 
00220     \textcolor{comment}{/* Attempt to figure out where this function was called, if possible */}
00221     \textcolor{keywordflow}{if}(lua\_getstack(lua, 1, &dbg) && lua\_getinfo(lua, \textcolor{stringliteral}{"nSl"}, &dbg)) \{
00222         sds msg = sdscatprintf(sdsempty(), \textcolor{stringliteral}{"%s: %d: %s"},
00223             dbg.source, dbg.currentline, error);
00224         lua\_pushstring(lua, msg);
00225         sdsfree(msg);
00226     \} \textcolor{keywordflow}{else} \{
00227         lua\_pushstring(lua, error);
00228     \}
00229     lua\_settable(lua,-3);
00230 \}
00231 
00232 \textcolor{comment}{/* In case the error set into the Lua stack by luaPushError() was generated}
00233 \textcolor{comment}{ * by the non-error-trapping version of redis.pcall(), which is redis.call(),}
00234 \textcolor{comment}{ * this function will raise the Lua error so that the execution of the}
00235 \textcolor{comment}{ * script will be halted. */}
00236 \textcolor{keywordtype}{int} luaRaiseError(lua\_State *lua) \{
00237     lua\_pushstring(lua,\textcolor{stringliteral}{"err"});
00238     lua\_gettable(lua,-2);
00239     \textcolor{keywordflow}{return} lua\_error(lua);
00240 \}
00241 
00242 \textcolor{comment}{/* Sort the array currently in the stack. We do this to make the output}
00243 \textcolor{comment}{ * of commands like KEYS or SMEMBERS something deterministic when called}
00244 \textcolor{comment}{ * from Lua (to play well with AOf/replication).}
00245 \textcolor{comment}{ *}
00246 \textcolor{comment}{ * The array is sorted using table.sort itself, and assuming all the}
00247 \textcolor{comment}{ * list elements are strings. */}
00248 \textcolor{keywordtype}{void} luaSortArray(lua\_State *lua) \{
00249     \textcolor{comment}{/* Initial Stack: array */}
00250     lua\_getglobal(lua,\textcolor{stringliteral}{"table"});
00251     lua\_pushstring(lua,\textcolor{stringliteral}{"sort"});
00252     lua\_gettable(lua,-2);       \textcolor{comment}{/* Stack: array, table, table.sort */}
00253     lua\_pushvalue(lua,-3);      \textcolor{comment}{/* Stack: array, table, table.sort, array */}
00254     \textcolor{keywordflow}{if} (lua\_pcall(lua,1,0,0)) \{
00255         \textcolor{comment}{/* Stack: array, table, error */}
00256 
00257         \textcolor{comment}{/* We are not interested in the error, we assume that the problem is}
00258 \textcolor{comment}{         * that there are 'false' elements inside the array, so we try}
00259 \textcolor{comment}{         * again with a slower function but able to handle this case, that}
00260 \textcolor{comment}{         * is: table.sort(table, \_\_redis\_\_compare\_helper) */}
00261         lua\_pop(lua,1);             \textcolor{comment}{/* Stack: array, table */}
00262         lua\_pushstring(lua,\textcolor{stringliteral}{"sort"}); \textcolor{comment}{/* Stack: array, table, sort */}
00263         lua\_gettable(lua,-2);       \textcolor{comment}{/* Stack: array, table, table.sort */}
00264         lua\_pushvalue(lua,-3);      \textcolor{comment}{/* Stack: array, table, table.sort, array */}
00265         lua\_getglobal(lua,\textcolor{stringliteral}{"\_\_redis\_\_compare\_helper"});
00266         \textcolor{comment}{/* Stack: array, table, table.sort, array, \_\_redis\_\_compare\_helper */}
00267         lua\_call(lua,2,0);
00268     \}
00269     \textcolor{comment}{/* Stack: array (sorted), table */}
00270     lua\_pop(lua,1);             \textcolor{comment}{/* Stack: array (sorted) */}
00271 \}
00272 
00273 \textcolor{comment}{/* ---------------------------------------------------------------------------}
00274 \textcolor{comment}{ * Lua reply to Redis reply conversion functions.}
00275 \textcolor{comment}{ * ------------------------------------------------------------------------- */}
00276 
00277 \textcolor{keywordtype}{void} luaReplyToRedisReply(\hyperlink{structclient}{client} *c, lua\_State *lua) \{
00278     \textcolor{keywordtype}{int} t = lua\_type(lua,-1);
00279 
00280     \textcolor{keywordflow}{switch}(t) \{
00281     \textcolor{keywordflow}{case} LUA\_TSTRING:
00282         addReplyBulkCBuffer(c,(\textcolor{keywordtype}{char}*)lua\_tostring(lua,-1),lua\_strlen(lua,-1));
00283         \textcolor{keywordflow}{break};
00284     \textcolor{keywordflow}{case} LUA\_TBOOLEAN:
00285         addReply(c,lua\_toboolean(lua,-1) ? shared.cone : shared.nullbulk);
00286         \textcolor{keywordflow}{break};
00287     \textcolor{keywordflow}{case} LUA\_TNUMBER:
00288         addReplyLongLong(c,(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long})lua\_tonumber(lua,-1));
00289         \textcolor{keywordflow}{break};
00290     \textcolor{keywordflow}{case} LUA\_TTABLE:
00291         \textcolor{comment}{/* We need to check if it is an array, an error, or a status reply.}
00292 \textcolor{comment}{         * Error are returned as a single element table with 'err' field.}
00293 \textcolor{comment}{         * Status replies are returned as single element table with 'ok'}
00294 \textcolor{comment}{         * field. */}
00295         lua\_pushstring(lua,\textcolor{stringliteral}{"err"});
00296         lua\_gettable(lua,-2);
00297         t = lua\_type(lua,-1);
00298         \textcolor{keywordflow}{if} (t == LUA\_TSTRING) \{
00299             sds err = sdsnew(lua\_tostring(lua,-1));
00300             sdsmapchars(err,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"},\textcolor{stringliteral}{"  "},2);
00301             addReplySds(c,sdscatprintf(sdsempty(),\textcolor{stringliteral}{"-%s\(\backslash\)r\(\backslash\)n"},err));
00302             sdsfree(err);
00303             lua\_pop(lua,2);
00304             \textcolor{keywordflow}{return};
00305         \}
00306 
00307         lua\_pop(lua,1);
00308         lua\_pushstring(lua,\textcolor{stringliteral}{"ok"});
00309         lua\_gettable(lua,-2);
00310         t = lua\_type(lua,-1);
00311         \textcolor{keywordflow}{if} (t == LUA\_TSTRING) \{
00312             sds ok = sdsnew(lua\_tostring(lua,-1));
00313             sdsmapchars(ok,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"},\textcolor{stringliteral}{"  "},2);
00314             addReplySds(c,sdscatprintf(sdsempty(),\textcolor{stringliteral}{"+%s\(\backslash\)r\(\backslash\)n"},ok));
00315             sdsfree(ok);
00316             lua\_pop(lua,1);
00317         \} \textcolor{keywordflow}{else} \{
00318             \textcolor{keywordtype}{void} *replylen = addDeferredMultiBulkLength(c);
00319             \textcolor{keywordtype}{int} j = 1, mbulklen = 0;
00320 
00321             lua\_pop(lua,1); \textcolor{comment}{/* Discard the 'ok' field value we popped */}
00322             \textcolor{keywordflow}{while}(1) \{
00323                 lua\_pushnumber(lua,j++);
00324                 lua\_gettable(lua,-2);
00325                 t = lua\_type(lua,-1);
00326                 \textcolor{keywordflow}{if} (t == LUA\_TNIL) \{
00327                     lua\_pop(lua,1);
00328                     \textcolor{keywordflow}{break};
00329                 \}
00330                 luaReplyToRedisReply(c, lua);
00331                 mbulklen++;
00332             \}
00333             setDeferredMultiBulkLength(c,replylen,mbulklen);
00334         \}
00335         \textcolor{keywordflow}{break};
00336     \textcolor{keywordflow}{default}:
00337         addReply(c,shared.nullbulk);
00338     \}
00339     lua\_pop(lua,1);
00340 \}
00341 
00342 \textcolor{comment}{/* ---------------------------------------------------------------------------}
00343 \textcolor{comment}{ * Lua redis.* functions implementations.}
00344 \textcolor{comment}{ * ------------------------------------------------------------------------- */}
00345 
00346 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LUA\_CMD\_OBJCACHE\_SIZE} 32
00347 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LUA\_CMD\_OBJCACHE\_MAX\_LEN} 64
00348 \textcolor{keywordtype}{int} luaRedisGenericCommand(lua\_State *lua, \textcolor{keywordtype}{int} raise\_error) \{
00349     \textcolor{keywordtype}{int} j, argc = lua\_gettop(lua);
00350     \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd;
00351     \hyperlink{structclient}{client} *c = server.lua\_client;
00352     sds reply;
00353 
00354     \textcolor{comment}{/* Cached across calls. */}
00355     \textcolor{keyword}{static} robj **argv = NULL;
00356     \textcolor{keyword}{static} \textcolor{keywordtype}{int} argv\_size = 0;
00357     \textcolor{keyword}{static} robj *cached\_objects[\hyperlink{scripting_8c_a850a6381c0da4c20a2a6bfdd1cd179b4}{LUA\_CMD\_OBJCACHE\_SIZE}];
00358     \textcolor{keyword}{static} size\_t cached\_objects\_len[\hyperlink{scripting_8c_a850a6381c0da4c20a2a6bfdd1cd179b4}{LUA\_CMD\_OBJCACHE\_SIZE}];
00359     \textcolor{keyword}{static} \textcolor{keywordtype}{int} inuse = 0;   \textcolor{comment}{/* Recursive calls detection. */}
00360 
00361     \textcolor{comment}{/* Reflect MULTI state */}
00362     \textcolor{keywordflow}{if} (server.lua\_multi\_emitted || (server.lua\_caller->flags & 
      \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI})) \{
00363         c->flags |= \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI};
00364     \} \textcolor{keywordflow}{else} \{
00365         c->flags &= ~\hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI};
00366     \}
00367 
00368     \textcolor{comment}{/* By using Lua debug hooks it is possible to trigger a recursive call}
00369 \textcolor{comment}{     * to luaRedisGenericCommand(), which normally should never happen.}
00370 \textcolor{comment}{     * To make this function reentrant is futile and makes it slower, but}
00371 \textcolor{comment}{     * we should at least detect such a misuse, and abort. */}
00372     \textcolor{keywordflow}{if} (inuse) \{
00373         \textcolor{keywordtype}{char} *recursion\_warning =
00374             \textcolor{stringliteral}{"luaRedisGenericCommand() recursive call detected. "}
00375             \textcolor{stringliteral}{"Are you doing funny stuff with Lua debug hooks?"};
00376         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"%s"},recursion\_warning);
00377         luaPushError(lua,recursion\_warning);
00378         \textcolor{keywordflow}{return} 1;
00379     \}
00380     inuse++;
00381 
00382     \textcolor{comment}{/* Require at least one argument */}
00383     \textcolor{keywordflow}{if} (argc == 0) \{
00384         luaPushError(lua,
00385             \textcolor{stringliteral}{"Please specify at least one argument for redis.call()"});
00386         inuse--;
00387         \textcolor{keywordflow}{return} raise\_error ? luaRaiseError(lua) : 1;
00388     \}
00389 
00390     \textcolor{comment}{/* Build the arguments vector */}
00391     \textcolor{keywordflow}{if} (argv\_size < argc) \{
00392         argv = zrealloc(argv,\textcolor{keyword}{sizeof}(robj*)*argc);
00393         argv\_size = argc;
00394     \}
00395 
00396     \textcolor{keywordflow}{for} (j = 0; j < argc; j++) \{
00397         \textcolor{keywordtype}{char} *obj\_s;
00398         size\_t obj\_len;
00399         \textcolor{keywordtype}{char} dbuf[64];
00400 
00401         \textcolor{keywordflow}{if} (lua\_type(lua,j+1) == LUA\_TNUMBER) \{
00402             \textcolor{comment}{/* We can't use lua\_tolstring() for number -> string conversion}
00403 \textcolor{comment}{             * since Lua uses a format specifier that loses precision. */}
00404             lua\_Number num = lua\_tonumber(lua,j+1);
00405 
00406             obj\_len = snprintf(dbuf,\textcolor{keyword}{sizeof}(dbuf),\textcolor{stringliteral}{"%.17g"},(\textcolor{keywordtype}{double})num);
00407             obj\_s = dbuf;
00408         \} \textcolor{keywordflow}{else} \{
00409             obj\_s = (\textcolor{keywordtype}{char}*)lua\_tolstring(lua,j+1,&obj\_len);
00410             \textcolor{keywordflow}{if} (obj\_s == NULL) \textcolor{keywordflow}{break}; \textcolor{comment}{/* Not a string. */}
00411         \}
00412 
00413         \textcolor{comment}{/* Try to use a cached object. */}
00414         \textcolor{keywordflow}{if} (j < \hyperlink{scripting_8c_a850a6381c0da4c20a2a6bfdd1cd179b4}{LUA\_CMD\_OBJCACHE\_SIZE} && cached\_objects[j] &&
00415             cached\_objects\_len[j] >= obj\_len)
00416         \{
00417             sds s = cached\_objects[j]->ptr;
00418             argv[j] = cached\_objects[j];
00419             cached\_objects[j] = NULL;
00420             memcpy(s,obj\_s,obj\_len+1);
00421             sdssetlen(s, obj\_len);
00422         \} \textcolor{keywordflow}{else} \{
00423             argv[j] = createStringObject(obj\_s, obj\_len);
00424         \}
00425     \}
00426 
00427     \textcolor{comment}{/* Check if one of the arguments passed by the Lua script}
00428 \textcolor{comment}{     * is not a string or an integer (lua\_isstring() return true for}
00429 \textcolor{comment}{     * integers as well). */}
00430     \textcolor{keywordflow}{if} (j != argc) \{
00431         j--;
00432         \textcolor{keywordflow}{while} (j >= 0) \{
00433             decrRefCount(argv[j]);
00434             j--;
00435         \}
00436         luaPushError(lua,
00437             \textcolor{stringliteral}{"Lua redis() command arguments must be strings or integers"});
00438         inuse--;
00439         \textcolor{keywordflow}{return} raise\_error ? luaRaiseError(lua) : 1;
00440     \}
00441 
00442     \textcolor{comment}{/* Setup our fake client for command execution */}
00443     c->argv = argv;
00444     c->argc = argc;
00445 
00446     \textcolor{comment}{/* Log the command if debugging is active. */}
00447     \textcolor{keywordflow}{if} (ldb.active && ldb.step) \{
00448         sds cmdlog = sdsnew(\textcolor{stringliteral}{"<redis>"});
00449         \textcolor{keywordflow}{for} (j = 0; j < c->argc; j++) \{
00450             \textcolor{keywordflow}{if} (j == 10) \{
00451                 cmdlog = sdscatprintf(cmdlog,\textcolor{stringliteral}{" ... (%d more)"},
00452                     c->argc-j-1);
00453                 \textcolor{keywordflow}{break};
00454             \} \textcolor{keywordflow}{else} \{
00455                 cmdlog = sdscatlen(cmdlog,\textcolor{stringliteral}{" "},1);
00456                 cmdlog = sdscatsds(cmdlog,c->argv[j]->ptr);
00457             \}
00458         \}
00459         ldbLog(cmdlog);
00460     \}
00461 
00462     \textcolor{comment}{/* Command lookup */}
00463     cmd = lookupCommand(argv[0]->ptr);
00464     \textcolor{keywordflow}{if} (!cmd || ((cmd->arity > 0 && cmd->arity != argc) ||
00465                    (argc < -cmd->arity)))
00466     \{
00467         \textcolor{keywordflow}{if} (cmd)
00468             luaPushError(lua,
00469                 \textcolor{stringliteral}{"Wrong number of args calling Redis command From Lua script"});
00470         \textcolor{keywordflow}{else}
00471             luaPushError(lua,\textcolor{stringliteral}{"Unknown Redis command called from Lua script"});
00472         \textcolor{keywordflow}{goto} cleanup;
00473     \}
00474     c->cmd = c->lastcmd = cmd;
00475 
00476     \textcolor{comment}{/* There are commands that are not allowed inside scripts. */}
00477     \textcolor{keywordflow}{if} (cmd->flags & \hyperlink{server_8h_aaf26ba9b59589bc7701e36fb440a0fbe}{CMD\_NOSCRIPT}) \{
00478         luaPushError(lua, \textcolor{stringliteral}{"This Redis command is not allowed from scripts"});
00479         \textcolor{keywordflow}{goto} cleanup;
00480     \}
00481 
00482     \textcolor{comment}{/* Write commands are forbidden against read-only slaves, or if a}
00483 \textcolor{comment}{     * command marked as non-deterministic was already called in the context}
00484 \textcolor{comment}{     * of this script. */}
00485     \textcolor{keywordflow}{if} (cmd->flags & \hyperlink{server_8h_a7391deb9c3a262ded3e186e94eb884e2}{CMD\_WRITE}) \{
00486         \textcolor{keywordflow}{if} (server.lua\_random\_dirty && !server.lua\_replicate\_commands) \{
00487             luaPushError(lua,
00488                 \textcolor{stringliteral}{"Write commands not allowed after non deterministic commands. Call
       redis.replicate\_commands() at the start of your script in order to switch to single commands replication mode."});
00489             \textcolor{keywordflow}{goto} cleanup;
00490         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.masterhost && server.repl\_slave\_ro &&
00491                    !server.loading &&
00492                    !(server.lua\_caller->flags & \hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER}))
00493         \{
00494             luaPushError(lua, shared.roslaveerr->ptr);
00495             \textcolor{keywordflow}{goto} cleanup;
00496         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.stop\_writes\_on\_bgsave\_err &&
00497                    server.saveparamslen > 0 &&
00498                    server.lastbgsave\_status == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR})
00499         \{
00500             luaPushError(lua, shared.bgsaveerr->ptr);
00501             \textcolor{keywordflow}{goto} cleanup;
00502         \}
00503     \}
00504 
00505     \textcolor{comment}{/* If we reached the memory limit configured via maxmemory, commands that}
00506 \textcolor{comment}{     * could enlarge the memory usage are not allowed, but only if this is the}
00507 \textcolor{comment}{     * first write in the context of this script, otherwise we can't stop}
00508 \textcolor{comment}{     * in the middle. */}
00509     \textcolor{keywordflow}{if} (server.maxmemory && server.lua\_write\_dirty == 0 &&
00510         (cmd->flags & \hyperlink{server_8h_aef97c640ad8dfdaca21eb67d4c37e447}{CMD\_DENYOOM}))
00511     \{
00512         \textcolor{keywordflow}{if} (freeMemoryIfNeeded() == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
00513             luaPushError(lua, shared.oomerr->ptr);
00514             \textcolor{keywordflow}{goto} cleanup;
00515         \}
00516     \}
00517 
00518     \textcolor{keywordflow}{if} (cmd->flags & \hyperlink{server_8h_a9f6608fefa355981c2a865ef3d44f196}{CMD\_RANDOM}) server.lua\_random\_dirty = 1;
00519     \textcolor{keywordflow}{if} (cmd->flags & \hyperlink{server_8h_a7391deb9c3a262ded3e186e94eb884e2}{CMD\_WRITE}) server.lua\_write\_dirty = 1;
00520 
00521     \textcolor{comment}{/* If this is a Redis Cluster node, we need to make sure Lua is not}
00522 \textcolor{comment}{     * trying to access non-local keys, with the exception of commands}
00523 \textcolor{comment}{     * received from our master or when loading the AOF back in memory. */}
00524     \textcolor{keywordflow}{if} (server.cluster\_enabled && !server.loading &&
00525         !(server.lua\_caller->flags & \hyperlink{server_8h_a3d8f0cc8d0653ee2b6dafb454292c069}{CLIENT\_MASTER}))
00526     \{
00527         \textcolor{comment}{/* Duplicate relevant flags in the lua client. */}
00528         c->flags &= ~(\hyperlink{server_8h_a84ba0494755e2f4f0faf6017175b5e0a}{CLIENT\_READONLY}|\hyperlink{server_8h_a108ac316dfd847430daf3c97f28557d3}{CLIENT\_ASKING});
00529         c->flags |= server.lua\_caller->flags & (\hyperlink{server_8h_a84ba0494755e2f4f0faf6017175b5e0a}{CLIENT\_READONLY}|
      \hyperlink{server_8h_a108ac316dfd847430daf3c97f28557d3}{CLIENT\_ASKING});
00530         \textcolor{keywordflow}{if} (getNodeByQuery(c,c->cmd,c->argv,c->argc,NULL,NULL) !=
00531                            server.cluster->myself)
00532         \{
00533             luaPushError(lua,
00534                 \textcolor{stringliteral}{"Lua script attempted to access a non local key in a "}
00535                 \textcolor{stringliteral}{"cluster node"});
00536             \textcolor{keywordflow}{goto} cleanup;
00537         \}
00538     \}
00539 
00540     \textcolor{comment}{/* If we are using single commands replication, we need to wrap what}
00541 \textcolor{comment}{     * we propagate into a MULTI/EXEC block, so that it will be atomic like}
00542 \textcolor{comment}{     * a Lua script in the context of AOF and slaves. */}
00543     \textcolor{keywordflow}{if} (server.lua\_replicate\_commands &&
00544         !server.lua\_multi\_emitted &&
00545         !(server.lua\_caller->flags & \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI}) &&
00546         server.lua\_write\_dirty &&
00547         server.lua\_repl != \hyperlink{server_8h_a0c7409da047d754c0adeb001025acc03}{PROPAGATE\_NONE})
00548     \{
00549         execCommandPropagateMulti(server.lua\_caller);
00550         server.lua\_multi\_emitted = 1;
00551     \}
00552 
00553     \textcolor{comment}{/* Run the command */}
00554     \textcolor{keywordtype}{int} call\_flags = \hyperlink{server_8h_a934cea7b13db05a29264146cd5b14064}{CMD\_CALL\_SLOWLOG} | \hyperlink{server_8h_a7b1d9cf5be21e4808da0c16f03155973}{CMD\_CALL\_STATS};
00555     \textcolor{keywordflow}{if} (server.lua\_replicate\_commands) \{
00556         \textcolor{comment}{/* Set flags according to redis.set\_repl() settings. */}
00557         \textcolor{keywordflow}{if} (server.lua\_repl & \hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF})
00558             call\_flags |= \hyperlink{server_8h_a3ca848c94df18641ac372c58fca0e236}{CMD\_CALL\_PROPAGATE\_AOF};
00559         \textcolor{keywordflow}{if} (server.lua\_repl & \hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL})
00560             call\_flags |= \hyperlink{server_8h_a69e4a8fdb26588e1028deb20fd51424a}{CMD\_CALL\_PROPAGATE\_REPL};
00561     \}
00562     call(c,call\_flags);
00563 
00564     \textcolor{comment}{/* Convert the result of the Redis command into a suitable Lua type.}
00565 \textcolor{comment}{     * The first thing we need is to create a single string from the client}
00566 \textcolor{comment}{     * output buffers. */}
00567     \textcolor{keywordflow}{if} (\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(c->reply) == 0 && c->bufpos < 
      \hyperlink{server_8h_ab467e0a40be9097e85445616d9bb32e3}{PROTO\_REPLY\_CHUNK\_BYTES}) \{
00568         \textcolor{comment}{/* This is a fast path for the common case of a reply inside the}
00569 \textcolor{comment}{         * client static buffer. Don't create an SDS string but just use}
00570 \textcolor{comment}{         * the client buffer directly. */}
00571         c->buf[c->bufpos] = \textcolor{stringliteral}{'\(\backslash\)0'};
00572         reply = c->buf;
00573         c->bufpos = 0;
00574     \} \textcolor{keywordflow}{else} \{
00575         reply = sdsnewlen(c->buf,c->bufpos);
00576         c->bufpos = 0;
00577         \textcolor{keywordflow}{while}(\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(c->reply)) \{
00578             sds o = \hyperlink{adlist_8h_af84cae230e7180ebcda1e2736fce9f65}{listNodeValue}(\hyperlink{adlist_8h_aa8dc514bbe217bb2e87c1c77cfa84690}{listFirst}(c->reply));
00579 
00580             reply = sdscatsds(reply,o);
00581             listDelNode(c->reply,\hyperlink{adlist_8h_aa8dc514bbe217bb2e87c1c77cfa84690}{listFirst}(c->reply));
00582         \}
00583     \}
00584     \textcolor{keywordflow}{if} (raise\_error && reply[0] != \textcolor{stringliteral}{'-'}) raise\_error = 0;
00585     redisProtocolToLuaType(lua,reply);
00586 
00587     \textcolor{comment}{/* If the debugger is active, log the reply from Redis. */}
00588     \textcolor{keywordflow}{if} (ldb.active && ldb.step)
00589         ldbLogRedisReply(reply);
00590 
00591     \textcolor{comment}{/* Sort the output array if needed, assuming it is a non-null multi bulk}
00592 \textcolor{comment}{     * reply as expected. */}
00593     \textcolor{keywordflow}{if} ((cmd->flags & \hyperlink{server_8h_a819ad39aa4aef302c4421c3cd910252d}{CMD\_SORT\_FOR\_SCRIPT}) &&
00594         (server.lua\_replicate\_commands == 0) &&
00595         (reply[0] == \textcolor{stringliteral}{'*'} && reply[1] != \textcolor{stringliteral}{'-'})) \{
00596             luaSortArray(lua);
00597     \}
00598     \textcolor{keywordflow}{if} (reply != c->buf) sdsfree(reply);
00599     c->reply\_bytes = 0;
00600 
00601 cleanup:
00602     \textcolor{comment}{/* Clean up. Command code may have changed argv/argc so we use the}
00603 \textcolor{comment}{     * argv/argc of the client instead of the local variables. */}
00604     \textcolor{keywordflow}{for} (j = 0; j < c->argc; j++) \{
00605         robj *o = c->argv[j];
00606 
00607         \textcolor{comment}{/* Try to cache the object in the cached\_objects array.}
00608 \textcolor{comment}{         * The object must be small, SDS-encoded, and with refcount = 1}
00609 \textcolor{comment}{         * (we must be the only owner) for us to cache it. */}
00610         \textcolor{keywordflow}{if} (j < \hyperlink{scripting_8c_a850a6381c0da4c20a2a6bfdd1cd179b4}{LUA\_CMD\_OBJCACHE\_SIZE} &&
00611             o->refcount == 1 &&
00612             (o->encoding == \hyperlink{server_8h_a148bc85e3074e324a6dc5eebcad1bcd5}{OBJ\_ENCODING\_RAW} ||
00613              o->encoding == \hyperlink{server_8h_ac5bb76b546161fd0da4b0ff89b3142ee}{OBJ\_ENCODING\_EMBSTR}) &&
00614             sdslen(o->ptr) <= \hyperlink{scripting_8c_ab2fd5c42d2e8edae6134b3d56184affc}{LUA\_CMD\_OBJCACHE\_MAX\_LEN})
00615         \{
00616             sds s = o->ptr;
00617             \textcolor{keywordflow}{if} (cached\_objects[j]) decrRefCount(cached\_objects[j]);
00618             cached\_objects[j] = o;
00619             cached\_objects\_len[j] = sdsalloc(s);
00620         \} \textcolor{keywordflow}{else} \{
00621             decrRefCount(o);
00622         \}
00623     \}
00624 
00625     \textcolor{keywordflow}{if} (c->argv != argv) \{
00626         zfree(c->argv);
00627         argv = NULL;
00628         argv\_size = 0;
00629     \}
00630 
00631     \textcolor{keywordflow}{if} (raise\_error) \{
00632         \textcolor{comment}{/* If we are here we should have an error in the stack, in the}
00633 \textcolor{comment}{         * form of a table with an "err" field. Extract the string to}
00634 \textcolor{comment}{         * return the plain error. */}
00635         inuse--;
00636         \textcolor{keywordflow}{return} luaRaiseError(lua);
00637     \}
00638     inuse--;
00639     \textcolor{keywordflow}{return} 1;
00640 \}
00641 
00642 \textcolor{comment}{/* redis.call() */}
00643 \textcolor{keywordtype}{int} luaRedisCallCommand(lua\_State *lua) \{
00644     \textcolor{keywordflow}{return} luaRedisGenericCommand(lua,1);
00645 \}
00646 
00647 \textcolor{comment}{/* redis.pcall() */}
00648 \textcolor{keywordtype}{int} luaRedisPCallCommand(lua\_State *lua) \{
00649     \textcolor{keywordflow}{return} luaRedisGenericCommand(lua,0);
00650 \}
00651 
00652 \textcolor{comment}{/* This adds redis.sha1hex(string) to Lua scripts using the same hashing}
00653 \textcolor{comment}{ * function used for sha1ing lua scripts. */}
00654 \textcolor{keywordtype}{int} luaRedisSha1hexCommand(lua\_State *lua) \{
00655     \textcolor{keywordtype}{int} argc = lua\_gettop(lua);
00656     \textcolor{keywordtype}{char} digest[41];
00657     size\_t len;
00658     \textcolor{keywordtype}{char} *s;
00659 
00660     \textcolor{keywordflow}{if} (argc != 1) \{
00661         lua\_pushstring(lua, \textcolor{stringliteral}{"wrong number of arguments"});
00662         \textcolor{keywordflow}{return} lua\_error(lua);
00663     \}
00664 
00665     s = (\textcolor{keywordtype}{char}*)lua\_tolstring(lua,1,&len);
00666     sha1hex(digest,s,len);
00667     lua\_pushstring(lua,digest);
00668     \textcolor{keywordflow}{return} 1;
00669 \}
00670 
00671 \textcolor{comment}{/* Returns a table with a single field 'field' set to the string value}
00672 \textcolor{comment}{ * passed as argument. This helper function is handy when returning}
00673 \textcolor{comment}{ * a Redis Protocol error or status reply from Lua:}
00674 \textcolor{comment}{ *}
00675 \textcolor{comment}{ * return redis.error\_reply("ERR Some Error")}
00676 \textcolor{comment}{ * return redis.status\_reply("ERR Some Error")}
00677 \textcolor{comment}{ */}
00678 \textcolor{keywordtype}{int} luaRedisReturnSingleFieldTable(lua\_State *lua, \textcolor{keywordtype}{char} *field) \{
00679     \textcolor{keywordflow}{if} (lua\_gettop(lua) != 1 || lua\_type(lua,-1) != LUA\_TSTRING) \{
00680         luaPushError(lua, \textcolor{stringliteral}{"wrong number or type of arguments"});
00681         \textcolor{keywordflow}{return} 1;
00682     \}
00683 
00684     lua\_newtable(lua);
00685     lua\_pushstring(lua, field);
00686     lua\_pushvalue(lua, -3);
00687     lua\_settable(lua, -3);
00688     \textcolor{keywordflow}{return} 1;
00689 \}
00690 
00691 \textcolor{comment}{/* redis.error\_reply() */}
00692 \textcolor{keywordtype}{int} luaRedisErrorReplyCommand(lua\_State *lua) \{
00693     \textcolor{keywordflow}{return} luaRedisReturnSingleFieldTable(lua,\textcolor{stringliteral}{"err"});
00694 \}
00695 
00696 \textcolor{comment}{/* redis.status\_reply() */}
00697 \textcolor{keywordtype}{int} luaRedisStatusReplyCommand(lua\_State *lua) \{
00698     \textcolor{keywordflow}{return} luaRedisReturnSingleFieldTable(lua,\textcolor{stringliteral}{"ok"});
00699 \}
00700 
00701 \textcolor{comment}{/* redis.replicate\_commands()}
00702 \textcolor{comment}{ *}
00703 \textcolor{comment}{ * Turn on single commands replication if the script never called}
00704 \textcolor{comment}{ * a write command so far, and returns true. Otherwise if the script}
00705 \textcolor{comment}{ * already started to write, returns false and stick to whole scripts}
00706 \textcolor{comment}{ * replication, which is our default. */}
00707 \textcolor{keywordtype}{int} luaRedisReplicateCommandsCommand(lua\_State *lua) \{
00708     \textcolor{keywordflow}{if} (server.lua\_write\_dirty) \{
00709         lua\_pushboolean(lua,0);
00710     \} \textcolor{keywordflow}{else} \{
00711         server.lua\_replicate\_commands = 1;
00712         \textcolor{comment}{/* When we switch to single commands replication, we can provide}
00713 \textcolor{comment}{         * different math.random() sequences at every call, which is what}
00714 \textcolor{comment}{         * the user normally expects. */}
00715         redisSrand48(rand());
00716         lua\_pushboolean(lua,1);
00717     \}
00718     \textcolor{keywordflow}{return} 1;
00719 \}
00720 
00721 \textcolor{comment}{/* redis.breakpoint()}
00722 \textcolor{comment}{ *}
00723 \textcolor{comment}{ * Allows to stop execution during a debuggign session from within}
00724 \textcolor{comment}{ * the Lua code implementation, like if a breakpoint was set in the code}
00725 \textcolor{comment}{ * immediately after the function. */}
00726 \textcolor{keywordtype}{int} luaRedisBreakpointCommand(lua\_State *lua) \{
00727     \textcolor{keywordflow}{if} (ldb.active) \{
00728         ldb.luabp = 1;
00729         lua\_pushboolean(lua,1);
00730     \} \textcolor{keywordflow}{else} \{
00731         lua\_pushboolean(lua,0);
00732     \}
00733     \textcolor{keywordflow}{return} 1;
00734 \}
00735 
00736 \textcolor{comment}{/* redis.debug()}
00737 \textcolor{comment}{ *}
00738 \textcolor{comment}{ * Log a string message into the output console.}
00739 \textcolor{comment}{ * Can take multiple arguments that will be separated by commas.}
00740 \textcolor{comment}{ * Nothing is returned to the caller. */}
00741 \textcolor{keywordtype}{int} luaRedisDebugCommand(lua\_State *lua) \{
00742     \textcolor{keywordflow}{if} (!ldb.active) \textcolor{keywordflow}{return} 0;
00743     \textcolor{keywordtype}{int} argc = lua\_gettop(lua);
00744     sds log = sdscatprintf(sdsempty(),\textcolor{stringliteral}{"<debug> line %d: "}, ldb.currentline);
00745     \textcolor{keywordflow}{while}(argc--) \{
00746         log = ldbCatStackValue(log,lua,-1 - argc);
00747         \textcolor{keywordflow}{if} (argc != 0) log = sdscatlen(log,\textcolor{stringliteral}{", "},2);
00748     \}
00749     ldbLog(log);
00750     \textcolor{keywordflow}{return} 0;
00751 \}
00752 
00753 \textcolor{comment}{/* redis.set\_repl()}
00754 \textcolor{comment}{ *}
00755 \textcolor{comment}{ * Set the propagation of write commands executed in the context of the}
00756 \textcolor{comment}{ * script to on/off for AOF and slaves. */}
00757 \textcolor{keywordtype}{int} luaRedisSetReplCommand(lua\_State *lua) \{
00758     \textcolor{keywordtype}{int} argc = lua\_gettop(lua);
00759     \textcolor{keywordtype}{int} flags;
00760 
00761     \textcolor{keywordflow}{if} (server.lua\_replicate\_commands == 0) \{
00762         lua\_pushstring(lua, \textcolor{stringliteral}{"You can set the replication behavior only after turning on single
       commands replication with redis.replicate\_commands()."});
00763         \textcolor{keywordflow}{return} lua\_error(lua);
00764     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (argc != 1) \{
00765         lua\_pushstring(lua, \textcolor{stringliteral}{"redis.set\_repl() requires two arguments."});
00766         \textcolor{keywordflow}{return} lua\_error(lua);
00767     \}
00768 
00769     flags = lua\_tonumber(lua,-1);
00770     \textcolor{keywordflow}{if} ((flags & ~(\hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF}|\hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL})) != 0) \{
00771         lua\_pushstring(lua, \textcolor{stringliteral}{"Invalid replication flags. Use REPL\_AOF, REPL\_SLAVE, REPL\_ALL or
       REPL\_NONE."});
00772         \textcolor{keywordflow}{return} lua\_error(lua);
00773     \}
00774     server.lua\_repl = flags;
00775     \textcolor{keywordflow}{return} 0;
00776 \}
00777 
00778 \textcolor{comment}{/* redis.log() */}
00779 \textcolor{keywordtype}{int} luaLogCommand(lua\_State *lua) \{
00780     \textcolor{keywordtype}{int} j, argc = lua\_gettop(lua);
00781     \textcolor{keywordtype}{int} level;
00782     sds log;
00783 
00784     \textcolor{keywordflow}{if} (argc < 2) \{
00785         lua\_pushstring(lua, \textcolor{stringliteral}{"redis.log() requires two arguments or more."});
00786         \textcolor{keywordflow}{return} lua\_error(lua);
00787     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!lua\_isnumber(lua,-argc)) \{
00788         lua\_pushstring(lua, \textcolor{stringliteral}{"First argument must be a number (log level)."});
00789         \textcolor{keywordflow}{return} lua\_error(lua);
00790     \}
00791     level = lua\_tonumber(lua,-argc);
00792     \textcolor{keywordflow}{if} (level < \hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG} || level > \hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}) \{
00793         lua\_pushstring(lua, \textcolor{stringliteral}{"Invalid debug level."});
00794         \textcolor{keywordflow}{return} lua\_error(lua);
00795     \}
00796 
00797     \textcolor{comment}{/* Glue together all the arguments */}
00798     log = sdsempty();
00799     \textcolor{keywordflow}{for} (j = 1; j < argc; j++) \{
00800         size\_t len;
00801         \textcolor{keywordtype}{char} *s;
00802 
00803         s = (\textcolor{keywordtype}{char}*)lua\_tolstring(lua,(-argc)+j,&len);
00804         \textcolor{keywordflow}{if} (s) \{
00805             \textcolor{keywordflow}{if} (j != 1) log = sdscatlen(log,\textcolor{stringliteral}{" "},1);
00806             log = sdscatlen(log,s,len);
00807         \}
00808     \}
00809     serverLogRaw(level,log);
00810     sdsfree(log);
00811     \textcolor{keywordflow}{return} 0;
00812 \}
00813 
00814 \textcolor{comment}{/* ---------------------------------------------------------------------------}
00815 \textcolor{comment}{ * Lua engine initialization and reset.}
00816 \textcolor{comment}{ * ------------------------------------------------------------------------- */}
00817 
00818 \textcolor{keywordtype}{void} luaLoadLib(lua\_State *lua, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *libname, lua\_CFunction luafunc) \{
00819   lua\_pushcfunction(lua, luafunc);
00820   lua\_pushstring(lua, libname);
00821   lua\_call(lua, 1, 0);
00822 \}
00823 
00824 LUALIB\_API \textcolor{keywordtype}{int} (luaopen\_cjson) (lua\_State *L);
00825 LUALIB\_API \textcolor{keywordtype}{int} (luaopen\_struct) (lua\_State *L);
00826 LUALIB\_API \textcolor{keywordtype}{int} (luaopen\_cmsgpack) (lua\_State *L);
00827 LUALIB\_API \textcolor{keywordtype}{int} (luaopen\_bit) (lua\_State *L);
00828 
00829 \textcolor{keywordtype}{void} luaLoadLibraries(lua\_State *lua) \{
00830     luaLoadLib(lua, \textcolor{stringliteral}{""}, luaopen\_base);
00831     luaLoadLib(lua, LUA\_TABLIBNAME, luaopen\_table);
00832     luaLoadLib(lua, LUA\_STRLIBNAME, luaopen\_string);
00833     luaLoadLib(lua, LUA\_MATHLIBNAME, luaopen\_math);
00834     luaLoadLib(lua, LUA\_DBLIBNAME, luaopen\_debug);
00835     luaLoadLib(lua, \textcolor{stringliteral}{"cjson"}, luaopen\_cjson);
00836     luaLoadLib(lua, \textcolor{stringliteral}{"struct"}, luaopen\_struct);
00837     luaLoadLib(lua, \textcolor{stringliteral}{"cmsgpack"}, luaopen\_cmsgpack);
00838     luaLoadLib(lua, \textcolor{stringliteral}{"bit"}, luaopen\_bit);
00839 
00840 \textcolor{preprocessor}{#}\textcolor{preprocessor}{if} 0 \textcolor{comment}{/* Stuff that we don't load currently, for sandboxing concerns. */}
00841     luaLoadLib(lua, LUA\_LOADLIBNAME, luaopen\_package);
00842     luaLoadLib(lua, LUA\_OSLIBNAME, luaopen\_os);
00843 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
00844 \}
00845 
00846 \textcolor{comment}{/* Remove a functions that we don't want to expose to the Redis scripting}
00847 \textcolor{comment}{ * environment. */}
00848 \textcolor{keywordtype}{void} luaRemoveUnsupportedFunctions(lua\_State *lua) \{
00849     lua\_pushnil(lua);
00850     lua\_setglobal(lua,\textcolor{stringliteral}{"loadfile"});
00851     lua\_pushnil(lua);
00852     lua\_setglobal(lua,\textcolor{stringliteral}{"dofile"});
00853 \}
00854 
00855 \textcolor{comment}{/* This function installs metamethods in the global table \_G that prevent}
00856 \textcolor{comment}{ * the creation of globals accidentally.}
00857 \textcolor{comment}{ *}
00858 \textcolor{comment}{ * It should be the last to be called in the scripting engine initialization}
00859 \textcolor{comment}{ * sequence, because it may interact with creation of globals. */}
00860 \textcolor{keywordtype}{void} scriptingEnableGlobalsProtection(lua\_State *lua) \{
00861     \textcolor{keywordtype}{char} *s[32];
00862     sds code = sdsempty();
00863     \textcolor{keywordtype}{int} j = 0;
00864 
00865     \textcolor{comment}{/* strict.lua from: http://metalua.luaforge.net/src/lib/strict.lua.html.}
00866 \textcolor{comment}{     * Modified to be adapted to Redis. */}
00867     s[j++]=\textcolor{stringliteral}{"local dbg=debug\(\backslash\)n"};
00868     s[j++]=\textcolor{stringliteral}{"local mt = \{\}\(\backslash\)n"};
00869     s[j++]=\textcolor{stringliteral}{"setmetatable(\_G, mt)\(\backslash\)n"};
00870     s[j++]=\textcolor{stringliteral}{"mt.\_\_newindex = function (t, n, v)\(\backslash\)n"};
00871     s[j++]=\textcolor{stringliteral}{"  if dbg.getinfo(2) then\(\backslash\)n"};
00872     s[j++]=\textcolor{stringliteral}{"    local w = dbg.getinfo(2, \(\backslash\)"S\(\backslash\)").what\(\backslash\)n"};
00873     s[j++]=\textcolor{stringliteral}{"    if w ~= \(\backslash\)"main\(\backslash\)" and w ~= \(\backslash\)"C\(\backslash\)" then\(\backslash\)n"};
00874     s[j++]=\textcolor{stringliteral}{"      error(\(\backslash\)"Script attempted to create global variable '\(\backslash\)"..tostring(n)..\(\backslash\)"'\(\backslash\)", 2)\(\backslash\)n"};
00875     s[j++]=\textcolor{stringliteral}{"    end\(\backslash\)n"};
00876     s[j++]=\textcolor{stringliteral}{"  end\(\backslash\)n"};
00877     s[j++]=\textcolor{stringliteral}{"  rawset(t, n, v)\(\backslash\)n"};
00878     s[j++]=\textcolor{stringliteral}{"end\(\backslash\)n"};
00879     s[j++]=\textcolor{stringliteral}{"mt.\_\_index = function (t, n)\(\backslash\)n"};
00880     s[j++]=\textcolor{stringliteral}{"  if dbg.getinfo(2) and dbg.getinfo(2, \(\backslash\)"S\(\backslash\)").what ~= \(\backslash\)"C\(\backslash\)" then\(\backslash\)n"};
00881     s[j++]=\textcolor{stringliteral}{"    error(\(\backslash\)"Script attempted to access nonexistent global variable
       '\(\backslash\)"..tostring(n)..\(\backslash\)"'\(\backslash\)", 2)\(\backslash\)n"};
00882     s[j++]=\textcolor{stringliteral}{"  end\(\backslash\)n"};
00883     s[j++]=\textcolor{stringliteral}{"  return rawget(t, n)\(\backslash\)n"};
00884     s[j++]=\textcolor{stringliteral}{"end\(\backslash\)n"};
00885     s[j++]=\textcolor{stringliteral}{"debug = nil\(\backslash\)n"};
00886     s[j++]=NULL;
00887 
00888     \textcolor{keywordflow}{for} (j = 0; s[j] != NULL; j++) code = sdscatlen(code,s[j],strlen(s[j]));
00889     luaL\_loadbuffer(lua,code,sdslen(code),\textcolor{stringliteral}{"@enable\_strict\_lua"});
00890     lua\_pcall(lua,0,0,0);
00891     sdsfree(code);
00892 \}
00893 
00894 \textcolor{comment}{/* Initialize the scripting environment.}
00895 \textcolor{comment}{ *}
00896 \textcolor{comment}{ * This function is called the first time at server startup with}
00897 \textcolor{comment}{ * the 'setup' argument set to 1.}
00898 \textcolor{comment}{ *}
00899 \textcolor{comment}{ * It can be called again multiple times during the lifetime of the Redis}
00900 \textcolor{comment}{ * process, with 'setup' set to 0, and following a scriptingRelease() call,}
00901 \textcolor{comment}{ * in order to reset the Lua scripting environment.}
00902 \textcolor{comment}{ *}
00903 \textcolor{comment}{ * However it is simpler to just call scriptingReset() that does just that. */}
00904 \textcolor{keywordtype}{void} scriptingInit(\textcolor{keywordtype}{int} setup) \{
00905     lua\_State *lua = lua\_open();
00906 
00907     \textcolor{keywordflow}{if} (setup) \{
00908         server.lua\_client = NULL;
00909         server.lua\_caller = NULL;
00910         server.lua\_timedout = 0;
00911         server.lua\_always\_replicate\_commands = 0; \textcolor{comment}{/* Only DEBUG can change it.*/}
00912         ldbInit();
00913     \}
00914 
00915     luaLoadLibraries(lua);
00916     luaRemoveUnsupportedFunctions(lua);
00917 
00918     \textcolor{comment}{/* Initialize a dictionary we use to map SHAs to scripts.}
00919 \textcolor{comment}{     * This is useful for replication, as we need to replicate EVALSHA}
00920 \textcolor{comment}{     * as EVAL, so we need to remember the associated script. */}
00921     server.lua\_scripts = dictCreate(&shaScriptObjectDictType,NULL);
00922 
00923     \textcolor{comment}{/* Register the redis commands table and fields */}
00924     lua\_newtable(lua);
00925 
00926     \textcolor{comment}{/* redis.call */}
00927     lua\_pushstring(lua,\textcolor{stringliteral}{"call"});
00928     lua\_pushcfunction(lua,luaRedisCallCommand);
00929     lua\_settable(lua,-3);
00930 
00931     \textcolor{comment}{/* redis.pcall */}
00932     lua\_pushstring(lua,\textcolor{stringliteral}{"pcall"});
00933     lua\_pushcfunction(lua,luaRedisPCallCommand);
00934     lua\_settable(lua,-3);
00935 
00936     \textcolor{comment}{/* redis.log and log levels. */}
00937     lua\_pushstring(lua,\textcolor{stringliteral}{"log"});
00938     lua\_pushcfunction(lua,luaLogCommand);
00939     lua\_settable(lua,-3);
00940 
00941     lua\_pushstring(lua,\textcolor{stringliteral}{"LOG\_DEBUG"});
00942     lua\_pushnumber(lua,\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG});
00943     lua\_settable(lua,-3);
00944 
00945     lua\_pushstring(lua,\textcolor{stringliteral}{"LOG\_VERBOSE"});
00946     lua\_pushnumber(lua,\hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE});
00947     lua\_settable(lua,-3);
00948 
00949     lua\_pushstring(lua,\textcolor{stringliteral}{"LOG\_NOTICE"});
00950     lua\_pushnumber(lua,\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE});
00951     lua\_settable(lua,-3);
00952 
00953     lua\_pushstring(lua,\textcolor{stringliteral}{"LOG\_WARNING"});
00954     lua\_pushnumber(lua,\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING});
00955     lua\_settable(lua,-3);
00956 
00957     \textcolor{comment}{/* redis.sha1hex */}
00958     lua\_pushstring(lua, \textcolor{stringliteral}{"sha1hex"});
00959     lua\_pushcfunction(lua, luaRedisSha1hexCommand);
00960     lua\_settable(lua, -3);
00961 
00962     \textcolor{comment}{/* redis.error\_reply and redis.status\_reply */}
00963     lua\_pushstring(lua, \textcolor{stringliteral}{"error\_reply"});
00964     lua\_pushcfunction(lua, luaRedisErrorReplyCommand);
00965     lua\_settable(lua, -3);
00966     lua\_pushstring(lua, \textcolor{stringliteral}{"status\_reply"});
00967     lua\_pushcfunction(lua, luaRedisStatusReplyCommand);
00968     lua\_settable(lua, -3);
00969 
00970     \textcolor{comment}{/* redis.replicate\_commands */}
00971     lua\_pushstring(lua, \textcolor{stringliteral}{"replicate\_commands"});
00972     lua\_pushcfunction(lua, luaRedisReplicateCommandsCommand);
00973     lua\_settable(lua, -3);
00974 
00975     \textcolor{comment}{/* redis.set\_repl and associated flags. */}
00976     lua\_pushstring(lua,\textcolor{stringliteral}{"set\_repl"});
00977     lua\_pushcfunction(lua,luaRedisSetReplCommand);
00978     lua\_settable(lua,-3);
00979 
00980     lua\_pushstring(lua,\textcolor{stringliteral}{"REPL\_NONE"});
00981     lua\_pushnumber(lua,\hyperlink{server_8h_a0c7409da047d754c0adeb001025acc03}{PROPAGATE\_NONE});
00982     lua\_settable(lua,-3);
00983 
00984     lua\_pushstring(lua,\textcolor{stringliteral}{"REPL\_AOF"});
00985     lua\_pushnumber(lua,\hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF});
00986     lua\_settable(lua,-3);
00987 
00988     lua\_pushstring(lua,\textcolor{stringliteral}{"REPL\_SLAVE"});
00989     lua\_pushnumber(lua,\hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL});
00990     lua\_settable(lua,-3);
00991 
00992     lua\_pushstring(lua,\textcolor{stringliteral}{"REPL\_ALL"});
00993     lua\_pushnumber(lua,\hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF}|\hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL});
00994     lua\_settable(lua,-3);
00995 
00996     \textcolor{comment}{/* redis.breakpoint */}
00997     lua\_pushstring(lua,\textcolor{stringliteral}{"breakpoint"});
00998     lua\_pushcfunction(lua,luaRedisBreakpointCommand);
00999     lua\_settable(lua,-3);
01000 
01001     \textcolor{comment}{/* redis.debug */}
01002     lua\_pushstring(lua,\textcolor{stringliteral}{"debug"});
01003     lua\_pushcfunction(lua,luaRedisDebugCommand);
01004     lua\_settable(lua,-3);
01005 
01006     \textcolor{comment}{/* Finally set the table as 'redis' global var. */}
01007     lua\_setglobal(lua,\textcolor{stringliteral}{"redis"});
01008 
01009     \textcolor{comment}{/* Replace math.random and math.randomseed with our implementations. */}
01010     lua\_getglobal(lua,\textcolor{stringliteral}{"math"});
01011 
01012     lua\_pushstring(lua,\textcolor{stringliteral}{"random"});
01013     lua\_pushcfunction(lua,redis\_math\_random);
01014     lua\_settable(lua,-3);
01015 
01016     lua\_pushstring(lua,\textcolor{stringliteral}{"randomseed"});
01017     lua\_pushcfunction(lua,redis\_math\_randomseed);
01018     lua\_settable(lua,-3);
01019 
01020     lua\_setglobal(lua,\textcolor{stringliteral}{"math"});
01021 
01022     \textcolor{comment}{/* Add a helper function that we use to sort the multi bulk output of non}
01023 \textcolor{comment}{     * deterministic commands, when containing 'false' elements. */}
01024     \{
01025         \textcolor{keywordtype}{char} *compare\_func =    \textcolor{stringliteral}{"function \_\_redis\_\_compare\_helper(a,b)\(\backslash\)n"}
01026                                 \textcolor{stringliteral}{"  if a == false then a = '' end\(\backslash\)n"}
01027                                 \textcolor{stringliteral}{"  if b == false then b = '' end\(\backslash\)n"}
01028                                 \textcolor{stringliteral}{"  return a<b\(\backslash\)n"}
01029                                 \textcolor{stringliteral}{"end\(\backslash\)n"};
01030         luaL\_loadbuffer(lua,compare\_func,strlen(compare\_func),\textcolor{stringliteral}{"@cmp\_func\_def"});
01031         lua\_pcall(lua,0,0,0);
01032     \}
01033 
01034     \textcolor{comment}{/* Add a helper function we use for pcall error reporting.}
01035 \textcolor{comment}{     * Note that when the error is in the C function we want to report the}
01036 \textcolor{comment}{     * information about the caller, that's what makes sense from the point}
01037 \textcolor{comment}{     * of view of the user debugging a script. */}
01038     \{
01039         \textcolor{keywordtype}{char} *errh\_func =       \textcolor{stringliteral}{"local dbg = debug\(\backslash\)n"}
01040                                 \textcolor{stringliteral}{"function \_\_redis\_\_err\_\_handler(err)\(\backslash\)n"}
01041                                 \textcolor{stringliteral}{"  local i = dbg.getinfo(2,'nSl')\(\backslash\)n"}
01042                                 \textcolor{stringliteral}{"  if i and i.what == 'C' then\(\backslash\)n"}
01043                                 \textcolor{stringliteral}{"    i = dbg.getinfo(3,'nSl')\(\backslash\)n"}
01044                                 \textcolor{stringliteral}{"  end\(\backslash\)n"}
01045                                 \textcolor{stringliteral}{"  if i then\(\backslash\)n"}
01046                                 \textcolor{stringliteral}{"    return i.source .. ':' .. i.currentline .. ': ' .. err\(\backslash\)n"}
01047                                 \textcolor{stringliteral}{"  else\(\backslash\)n"}
01048                                 \textcolor{stringliteral}{"    return err\(\backslash\)n"}
01049                                 \textcolor{stringliteral}{"  end\(\backslash\)n"}
01050                                 \textcolor{stringliteral}{"end\(\backslash\)n"};
01051         luaL\_loadbuffer(lua,errh\_func,strlen(errh\_func),\textcolor{stringliteral}{"@err\_handler\_def"});
01052         lua\_pcall(lua,0,0,0);
01053     \}
01054 
01055     \textcolor{comment}{/* Create the (non connected) client that we use to execute Redis commands}
01056 \textcolor{comment}{     * inside the Lua interpreter.}
01057 \textcolor{comment}{     * Note: there is no need to create it again when this function is called}
01058 \textcolor{comment}{     * by scriptingReset(). */}
01059     \textcolor{keywordflow}{if} (server.lua\_client == NULL) \{
01060         server.lua\_client = createClient(-1);
01061         server.lua\_client->flags |= \hyperlink{server_8h_af9d0b0f45ef2c1fd29ac714a300de706}{CLIENT\_LUA};
01062     \}
01063 
01064     \textcolor{comment}{/* Lua beginners often don't use "local", this is likely to introduce}
01065 \textcolor{comment}{     * subtle bugs in their code. To prevent problems we protect accesses}
01066 \textcolor{comment}{     * to global variables. */}
01067     scriptingEnableGlobalsProtection(lua);
01068 
01069     server.lua = lua;
01070 \}
01071 
01072 \textcolor{comment}{/* Release resources related to Lua scripting.}
01073 \textcolor{comment}{ * This function is used in order to reset the scripting environment. */}
01074 \textcolor{keywordtype}{void} scriptingRelease(\textcolor{keywordtype}{void}) \{
01075     dictRelease(server.lua\_scripts);
01076     lua\_close(server.lua);
01077 \}
01078 
01079 \textcolor{keywordtype}{void} scriptingReset(\textcolor{keywordtype}{void}) \{
01080     scriptingRelease();
01081     scriptingInit(0);
01082 \}
01083 
01084 \textcolor{comment}{/* Set an array of Redis String Objects as a Lua array (table) stored into a}
01085 \textcolor{comment}{ * global variable. */}
01086 \textcolor{keywordtype}{void} luaSetGlobalArray(lua\_State *lua, \textcolor{keywordtype}{char} *var, robj **elev, \textcolor{keywordtype}{int} elec) \{
01087     \textcolor{keywordtype}{int} j;
01088 
01089     lua\_newtable(lua);
01090     \textcolor{keywordflow}{for} (j = 0; j < elec; j++) \{
01091         lua\_pushlstring(lua,(\textcolor{keywordtype}{char}*)elev[j]->ptr,sdslen(elev[j]->ptr));
01092         lua\_rawseti(lua,-2,j+1);
01093     \}
01094     lua\_setglobal(lua,var);
01095 \}
01096 
01097 \textcolor{comment}{/* ---------------------------------------------------------------------------}
01098 \textcolor{comment}{ * Redis provided math.random}
01099 \textcolor{comment}{ * ------------------------------------------------------------------------- */}
01100 
01101 \textcolor{comment}{/* We replace math.random() with our implementation that is not affected}
01102 \textcolor{comment}{ * by specific libc random() implementations and will output the same sequence}
01103 \textcolor{comment}{ * (for the same seed) in every arch. */}
01104 
01105 \textcolor{comment}{/* The following implementation is the one shipped with Lua itself but with}
01106 \textcolor{comment}{ * rand() replaced by redisLrand48(). */}
01107 \textcolor{keywordtype}{int} redis\_math\_random (lua\_State *L) \{
01108   \textcolor{comment}{/* the `%' avoids the (rare) case of r==1, and is needed also because on}
01109 \textcolor{comment}{     some systems (SunOS!) `rand()' may return a value larger than RAND\_MAX */}
01110   lua\_Number r = (lua\_Number)(redisLrand48()%\hyperlink{rand_8h_a182af7f92013fc310391b56e090dfd33}{REDIS\_LRAND48\_MAX}) /
01111                                 (lua\_Number)\hyperlink{rand_8h_a182af7f92013fc310391b56e090dfd33}{REDIS\_LRAND48\_MAX};
01112   \textcolor{keywordflow}{switch} (lua\_gettop(L)) \{  \textcolor{comment}{/* check number of arguments */}
01113     \textcolor{keywordflow}{case} 0: \{  \textcolor{comment}{/* no arguments */}
01114       lua\_pushnumber(L, r);  \textcolor{comment}{/* Number between 0 and 1 */}
01115       \textcolor{keywordflow}{break};
01116     \}
01117     \textcolor{keywordflow}{case} 1: \{  \textcolor{comment}{/* only upper limit */}
01118       \textcolor{keywordtype}{int} u = luaL\_checkint(L, 1);
01119       luaL\_argcheck(L, 1<=u, 1, \textcolor{stringliteral}{"interval is empty"});
01120       lua\_pushnumber(L, floor(r*u)+1);  \textcolor{comment}{/* int between 1 and `u' */}
01121       \textcolor{keywordflow}{break};
01122     \}
01123     \textcolor{keywordflow}{case} 2: \{  \textcolor{comment}{/* lower and upper limits */}
01124       \textcolor{keywordtype}{int} l = luaL\_checkint(L, 1);
01125       \textcolor{keywordtype}{int} u = luaL\_checkint(L, 2);
01126       luaL\_argcheck(L, l<=u, 2, \textcolor{stringliteral}{"interval is empty"});
01127       lua\_pushnumber(L, floor(r*(u-l+1))+l);  \textcolor{comment}{/* int between `l' and `u' */}
01128       \textcolor{keywordflow}{break};
01129     \}
01130     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} luaL\_error(L, \textcolor{stringliteral}{"wrong number of arguments"});
01131   \}
01132   \textcolor{keywordflow}{return} 1;
01133 \}
01134 
01135 \textcolor{keywordtype}{int} redis\_math\_randomseed (lua\_State *L) \{
01136   redisSrand48(luaL\_checkint(L, 1));
01137   \textcolor{keywordflow}{return} 0;
01138 \}
01139 
01140 \textcolor{comment}{/* ---------------------------------------------------------------------------}
01141 \textcolor{comment}{ * EVAL and SCRIPT commands implementation}
01142 \textcolor{comment}{ * ------------------------------------------------------------------------- */}
01143 
01144 \textcolor{comment}{/* Define a Lua function with the specified body.}
01145 \textcolor{comment}{ * The function name will be generated in the following form:}
01146 \textcolor{comment}{ *}
01147 \textcolor{comment}{ *   f\_<hex sha1 sum>}
01148 \textcolor{comment}{ *}
01149 \textcolor{comment}{ * The function increments the reference count of the 'body' object as a}
01150 \textcolor{comment}{ * side effect of a successful call.}
01151 \textcolor{comment}{ *}
01152 \textcolor{comment}{ * On success a pointer to an SDS string representing the function SHA1 of the}
01153 \textcolor{comment}{ * just added function is returned (and will be valid until the next call}
01154 \textcolor{comment}{ * to scriptingReset() function), otherwise NULL is returned.}
01155 \textcolor{comment}{ *}
01156 \textcolor{comment}{ * The function handles the fact of being called with a script that already}
01157 \textcolor{comment}{ * exists, and in such a case, it behaves like in the success case.}
01158 \textcolor{comment}{ *}
01159 \textcolor{comment}{ * If 'c' is not NULL, on error the client is informed with an appropriate}
01160 \textcolor{comment}{ * error describing the nature of the problem and the Lua interpreter error. */}
01161 sds luaCreateFunction(\hyperlink{structclient}{client} *c, lua\_State *lua, robj *body) \{
01162     \textcolor{keywordtype}{char} funcname[43];
01163     dictEntry *de;
01164 
01165     funcname[0] = \textcolor{stringliteral}{'f'};
01166     funcname[1] = \textcolor{stringliteral}{'\_'};
01167     sha1hex(funcname+2,body->ptr,sdslen(body->ptr));
01168 
01169     sds sha = sdsnewlen(funcname+2,40);
01170     \textcolor{keywordflow}{if} ((de = dictFind(server.lua\_scripts,sha)) != NULL) \{
01171         sdsfree(sha);
01172         \textcolor{keywordflow}{return} \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
01173     \}
01174 
01175     sds funcdef = sdsempty();
01176     funcdef = sdscat(funcdef,\textcolor{stringliteral}{"function "});
01177     funcdef = sdscatlen(funcdef,funcname,42);
01178     funcdef = sdscatlen(funcdef,\textcolor{stringliteral}{"() "},3);
01179     funcdef = sdscatlen(funcdef,body->ptr,sdslen(body->ptr));
01180     funcdef = sdscatlen(funcdef,\textcolor{stringliteral}{"\(\backslash\)nend"},4);
01181 
01182     \textcolor{keywordflow}{if} (luaL\_loadbuffer(lua,funcdef,sdslen(funcdef),\textcolor{stringliteral}{"@user\_script"})) \{
01183         \textcolor{keywordflow}{if} (c != NULL) \{
01184             addReplyErrorFormat(c,
01185                 \textcolor{stringliteral}{"Error compiling script (new function): %s\(\backslash\)n"},
01186                 lua\_tostring(lua,-1));
01187         \}
01188         lua\_pop(lua,1);
01189         sdsfree(sha);
01190         sdsfree(funcdef);
01191         \textcolor{keywordflow}{return} NULL;
01192     \}
01193     sdsfree(funcdef);
01194 
01195     \textcolor{keywordflow}{if} (lua\_pcall(lua,0,0,0)) \{
01196         \textcolor{keywordflow}{if} (c != NULL) \{
01197             addReplyErrorFormat(c,\textcolor{stringliteral}{"Error running script (new function): %s\(\backslash\)n"},
01198                 lua\_tostring(lua,-1));
01199         \}
01200         lua\_pop(lua,1);
01201         sdsfree(sha);
01202         \textcolor{keywordflow}{return} NULL;
01203     \}
01204 
01205     \textcolor{comment}{/* We also save a SHA1 -> Original script map in a dictionary}
01206 \textcolor{comment}{     * so that we can replicate / write in the AOF all the}
01207 \textcolor{comment}{     * EVALSHA commands as EVAL using the original script. */}
01208     \textcolor{keywordtype}{int} retval = dictAdd(server.lua\_scripts,sha,body);
01209     \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c ? c : server.lua\_client,NULL,retval == 
      \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK});
01210     incrRefCount(body);
01211     \textcolor{keywordflow}{return} sha;
01212 \}
01213 
01214 \textcolor{comment}{/* This is the Lua script "count" hook that we use to detect scripts timeout. */}
01215 \textcolor{keywordtype}{void} luaMaskCountHook(lua\_State *lua, lua\_Debug *ar) \{
01216     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} elapsed;
01217     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(ar);
01218     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(lua);
01219 
01220     elapsed = mstime() - server.lua\_time\_start;
01221     \textcolor{keywordflow}{if} (elapsed >= server.lua\_time\_limit && server.lua\_timedout == 0) \{
01222         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Lua slow script detected: still in execution after %lld
       milliseconds. You can try killing the script using the SCRIPT KILL command."},elapsed);
01223         server.lua\_timedout = 1;
01224         \textcolor{comment}{/* Once the script timeouts we reenter the event loop to permit others}
01225 \textcolor{comment}{         * to call SCRIPT KILL or SHUTDOWN NOSAVE if needed. For this reason}
01226 \textcolor{comment}{         * we need to mask the client executing the script from the event loop.}
01227 \textcolor{comment}{         * If we don't do that the client may disconnect and could no longer be}
01228 \textcolor{comment}{         * here when the EVAL command will return. */}
01229          aeDeleteFileEvent(server.el, server.lua\_caller->fd, \hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE});
01230     \}
01231     \textcolor{keywordflow}{if} (server.lua\_timedout) processEventsWhileBlocked();
01232     \textcolor{keywordflow}{if} (server.lua\_kill) \{
01233         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Lua script killed by user with SCRIPT KILL."});
01234         lua\_pushstring(lua,\textcolor{stringliteral}{"Script killed by user with SCRIPT KILL..."});
01235         lua\_error(lua);
01236     \}
01237 \}
01238 
01239 \textcolor{keywordtype}{void} evalGenericCommand(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} evalsha) \{
01240     lua\_State *lua = server.lua;
01241     \textcolor{keywordtype}{char} funcname[43];
01242     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} numkeys;
01243     \textcolor{keywordtype}{int} delhook = 0, err;
01244 
01245     \textcolor{comment}{/* When we replicate whole scripts, we want the same PRNG sequence at}
01246 \textcolor{comment}{     * every call so that our PRNG is not affected by external state. */}
01247     redisSrand48(0);
01248 
01249     \textcolor{comment}{/* We set this flag to zero to remember that so far no random command}
01250 \textcolor{comment}{     * was called. This way we can allow the user to call commands like}
01251 \textcolor{comment}{     * SRANDMEMBER or RANDOMKEY from Lua scripts as far as no write command}
01252 \textcolor{comment}{     * is called (otherwise the replication and AOF would end with non}
01253 \textcolor{comment}{     * deterministic sequences).}
01254 \textcolor{comment}{     *}
01255 \textcolor{comment}{     * Thanks to this flag we'll raise an error every time a write command}
01256 \textcolor{comment}{     * is called after a random command was used. */}
01257     server.lua\_random\_dirty = 0;
01258     server.lua\_write\_dirty = 0;
01259     server.lua\_replicate\_commands = server.lua\_always\_replicate\_commands;
01260     server.lua\_multi\_emitted = 0;
01261     server.lua\_repl = \hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF}|\hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL};
01262 
01263     \textcolor{comment}{/* Get the number of arguments that are keys */}
01264     \textcolor{keywordflow}{if} (getLongLongFromObjectOrReply(c,c->argv[2],&numkeys,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
01265         \textcolor{keywordflow}{return};
01266     \textcolor{keywordflow}{if} (numkeys > (c->argc - 3)) \{
01267         addReplyError(c,\textcolor{stringliteral}{"Number of keys can't be greater than number of args"});
01268         \textcolor{keywordflow}{return};
01269     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (numkeys < 0) \{
01270         addReplyError(c,\textcolor{stringliteral}{"Number of keys can't be negative"});
01271         \textcolor{keywordflow}{return};
01272     \}
01273 
01274     \textcolor{comment}{/* We obtain the script SHA1, then check if this function is already}
01275 \textcolor{comment}{     * defined into the Lua state */}
01276     funcname[0] = \textcolor{stringliteral}{'f'};
01277     funcname[1] = \textcolor{stringliteral}{'\_'};
01278     \textcolor{keywordflow}{if} (!evalsha) \{
01279         \textcolor{comment}{/* Hash the code if this is an EVAL call */}
01280         sha1hex(funcname+2,c->argv[1]->ptr,sdslen(c->argv[1]->ptr));
01281     \} \textcolor{keywordflow}{else} \{
01282         \textcolor{comment}{/* We already have the SHA if it is a EVALSHA */}
01283         \textcolor{keywordtype}{int} j;
01284         \textcolor{keywordtype}{char} *sha = c->argv[1]->ptr;
01285 
01286         \textcolor{comment}{/* Convert to lowercase. We don't use tolower since the function}
01287 \textcolor{comment}{         * managed to always show up in the profiler output consuming}
01288 \textcolor{comment}{         * a non trivial amount of time. */}
01289         \textcolor{keywordflow}{for} (j = 0; j < 40; j++)
01290             funcname[j+2] = (sha[j] >= \textcolor{stringliteral}{'A'} && sha[j] <= \textcolor{stringliteral}{'Z'}) ?
01291                 sha[j]+(\textcolor{stringliteral}{'a'}-\textcolor{stringliteral}{'A'}) : sha[j];
01292         funcname[42] = \textcolor{stringliteral}{'\(\backslash\)0'};
01293     \}
01294 
01295     \textcolor{comment}{/* Push the pcall error handler function on the stack. */}
01296     lua\_getglobal(lua, \textcolor{stringliteral}{"\_\_redis\_\_err\_\_handler"});
01297 
01298     \textcolor{comment}{/* Try to lookup the Lua function */}
01299     lua\_getglobal(lua, funcname);
01300     \textcolor{keywordflow}{if} (lua\_isnil(lua,-1)) \{
01301         lua\_pop(lua,1); \textcolor{comment}{/* remove the nil from the stack */}
01302         \textcolor{comment}{/* Function not defined... let's define it if we have the}
01303 \textcolor{comment}{         * body of the function. If this is an EVALSHA call we can just}
01304 \textcolor{comment}{         * return an error. */}
01305         \textcolor{keywordflow}{if} (evalsha) \{
01306             lua\_pop(lua,1); \textcolor{comment}{/* remove the error handler from the stack. */}
01307             addReply(c, shared.noscripterr);
01308             \textcolor{keywordflow}{return};
01309         \}
01310         \textcolor{keywordflow}{if} (luaCreateFunction(c,lua,c->argv[1]) == NULL) \{
01311             lua\_pop(lua,1); \textcolor{comment}{/* remove the error handler from the stack. */}
01312             \textcolor{comment}{/* The error is sent to the client by luaCreateFunction()}
01313 \textcolor{comment}{             * itself when it returns NULL. */}
01314             \textcolor{keywordflow}{return};
01315         \}
01316         \textcolor{comment}{/* Now the following is guaranteed to return non nil */}
01317         lua\_getglobal(lua, funcname);
01318         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(!lua\_isnil(lua,-1));
01319     \}
01320 
01321     \textcolor{comment}{/* Populate the argv and keys table accordingly to the arguments that}
01322 \textcolor{comment}{     * EVAL received. */}
01323     luaSetGlobalArray(lua,\textcolor{stringliteral}{"KEYS"},c->argv+3,numkeys);
01324     luaSetGlobalArray(lua,\textcolor{stringliteral}{"ARGV"},c->argv+3+numkeys,c->argc-3-numkeys);
01325 
01326     \textcolor{comment}{/* Select the right DB in the context of the Lua client */}
01327     selectDb(server.lua\_client,c->db->id);
01328 
01329     \textcolor{comment}{/* Set a hook in order to be able to stop the script execution if it}
01330 \textcolor{comment}{     * is running for too much time.}
01331 \textcolor{comment}{     * We set the hook only if the time limit is enabled as the hook will}
01332 \textcolor{comment}{     * make the Lua script execution slower.}
01333 \textcolor{comment}{     *}
01334 \textcolor{comment}{     * If we are debugging, we set instead a "line" hook so that the}
01335 \textcolor{comment}{     * debugger is call-back at every line executed by the script. */}
01336     server.lua\_caller = c;
01337     server.lua\_time\_start = mstime();
01338     server.lua\_kill = 0;
01339     \textcolor{keywordflow}{if} (server.lua\_time\_limit > 0 && server.masterhost == NULL &&
01340         ldb.active == 0)
01341     \{
01342         lua\_sethook(lua,luaMaskCountHook,LUA\_MASKCOUNT,100000);
01343         delhook = 1;
01344     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ldb.active) \{
01345         lua\_sethook(server.lua,luaLdbLineHook,LUA\_MASKLINE|LUA\_MASKCOUNT,100000);
01346         delhook = 1;
01347     \}
01348 
01349     \textcolor{comment}{/* At this point whether this script was never seen before or if it was}
01350 \textcolor{comment}{     * already defined, we can call it. We have zero arguments and expect}
01351 \textcolor{comment}{     * a single return value. */}
01352     err = lua\_pcall(lua,0,1,-2);
01353 
01354     \textcolor{comment}{/* Perform some cleanup that we need to do both on error and success. */}
01355     \textcolor{keywordflow}{if} (delhook) lua\_sethook(lua,NULL,0,0); \textcolor{comment}{/* Disable hook */}
01356     \textcolor{keywordflow}{if} (server.lua\_timedout) \{
01357         server.lua\_timedout = 0;
01358         \textcolor{comment}{/* Restore the readable handler that was unregistered when the}
01359 \textcolor{comment}{         * script timeout was detected. */}
01360         aeCreateFileEvent(server.el,c->fd,\hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE},
01361                           readQueryFromClient,c);
01362     \}
01363     server.lua\_caller = NULL;
01364 
01365     \textcolor{comment}{/* Call the Lua garbage collector from time to time to avoid a}
01366 \textcolor{comment}{     * full cycle performed by Lua, which adds too latency.}
01367 \textcolor{comment}{     *}
01368 \textcolor{comment}{     * The call is performed every LUA\_GC\_CYCLE\_PERIOD executed commands}
01369 \textcolor{comment}{     * (and for LUA\_GC\_CYCLE\_PERIOD collection steps) because calling it}
01370 \textcolor{comment}{     * for every command uses too much CPU. */}
01371     \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LUA\_GC\_CYCLE\_PERIOD} 50
01372     \{
01373         \textcolor{keyword}{static} \textcolor{keywordtype}{long} gc\_count = 0;
01374 
01375         gc\_count++;
01376         \textcolor{keywordflow}{if} (gc\_count == \hyperlink{scripting_8c_ae050ccd6d490ee95078eda5733c07a58}{LUA\_GC\_CYCLE\_PERIOD}) \{
01377             lua\_gc(lua,LUA\_GCSTEP,\hyperlink{scripting_8c_ae050ccd6d490ee95078eda5733c07a58}{LUA\_GC\_CYCLE\_PERIOD});
01378             gc\_count = 0;
01379         \}
01380     \}
01381 
01382     \textcolor{keywordflow}{if} (err) \{
01383         addReplyErrorFormat(c,\textcolor{stringliteral}{"Error running script (call to %s): %s\(\backslash\)n"},
01384             funcname, lua\_tostring(lua,-1));
01385         lua\_pop(lua,2); \textcolor{comment}{/* Consume the Lua reply and remove error handler. */}
01386     \} \textcolor{keywordflow}{else} \{
01387         \textcolor{comment}{/* On success convert the Lua return value into Redis protocol, and}
01388 \textcolor{comment}{         * send it to * the client. */}
01389         luaReplyToRedisReply(c,lua); \textcolor{comment}{/* Convert and consume the reply. */}
01390         lua\_pop(lua,1); \textcolor{comment}{/* Remove the error handler. */}
01391     \}
01392 
01393     \textcolor{comment}{/* If we are using single commands replication, emit EXEC if there}
01394 \textcolor{comment}{     * was at least a write. */}
01395     \textcolor{keywordflow}{if} (server.lua\_replicate\_commands) \{
01396         preventCommandPropagation(c);
01397         \textcolor{keywordflow}{if} (server.lua\_multi\_emitted) \{
01398             robj *propargv[1];
01399             propargv[0] = createStringObject(\textcolor{stringliteral}{"EXEC"},4);
01400             alsoPropagate(server.execCommand,c->db->id,propargv,1,
01401                 \hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF}|\hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL});
01402             decrRefCount(propargv[0]);
01403         \}
01404     \}
01405 
01406     \textcolor{comment}{/* EVALSHA should be propagated to Slave and AOF file as full EVAL, unless}
01407 \textcolor{comment}{     * we are sure that the script was already in the context of all the}
01408 \textcolor{comment}{     * attached slaves *and* the current AOF file if enabled.}
01409 \textcolor{comment}{     *}
01410 \textcolor{comment}{     * To do so we use a cache of SHA1s of scripts that we already propagated}
01411 \textcolor{comment}{     * as full EVAL, that's called the Replication Script Cache.}
01412 \textcolor{comment}{     *}
01413 \textcolor{comment}{     * For repliation, everytime a new slave attaches to the master, we need to}
01414 \textcolor{comment}{     * flush our cache of scripts that can be replicated as EVALSHA, while}
01415 \textcolor{comment}{     * for AOF we need to do so every time we rewrite the AOF file. */}
01416     \textcolor{keywordflow}{if} (evalsha && !server.lua\_replicate\_commands) \{
01417         \textcolor{keywordflow}{if} (!replicationScriptCacheExists(c->argv[1]->ptr)) \{
01418             \textcolor{comment}{/* This script is not in our script cache, replicate it as}
01419 \textcolor{comment}{             * EVAL, then add it into the script cache, as from now on}
01420 \textcolor{comment}{             * slaves and AOF know about it. */}
01421             robj *script = dictFetchValue(server.lua\_scripts,c->argv[1]->ptr);
01422 
01423             replicationScriptCacheAdd(c->argv[1]->ptr);
01424             \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,script != NULL);
01425             rewriteClientCommandArgument(c,0,
01426                 resetRefCount(createStringObject(\textcolor{stringliteral}{"EVAL"},4)));
01427             rewriteClientCommandArgument(c,1,script);
01428             forceCommandPropagation(c,\hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL}|
      \hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF});
01429         \}
01430     \}
01431 \}
01432 
01433 \textcolor{keywordtype}{void} evalCommand(\hyperlink{structclient}{client} *c) \{
01434     \textcolor{keywordflow}{if} (!(c->flags & \hyperlink{server_8h_a59ed6554c95f9d07bf88bd62574f5946}{CLIENT\_LUA\_DEBUG}))
01435         evalGenericCommand(c,0);
01436     \textcolor{keywordflow}{else}
01437         evalGenericCommandWithDebugging(c,0);
01438 \}
01439 
01440 \textcolor{keywordtype}{void} evalShaCommand(\hyperlink{structclient}{client} *c) \{
01441     \textcolor{keywordflow}{if} (sdslen(c->argv[1]->ptr) != 40) \{
01442         \textcolor{comment}{/* We know that a match is not possible if the provided SHA is}
01443 \textcolor{comment}{         * not the right length. So we return an error ASAP, this way}
01444 \textcolor{comment}{         * evalGenericCommand() can be implemented without string length}
01445 \textcolor{comment}{         * sanity check */}
01446         addReply(c, shared.noscripterr);
01447         \textcolor{keywordflow}{return};
01448     \}
01449     \textcolor{keywordflow}{if} (!(c->flags & \hyperlink{server_8h_a59ed6554c95f9d07bf88bd62574f5946}{CLIENT\_LUA\_DEBUG}))
01450         evalGenericCommand(c,1);
01451     \textcolor{keywordflow}{else} \{
01452         addReplyError(c,\textcolor{stringliteral}{"Please use EVAL instead of EVALSHA for debugging"});
01453         \textcolor{keywordflow}{return};
01454     \}
01455 \}
01456 
01457 \textcolor{keywordtype}{void} scriptCommand(\hyperlink{structclient}{client} *c) \{
01458     \textcolor{keywordflow}{if} (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"help"})) \{
01459         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *help[] = \{
01460 \textcolor{stringliteral}{"debug (yes|sync|no) -- Set the debug mode for subsequent scripts executed."},
01461 \textcolor{stringliteral}{"exists <sha1> [<sha1> ...] -- Return information about the existence of the scripts in the script
       cache."},
01462 \textcolor{stringliteral}{"flush -- Flush the Lua scripts cache. Very dangerous on slaves."},
01463 \textcolor{stringliteral}{"kill -- Kill the currently executing Lua script."},
01464 \textcolor{stringliteral}{"load <script> -- Load a script into the scripts cache, without executing it."},
01465 NULL
01466         \};
01467         addReplyHelp(c, help);
01468     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"flush"})) \{
01469         scriptingReset();
01470         addReply(c,shared.ok);
01471         replicationScriptCacheFlush();
01472         server.dirty++; \textcolor{comment}{/* Propagating this command is a good idea. */}
01473     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->argc >= 2 && !strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"exists"})) \{
01474         \textcolor{keywordtype}{int} j;
01475 
01476         addReplyMultiBulkLen(c, c->argc-2);
01477         \textcolor{keywordflow}{for} (j = 2; j < c->argc; j++) \{
01478             \textcolor{keywordflow}{if} (dictFind(server.lua\_scripts,c->argv[j]->ptr))
01479                 addReply(c,shared.cone);
01480             \textcolor{keywordflow}{else}
01481                 addReply(c,shared.czero);
01482         \}
01483     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->argc == 3 && !strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"load"})) \{
01484         sds sha = luaCreateFunction(c,server.lua,c->argv[2]);
01485         \textcolor{keywordflow}{if} (sha == NULL) \textcolor{keywordflow}{return}; \textcolor{comment}{/* The error was sent by luaCreateFunction(). */}
01486         addReplyBulkCBuffer(c,sha,40);
01487         forceCommandPropagation(c,\hyperlink{server_8h_a59c6e025b4ed85642a0472fc3e73e298}{PROPAGATE\_REPL}|
      \hyperlink{server_8h_a542fb79924ca427c866fd63632f60777}{PROPAGATE\_AOF});
01488     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"kill"})) \{
01489         \textcolor{keywordflow}{if} (server.lua\_caller == NULL) \{
01490             addReplySds(c,sdsnew(\textcolor{stringliteral}{"-NOTBUSY No scripts in execution right now.\(\backslash\)r\(\backslash\)n"}));
01491         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.lua\_write\_dirty) \{
01492             addReplySds(c,sdsnew(\textcolor{stringliteral}{"-UNKILLABLE Sorry the script already executed write commands against
       the dataset. You can either wait the script termination or kill the server in a hard way using the SHUTDOWN
       NOSAVE command.\(\backslash\)r\(\backslash\)n"}));
01493         \} \textcolor{keywordflow}{else} \{
01494             server.lua\_kill = 1;
01495             addReply(c,shared.ok);
01496         \}
01497     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c->argc == 3 && !strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"debug"})) \{
01498         \textcolor{keywordflow}{if} (clientHasPendingReplies(c)) \{
01499             addReplyError(c,\textcolor{stringliteral}{"SCRIPT DEBUG must be called outside a pipeline"});
01500             \textcolor{keywordflow}{return};
01501         \}
01502         \textcolor{keywordflow}{if} (!strcasecmp(c->argv[2]->ptr,\textcolor{stringliteral}{"no"})) \{
01503             ldbDisable(c);
01504             addReply(c,shared.ok);
01505         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[2]->ptr,\textcolor{stringliteral}{"yes"})) \{
01506             ldbEnable(c);
01507             addReply(c,shared.ok);
01508         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[2]->ptr,\textcolor{stringliteral}{"sync"})) \{
01509             ldbEnable(c);
01510             addReply(c,shared.ok);
01511             c->flags |= \hyperlink{server_8h_a2f388b8fa8e4b592be374850524472e5}{CLIENT\_LUA\_DEBUG\_SYNC};
01512         \} \textcolor{keywordflow}{else} \{
01513             addReplyError(c,\textcolor{stringliteral}{"Use SCRIPT DEBUG yes/sync/no"});
01514             \textcolor{keywordflow}{return};
01515         \}
01516     \} \textcolor{keywordflow}{else} \{
01517         addReplyErrorFormat(c, \textcolor{stringliteral}{"Unknown subcommand or wrong number of arguments for '%s'. Try SCRIPT
       HELP"}, (\textcolor{keywordtype}{char}*)c->argv[1]->ptr);
01518     \}
01519 \}
01520 
01521 \textcolor{comment}{/* ---------------------------------------------------------------------------}
01522 \textcolor{comment}{ * LDB: Redis Lua debugging facilities}
01523 \textcolor{comment}{ * ------------------------------------------------------------------------- */}
01524 
01525 \textcolor{comment}{/* Initialize Lua debugger data structures. */}
01526 \textcolor{keywordtype}{void} ldbInit(\textcolor{keywordtype}{void}) \{
01527     ldb.fd = -1;
01528     ldb.active = 0;
01529     ldb.logs = listCreate();
01530     \hyperlink{adlist_8h_a648e4a2d20decff3182a72a608b0b8f2}{listSetFreeMethod}(ldb.logs,(\textcolor{keywordtype}{void} (*)(\textcolor{keywordtype}{void}*))sdsfree);
01531     ldb.children = listCreate();
01532     ldb.src = NULL;
01533     ldb.lines = 0;
01534     ldb.cbuf = sdsempty();
01535 \}
01536 
01537 \textcolor{comment}{/* Remove all the pending messages in the specified list. */}
01538 \textcolor{keywordtype}{void} ldbFlushLog(list *log) \{
01539     listNode *ln;
01540 
01541     \textcolor{keywordflow}{while}((ln = \hyperlink{adlist_8h_aa8dc514bbe217bb2e87c1c77cfa84690}{listFirst}(log)) != NULL)
01542         listDelNode(log,ln);
01543 \}
01544 
01545 \textcolor{comment}{/* Enable debug mode of Lua scripts for this client. */}
01546 \textcolor{keywordtype}{void} ldbEnable(\hyperlink{structclient}{client} *c) \{
01547     c->flags |= \hyperlink{server_8h_a59ed6554c95f9d07bf88bd62574f5946}{CLIENT\_LUA\_DEBUG};
01548     ldbFlushLog(ldb.logs);
01549     ldb.fd = c->fd;
01550     ldb.step = 1;
01551     ldb.bpcount = 0;
01552     ldb.luabp = 0;
01553     sdsfree(ldb.cbuf);
01554     ldb.cbuf = sdsempty();
01555     ldb.maxlen = \hyperlink{scripting_8c_a07ee5952305c31c72b45bebe4e78c05c}{LDB\_MAX\_LEN\_DEFAULT};
01556     ldb.maxlen\_hint\_sent = 0;
01557 \}
01558 
01559 \textcolor{comment}{/* Exit debugging mode from the POV of client. This function is not enough}
01560 \textcolor{comment}{ * to properly shut down a client debugging session, see ldbEndSession()}
01561 \textcolor{comment}{ * for more information. */}
01562 \textcolor{keywordtype}{void} ldbDisable(\hyperlink{structclient}{client} *c) \{
01563     c->flags &= ~(\hyperlink{server_8h_a59ed6554c95f9d07bf88bd62574f5946}{CLIENT\_LUA\_DEBUG}|\hyperlink{server_8h_a2f388b8fa8e4b592be374850524472e5}{CLIENT\_LUA\_DEBUG\_SYNC});
01564 \}
01565 
01566 \textcolor{comment}{/* Append a log entry to the specified LDB log. */}
01567 \textcolor{keywordtype}{void} ldbLog(sds entry) \{
01568     listAddNodeTail(ldb.logs,entry);
01569 \}
01570 
01571 \textcolor{comment}{/* A version of ldbLog() which prevents producing logs greater than}
01572 \textcolor{comment}{ * ldb.maxlen. The first time the limit is reached an hint is generated}
01573 \textcolor{comment}{ * to inform the user that reply trimming can be disabled using the}
01574 \textcolor{comment}{ * debugger "maxlen" command. */}
01575 \textcolor{keywordtype}{void} ldbLogWithMaxLen(sds entry) \{
01576     \textcolor{keywordtype}{int} trimmed = 0;
01577     \textcolor{keywordflow}{if} (ldb.maxlen && sdslen(entry) > ldb.maxlen) \{
01578         sdsrange(entry,0,ldb.maxlen-1);
01579         entry = sdscatlen(entry,\textcolor{stringliteral}{" ..."},4);
01580         trimmed = 1;
01581     \}
01582     ldbLog(entry);
01583     \textcolor{keywordflow}{if} (trimmed && ldb.maxlen\_hint\_sent == 0) \{
01584         ldb.maxlen\_hint\_sent = 1;
01585         ldbLog(sdsnew(
01586         \textcolor{stringliteral}{"<hint> The above reply was trimmed. Use 'maxlen 0' to disable trimming."}));
01587     \}
01588 \}
01589 
01590 \textcolor{comment}{/* Send ldb.logs to the debugging client as a multi-bulk reply}
01591 \textcolor{comment}{ * consisting of simple strings. Log entries which include newlines have them}
01592 \textcolor{comment}{ * replaced with spaces. The entries sent are also consumed. */}
01593 \textcolor{keywordtype}{void} ldbSendLogs(\textcolor{keywordtype}{void}) \{
01594     sds proto = sdsempty();
01595     proto = sdscatfmt(proto,\textcolor{stringliteral}{"*%i\(\backslash\)r\(\backslash\)n"}, (\textcolor{keywordtype}{int})\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(ldb.logs));
01596     \textcolor{keywordflow}{while}(\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(ldb.logs)) \{
01597         listNode *ln = \hyperlink{adlist_8h_aa8dc514bbe217bb2e87c1c77cfa84690}{listFirst}(ldb.logs);
01598         proto = sdscatlen(proto,\textcolor{stringliteral}{"+"},1);
01599         sdsmapchars(ln->value,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"},\textcolor{stringliteral}{"  "},2);
01600         proto = sdscatsds(proto,ln->value);
01601         proto = sdscatlen(proto,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"},2);
01602         listDelNode(ldb.logs,ln);
01603     \}
01604     \textcolor{keywordflow}{if} (write(ldb.fd,proto,sdslen(proto)) == -1) \{
01605         \textcolor{comment}{/* Avoid warning. We don't check the return value of write()}
01606 \textcolor{comment}{         * since the next read() will catch the I/O error and will}
01607 \textcolor{comment}{         * close the debugging session. */}
01608     \}
01609     sdsfree(proto);
01610 \}
01611 
01612 \textcolor{comment}{/* Start a debugging session before calling EVAL implementation.}
01613 \textcolor{comment}{ * The techique we use is to capture the client socket file descriptor,}
01614 \textcolor{comment}{ * in order to perform direct I/O with it from within Lua hooks. This}
01615 \textcolor{comment}{ * way we don't have to re-enter Redis in order to handle I/O.}
01616 \textcolor{comment}{ *}
01617 \textcolor{comment}{ * The function returns 1 if the caller should proceed to call EVAL,}
01618 \textcolor{comment}{ * and 0 if instead the caller should abort the operation (this happens}
01619 \textcolor{comment}{ * for the parent in a forked session, since it's up to the children}
01620 \textcolor{comment}{ * to continue, or when fork returned an error).}
01621 \textcolor{comment}{ *}
01622 \textcolor{comment}{ * The caller should call ldbEndSession() only if ldbStartSession()}
01623 \textcolor{comment}{ * returned 1. */}
01624 \textcolor{keywordtype}{int} ldbStartSession(\hyperlink{structclient}{client} *c) \{
01625     ldb.forked = (c->flags & \hyperlink{server_8h_a2f388b8fa8e4b592be374850524472e5}{CLIENT\_LUA\_DEBUG\_SYNC}) == 0;
01626     \textcolor{keywordflow}{if} (ldb.forked) \{
01627         pid\_t cp = fork();
01628         \textcolor{keywordflow}{if} (cp == -1) \{
01629             addReplyError(c,\textcolor{stringliteral}{"Fork() failed: can't run EVAL in debugging mode."});
01630             \textcolor{keywordflow}{return} 0;
01631         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cp == 0) \{
01632             \textcolor{comment}{/* Child. Let's ignore important signals handled by the parent. */}
01633             \textcolor{keyword}{struct} sigaction act;
01634             sigemptyset(&act.sa\_mask);
01635             act.sa\_flags = 0;
01636             act.sa\_handler = SIG\_IGN;
01637             sigaction(SIGTERM, &act, NULL);
01638             sigaction(SIGINT, &act, NULL);
01639 
01640             \textcolor{comment}{/* Log the creation of the child and close the listening}
01641 \textcolor{comment}{             * socket to make sure if the parent crashes a reset is sent}
01642 \textcolor{comment}{             * to the clients. */}
01643             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Redis forked for debugging eval"});
01644             closeListeningSockets(0);
01645         \} \textcolor{keywordflow}{else} \{
01646             \textcolor{comment}{/* Parent */}
01647             listAddNodeTail(ldb.children,(\textcolor{keywordtype}{void}*)(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})cp);
01648             freeClientAsync(c); \textcolor{comment}{/* Close the client in the parent side. */}
01649             \textcolor{keywordflow}{return} 0;
01650         \}
01651     \} \textcolor{keywordflow}{else} \{
01652         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01653             \textcolor{stringliteral}{"Redis synchronous debugging eval session started"});
01654     \}
01655 
01656     \textcolor{comment}{/* Setup our debugging session. */}
01657     anetBlock(NULL,ldb.fd);
01658     anetSendTimeout(NULL,ldb.fd,5000);
01659     ldb.active = 1;
01660 
01661     \textcolor{comment}{/* First argument of EVAL is the script itself. We split it into different}
01662 \textcolor{comment}{     * lines since this is the way the debugger accesses the source code. */}
01663     sds srcstring = sdsdup(c->argv[1]->ptr);
01664     size\_t srclen = sdslen(srcstring);
01665     \textcolor{keywordflow}{while}(srclen && (srcstring[srclen-1] == \textcolor{stringliteral}{'\(\backslash\)n'} ||
01666                      srcstring[srclen-1] == \textcolor{stringliteral}{'\(\backslash\)r'}))
01667     \{
01668         srcstring[--srclen] = \textcolor{stringliteral}{'\(\backslash\)0'};
01669     \}
01670     sdssetlen(srcstring,srclen);
01671     ldb.src = sdssplitlen(srcstring,sdslen(srcstring),\textcolor{stringliteral}{"\(\backslash\)n"},1,&ldb.lines);
01672     sdsfree(srcstring);
01673     \textcolor{keywordflow}{return} 1;
01674 \}
01675 
01676 \textcolor{comment}{/* End a debugging session after the EVAL call with debugging enabled}
01677 \textcolor{comment}{ * returned. */}
01678 \textcolor{keywordtype}{void} ldbEndSession(\hyperlink{structclient}{client} *c) \{
01679     \textcolor{comment}{/* Emit the remaining logs and an <endsession> mark. */}
01680     ldbLog(sdsnew(\textcolor{stringliteral}{"<endsession>"}));
01681     ldbSendLogs();
01682 
01683     \textcolor{comment}{/* If it's a fork()ed session, we just exit. */}
01684     \textcolor{keywordflow}{if} (ldb.forked) \{
01685         writeToClient(c->fd, c, 0);
01686         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Lua debugging session child exiting"});
01687         exitFromChild(0);
01688     \} \textcolor{keywordflow}{else} \{
01689         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01690             \textcolor{stringliteral}{"Redis synchronous debugging eval session ended"});
01691     \}
01692 
01693     \textcolor{comment}{/* Otherwise let's restore client's state. */}
01694     anetNonBlock(NULL,ldb.fd);
01695     anetSendTimeout(NULL,ldb.fd,0);
01696 
01697     \textcolor{comment}{/* Close the client connectin after sending the final EVAL reply}
01698 \textcolor{comment}{     * in order to signal the end of the debugging session. */}
01699     c->flags |= \hyperlink{server_8h_a8cff2154afcc2e87ac85bdbbe2814091}{CLIENT\_CLOSE\_AFTER\_REPLY};
01700 
01701     \textcolor{comment}{/* Cleanup. */}
01702     sdsfreesplitres(ldb.src,ldb.lines);
01703     ldb.lines = 0;
01704     ldb.active = 0;
01705 \}
01706 
01707 \textcolor{comment}{/* If the specified pid is among the list of children spawned for}
01708 \textcolor{comment}{ * forked debugging sessions, it is removed from the children list.}
01709 \textcolor{comment}{ * If the pid was found non-zero is returned. */}
01710 \textcolor{keywordtype}{int} ldbRemoveChild(pid\_t pid) \{
01711     listNode *ln = listSearchKey(ldb.children,(\textcolor{keywordtype}{void}*)(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})pid);
01712     \textcolor{keywordflow}{if} (ln) \{
01713         listDelNode(ldb.children,ln);
01714         \textcolor{keywordflow}{return} 1;
01715     \}
01716     \textcolor{keywordflow}{return} 0;
01717 \}
01718 
01719 \textcolor{comment}{/* Return the number of children we still did not received termination}
01720 \textcolor{comment}{ * acknowledge via wait() in the parent process. */}
01721 \textcolor{keywordtype}{int} ldbPendingChildren(\textcolor{keywordtype}{void}) \{
01722     \textcolor{keywordflow}{return} \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(ldb.children);
01723 \}
01724 
01725 \textcolor{comment}{/* Kill all the forked sessions. */}
01726 \textcolor{keywordtype}{void} ldbKillForkedSessions(\textcolor{keywordtype}{void}) \{
01727     listIter li;
01728     listNode *ln;
01729 
01730     listRewind(ldb.children,&li);
01731     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
01732         pid\_t pid = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}) ln->value;
01733         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Killing debugging session %ld"},(\textcolor{keywordtype}{long})pid);
01734         kill(pid,SIGKILL);
01735     \}
01736     listRelease(ldb.children);
01737     ldb.children = listCreate();
01738 \}
01739 
01740 \textcolor{comment}{/* Wrapper for EVAL / EVALSHA that enables debugging, and makes sure}
01741 \textcolor{comment}{ * that when EVAL returns, whatever happened, the session is ended. */}
01742 \textcolor{keywordtype}{void} evalGenericCommandWithDebugging(\hyperlink{structclient}{client} *c, \textcolor{keywordtype}{int} evalsha) \{
01743     \textcolor{keywordflow}{if} (ldbStartSession(c)) \{
01744         evalGenericCommand(c,evalsha);
01745         ldbEndSession(c);
01746     \} \textcolor{keywordflow}{else} \{
01747         ldbDisable(c);
01748     \}
01749 \}
01750 
01751 \textcolor{comment}{/* Return a pointer to ldb.src source code line, considering line to be}
01752 \textcolor{comment}{ * one-based, and returning a special string for out of range lines. */}
01753 \textcolor{keywordtype}{char} *ldbGetSourceLine(\textcolor{keywordtype}{int} line) \{
01754     \textcolor{keywordtype}{int} idx = line-1;
01755     \textcolor{keywordflow}{if} (idx < 0 || idx >= ldb.lines) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"<out of range source code line>"};
01756     \textcolor{keywordflow}{return} ldb.src[idx];
01757 \}
01758 
01759 \textcolor{comment}{/* Return true if there is a breakpoint in the specified line. */}
01760 \textcolor{keywordtype}{int} ldbIsBreakpoint(\textcolor{keywordtype}{int} line) \{
01761     \textcolor{keywordtype}{int} j;
01762 
01763     \textcolor{keywordflow}{for} (j = 0; j < ldb.bpcount; j++)
01764         \textcolor{keywordflow}{if} (ldb.bp[j] == line) \textcolor{keywordflow}{return} 1;
01765     \textcolor{keywordflow}{return} 0;
01766 \}
01767 
01768 \textcolor{comment}{/* Add the specified breakpoint. Ignore it if we already reached the max.}
01769 \textcolor{comment}{ * Returns 1 if the breakpoint was added (or was already set). 0 if there is}
01770 \textcolor{comment}{ * no space for the breakpoint or if the line is invalid. */}
01771 \textcolor{keywordtype}{int} ldbAddBreakpoint(\textcolor{keywordtype}{int} line) \{
01772     \textcolor{keywordflow}{if} (line <= 0 || line > ldb.lines) \textcolor{keywordflow}{return} 0;
01773     \textcolor{keywordflow}{if} (!ldbIsBreakpoint(line) && ldb.bpcount != \hyperlink{scripting_8c_a4f3000cf3b5955f8134bfcd2fa340db3}{LDB\_BREAKPOINTS\_MAX}) \{
01774         ldb.bp[ldb.bpcount++] = line;
01775         \textcolor{keywordflow}{return} 1;
01776     \}
01777     \textcolor{keywordflow}{return} 0;
01778 \}
01779 
01780 \textcolor{comment}{/* Remove the specified breakpoint, returning 1 if the operation was}
01781 \textcolor{comment}{ * performed or 0 if there was no such breakpoint. */}
01782 \textcolor{keywordtype}{int} ldbDelBreakpoint(\textcolor{keywordtype}{int} line) \{
01783     \textcolor{keywordtype}{int} j;
01784 
01785     \textcolor{keywordflow}{for} (j = 0; j < ldb.bpcount; j++) \{
01786         \textcolor{keywordflow}{if} (ldb.bp[j] == line) \{
01787             ldb.bpcount--;
01788             memmove(ldb.bp+j,ldb.bp+j+1,ldb.bpcount-j);
01789             \textcolor{keywordflow}{return} 1;
01790         \}
01791     \}
01792     \textcolor{keywordflow}{return} 0;
01793 \}
01794 
01795 \textcolor{comment}{/* Expect a valid multi-bulk command in the debugging client query buffer.}
01796 \textcolor{comment}{ * On success the command is parsed and returned as an array of SDS strings,}
01797 \textcolor{comment}{ * otherwise NULL is returned and there is to read more buffer. */}
01798 sds *ldbReplParseCommand(\textcolor{keywordtype}{int} *argcp) \{
01799     sds *argv = NULL;
01800     \textcolor{keywordtype}{int} argc = 0;
01801     \textcolor{keywordflow}{if} (sdslen(ldb.cbuf) == 0) \textcolor{keywordflow}{return} NULL;
01802 
01803     \textcolor{comment}{/* Working on a copy is simpler in this case. We can modify it freely}
01804 \textcolor{comment}{     * for the sake of simpler parsing. */}
01805     sds copy = sdsdup(ldb.cbuf);
01806     \textcolor{keywordtype}{char} *p = copy;
01807 
01808     \textcolor{comment}{/* This Redis protocol parser is a joke... just the simplest thing that}
01809 \textcolor{comment}{     * works in this context. It is also very forgiving regarding broken}
01810 \textcolor{comment}{     * protocol. */}
01811 
01812     \textcolor{comment}{/* Seek and parse *<count>\(\backslash\)r\(\backslash\)n. */}
01813     p = strchr(p,\textcolor{stringliteral}{'*'}); \textcolor{keywordflow}{if} (!p) \textcolor{keywordflow}{goto} protoerr;
01814     \textcolor{keywordtype}{char} *plen = p+1; \textcolor{comment}{/* Multi bulk len pointer. */}
01815     p = strstr(p,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"}); \textcolor{keywordflow}{if} (!p) \textcolor{keywordflow}{goto} protoerr;
01816     *p = \textcolor{stringliteral}{'\(\backslash\)0'}; p += 2;
01817     *argcp = atoi(plen);
01818     \textcolor{keywordflow}{if} (*argcp <= 0 || *argcp > 1024) \textcolor{keywordflow}{goto} protoerr;
01819 
01820     \textcolor{comment}{/* Parse each argument. */}
01821     argv = zmalloc(\textcolor{keyword}{sizeof}(sds)*(*argcp));
01822     argc = 0;
01823     \textcolor{keywordflow}{while}(argc < *argcp) \{
01824         \textcolor{keywordflow}{if} (*p != \textcolor{stringliteral}{'$'}) \textcolor{keywordflow}{goto} protoerr;
01825         plen = p+1; \textcolor{comment}{/* Bulk string len pointer. */}
01826         p = strstr(p,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"}); \textcolor{keywordflow}{if} (!p) \textcolor{keywordflow}{goto} protoerr;
01827         *p = \textcolor{stringliteral}{'\(\backslash\)0'}; p += 2;
01828         \textcolor{keywordtype}{int} slen = atoi(plen); \textcolor{comment}{/* Length of this arg. */}
01829         \textcolor{keywordflow}{if} (slen <= 0 || slen > 1024) \textcolor{keywordflow}{goto} protoerr;
01830         argv[argc++] = sdsnewlen(p,slen);
01831         p += slen; \textcolor{comment}{/* Skip the already parsed argument. */}
01832         \textcolor{keywordflow}{if} (p[0] != \textcolor{stringliteral}{'\(\backslash\)r'} || p[1] != \textcolor{stringliteral}{'\(\backslash\)n'}) \textcolor{keywordflow}{goto} protoerr;
01833         p += 2; \textcolor{comment}{/* Skip \(\backslash\)r\(\backslash\)n. */}
01834     \}
01835     sdsfree(copy);
01836     \textcolor{keywordflow}{return} argv;
01837 
01838 protoerr:
01839     sdsfreesplitres(argv,argc);
01840     sdsfree(copy);
01841     \textcolor{keywordflow}{return} NULL;
01842 \}
01843 
01844 \textcolor{comment}{/* Log the specified line in the Lua debugger output. */}
01845 \textcolor{keywordtype}{void} ldbLogSourceLine(\textcolor{keywordtype}{int} lnum) \{
01846     \textcolor{keywordtype}{char} *line = ldbGetSourceLine(lnum);
01847     \textcolor{keywordtype}{char} *prefix;
01848     \textcolor{keywordtype}{int} bp = ldbIsBreakpoint(lnum);
01849     \textcolor{keywordtype}{int} current = ldb.currentline == lnum;
01850 
01851     \textcolor{keywordflow}{if} (current && bp)
01852         prefix = \textcolor{stringliteral}{"->#"};
01853     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (current)
01854         prefix = \textcolor{stringliteral}{"-> "};
01855     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (bp)
01856         prefix = \textcolor{stringliteral}{"  #"};
01857     \textcolor{keywordflow}{else}
01858         prefix = \textcolor{stringliteral}{"   "};
01859     sds thisline = sdscatprintf(sdsempty(),\textcolor{stringliteral}{"%s%-3d %s"}, prefix, lnum, line);
01860     ldbLog(thisline);
01861 \}
01862 
01863 \textcolor{comment}{/* Implement the "list" command of the Lua debugger. If around is 0}
01864 \textcolor{comment}{ * the whole file is listed, otherwise only a small portion of the file}
01865 \textcolor{comment}{ * around the specified line is shown. When a line number is specified}
01866 \textcolor{comment}{ * the amonut of context (lines before/after) is specified via the}
01867 \textcolor{comment}{ * 'context' argument. */}
01868 \textcolor{keywordtype}{void} ldbList(\textcolor{keywordtype}{int} around, \textcolor{keywordtype}{int} context) \{
01869     \textcolor{keywordtype}{int} j;
01870 
01871     \textcolor{keywordflow}{for} (j = 1; j <= ldb.lines; j++) \{
01872         \textcolor{keywordflow}{if} (around != 0 && abs(around-j) > context) \textcolor{keywordflow}{continue};
01873         ldbLogSourceLine(j);
01874     \}
01875 \}
01876 
01877 \textcolor{comment}{/* Append an human readable representation of the Lua value at position 'idx'}
01878 \textcolor{comment}{ * on the stack of the 'lua' state, to the SDS string passed as argument.}
01879 \textcolor{comment}{ * The new SDS string with the represented value attached is returned.}
01880 \textcolor{comment}{ * Used in order to implement ldbLogStackValue().}
01881 \textcolor{comment}{ *}
01882 \textcolor{comment}{ * The element is not automatically removed from the stack, nor it is}
01883 \textcolor{comment}{ * converted to a different type. */}
01884 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{LDB\_MAX\_VALUES\_DEPTH} \textcolor{preprocessor}{(}\textcolor{preprocessor}{LUA\_MINSTACK}\textcolor{preprocessor}{/}2\textcolor{preprocessor}{)}
01885 sds ldbCatStackValueRec(sds s, lua\_State *lua, \textcolor{keywordtype}{int} idx, \textcolor{keywordtype}{int} level) \{
01886     \textcolor{keywordtype}{int} t = lua\_type(lua,idx);
01887 
01888     \textcolor{keywordflow}{if} (level++ == \hyperlink{scripting_8c_a710b4655ec5cbdef50fc86e83d6891ef}{LDB\_MAX\_VALUES\_DEPTH})
01889         \textcolor{keywordflow}{return} sdscat(s,\textcolor{stringliteral}{"<max recursion level reached! Nested table?>"});
01890 
01891     \textcolor{keywordflow}{switch}(t) \{
01892     \textcolor{keywordflow}{case} LUA\_TSTRING:
01893         \{
01894         size\_t strl;
01895         \textcolor{keywordtype}{char} *strp = (\textcolor{keywordtype}{char}*)lua\_tolstring(lua,idx,&strl);
01896         s = sdscatrepr(s,strp,strl);
01897         \}
01898         \textcolor{keywordflow}{break};
01899     \textcolor{keywordflow}{case} LUA\_TBOOLEAN:
01900         s = sdscat(s,lua\_toboolean(lua,idx) ? \textcolor{stringliteral}{"true"} : \textcolor{stringliteral}{"false"});
01901         \textcolor{keywordflow}{break};
01902     \textcolor{keywordflow}{case} LUA\_TNUMBER:
01903         s = sdscatprintf(s,\textcolor{stringliteral}{"%g"},(\textcolor{keywordtype}{double})lua\_tonumber(lua,idx));
01904         \textcolor{keywordflow}{break};
01905     \textcolor{keywordflow}{case} LUA\_TNIL:
01906         s = sdscatlen(s,\textcolor{stringliteral}{"nil"},3);
01907         \textcolor{keywordflow}{break};
01908     \textcolor{keywordflow}{case} LUA\_TTABLE:
01909         \{
01910         \textcolor{keywordtype}{int} expected\_index = 1; \textcolor{comment}{/* First index we expect in an array. */}
01911         \textcolor{keywordtype}{int} is\_array = 1; \textcolor{comment}{/* Will be set to null if check fails. */}
01912         \textcolor{comment}{/* Note: we create two representations at the same time, one}
01913 \textcolor{comment}{         * assuming the table is an array, one assuming it is not. At the}
01914 \textcolor{comment}{         * end we know what is true and select the right one. */}
01915         sds repr1 = sdsempty();
01916         sds repr2 = sdsempty();
01917         lua\_pushnil(lua); \textcolor{comment}{/* The first key to start the iteration is nil. */}
01918         \textcolor{keywordflow}{while} (lua\_next(lua,idx-1)) \{
01919             \textcolor{comment}{/* Test if so far the table looks like an array. */}
01920             \textcolor{keywordflow}{if} (is\_array &&
01921                 (lua\_type(lua,-2) != LUA\_TNUMBER ||
01922                  lua\_tonumber(lua,-2) != expected\_index)) is\_array = 0;
01923             \textcolor{comment}{/* Stack now: table, key, value */}
01924             \textcolor{comment}{/* Array repr. */}
01925             repr1 = ldbCatStackValueRec(repr1,lua,-1,level);
01926             repr1 = sdscatlen(repr1,\textcolor{stringliteral}{"; "},2);
01927             \textcolor{comment}{/* Full repr. */}
01928             repr2 = sdscatlen(repr2,\textcolor{stringliteral}{"["},1);
01929             repr2 = ldbCatStackValueRec(repr2,lua,-2,level);
01930             repr2 = sdscatlen(repr2,\textcolor{stringliteral}{"]="},2);
01931             repr2 = ldbCatStackValueRec(repr2,lua,-1,level);
01932             repr2 = sdscatlen(repr2,\textcolor{stringliteral}{"; "},2);
01933             lua\_pop(lua,1); \textcolor{comment}{/* Stack: table, key. Ready for next iteration. */}
01934             expected\_index++;
01935         \}
01936         \textcolor{comment}{/* Strip the last " ;" from both the representations. */}
01937         \textcolor{keywordflow}{if} (sdslen(repr1)) sdsrange(repr1,0,-3);
01938         \textcolor{keywordflow}{if} (sdslen(repr2)) sdsrange(repr2,0,-3);
01939         \textcolor{comment}{/* Select the right one and discard the other. */}
01940         s = sdscatlen(s,\textcolor{stringliteral}{"\{"},1);
01941         s = sdscatsds(s,is\_array ? repr1 : repr2);
01942         s = sdscatlen(s,\textcolor{stringliteral}{"\}"},1);
01943         sdsfree(repr1);
01944         sdsfree(repr2);
01945         \}
01946         \textcolor{keywordflow}{break};
01947     \textcolor{keywordflow}{case} LUA\_TFUNCTION:
01948     \textcolor{keywordflow}{case} LUA\_TUSERDATA:
01949     \textcolor{keywordflow}{case} LUA\_TTHREAD:
01950     \textcolor{keywordflow}{case} LUA\_TLIGHTUSERDATA:
01951         \{
01952         \textcolor{keyword}{const} \textcolor{keywordtype}{void} *p = lua\_topointer(lua,idx);
01953         \textcolor{keywordtype}{char} *\textcolor{keyword}{typename} = \textcolor{stringliteral}{"unknown"};
01954         \textcolor{keywordflow}{if} (t == LUA\_TFUNCTION) \textcolor{keyword}{typename} = \textcolor{stringliteral}{"function"};
01955         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (t == LUA\_TUSERDATA) \textcolor{keyword}{typename} = \textcolor{stringliteral}{"userdata"};
01956         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (t == LUA\_TTHREAD) \textcolor{keyword}{typename} = \textcolor{stringliteral}{"thread"};
01957         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (t == LUA\_TLIGHTUSERDATA) \textcolor{keyword}{typename} = \textcolor{stringliteral}{"light-userdata"};
01958         s = sdscatprintf(s,\textcolor{stringliteral}{"\(\backslash\)"%s@%p\(\backslash\)""},\textcolor{keyword}{typename},p);
01959         \}
01960         \textcolor{keywordflow}{break};
01961     \textcolor{keywordflow}{default}:
01962         s = sdscat(s,\textcolor{stringliteral}{"\(\backslash\)"<unknown-lua-type>\(\backslash\)""});
01963         \textcolor{keywordflow}{break};
01964     \}
01965     \textcolor{keywordflow}{return} s;
01966 \}
01967 
01968 \textcolor{comment}{/* Higher level wrapper for ldbCatStackValueRec() that just uses an initial}
01969 \textcolor{comment}{ * recursion level of '0'. */}
01970 sds ldbCatStackValue(sds s, lua\_State *lua, \textcolor{keywordtype}{int} idx) \{
01971     \textcolor{keywordflow}{return} ldbCatStackValueRec(s,lua,idx,0);
01972 \}
01973 
01974 \textcolor{comment}{/* Produce a debugger log entry representing the value of the Lua object}
01975 \textcolor{comment}{ * currently on the top of the stack. The element is ot popped nor modified.}
01976 \textcolor{comment}{ * Check ldbCatStackValue() for the actual implementation. */}
01977 \textcolor{keywordtype}{void} ldbLogStackValue(lua\_State *lua, \textcolor{keywordtype}{char} *prefix) \{
01978     sds s = sdsnew(prefix);
01979     s = ldbCatStackValue(s,lua,-1);
01980     ldbLogWithMaxLen(s);
01981 \}
01982 
01983 \textcolor{keywordtype}{char} *ldbRedisProtocolToHuman\_Int(sds *o, \textcolor{keywordtype}{char} *reply);
01984 \textcolor{keywordtype}{char} *ldbRedisProtocolToHuman\_Bulk(sds *o, \textcolor{keywordtype}{char} *reply);
01985 \textcolor{keywordtype}{char} *ldbRedisProtocolToHuman\_Status(sds *o, \textcolor{keywordtype}{char} *reply);
01986 \textcolor{keywordtype}{char} *ldbRedisProtocolToHuman\_MultiBulk(sds *o, \textcolor{keywordtype}{char} *reply);
01987 
01988 \textcolor{comment}{/* Get Redis protocol from 'reply' and appends it in human readable form to}
01989 \textcolor{comment}{ * the passed SDS string 'o'.}
01990 \textcolor{comment}{ *}
01991 \textcolor{comment}{ * Note that the SDS string is passed by reference (pointer of pointer to}
01992 \textcolor{comment}{ * char*) so that we can return a modified pointer, as for SDS semantics. */}
01993 \textcolor{keywordtype}{char} *ldbRedisProtocolToHuman(sds *o, \textcolor{keywordtype}{char} *reply) \{
01994     \textcolor{keywordtype}{char} *p = reply;
01995     \textcolor{keywordflow}{switch}(*p) \{
01996     \textcolor{keywordflow}{case} \textcolor{stringliteral}{':'}: p = ldbRedisProtocolToHuman\_Int(o,reply); \textcolor{keywordflow}{break};
01997     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'$'}: p = ldbRedisProtocolToHuman\_Bulk(o,reply); \textcolor{keywordflow}{break};
01998     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'+'}: p = ldbRedisProtocolToHuman\_Status(o,reply); \textcolor{keywordflow}{break};
01999     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'-'}: p = ldbRedisProtocolToHuman\_Status(o,reply); \textcolor{keywordflow}{break};
02000     \textcolor{keywordflow}{case} \textcolor{stringliteral}{'*'}: p = ldbRedisProtocolToHuman\_MultiBulk(o,reply); \textcolor{keywordflow}{break};
02001     \}
02002     \textcolor{keywordflow}{return} p;
02003 \}
02004 
02005 \textcolor{comment}{/* The following functions are helpers for ldbRedisProtocolToHuman(), each}
02006 \textcolor{comment}{ * take care of a given Redis return type. */}
02007 
02008 \textcolor{keywordtype}{char} *ldbRedisProtocolToHuman\_Int(sds *o, \textcolor{keywordtype}{char} *reply) \{
02009     \textcolor{keywordtype}{char} *p = strchr(reply+1,\textcolor{stringliteral}{'\(\backslash\)r'});
02010     *o = sdscatlen(*o,reply+1,p-reply-1);
02011     \textcolor{keywordflow}{return} p+2;
02012 \}
02013 
02014 \textcolor{keywordtype}{char} *ldbRedisProtocolToHuman\_Bulk(sds *o, \textcolor{keywordtype}{char} *reply) \{
02015     \textcolor{keywordtype}{char} *p = strchr(reply+1,\textcolor{stringliteral}{'\(\backslash\)r'});
02016     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} bulklen;
02017 
02018     string2ll(reply+1,p-reply-1,&bulklen);
02019     \textcolor{keywordflow}{if} (bulklen == -1) \{
02020         *o = sdscatlen(*o,\textcolor{stringliteral}{"NULL"},4);
02021         \textcolor{keywordflow}{return} p+2;
02022     \} \textcolor{keywordflow}{else} \{
02023         *o = sdscatrepr(*o,p+2,bulklen);
02024         \textcolor{keywordflow}{return} p+2+bulklen+2;
02025     \}
02026 \}
02027 
02028 \textcolor{keywordtype}{char} *ldbRedisProtocolToHuman\_Status(sds *o, \textcolor{keywordtype}{char} *reply) \{
02029     \textcolor{keywordtype}{char} *p = strchr(reply+1,\textcolor{stringliteral}{'\(\backslash\)r'});
02030 
02031     *o = sdscatrepr(*o,reply,p-reply);
02032     \textcolor{keywordflow}{return} p+2;
02033 \}
02034 
02035 \textcolor{keywordtype}{char} *ldbRedisProtocolToHuman\_MultiBulk(sds *o, \textcolor{keywordtype}{char} *reply) \{
02036     \textcolor{keywordtype}{char} *p = strchr(reply+1,\textcolor{stringliteral}{'\(\backslash\)r'});
02037     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} mbulklen;
02038     \textcolor{keywordtype}{int} j = 0;
02039 
02040     string2ll(reply+1,p-reply-1,&mbulklen);
02041     p += 2;
02042     \textcolor{keywordflow}{if} (mbulklen == -1) \{
02043         *o = sdscatlen(*o,\textcolor{stringliteral}{"NULL"},4);
02044         \textcolor{keywordflow}{return} p;
02045     \}
02046     *o = sdscatlen(*o,\textcolor{stringliteral}{"["},1);
02047     \textcolor{keywordflow}{for} (j = 0; j < mbulklen; j++) \{
02048         p = ldbRedisProtocolToHuman(o,p);
02049         \textcolor{keywordflow}{if} (j != mbulklen-1) *o = sdscatlen(*o,\textcolor{stringliteral}{","},1);
02050     \}
02051     *o = sdscatlen(*o,\textcolor{stringliteral}{"]"},1);
02052     \textcolor{keywordflow}{return} p;
02053 \}
02054 
02055 \textcolor{comment}{/* Log a Redis reply as debugger output, in an human readable format.}
02056 \textcolor{comment}{ * If the resulting string is longer than 'len' plus a few more chars}
02057 \textcolor{comment}{ * used as prefix, it gets truncated. */}
02058 \textcolor{keywordtype}{void} ldbLogRedisReply(\textcolor{keywordtype}{char} *reply) \{
02059     sds log = sdsnew(\textcolor{stringliteral}{"<reply> "});
02060     ldbRedisProtocolToHuman(&log,reply);
02061     ldbLogWithMaxLen(log);
02062 \}
02063 
02064 \textcolor{comment}{/* Implements the "print <var>" command of the Lua debugger. It scans for Lua}
02065 \textcolor{comment}{ * var "varname" starting from the current stack frame up to the top stack}
02066 \textcolor{comment}{ * frame. The first matching variable is printed. */}
02067 \textcolor{keywordtype}{void} ldbPrint(lua\_State *lua, \textcolor{keywordtype}{char} *varname) \{
02068     lua\_Debug ar;
02069 
02070     \textcolor{keywordtype}{int} l = 0; \textcolor{comment}{/* Stack level. */}
02071     \textcolor{keywordflow}{while} (lua\_getstack(lua,l,&ar) != 0) \{
02072         l++;
02073         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *name;
02074         \textcolor{keywordtype}{int} i = 1; \textcolor{comment}{/* Variable index. */}
02075         \textcolor{keywordflow}{while}((name = lua\_getlocal(lua,&ar,i)) != NULL) \{
02076             i++;
02077             \textcolor{keywordflow}{if} (strcmp(varname,name) == 0) \{
02078                 ldbLogStackValue(lua,\textcolor{stringliteral}{"<value> "});
02079                 lua\_pop(lua,1);
02080                 \textcolor{keywordflow}{return};
02081             \} \textcolor{keywordflow}{else} \{
02082                 lua\_pop(lua,1); \textcolor{comment}{/* Discard the var name on the stack. */}
02083             \}
02084         \}
02085     \}
02086 
02087     \textcolor{comment}{/* Let's try with global vars in two selected cases */}
02088     \textcolor{keywordflow}{if} (!strcmp(varname,\textcolor{stringliteral}{"ARGV"}) || !strcmp(varname,\textcolor{stringliteral}{"KEYS"})) \{
02089         lua\_getglobal(lua, varname);
02090         ldbLogStackValue(lua,\textcolor{stringliteral}{"<value> "});
02091         lua\_pop(lua,1);
02092     \} \textcolor{keywordflow}{else} \{
02093         ldbLog(sdsnew(\textcolor{stringliteral}{"No such variable."}));
02094     \}
02095 \}
02096 
02097 \textcolor{comment}{/* Implements the "print" command (without arguments) of the Lua debugger.}
02098 \textcolor{comment}{ * Prints all the variables in the current stack frame. */}
02099 \textcolor{keywordtype}{void} ldbPrintAll(lua\_State *lua) \{
02100     lua\_Debug ar;
02101     \textcolor{keywordtype}{int} vars = 0;
02102 
02103     \textcolor{keywordflow}{if} (lua\_getstack(lua,0,&ar) != 0) \{
02104         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *name;
02105         \textcolor{keywordtype}{int} i = 1; \textcolor{comment}{/* Variable index. */}
02106         \textcolor{keywordflow}{while}((name = lua\_getlocal(lua,&ar,i)) != NULL) \{
02107             i++;
02108             \textcolor{keywordflow}{if} (!strstr(name,\textcolor{stringliteral}{"(*temporary)"})) \{
02109                 sds prefix = sdscatprintf(sdsempty(),\textcolor{stringliteral}{"<value> %s = "},name);
02110                 ldbLogStackValue(lua,prefix);
02111                 sdsfree(prefix);
02112                 vars++;
02113             \}
02114             lua\_pop(lua,1);
02115         \}
02116     \}
02117 
02118     \textcolor{keywordflow}{if} (vars == 0) \{
02119         ldbLog(sdsnew(\textcolor{stringliteral}{"No local variables in the current context."}));
02120     \}
02121 \}
02122 
02123 \textcolor{comment}{/* Implements the break command to list, add and remove breakpoints. */}
02124 \textcolor{keywordtype}{void} ldbBreak(sds *argv, \textcolor{keywordtype}{int} argc) \{
02125     \textcolor{keywordflow}{if} (argc == 1) \{
02126         \textcolor{keywordflow}{if} (ldb.bpcount == 0) \{
02127             ldbLog(sdsnew(\textcolor{stringliteral}{"No breakpoints set. Use 'b <line>' to add one."}));
02128             \textcolor{keywordflow}{return};
02129         \} \textcolor{keywordflow}{else} \{
02130             ldbLog(sdscatfmt(sdsempty(),\textcolor{stringliteral}{"%i breakpoints set:"},ldb.bpcount));
02131             \textcolor{keywordtype}{int} j;
02132             \textcolor{keywordflow}{for} (j = 0; j < ldb.bpcount; j++)
02133                 ldbLogSourceLine(ldb.bp[j]);
02134         \}
02135     \} \textcolor{keywordflow}{else} \{
02136         \textcolor{keywordtype}{int} j;
02137         \textcolor{keywordflow}{for} (j = 1; j < argc; j++) \{
02138             \textcolor{keywordtype}{char} *arg = argv[j];
02139             \textcolor{keywordtype}{long} line;
02140             \textcolor{keywordflow}{if} (!string2l(arg,sdslen(arg),&line)) \{
02141                 ldbLog(sdscatfmt(sdsempty(),\textcolor{stringliteral}{"Invalid argument:'%s'"},arg));
02142             \} \textcolor{keywordflow}{else} \{
02143                 \textcolor{keywordflow}{if} (line == 0) \{
02144                     ldb.bpcount = 0;
02145                     ldbLog(sdsnew(\textcolor{stringliteral}{"All breakpoints removed."}));
02146                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (line > 0) \{
02147                     \textcolor{keywordflow}{if} (ldb.bpcount == \hyperlink{scripting_8c_a4f3000cf3b5955f8134bfcd2fa340db3}{LDB\_BREAKPOINTS\_MAX}) \{
02148                         ldbLog(sdsnew(\textcolor{stringliteral}{"Too many breakpoints set."}));
02149                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ldbAddBreakpoint(line)) \{
02150                         ldbList(line,1);
02151                     \} \textcolor{keywordflow}{else} \{
02152                         ldbLog(sdsnew(\textcolor{stringliteral}{"Wrong line number."}));
02153                     \}
02154                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (line < 0) \{
02155                     \textcolor{keywordflow}{if} (ldbDelBreakpoint(-line))
02156                         ldbLog(sdsnew(\textcolor{stringliteral}{"Breakpoint removed."}));
02157                     \textcolor{keywordflow}{else}
02158                         ldbLog(sdsnew(\textcolor{stringliteral}{"No breakpoint in the specified line."}));
02159                 \}
02160             \}
02161         \}
02162     \}
02163 \}
02164 
02165 \textcolor{comment}{/* Implements the Lua debugger "eval" command. It just compiles the user}
02166 \textcolor{comment}{ * passed fragment of code and executes it, showing the result left on}
02167 \textcolor{comment}{ * the stack. */}
02168 \textcolor{keywordtype}{void} ldbEval(lua\_State *lua, sds *argv, \textcolor{keywordtype}{int} argc) \{
02169     \textcolor{comment}{/* Glue the script together if it is composed of multiple arguments. */}
02170     sds code = sdsjoinsds(argv+1,argc-1,\textcolor{stringliteral}{" "},1);
02171     sds expr = sdscatsds(sdsnew(\textcolor{stringliteral}{"return "}),code);
02172 
02173     \textcolor{comment}{/* Try to compile it as an expression, prepending "return ". */}
02174     \textcolor{keywordflow}{if} (luaL\_loadbuffer(lua,expr,sdslen(expr),\textcolor{stringliteral}{"@ldb\_eval"})) \{
02175         lua\_pop(lua,1);
02176         \textcolor{comment}{/* Failed? Try as a statement. */}
02177         \textcolor{keywordflow}{if} (luaL\_loadbuffer(lua,code,sdslen(code),\textcolor{stringliteral}{"@ldb\_eval"})) \{
02178             ldbLog(sdscatfmt(sdsempty(),\textcolor{stringliteral}{"<error> %s"},lua\_tostring(lua,-1)));
02179             lua\_pop(lua,1);
02180             sdsfree(code);
02181             \textcolor{keywordflow}{return};
02182         \}
02183     \}
02184 
02185     \textcolor{comment}{/* Call it. */}
02186     sdsfree(code);
02187     sdsfree(expr);
02188     \textcolor{keywordflow}{if} (lua\_pcall(lua,0,1,0)) \{
02189         ldbLog(sdscatfmt(sdsempty(),\textcolor{stringliteral}{"<error> %s"},lua\_tostring(lua,-1)));
02190         lua\_pop(lua,1);
02191         \textcolor{keywordflow}{return};
02192     \}
02193     ldbLogStackValue(lua,\textcolor{stringliteral}{"<retval> "});
02194     lua\_pop(lua,1);
02195 \}
02196 
02197 \textcolor{comment}{/* Implement the debugger "redis" command. We use a trick in order to make}
02198 \textcolor{comment}{ * the implementation very simple: we just call the Lua redis.call() command}
02199 \textcolor{comment}{ * implementation, with ldb.step enabled, so as a side effect the Redis command}
02200 \textcolor{comment}{ * and its reply are logged. */}
02201 \textcolor{keywordtype}{void} ldbRedis(lua\_State *lua, sds *argv, \textcolor{keywordtype}{int} argc) \{
02202     \textcolor{keywordtype}{int} j, saved\_rc = server.lua\_replicate\_commands;
02203 
02204     lua\_getglobal(lua,\textcolor{stringliteral}{"redis"});
02205     lua\_pushstring(lua,\textcolor{stringliteral}{"call"});
02206     lua\_gettable(lua,-2);       \textcolor{comment}{/* Stack: redis, redis.call */}
02207     \textcolor{keywordflow}{for} (j = 1; j < argc; j++)
02208         lua\_pushlstring(lua,argv[j],sdslen(argv[j]));
02209     ldb.step = 1;               \textcolor{comment}{/* Force redis.call() to log. */}
02210     server.lua\_replicate\_commands = 1;
02211     lua\_pcall(lua,argc-1,1,0);  \textcolor{comment}{/* Stack: redis, result */}
02212     ldb.step = 0;               \textcolor{comment}{/* Disable logging. */}
02213     server.lua\_replicate\_commands = saved\_rc;
02214     lua\_pop(lua,2);             \textcolor{comment}{/* Discard the result and clean the stack. */}
02215 \}
02216 
02217 \textcolor{comment}{/* Implements "trace" command of the Lua debugger. It just prints a backtrace}
02218 \textcolor{comment}{ * querying Lua starting from the current callframe back to the outer one. */}
02219 \textcolor{keywordtype}{void} ldbTrace(lua\_State *lua) \{
02220     lua\_Debug ar;
02221     \textcolor{keywordtype}{int} level = 0;
02222 
02223     \textcolor{keywordflow}{while}(lua\_getstack(lua,level,&ar)) \{
02224         lua\_getinfo(lua,\textcolor{stringliteral}{"Snl"},&ar);
02225         \textcolor{keywordflow}{if}(strstr(ar.short\_src,\textcolor{stringliteral}{"user\_script"}) != NULL) \{
02226             ldbLog(sdscatprintf(sdsempty(),\textcolor{stringliteral}{"%s %s:"},
02227                 (level == 0) ? \textcolor{stringliteral}{"In"} : \textcolor{stringliteral}{"From"},
02228                 ar.name ? ar.name : \textcolor{stringliteral}{"top level"}));
02229             ldbLogSourceLine(ar.currentline);
02230         \}
02231         level++;
02232     \}
02233     \textcolor{keywordflow}{if} (level == 0) \{
02234         ldbLog(sdsnew(\textcolor{stringliteral}{"<error> Can't retrieve Lua stack."}));
02235     \}
02236 \}
02237 
02238 \textcolor{comment}{/* Impleemnts the debugger "maxlen" command. It just queries or sets the}
02239 \textcolor{comment}{ * ldb.maxlen variable. */}
02240 \textcolor{keywordtype}{void} ldbMaxlen(sds *argv, \textcolor{keywordtype}{int} argc) \{
02241     \textcolor{keywordflow}{if} (argc == 2) \{
02242         \textcolor{keywordtype}{int} newval = atoi(argv[1]);
02243         ldb.maxlen\_hint\_sent = 1; \textcolor{comment}{/* User knows about this command. */}
02244         \textcolor{keywordflow}{if} (newval != 0 && newval <= 60) newval = 60;
02245         ldb.maxlen = newval;
02246     \}
02247     \textcolor{keywordflow}{if} (ldb.maxlen) \{
02248         ldbLog(sdscatprintf(sdsempty(),\textcolor{stringliteral}{"<value> replies are truncated at %d bytes."},(\textcolor{keywordtype}{int})ldb.maxlen));
02249     \} \textcolor{keywordflow}{else} \{
02250         ldbLog(sdscatprintf(sdsempty(),\textcolor{stringliteral}{"<value> replies are unlimited."}));
02251     \}
02252 \}
02253 
02254 \textcolor{comment}{/* Read debugging commands from client.}
02255 \textcolor{comment}{ * Return C\_OK if the debugging session is continuing, otherwise}
02256 \textcolor{comment}{ * C\_ERR if the client closed the connection or is timing out. */}
02257 \textcolor{keywordtype}{int} ldbRepl(lua\_State *lua) \{
02258     sds *argv;
02259     \textcolor{keywordtype}{int} argc;
02260 
02261     \textcolor{comment}{/* We continue processing commands until a command that should return}
02262 \textcolor{comment}{     * to the Lua interpreter is found. */}
02263     \textcolor{keywordflow}{while}(1) \{
02264         \textcolor{keywordflow}{while}((argv = ldbReplParseCommand(&argc)) == NULL) \{
02265             \textcolor{keywordtype}{char} buf[1024];
02266             \textcolor{keywordtype}{int} nread = read(ldb.fd,buf,\textcolor{keyword}{sizeof}(buf));
02267             \textcolor{keywordflow}{if} (nread <= 0) \{
02268                 \textcolor{comment}{/* Make sure the script runs without user input since the}
02269 \textcolor{comment}{                 * client is no longer connected. */}
02270                 ldb.step = 0;
02271                 ldb.bpcount = 0;
02272                 \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
02273             \}
02274             ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);
02275         \}
02276 
02277         \textcolor{comment}{/* Flush the old buffer. */}
02278         sdsfree(ldb.cbuf);
02279         ldb.cbuf = sdsempty();
02280 
02281         \textcolor{comment}{/* Execute the command. */}
02282         \textcolor{keywordflow}{if} (!strcasecmp(argv[0],\textcolor{stringliteral}{"h"}) || !strcasecmp(argv[0],\textcolor{stringliteral}{"help"})) \{
02283 ldbLog(sdsnew(\textcolor{stringliteral}{"Redis Lua debugger help:"}));
02284 ldbLog(sdsnew(\textcolor{stringliteral}{"[h]elp               Show this help."}));
02285 ldbLog(sdsnew(\textcolor{stringliteral}{"[s]tep               Run current line and stop again."}));
02286 ldbLog(sdsnew(\textcolor{stringliteral}{"[n]ext               Alias for step."}));
02287 ldbLog(sdsnew(\textcolor{stringliteral}{"[c]continue          Run till next breakpoint."}));
02288 ldbLog(sdsnew(\textcolor{stringliteral}{"[l]list              List source code around current line."}));
02289 ldbLog(sdsnew(\textcolor{stringliteral}{"[l]list [line]       List source code around [line]."}));
02290 ldbLog(sdsnew(\textcolor{stringliteral}{"                     line = 0 means: current position."}));
02291 ldbLog(sdsnew(\textcolor{stringliteral}{"[l]list [line] [ctx] In this form [ctx] specifies how many lines"}));
02292 ldbLog(sdsnew(\textcolor{stringliteral}{"                     to show before/after [line]."}));
02293 ldbLog(sdsnew(\textcolor{stringliteral}{"[w]hole              List all source code. Alias for 'list 1 1000000'."}));
02294 ldbLog(sdsnew(\textcolor{stringliteral}{"[p]rint              Show all the local variables."}));
02295 ldbLog(sdsnew(\textcolor{stringliteral}{"[p]rint <var>        Show the value of the specified variable."}));
02296 ldbLog(sdsnew(\textcolor{stringliteral}{"                     Can also show global vars KEYS and ARGV."}));
02297 ldbLog(sdsnew(\textcolor{stringliteral}{"[b]reak              Show all breakpoints."}));
02298 ldbLog(sdsnew(\textcolor{stringliteral}{"[b]reak <line>       Add a breakpoint to the specified line."}));
02299 ldbLog(sdsnew(\textcolor{stringliteral}{"[b]reak -<line>      Remove breakpoint from the specified line."}));
02300 ldbLog(sdsnew(\textcolor{stringliteral}{"[b]reak 0            Remove all breakpoints."}));
02301 ldbLog(sdsnew(\textcolor{stringliteral}{"[t]race              Show a backtrace."}));
02302 ldbLog(sdsnew(\textcolor{stringliteral}{"[e]eval <code>       Execute some Lua code (in a different callframe)."}));
02303 ldbLog(sdsnew(\textcolor{stringliteral}{"[r]edis <cmd>        Execute a Redis command."}));
02304 ldbLog(sdsnew(\textcolor{stringliteral}{"[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len."}));
02305 ldbLog(sdsnew(\textcolor{stringliteral}{"                     Specifying zero as <len> means unlimited."}));
02306 ldbLog(sdsnew(\textcolor{stringliteral}{"[a]bort              Stop the execution of the script. In sync"}));
02307 ldbLog(sdsnew(\textcolor{stringliteral}{"                     mode dataset changes will be retained."}));
02308 ldbLog(sdsnew(\textcolor{stringliteral}{""}));
02309 ldbLog(sdsnew(\textcolor{stringliteral}{"Debugger functions you can call from Lua scripts:"}));
02310 ldbLog(sdsnew(\textcolor{stringliteral}{"redis.debug()        Produce logs in the debugger console."}));
02311 ldbLog(sdsnew(\textcolor{stringliteral}{"redis.breakpoint()   Stop execution like if there was a breakpoing."}));
02312 ldbLog(sdsnew(\textcolor{stringliteral}{"                     in the next line of code."}));
02313             ldbSendLogs();
02314         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(argv[0],\textcolor{stringliteral}{"s"}) || !strcasecmp(argv[0],\textcolor{stringliteral}{"step"}) ||
02315                    !strcasecmp(argv[0],\textcolor{stringliteral}{"n"}) || !strcasecmp(argv[0],\textcolor{stringliteral}{"next"})) \{
02316             ldb.step = 1;
02317             \textcolor{keywordflow}{break};
02318         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(argv[0],\textcolor{stringliteral}{"c"}) || !strcasecmp(argv[0],\textcolor{stringliteral}{"continue"}))\{
02319             \textcolor{keywordflow}{break};
02320         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(argv[0],\textcolor{stringliteral}{"t"}) || !strcasecmp(argv[0],\textcolor{stringliteral}{"trace"})) \{
02321             ldbTrace(lua);
02322             ldbSendLogs();
02323         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(argv[0],\textcolor{stringliteral}{"m"}) || !strcasecmp(argv[0],\textcolor{stringliteral}{"maxlen"})) \{
02324             ldbMaxlen(argv,argc);
02325             ldbSendLogs();
02326         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(argv[0],\textcolor{stringliteral}{"b"}) || !strcasecmp(argv[0],\textcolor{stringliteral}{"break"})) \{
02327             ldbBreak(argv,argc);
02328             ldbSendLogs();
02329         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(argv[0],\textcolor{stringliteral}{"e"}) || !strcasecmp(argv[0],\textcolor{stringliteral}{"eval"})) \{
02330             ldbEval(lua,argv,argc);
02331             ldbSendLogs();
02332         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(argv[0],\textcolor{stringliteral}{"a"}) || !strcasecmp(argv[0],\textcolor{stringliteral}{"abort"})) \{
02333             lua\_pushstring(lua, \textcolor{stringliteral}{"script aborted for user request"});
02334             lua\_error(lua);
02335         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (argc > 1 &&
02336                    (!strcasecmp(argv[0],\textcolor{stringliteral}{"r"}) || !strcasecmp(argv[0],\textcolor{stringliteral}{"redis"}))) \{
02337             ldbRedis(lua,argv,argc);
02338             ldbSendLogs();
02339         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((!strcasecmp(argv[0],\textcolor{stringliteral}{"p"}) || !strcasecmp(argv[0],\textcolor{stringliteral}{"print"}))) \{
02340             \textcolor{keywordflow}{if} (argc == 2)
02341                 ldbPrint(lua,argv[1]);
02342             \textcolor{keywordflow}{else}
02343                 ldbPrintAll(lua);
02344             ldbSendLogs();
02345         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(argv[0],\textcolor{stringliteral}{"l"}) || !strcasecmp(argv[0],\textcolor{stringliteral}{"list"}))\{
02346             \textcolor{keywordtype}{int} around = ldb.currentline, ctx = 5;
02347             \textcolor{keywordflow}{if} (argc > 1) \{
02348                 \textcolor{keywordtype}{int} num = atoi(argv[1]);
02349                 \textcolor{keywordflow}{if} (num > 0) around = num;
02350             \}
02351             \textcolor{keywordflow}{if} (argc > 2) ctx = atoi(argv[2]);
02352             ldbList(around,ctx);
02353             ldbSendLogs();
02354         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(argv[0],\textcolor{stringliteral}{"w"}) || !strcasecmp(argv[0],\textcolor{stringliteral}{"whole"}))\{
02355             ldbList(1,1000000);
02356             ldbSendLogs();
02357         \} \textcolor{keywordflow}{else} \{
02358             ldbLog(sdsnew(\textcolor{stringliteral}{"<error> Unknown Redis Lua debugger command or "}
02359                           \textcolor{stringliteral}{"wrong number of arguments."}));
02360             ldbSendLogs();
02361         \}
02362 
02363         \textcolor{comment}{/* Free the command vector. */}
02364         sdsfreesplitres(argv,argc);
02365     \}
02366 
02367     \textcolor{comment}{/* Free the current command argv if we break inside the while loop. */}
02368     sdsfreesplitres(argv,argc);
02369     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
02370 \}
02371 
02372 \textcolor{comment}{/* This is the core of our Lua debugger, called each time Lua is about}
02373 \textcolor{comment}{ * to start executing a new line. */}
02374 \textcolor{keywordtype}{void} luaLdbLineHook(lua\_State *lua, lua\_Debug *ar) \{
02375     lua\_getstack(lua,0,ar);
02376     lua\_getinfo(lua,\textcolor{stringliteral}{"Sl"},ar);
02377     ldb.currentline = ar->currentline;
02378 
02379     \textcolor{keywordtype}{int} bp = ldbIsBreakpoint(ldb.currentline) || ldb.luabp;
02380     \textcolor{keywordtype}{int} timeout = 0;
02381 
02382     \textcolor{comment}{/* Events outside our script are not interesting. */}
02383     \textcolor{keywordflow}{if}(strstr(ar->short\_src,\textcolor{stringliteral}{"user\_script"}) == NULL) \textcolor{keywordflow}{return};
02384 
02385     \textcolor{comment}{/* Check if a timeout occurred. */}
02386     \textcolor{keywordflow}{if} (ar->event == LUA\_HOOKCOUNT && ldb.step == 0 && bp == 0) \{
02387         mstime\_t elapsed = mstime() - server.lua\_time\_start;
02388         mstime\_t timelimit = server.lua\_time\_limit ?
02389                              server.lua\_time\_limit : 5000;
02390         \textcolor{keywordflow}{if} (elapsed >= timelimit) \{
02391             timeout = 1;
02392             ldb.step = 1;
02393         \} \textcolor{keywordflow}{else} \{
02394             \textcolor{keywordflow}{return}; \textcolor{comment}{/* No timeout, ignore the COUNT event. */}
02395         \}
02396     \}
02397 
02398     \textcolor{keywordflow}{if} (ldb.step || bp) \{
02399         \textcolor{keywordtype}{char} *reason = \textcolor{stringliteral}{"step over"};
02400         \textcolor{keywordflow}{if} (bp) reason = ldb.luabp ? \textcolor{stringliteral}{"redis.breakpoint() called"} :
02401                                      \textcolor{stringliteral}{"break point"};
02402         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (timeout) reason = \textcolor{stringliteral}{"timeout reached, infinite loop?"};
02403         ldb.step = 0;
02404         ldb.luabp = 0;
02405         ldbLog(sdscatprintf(sdsempty(),
02406             \textcolor{stringliteral}{"* Stopped at %d, stop reason = %s"},
02407             ldb.currentline, reason));
02408         ldbLogSourceLine(ldb.currentline);
02409         ldbSendLogs();
02410         \textcolor{keywordflow}{if} (ldbRepl(lua) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR} && timeout) \{
02411             \textcolor{comment}{/* If the client closed the connection and we have a timeout}
02412 \textcolor{comment}{             * connection, let's kill the script otherwise the process}
02413 \textcolor{comment}{             * will remain blocked indefinitely. */}
02414             lua\_pushstring(lua, \textcolor{stringliteral}{"timeout during Lua debugging with client closing connection"});
02415             lua\_error(lua);
02416         \}
02417         server.lua\_time\_start = mstime();
02418     \}
02419 \}
\end{DoxyCode}
