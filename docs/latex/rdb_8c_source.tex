\hypertarget{rdb_8c_source}{}\section{rdb.\+c}
\label{rdb_8c_source}\index{src/rdb.\+c@{src/rdb.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/*}
00002 \textcolor{comment}{ * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>}
00003 \textcolor{comment}{ * All rights reserved.}
00004 \textcolor{comment}{ *}
00005 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00006 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00007 \textcolor{comment}{ *}
00008 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00009 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00010 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00011 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00012 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00013 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00014 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00015 \textcolor{comment}{ *     specific prior written permission.}
00016 \textcolor{comment}{ *}
00017 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00018 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00019 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00020 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00021 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00022 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00023 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00024 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00025 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00026 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00027 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00028 \textcolor{comment}{ */}
00029 
00030 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{server_8h}{"server.h"}
00031 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{lzf_8h}{"lzf.h"}           \textcolor{comment}{/* LZF compression library */}
00032 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{zipmap_8h}{"zipmap.h"}
00033 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{endianconv_8h}{"endianconv.h"}
00034 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{stream_8h}{"stream.h"}
00035 
00036 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{math}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00037 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{types}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00038 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{time}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00039 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{resource}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00040 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{wait}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00041 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{arpa}\textcolor{preprocessor}{/}\textcolor{preprocessor}{inet}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00042 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{stat}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00043 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{param}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00044 
00045 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{rdbExitReportCorruptRDB}\textcolor{preprocessor}{(}\textcolor{preprocessor}{...}\textcolor{preprocessor}{)} \textcolor{preprocessor}{rdbCheckThenExit}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_\_LINE\_\_}\textcolor{preprocessor}{,}\textcolor{preprocessor}{\_\_VA\_ARGS\_\_}\textcolor{preprocessor}{)}
00046 
00047 \textcolor{keyword}{extern} \textcolor{keywordtype}{int} rdbCheckMode;
00048 \textcolor{keywordtype}{void} rdbCheckError(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, ...);
00049 \textcolor{keywordtype}{void} rdbCheckSetError(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *fmt, ...);
00050 
00051 \textcolor{keywordtype}{void} rdbCheckThenExit(\textcolor{keywordtype}{int} linenum, \textcolor{keywordtype}{char} *reason, ...) \{
00052     va\_list ap;
00053     \textcolor{keywordtype}{char} msg[1024];
00054     \textcolor{keywordtype}{int} len;
00055 
00056     len = snprintf(msg,\textcolor{keyword}{sizeof}(msg),
00057         \textcolor{stringliteral}{"Internal error in RDB reading function at rdb.c:%d -> "}, linenum);
00058     va\_start(ap,reason);
00059     vsnprintf(msg+len,\textcolor{keyword}{sizeof}(msg)-len,reason,ap);
00060     va\_end(ap);
00061 
00062     \textcolor{keywordflow}{if} (!rdbCheckMode) \{
00063         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"%s"}, msg);
00064         \textcolor{keywordtype}{char} *argv[2] = \{\textcolor{stringliteral}{""},server.rdb\_filename\};
00065         redis\_check\_rdb\_main(2,argv,NULL);
00066     \} \textcolor{keywordflow}{else} \{
00067         rdbCheckError(\textcolor{stringliteral}{"%s"},msg);
00068     \}
00069     exit(1);
00070 \}
00071 
00072 \textcolor{keyword}{static} \textcolor{keywordtype}{int} rdbWriteRaw(rio *rdb, \textcolor{keywordtype}{void} *p, size\_t len) \{
00073     \textcolor{keywordflow}{if} (rdb && rioWrite(rdb,p,len) == 0)
00074         \textcolor{keywordflow}{return} -1;
00075     \textcolor{keywordflow}{return} len;
00076 \}
00077 
00078 \textcolor{keywordtype}{int} rdbSaveType(rio *rdb, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} type) \{
00079     \textcolor{keywordflow}{return} rdbWriteRaw(rdb,&type,1);
00080 \}
00081 
00082 \textcolor{comment}{/* Load a "type" in RDB format, that is a one byte unsigned integer.}
00083 \textcolor{comment}{ * This function is not only used to load object types, but also special}
00084 \textcolor{comment}{ * "types" like the end-of-file type, the EXPIRE type, and so forth. */}
00085 \textcolor{keywordtype}{int} rdbLoadType(rio *rdb) \{
00086     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} type;
00087     \textcolor{keywordflow}{if} (rioRead(rdb,&type,1) == 0) \textcolor{keywordflow}{return} -1;
00088     \textcolor{keywordflow}{return} type;
00089 \}
00090 
00091 time\_t rdbLoadTime(rio *rdb) \{
00092     int32\_t t32;
00093     \textcolor{keywordflow}{if} (rioRead(rdb,&t32,4) == 0) \textcolor{keywordflow}{return} -1;
00094     \textcolor{keywordflow}{return} (time\_t)t32;
00095 \}
00096 
00097 \textcolor{keywordtype}{int} rdbSaveMillisecondTime(rio *rdb, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} t) \{
00098     int64\_t t64 = (int64\_t) t;
00099     \textcolor{keywordflow}{return} rdbWriteRaw(rdb,&t64,8);
00100 \}
00101 
00102 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} rdbLoadMillisecondTime(rio *rdb) \{
00103     int64\_t t64;
00104     \textcolor{keywordflow}{if} (rioRead(rdb,&t64,8) == 0) \textcolor{keywordflow}{return} -1;
00105     \textcolor{keywordflow}{return} (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long})t64;
00106 \}
00107 
00108 \textcolor{comment}{/* Saves an encoded length. The first two bits in the first byte are used to}
00109 \textcolor{comment}{ * hold the encoding type. See the RDB\_* definitions for more information}
00110 \textcolor{comment}{ * on the types of encoding. */}
00111 \textcolor{keywordtype}{int} rdbSaveLen(rio *rdb, uint64\_t len) \{
00112     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[2];
00113     size\_t nwritten;
00114 
00115     \textcolor{keywordflow}{if} (len < (1<<6)) \{
00116         \textcolor{comment}{/* Save a 6 bit len */}
00117         buf[0] = (len&0xFF)|(\hyperlink{rdb_8h_a11b7223b73ffc4e85093a19703362c5e}{RDB\_6BITLEN}<<6);
00118         \textcolor{keywordflow}{if} (rdbWriteRaw(rdb,buf,1) == -1) \textcolor{keywordflow}{return} -1;
00119         nwritten = 1;
00120     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (len < (1<<14)) \{
00121         \textcolor{comment}{/* Save a 14 bit len */}
00122         buf[0] = ((len>>8)&0xFF)|(\hyperlink{rdb_8h_acb8ebef4cb20868b6754659c2665cc44}{RDB\_14BITLEN}<<6);
00123         buf[1] = len&0xFF;
00124         \textcolor{keywordflow}{if} (rdbWriteRaw(rdb,buf,2) == -1) \textcolor{keywordflow}{return} -1;
00125         nwritten = 2;
00126     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (len <= UINT32\_MAX) \{
00127         \textcolor{comment}{/* Save a 32 bit len */}
00128         buf[0] = \hyperlink{rdb_8h_a27634f80a58e70e888a082f48a7b3a46}{RDB\_32BITLEN};
00129         \textcolor{keywordflow}{if} (rdbWriteRaw(rdb,buf,1) == -1) \textcolor{keywordflow}{return} -1;
00130         uint32\_t len32 = htonl(len);
00131         \textcolor{keywordflow}{if} (rdbWriteRaw(rdb,&len32,4) == -1) \textcolor{keywordflow}{return} -1;
00132         nwritten = 1+4;
00133     \} \textcolor{keywordflow}{else} \{
00134         \textcolor{comment}{/* Save a 64 bit len */}
00135         buf[0] = \hyperlink{rdb_8h_abb426bfb742c8661924175b285d1f55f}{RDB\_64BITLEN};
00136         \textcolor{keywordflow}{if} (rdbWriteRaw(rdb,buf,1) == -1) \textcolor{keywordflow}{return} -1;
00137         len = \hyperlink{endianconv_8h_a41a6b64ba8dec362f605f615e528fcf3}{htonu64}(len);
00138         \textcolor{keywordflow}{if} (rdbWriteRaw(rdb,&len,8) == -1) \textcolor{keywordflow}{return} -1;
00139         nwritten = 1+8;
00140     \}
00141     \textcolor{keywordflow}{return} nwritten;
00142 \}
00143 
00144 
00145 \textcolor{comment}{/* Load an encoded length. If the loaded length is a normal length as stored}
00146 \textcolor{comment}{ * with rdbSaveLen(), the read length is set to '*lenptr'. If instead the}
00147 \textcolor{comment}{ * loaded length describes a special encoding that follows, then '*isencoded'}
00148 \textcolor{comment}{ * is set to 1 and the encoding format is stored at '*lenptr'.}
00149 \textcolor{comment}{ *}
00150 \textcolor{comment}{ * See the RDB\_ENC\_* definitions in rdb.h for more information on special}
00151 \textcolor{comment}{ * encodings.}
00152 \textcolor{comment}{ *}
00153 \textcolor{comment}{ * The function returns -1 on error, 0 on success. */}
00154 \textcolor{keywordtype}{int} rdbLoadLenByRef(rio *rdb, \textcolor{keywordtype}{int} *isencoded, uint64\_t *lenptr) \{
00155     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[2];
00156     \textcolor{keywordtype}{int} type;
00157 
00158     \textcolor{keywordflow}{if} (isencoded) *isencoded = 0;
00159     \textcolor{keywordflow}{if} (rioRead(rdb,buf,1) == 0) \textcolor{keywordflow}{return} -1;
00160     type = (buf[0]&0xC0)>>6;
00161     \textcolor{keywordflow}{if} (type == \hyperlink{rdb_8h_a060ed4ae9ab0a1306508189d4c1b2e11}{RDB\_ENCVAL}) \{
00162         \textcolor{comment}{/* Read a 6 bit encoding type. */}
00163         \textcolor{keywordflow}{if} (isencoded) *isencoded = 1;
00164         *lenptr = buf[0]&0x3F;
00165     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == \hyperlink{rdb_8h_a11b7223b73ffc4e85093a19703362c5e}{RDB\_6BITLEN}) \{
00166         \textcolor{comment}{/* Read a 6 bit len. */}
00167         *lenptr = buf[0]&0x3F;
00168     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == \hyperlink{rdb_8h_acb8ebef4cb20868b6754659c2665cc44}{RDB\_14BITLEN}) \{
00169         \textcolor{comment}{/* Read a 14 bit len. */}
00170         \textcolor{keywordflow}{if} (rioRead(rdb,buf+1,1) == 0) \textcolor{keywordflow}{return} -1;
00171         *lenptr = ((buf[0]&0x3F)<<8)|buf[1];
00172     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (buf[0] == \hyperlink{rdb_8h_a27634f80a58e70e888a082f48a7b3a46}{RDB\_32BITLEN}) \{
00173         \textcolor{comment}{/* Read a 32 bit len. */}
00174         uint32\_t len;
00175         \textcolor{keywordflow}{if} (rioRead(rdb,&len,4) == 0) \textcolor{keywordflow}{return} -1;
00176         *lenptr = ntohl(len);
00177     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (buf[0] == \hyperlink{rdb_8h_abb426bfb742c8661924175b285d1f55f}{RDB\_64BITLEN}) \{
00178         \textcolor{comment}{/* Read a 64 bit len. */}
00179         uint64\_t len;
00180         \textcolor{keywordflow}{if} (rioRead(rdb,&len,8) == 0) \textcolor{keywordflow}{return} -1;
00181         *lenptr = \hyperlink{endianconv_8h_ab6e7416a2faac85cd6d50180e7348a1b}{ntohu64}(len);
00182     \} \textcolor{keywordflow}{else} \{
00183         \hyperlink{rdb_8c_afb34e310c0e5dfd9f8c2bebbec59c7f7}{rdbExitReportCorruptRDB}(
00184             \textcolor{stringliteral}{"Unknown length encoding %d in rdbLoadLen()"},type);
00185         \textcolor{keywordflow}{return} -1; \textcolor{comment}{/* Never reached. */}
00186     \}
00187     \textcolor{keywordflow}{return} 0;
00188 \}
00189 
00190 \textcolor{comment}{/* This is like rdbLoadLenByRef() but directly returns the value read}
00191 \textcolor{comment}{ * from the RDB stream, signaling an error by returning RDB\_LENERR}
00192 \textcolor{comment}{ * (since it is a too large count to be applicable in any Redis data}
00193 \textcolor{comment}{ * structure). */}
00194 uint64\_t rdbLoadLen(rio *rdb, \textcolor{keywordtype}{int} *isencoded) \{
00195     uint64\_t len;
00196 
00197     \textcolor{keywordflow}{if} (rdbLoadLenByRef(rdb,isencoded,&len) == -1) \textcolor{keywordflow}{return} \hyperlink{rdb_8h_aa66b6ad7261656029e6a67cf78432b2d}{RDB\_LENERR};
00198     \textcolor{keywordflow}{return} len;
00199 \}
00200 
00201 \textcolor{comment}{/* Encodes the "value" argument as integer when it fits in the supported ranges}
00202 \textcolor{comment}{ * for encoded types. If the function successfully encodes the integer, the}
00203 \textcolor{comment}{ * representation is stored in the buffer pointer to by "enc" and the string}
00204 \textcolor{comment}{ * length is returned. Otherwise 0 is returned. */}
00205 \textcolor{keywordtype}{int} rdbEncodeInteger(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *enc) \{
00206     \textcolor{keywordflow}{if} (value >= -(1<<7) && value <= (1<<7)-1) \{
00207         enc[0] = (\hyperlink{rdb_8h_a060ed4ae9ab0a1306508189d4c1b2e11}{RDB\_ENCVAL}<<6)|\hyperlink{rdb_8h_a56f2f16c5470043c643add1010823d23}{RDB\_ENC\_INT8};
00208         enc[1] = value&0xFF;
00209         \textcolor{keywordflow}{return} 2;
00210     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value >= -(1<<15) && value <= (1<<15)-1) \{
00211         enc[0] = (\hyperlink{rdb_8h_a060ed4ae9ab0a1306508189d4c1b2e11}{RDB\_ENCVAL}<<6)|\hyperlink{rdb_8h_a79072da2d9fb562368f1798bdf8d7645}{RDB\_ENC\_INT16};
00212         enc[1] = value&0xFF;
00213         enc[2] = (value>>8)&0xFF;
00214         \textcolor{keywordflow}{return} 3;
00215     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value >= -((\textcolor{keywordtype}{long} \textcolor{keywordtype}{long})1<<31) && value <= ((\textcolor{keywordtype}{long} \textcolor{keywordtype}{long})1<<31)-1) \{
00216         enc[0] = (\hyperlink{rdb_8h_a060ed4ae9ab0a1306508189d4c1b2e11}{RDB\_ENCVAL}<<6)|\hyperlink{rdb_8h_ab74cba44dacad1f1f0d87dffba9efa98}{RDB\_ENC\_INT32};
00217         enc[1] = value&0xFF;
00218         enc[2] = (value>>8)&0xFF;
00219         enc[3] = (value>>16)&0xFF;
00220         enc[4] = (value>>24)&0xFF;
00221         \textcolor{keywordflow}{return} 5;
00222     \} \textcolor{keywordflow}{else} \{
00223         \textcolor{keywordflow}{return} 0;
00224     \}
00225 \}
00226 
00227 \textcolor{comment}{/* Loads an integer-encoded object with the specified encoding type "enctype".}
00228 \textcolor{comment}{ * The returned value changes according to the flags, see}
00229 \textcolor{comment}{ * rdbGenerincLoadStringObject() for more info. */}
00230 \textcolor{keywordtype}{void} *rdbLoadIntegerObject(rio *rdb, \textcolor{keywordtype}{int} enctype, \textcolor{keywordtype}{int} flags, size\_t *lenptr) \{
00231     \textcolor{keywordtype}{int} plain = flags & \hyperlink{rdb_8h_a5579c0ff24afa891ad41006def040a25}{RDB\_LOAD\_PLAIN};
00232     \textcolor{keywordtype}{int} sds = flags & \hyperlink{rdb_8h_ad15f5cc8e1a7789cc35b66f017e98a18}{RDB\_LOAD\_SDS};
00233     \textcolor{keywordtype}{int} encode = flags & \hyperlink{rdb_8h_aea74502dc3a9f291a2ac8f3bd7d6de24}{RDB\_LOAD\_ENC};
00234     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} enc[4];
00235     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val;
00236 
00237     \textcolor{keywordflow}{if} (enctype == \hyperlink{rdb_8h_a56f2f16c5470043c643add1010823d23}{RDB\_ENC\_INT8}) \{
00238         \textcolor{keywordflow}{if} (rioRead(rdb,enc,1) == 0) \textcolor{keywordflow}{return} NULL;
00239         val = (\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char})enc[0];
00240     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (enctype == \hyperlink{rdb_8h_a79072da2d9fb562368f1798bdf8d7645}{RDB\_ENC\_INT16}) \{
00241         uint16\_t v;
00242         \textcolor{keywordflow}{if} (rioRead(rdb,enc,2) == 0) \textcolor{keywordflow}{return} NULL;
00243         v = enc[0]|(enc[1]<<8);
00244         val = (int16\_t)v;
00245     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (enctype == \hyperlink{rdb_8h_ab74cba44dacad1f1f0d87dffba9efa98}{RDB\_ENC\_INT32}) \{
00246         uint32\_t v;
00247         \textcolor{keywordflow}{if} (rioRead(rdb,enc,4) == 0) \textcolor{keywordflow}{return} NULL;
00248         v = enc[0]|(enc[1]<<8)|(enc[2]<<16)|(enc[3]<<24);
00249         val = (int32\_t)v;
00250     \} \textcolor{keywordflow}{else} \{
00251         val = 0; \textcolor{comment}{/* anti-warning */}
00252         \hyperlink{rdb_8c_afb34e310c0e5dfd9f8c2bebbec59c7f7}{rdbExitReportCorruptRDB}(\textcolor{stringliteral}{"Unknown RDB integer encoding type %d"},enctype)
      ;
00253     \}
00254     \textcolor{keywordflow}{if} (plain || sds) \{
00255         \textcolor{keywordtype}{char} buf[\hyperlink{server_8h_a39ec35278876f65fc1ef70b049856ca3}{LONG\_STR\_SIZE}], *p;
00256         \textcolor{keywordtype}{int} len = ll2string(buf,\textcolor{keyword}{sizeof}(buf),val);
00257         \textcolor{keywordflow}{if} (lenptr) *lenptr = len;
00258         p = plain ? zmalloc(len) : sdsnewlen(NULL,len);
00259         memcpy(p,buf,len);
00260         \textcolor{keywordflow}{return} p;
00261     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (encode) \{
00262         \textcolor{keywordflow}{return} createStringObjectFromLongLong(val);
00263     \} \textcolor{keywordflow}{else} \{
00264         \textcolor{keywordflow}{return} createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},sdsfromlonglong(val));
00265     \}
00266 \}
00267 
00268 \textcolor{comment}{/* String objects in the form "2391" "-100" without any space and with a}
00269 \textcolor{comment}{ * range of values that can fit in an 8, 16 or 32 bit signed value can be}
00270 \textcolor{comment}{ * encoded as integers to save space */}
00271 \textcolor{keywordtype}{int} rdbTryIntegerEncoding(\textcolor{keywordtype}{char} *s, size\_t len, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *enc) \{
00272     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value;
00273     \textcolor{keywordtype}{char} *endptr, buf[32];
00274 
00275     \textcolor{comment}{/* Check if it's possible to encode this value as a number */}
00276     value = strtoll(s, &endptr, 10);
00277     \textcolor{keywordflow}{if} (endptr[0] != \textcolor{stringliteral}{'\(\backslash\)0'}) \textcolor{keywordflow}{return} 0;
00278     ll2string(buf,32,value);
00279 
00280     \textcolor{comment}{/* If the number converted back into a string is not identical}
00281 \textcolor{comment}{     * then it's not possible to encode the string as integer */}
00282     \textcolor{keywordflow}{if} (strlen(buf) != len || memcmp(buf,s,len)) \textcolor{keywordflow}{return} 0;
00283 
00284     \textcolor{keywordflow}{return} rdbEncodeInteger(value,enc);
00285 \}
00286 
00287 ssize\_t rdbSaveLzfBlob(rio *rdb, \textcolor{keywordtype}{void} *data, size\_t compress\_len,
00288                        size\_t original\_len) \{
00289     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} byte;
00290     ssize\_t n, nwritten = 0;
00291 
00292     \textcolor{comment}{/* Data compressed! Let's save it on disk */}
00293     byte = (\hyperlink{rdb_8h_a060ed4ae9ab0a1306508189d4c1b2e11}{RDB\_ENCVAL}<<6)|\hyperlink{rdb_8h_a9438d9c9147f6d8846e71c0722343a95}{RDB\_ENC\_LZF};
00294     \textcolor{keywordflow}{if} ((n = rdbWriteRaw(rdb,&byte,1)) == -1) \textcolor{keywordflow}{goto} writeerr;
00295     nwritten += n;
00296 
00297     \textcolor{keywordflow}{if} ((n = rdbSaveLen(rdb,compress\_len)) == -1) \textcolor{keywordflow}{goto} writeerr;
00298     nwritten += n;
00299 
00300     \textcolor{keywordflow}{if} ((n = rdbSaveLen(rdb,original\_len)) == -1) \textcolor{keywordflow}{goto} writeerr;
00301     nwritten += n;
00302 
00303     \textcolor{keywordflow}{if} ((n = rdbWriteRaw(rdb,data,compress\_len)) == -1) \textcolor{keywordflow}{goto} writeerr;
00304     nwritten += n;
00305 
00306     \textcolor{keywordflow}{return} nwritten;
00307 
00308 writeerr:
00309     \textcolor{keywordflow}{return} -1;
00310 \}
00311 
00312 ssize\_t rdbSaveLzfStringObject(rio *rdb, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *s, size\_t len) \{
00313     size\_t comprlen, outlen;
00314     \textcolor{keywordtype}{void} *out;
00315 
00316     \textcolor{comment}{/* We require at least four bytes compression for this to be worth it */}
00317     \textcolor{keywordflow}{if} (len <= 4) \textcolor{keywordflow}{return} 0;
00318     outlen = len-4;
00319     \textcolor{keywordflow}{if} ((out = zmalloc(outlen+1)) == NULL) \textcolor{keywordflow}{return} 0;
00320     comprlen = lzf\_compress(s, len, out, outlen);
00321     \textcolor{keywordflow}{if} (comprlen == 0) \{
00322         zfree(out);
00323         \textcolor{keywordflow}{return} 0;
00324     \}
00325     ssize\_t nwritten = rdbSaveLzfBlob(rdb, out, comprlen, len);
00326     zfree(out);
00327     \textcolor{keywordflow}{return} nwritten;
00328 \}
00329 
00330 \textcolor{comment}{/* Load an LZF compressed string in RDB format. The returned value}
00331 \textcolor{comment}{ * changes according to 'flags'. For more info check the}
00332 \textcolor{comment}{ * rdbGenericLoadStringObject() function. */}
00333 \textcolor{keywordtype}{void} *rdbLoadLzfStringObject(rio *rdb, \textcolor{keywordtype}{int} flags, size\_t *lenptr) \{
00334     \textcolor{keywordtype}{int} plain = flags & \hyperlink{rdb_8h_a5579c0ff24afa891ad41006def040a25}{RDB\_LOAD\_PLAIN};
00335     \textcolor{keywordtype}{int} sds = flags & \hyperlink{rdb_8h_ad15f5cc8e1a7789cc35b66f017e98a18}{RDB\_LOAD\_SDS};
00336     uint64\_t len, clen;
00337     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *c = NULL;
00338     \textcolor{keywordtype}{char} *val = NULL;
00339 
00340     \textcolor{keywordflow}{if} ((clen = rdbLoadLen(rdb,NULL)) == \hyperlink{rdb_8h_aa66b6ad7261656029e6a67cf78432b2d}{RDB\_LENERR}) \textcolor{keywordflow}{return} NULL;
00341     \textcolor{keywordflow}{if} ((len = rdbLoadLen(rdb,NULL)) == \hyperlink{rdb_8h_aa66b6ad7261656029e6a67cf78432b2d}{RDB\_LENERR}) \textcolor{keywordflow}{return} NULL;
00342     \textcolor{keywordflow}{if} ((c = zmalloc(clen)) == NULL) \textcolor{keywordflow}{goto} err;
00343 
00344     \textcolor{comment}{/* Allocate our target according to the uncompressed size. */}
00345     \textcolor{keywordflow}{if} (plain) \{
00346         val = zmalloc(len);
00347         \textcolor{keywordflow}{if} (lenptr) *lenptr = len;
00348     \} \textcolor{keywordflow}{else} \{
00349         val = sdsnewlen(NULL,len);
00350     \}
00351 
00352     \textcolor{comment}{/* Load the compressed representation and uncompress it to target. */}
00353     \textcolor{keywordflow}{if} (rioRead(rdb,c,clen) == 0) \textcolor{keywordflow}{goto} err;
00354     \textcolor{keywordflow}{if} (lzf\_decompress(c,clen,val,len) == 0) \{
00355         \textcolor{keywordflow}{if} (rdbCheckMode) rdbCheckSetError(\textcolor{stringliteral}{"Invalid LZF compressed string"});
00356         \textcolor{keywordflow}{goto} err;
00357     \}
00358     zfree(c);
00359 
00360     \textcolor{keywordflow}{if} (plain || sds) \{
00361         \textcolor{keywordflow}{return} val;
00362     \} \textcolor{keywordflow}{else} \{
00363         \textcolor{keywordflow}{return} createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},val);
00364     \}
00365 err:
00366     zfree(c);
00367     \textcolor{keywordflow}{if} (plain)
00368         zfree(val);
00369     \textcolor{keywordflow}{else}
00370         sdsfree(val);
00371     \textcolor{keywordflow}{return} NULL;
00372 \}
00373 
00374 \textcolor{comment}{/* Save a string object as [len][data] on disk. If the object is a string}
00375 \textcolor{comment}{ * representation of an integer value we try to save it in a special form */}
00376 ssize\_t rdbSaveRawString(rio *rdb, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *s, size\_t len) \{
00377     \textcolor{keywordtype}{int} enclen;
00378     ssize\_t n, nwritten = 0;
00379 
00380     \textcolor{comment}{/* Try integer encoding */}
00381     \textcolor{keywordflow}{if} (len <= 11) \{
00382         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[5];
00383         \textcolor{keywordflow}{if} ((enclen = rdbTryIntegerEncoding((\textcolor{keywordtype}{char}*)s,len,buf)) > 0) \{
00384             \textcolor{keywordflow}{if} (rdbWriteRaw(rdb,buf,enclen) == -1) \textcolor{keywordflow}{return} -1;
00385             \textcolor{keywordflow}{return} enclen;
00386         \}
00387     \}
00388 
00389     \textcolor{comment}{/* Try LZF compression - under 20 bytes it's unable to compress even}
00390 \textcolor{comment}{     * aaaaaaaaaaaaaaaaaa so skip it */}
00391     \textcolor{keywordflow}{if} (server.rdb\_compression && len > 20) \{
00392         n = rdbSaveLzfStringObject(rdb,s,len);
00393         \textcolor{keywordflow}{if} (n == -1) \textcolor{keywordflow}{return} -1;
00394         \textcolor{keywordflow}{if} (n > 0) \textcolor{keywordflow}{return} n;
00395         \textcolor{comment}{/* Return value of 0 means data can't be compressed, save the old way */}
00396     \}
00397 
00398     \textcolor{comment}{/* Store verbatim */}
00399     \textcolor{keywordflow}{if} ((n = rdbSaveLen(rdb,len)) == -1) \textcolor{keywordflow}{return} -1;
00400     nwritten += n;
00401     \textcolor{keywordflow}{if} (len > 0) \{
00402         \textcolor{keywordflow}{if} (rdbWriteRaw(rdb,s,len) == -1) \textcolor{keywordflow}{return} -1;
00403         nwritten += len;
00404     \}
00405     \textcolor{keywordflow}{return} nwritten;
00406 \}
00407 
00408 \textcolor{comment}{/* Save a long long value as either an encoded string or a string. */}
00409 ssize\_t rdbSaveLongLongAsStringObject(rio *rdb, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value) \{
00410     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[32];
00411     ssize\_t n, nwritten = 0;
00412     \textcolor{keywordtype}{int} enclen = rdbEncodeInteger(value,buf);
00413     \textcolor{keywordflow}{if} (enclen > 0) \{
00414         \textcolor{keywordflow}{return} rdbWriteRaw(rdb,buf,enclen);
00415     \} \textcolor{keywordflow}{else} \{
00416         \textcolor{comment}{/* Encode as string */}
00417         enclen = ll2string((\textcolor{keywordtype}{char}*)buf,32,value);
00418         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(enclen < 32);
00419         \textcolor{keywordflow}{if} ((n = rdbSaveLen(rdb,enclen)) == -1) \textcolor{keywordflow}{return} -1;
00420         nwritten += n;
00421         \textcolor{keywordflow}{if} ((n = rdbWriteRaw(rdb,buf,enclen)) == -1) \textcolor{keywordflow}{return} -1;
00422         nwritten += n;
00423     \}
00424     \textcolor{keywordflow}{return} nwritten;
00425 \}
00426 
00427 \textcolor{comment}{/* Like rdbSaveRawString() gets a Redis object instead. */}
00428 \textcolor{keywordtype}{int} rdbSaveStringObject(rio *rdb, robj *obj) \{
00429     \textcolor{comment}{/* Avoid to decode the object, then encode it again, if the}
00430 \textcolor{comment}{     * object is already integer encoded. */}
00431     \textcolor{keywordflow}{if} (obj->encoding == \hyperlink{server_8h_ae934cf008a0be0ef009c92c2d006a816}{OBJ\_ENCODING\_INT}) \{
00432         \textcolor{keywordflow}{return} rdbSaveLongLongAsStringObject(rdb,(\textcolor{keywordtype}{long})obj->ptr);
00433     \} \textcolor{keywordflow}{else} \{
00434         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(NULL,obj,\hyperlink{server_8h_afcfb5bd97af52d1dbce331745cae030c}{sdsEncodedObject}(obj));
00435         \textcolor{keywordflow}{return} rdbSaveRawString(rdb,obj->ptr,sdslen(obj->ptr));
00436     \}
00437 \}
00438 
00439 \textcolor{comment}{/* Load a string object from an RDB file according to flags:}
00440 \textcolor{comment}{ *}
00441 \textcolor{comment}{ * RDB\_LOAD\_NONE (no flags): load an RDB object, unencoded.}
00442 \textcolor{comment}{ * RDB\_LOAD\_ENC: If the returned type is a Redis object, try to}
00443 \textcolor{comment}{ *               encode it in a special way to be more memory}
00444 \textcolor{comment}{ *               efficient. When this flag is passed the function}
00445 \textcolor{comment}{ *               no longer guarantees that obj->ptr is an SDS string.}
00446 \textcolor{comment}{ * RDB\_LOAD\_PLAIN: Return a plain string allocated with zmalloc()}
00447 \textcolor{comment}{ *                 instead of a Redis object with an sds in it.}
00448 \textcolor{comment}{ * RDB\_LOAD\_SDS: Return an SDS string instead of a Redis object.}
00449 \textcolor{comment}{ *}
00450 \textcolor{comment}{ * On I/O error NULL is returned.}
00451 \textcolor{comment}{ */}
00452 \textcolor{keywordtype}{void} *rdbGenericLoadStringObject(rio *rdb, \textcolor{keywordtype}{int} flags, size\_t *lenptr) \{
00453     \textcolor{keywordtype}{int} encode = flags & \hyperlink{rdb_8h_aea74502dc3a9f291a2ac8f3bd7d6de24}{RDB\_LOAD\_ENC};
00454     \textcolor{keywordtype}{int} plain = flags & \hyperlink{rdb_8h_a5579c0ff24afa891ad41006def040a25}{RDB\_LOAD\_PLAIN};
00455     \textcolor{keywordtype}{int} sds = flags & \hyperlink{rdb_8h_ad15f5cc8e1a7789cc35b66f017e98a18}{RDB\_LOAD\_SDS};
00456     \textcolor{keywordtype}{int} isencoded;
00457     uint64\_t len;
00458 
00459     len = rdbLoadLen(rdb,&isencoded);
00460     \textcolor{keywordflow}{if} (isencoded) \{
00461         \textcolor{keywordflow}{switch}(len) \{
00462         \textcolor{keywordflow}{case} \hyperlink{rdb_8h_a56f2f16c5470043c643add1010823d23}{RDB\_ENC\_INT8}:
00463         \textcolor{keywordflow}{case} \hyperlink{rdb_8h_a79072da2d9fb562368f1798bdf8d7645}{RDB\_ENC\_INT16}:
00464         \textcolor{keywordflow}{case} \hyperlink{rdb_8h_ab74cba44dacad1f1f0d87dffba9efa98}{RDB\_ENC\_INT32}:
00465             \textcolor{keywordflow}{return} rdbLoadIntegerObject(rdb,len,flags,lenptr);
00466         \textcolor{keywordflow}{case} \hyperlink{rdb_8h_a9438d9c9147f6d8846e71c0722343a95}{RDB\_ENC\_LZF}:
00467             \textcolor{keywordflow}{return} rdbLoadLzfStringObject(rdb,flags,lenptr);
00468         \textcolor{keywordflow}{default}:
00469             \hyperlink{rdb_8c_afb34e310c0e5dfd9f8c2bebbec59c7f7}{rdbExitReportCorruptRDB}(\textcolor{stringliteral}{"Unknown RDB string encoding type %d"},len);
00470         \}
00471     \}
00472 
00473     \textcolor{keywordflow}{if} (len == \hyperlink{rdb_8h_aa66b6ad7261656029e6a67cf78432b2d}{RDB\_LENERR}) \textcolor{keywordflow}{return} NULL;
00474     \textcolor{keywordflow}{if} (plain || sds) \{
00475         \textcolor{keywordtype}{void} *buf = plain ? zmalloc(len) : sdsnewlen(NULL,len);
00476         \textcolor{keywordflow}{if} (lenptr) *lenptr = len;
00477         \textcolor{keywordflow}{if} (len && rioRead(rdb,buf,len) == 0) \{
00478             \textcolor{keywordflow}{if} (plain)
00479                 zfree(buf);
00480             \textcolor{keywordflow}{else}
00481                 sdsfree(buf);
00482             \textcolor{keywordflow}{return} NULL;
00483         \}
00484         \textcolor{keywordflow}{return} buf;
00485     \} \textcolor{keywordflow}{else} \{
00486         robj *o = encode ? createStringObject(NULL,len) :
00487                            createRawStringObject(NULL,len);
00488         \textcolor{keywordflow}{if} (len && rioRead(rdb,o->ptr,len) == 0) \{
00489             decrRefCount(o);
00490             \textcolor{keywordflow}{return} NULL;
00491         \}
00492         \textcolor{keywordflow}{return} o;
00493     \}
00494 \}
00495 
00496 robj *rdbLoadStringObject(rio *rdb) \{
00497     \textcolor{keywordflow}{return} rdbGenericLoadStringObject(rdb,\hyperlink{rdb_8h_aa6539176570d3833856d0b6c71077c67}{RDB\_LOAD\_NONE},NULL);
00498 \}
00499 
00500 robj *rdbLoadEncodedStringObject(rio *rdb) \{
00501     \textcolor{keywordflow}{return} rdbGenericLoadStringObject(rdb,\hyperlink{rdb_8h_aea74502dc3a9f291a2ac8f3bd7d6de24}{RDB\_LOAD\_ENC},NULL);
00502 \}
00503 
00504 \textcolor{comment}{/* Save a double value. Doubles are saved as strings prefixed by an unsigned}
00505 \textcolor{comment}{ * 8 bit integer specifying the length of the representation.}
00506 \textcolor{comment}{ * This 8 bit integer has special values in order to specify the following}
00507 \textcolor{comment}{ * conditions:}
00508 \textcolor{comment}{ * 253: not a number}
00509 \textcolor{comment}{ * 254: + inf}
00510 \textcolor{comment}{ * 255: - inf}
00511 \textcolor{comment}{ */}
00512 \textcolor{keywordtype}{int} rdbSaveDoubleValue(rio *rdb, \textcolor{keywordtype}{double} val) \{
00513     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[128];
00514     \textcolor{keywordtype}{int} len;
00515 
00516     \textcolor{keywordflow}{if} (isnan(val)) \{
00517         buf[0] = 253;
00518         len = 1;
00519     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!isfinite(val)) \{
00520         len = 1;
00521         buf[0] = (val < 0) ? 255 : 254;
00522     \} \textcolor{keywordflow}{else} \{
00523 \textcolor{preprocessor}{#}\textcolor{preprocessor}{if} \textcolor{preprocessor}{(}\textcolor{preprocessor}{DBL\_MANT\_DIG} \textcolor{preprocessor}{>=} 52\textcolor{preprocessor}{)} \textcolor{preprocessor}{&&} \textcolor{preprocessor}{(}LLONG\_MAX \textcolor{preprocessor}{==} 0x7fffffffffffffffLL\textcolor{preprocessor}{)}
00524         \textcolor{comment}{/* Check if the float is in a safe range to be casted into a}
00525 \textcolor{comment}{         * long long. We are assuming that long long is 64 bit here.}
00526 \textcolor{comment}{         * Also we are assuming that there are no implementations around where}
00527 \textcolor{comment}{         * double has precision < 52 bit.}
00528 \textcolor{comment}{         *}
00529 \textcolor{comment}{         * Under this assumptions we test if a double is inside an interval}
00530 \textcolor{comment}{         * where casting to long long is safe. Then using two castings we}
00531 \textcolor{comment}{         * make sure the decimal part is zero. If all this is true we use}
00532 \textcolor{comment}{         * integer printing function that is much faster. */}
00533         \textcolor{keywordtype}{double} min = -4503599627370495; \textcolor{comment}{/* (2^52)-1 */}
00534         \textcolor{keywordtype}{double} max = 4503599627370496; \textcolor{comment}{/* -(2^52) */}
00535         \textcolor{keywordflow}{if} (val > min && val < max && val == ((\textcolor{keywordtype}{double})((\textcolor{keywordtype}{long} \textcolor{keywordtype}{long})val)))
00536             ll2string((\textcolor{keywordtype}{char}*)buf+1,\textcolor{keyword}{sizeof}(buf)-1,(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long})val);
00537         \textcolor{keywordflow}{else}
00538 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif}
00539             snprintf((\textcolor{keywordtype}{char}*)buf+1,\textcolor{keyword}{sizeof}(buf)-1,\textcolor{stringliteral}{"%.17g"},val);
00540         buf[0] = strlen((\textcolor{keywordtype}{char}*)buf+1);
00541         len = buf[0]+1;
00542     \}
00543     \textcolor{keywordflow}{return} rdbWriteRaw(rdb,buf,len);
00544 \}
00545 
00546 \textcolor{comment}{/* For information about double serialization check rdbSaveDoubleValue() */}
00547 \textcolor{keywordtype}{int} rdbLoadDoubleValue(rio *rdb, \textcolor{keywordtype}{double} *val) \{
00548     \textcolor{keywordtype}{char} buf[256];
00549     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} len;
00550 
00551     \textcolor{keywordflow}{if} (rioRead(rdb,&len,1) == 0) \textcolor{keywordflow}{return} -1;
00552     \textcolor{keywordflow}{switch}(len) \{
00553     \textcolor{keywordflow}{case} 255: *val = R\_NegInf; \textcolor{keywordflow}{return} 0;
00554     \textcolor{keywordflow}{case} 254: *val = R\_PosInf; \textcolor{keywordflow}{return} 0;
00555     \textcolor{keywordflow}{case} 253: *val = R\_Nan; \textcolor{keywordflow}{return} 0;
00556     \textcolor{keywordflow}{default}:
00557         \textcolor{keywordflow}{if} (rioRead(rdb,buf,len) == 0) \textcolor{keywordflow}{return} -1;
00558         buf[len] = \textcolor{stringliteral}{'\(\backslash\)0'};
00559         sscanf(buf, \textcolor{stringliteral}{"%lg"}, val);
00560         \textcolor{keywordflow}{return} 0;
00561     \}
00562 \}
00563 
00564 \textcolor{comment}{/* Saves a double for RDB 8 or greater, where IE754 binary64 format is assumed.}
00565 \textcolor{comment}{ * We just make sure the integer is always stored in little endian, otherwise}
00566 \textcolor{comment}{ * the value is copied verbatim from memory to disk.}
00567 \textcolor{comment}{ *}
00568 \textcolor{comment}{ * Return -1 on error, the size of the serialized value on success. */}
00569 \textcolor{keywordtype}{int} rdbSaveBinaryDoubleValue(rio *rdb, \textcolor{keywordtype}{double} val) \{
00570     \hyperlink{endianconv_8h_aa311b9f944c3b988f3601698a95890c1}{memrev64ifbe}(&val);
00571     \textcolor{keywordflow}{return} rdbWriteRaw(rdb,&val,\textcolor{keyword}{sizeof}(val));
00572 \}
00573 
00574 \textcolor{comment}{/* Loads a double from RDB 8 or greater. See rdbSaveBinaryDoubleValue() for}
00575 \textcolor{comment}{ * more info. On error -1 is returned, otherwise 0. */}
00576 \textcolor{keywordtype}{int} rdbLoadBinaryDoubleValue(rio *rdb, \textcolor{keywordtype}{double} *val) \{
00577     \textcolor{keywordflow}{if} (rioRead(rdb,val,\textcolor{keyword}{sizeof}(*val)) == 0) \textcolor{keywordflow}{return} -1;
00578     \hyperlink{endianconv_8h_aa311b9f944c3b988f3601698a95890c1}{memrev64ifbe}(val);
00579     \textcolor{keywordflow}{return} 0;
00580 \}
00581 
00582 \textcolor{comment}{/* Like rdbSaveBinaryDoubleValue() but single precision. */}
00583 \textcolor{keywordtype}{int} rdbSaveBinaryFloatValue(rio *rdb, \textcolor{keywordtype}{float} val) \{
00584     \hyperlink{endianconv_8h_a771f3656eb7d11a1e7f7294b657d8978}{memrev32ifbe}(&val);
00585     \textcolor{keywordflow}{return} rdbWriteRaw(rdb,&val,\textcolor{keyword}{sizeof}(val));
00586 \}
00587 
00588 \textcolor{comment}{/* Like rdbLoadBinaryDoubleValue() but single precision. */}
00589 \textcolor{keywordtype}{int} rdbLoadBinaryFloatValue(rio *rdb, \textcolor{keywordtype}{float} *val) \{
00590     \textcolor{keywordflow}{if} (rioRead(rdb,val,\textcolor{keyword}{sizeof}(*val)) == 0) \textcolor{keywordflow}{return} -1;
00591     \hyperlink{endianconv_8h_a771f3656eb7d11a1e7f7294b657d8978}{memrev32ifbe}(val);
00592     \textcolor{keywordflow}{return} 0;
00593 \}
00594 
00595 \textcolor{comment}{/* Save the object type of object "o". */}
00596 \textcolor{keywordtype}{int} rdbSaveObjectType(rio *rdb, robj *o) \{
00597     \textcolor{keywordflow}{switch} (o->type) \{
00598     \textcolor{keywordflow}{case} \hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING}:
00599         \textcolor{keywordflow}{return} rdbSaveType(rdb,\hyperlink{rdb_8h_ab64d2f599807d211a63337781c241c41}{RDB\_TYPE\_STRING});
00600     \textcolor{keywordflow}{case} \hyperlink{server_8h_a4a5f22a280949c97a0cb0d4213275126}{OBJ\_LIST}:
00601         \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_aec792aeed6d4bf83966672e6a23043b8}{OBJ\_ENCODING\_QUICKLIST})
00602             \textcolor{keywordflow}{return} rdbSaveType(rdb,\hyperlink{rdb_8h_a391dc0622a3b5f1b3b10c5b5e59eb095}{RDB\_TYPE\_LIST\_QUICKLIST});
00603         \textcolor{keywordflow}{else}
00604             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown list encoding"});
00605     \textcolor{keywordflow}{case} \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET}:
00606         \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET})
00607             \textcolor{keywordflow}{return} rdbSaveType(rdb,\hyperlink{rdb_8h_a0a267bc10fe879463d503d5182865b86}{RDB\_TYPE\_SET\_INTSET});
00608         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT})
00609             \textcolor{keywordflow}{return} rdbSaveType(rdb,\hyperlink{rdb_8h_a164174151582b9f8ce35cda22215abf5}{RDB\_TYPE\_SET});
00610         \textcolor{keywordflow}{else}
00611             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown set encoding"});
00612     \textcolor{keywordflow}{case} \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}:
00613         \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST})
00614             \textcolor{keywordflow}{return} rdbSaveType(rdb,\hyperlink{rdb_8h_a844a39336653d28b5a222404cb4a5bd2}{RDB\_TYPE\_ZSET\_ZIPLIST});
00615         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST})
00616             \textcolor{keywordflow}{return} rdbSaveType(rdb,\hyperlink{rdb_8h_adc645c9007ce7ce91f18bc88a7ea6918}{RDB\_TYPE\_ZSET\_2});
00617         \textcolor{keywordflow}{else}
00618             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted set encoding"});
00619     \textcolor{keywordflow}{case} \hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH}:
00620         \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST})
00621             \textcolor{keywordflow}{return} rdbSaveType(rdb,\hyperlink{rdb_8h_af7ff565f65a30ccd4bf55f1503b63946}{RDB\_TYPE\_HASH\_ZIPLIST});
00622         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT})
00623             \textcolor{keywordflow}{return} rdbSaveType(rdb,\hyperlink{rdb_8h_a61a89168792f4d82b4e5b0e3b02a68ca}{RDB\_TYPE\_HASH});
00624         \textcolor{keywordflow}{else}
00625             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown hash encoding"});
00626     \textcolor{keywordflow}{case} \hyperlink{server_8h_a2c2cc41300ca6b9daca7ea8a6d66edc6}{OBJ\_STREAM}:
00627         \textcolor{keywordflow}{return} rdbSaveType(rdb,\hyperlink{rdb_8h_a6552781f513eb80def691fe64e90000c}{RDB\_TYPE\_STREAM\_LISTPACKS});
00628     \textcolor{keywordflow}{case} \hyperlink{server_8h_a92c1fed85f709180fda0ff10d37d649b}{OBJ\_MODULE}:
00629         \textcolor{keywordflow}{return} rdbSaveType(rdb,\hyperlink{rdb_8h_a9a996d2f95870c7165faaa316a6f8931}{RDB\_TYPE\_MODULE\_2});
00630     \textcolor{keywordflow}{default}:
00631         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown object type"});
00632     \}
00633     \textcolor{keywordflow}{return} -1; \textcolor{comment}{/* avoid warning */}
00634 \}
00635 
00636 \textcolor{comment}{/* Use rdbLoadType() to load a TYPE in RDB format, but returns -1 if the}
00637 \textcolor{comment}{ * type is not specifically a valid Object Type. */}
00638 \textcolor{keywordtype}{int} rdbLoadObjectType(rio *rdb) \{
00639     \textcolor{keywordtype}{int} type;
00640     \textcolor{keywordflow}{if} ((type = rdbLoadType(rdb)) == -1) \textcolor{keywordflow}{return} -1;
00641     \textcolor{keywordflow}{if} (!\hyperlink{rdb_8h_aab085218231452c8782bd5f7d8011ce2}{rdbIsObjectType}(type)) \textcolor{keywordflow}{return} -1;
00642     \textcolor{keywordflow}{return} type;
00643 \}
00644 
00645 \textcolor{comment}{/* Save a Redis object. Returns -1 on error, number of bytes written on success. */}
00646 ssize\_t rdbSaveObject(rio *rdb, robj *o) \{
00647     ssize\_t n = 0, nwritten = 0;
00648 
00649     \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING}) \{
00650         \textcolor{comment}{/* Save a string value */}
00651         \textcolor{keywordflow}{if} ((n = rdbSaveStringObject(rdb,o)) == -1) \textcolor{keywordflow}{return} -1;
00652         nwritten += n;
00653     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a4a5f22a280949c97a0cb0d4213275126}{OBJ\_LIST}) \{
00654         \textcolor{comment}{/* Save a list value */}
00655         \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_aec792aeed6d4bf83966672e6a23043b8}{OBJ\_ENCODING\_QUICKLIST}) \{
00656             quicklist *ql = o->ptr;
00657             quicklistNode *node = ql->head;
00658 
00659             \textcolor{keywordflow}{if} ((n = rdbSaveLen(rdb,ql->len)) == -1) \textcolor{keywordflow}{return} -1;
00660             nwritten += n;
00661 
00662             \textcolor{keywordflow}{while}(node) \{
00663                 \textcolor{keywordflow}{if} (\hyperlink{quicklist_8h_a5ef6eede0028ac5ef22c208cd7828aed}{quicklistNodeIsCompressed}(node)) \{
00664                     \textcolor{keywordtype}{void} *data;
00665                     size\_t compress\_len = quicklistGetLzf(node, &data);
00666                     \textcolor{keywordflow}{if} ((n = rdbSaveLzfBlob(rdb,data,compress\_len,node->sz)) == -1) \textcolor{keywordflow}{return} -1;
00667                     nwritten += n;
00668                 \} \textcolor{keywordflow}{else} \{
00669                     \textcolor{keywordflow}{if} ((n = rdbSaveRawString(rdb,node->zl,node->sz)) == -1) \textcolor{keywordflow}{return} -1;
00670                     nwritten += n;
00671                 \}
00672                 node = node->next;
00673             \}
00674         \} \textcolor{keywordflow}{else} \{
00675             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown list encoding"});
00676         \}
00677     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET}) \{
00678         \textcolor{comment}{/* Save a set value */}
00679         \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00680             dict *set = o->ptr;
00681             dictIterator *di = dictGetIterator(set);
00682             dictEntry *de;
00683 
00684             \textcolor{keywordflow}{if} ((n = rdbSaveLen(rdb,\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(set))) == -1) \textcolor{keywordflow}{return} -1;
00685             nwritten += n;
00686 
00687             \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
00688                 sds ele = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
00689                 \textcolor{keywordflow}{if} ((n = rdbSaveRawString(rdb,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)ele,sdslen(ele)))
00690                     == -1) \textcolor{keywordflow}{return} -1;
00691                 nwritten += n;
00692             \}
00693             dictReleaseIterator(di);
00694         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
00695             size\_t l = intsetBlobLen((intset*)o->ptr);
00696 
00697             \textcolor{keywordflow}{if} ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) \textcolor{keywordflow}{return} -1;
00698             nwritten += n;
00699         \} \textcolor{keywordflow}{else} \{
00700             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown set encoding"});
00701         \}
00702     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET}) \{
00703         \textcolor{comment}{/* Save a sorted set value */}
00704         \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
00705             size\_t l = ziplistBlobLen((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)o->ptr);
00706 
00707             \textcolor{keywordflow}{if} ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) \textcolor{keywordflow}{return} -1;
00708             nwritten += n;
00709         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST}) \{
00710             zset *zs = o->ptr;
00711             zskiplist *zsl = zs->zsl;
00712 
00713             \textcolor{keywordflow}{if} ((n = rdbSaveLen(rdb,zsl->length)) == -1) \textcolor{keywordflow}{return} -1;
00714             nwritten += n;
00715 
00716             \textcolor{comment}{/* We save the skiplist elements from the greatest to the smallest}
00717 \textcolor{comment}{             * (that's trivial since the elements are already ordered in the}
00718 \textcolor{comment}{             * skiplist): this improves the load process, since the next loaded}
00719 \textcolor{comment}{             * element will always be the smaller, so adding to the skiplist}
00720 \textcolor{comment}{             * will always immediately stop at the head, making the insertion}
00721 \textcolor{comment}{             * O(1) instead of O(log(N)). */}
00722             zskiplistNode *zn = zsl->tail;
00723             \textcolor{keywordflow}{while} (zn != NULL) \{
00724                 \textcolor{keywordflow}{if} ((n = rdbSaveRawString(rdb,
00725                     (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)zn->ele,sdslen(zn->ele))) == -1)
00726                 \{
00727                     \textcolor{keywordflow}{return} -1;
00728                 \}
00729                 nwritten += n;
00730                 \textcolor{keywordflow}{if} ((n = rdbSaveBinaryDoubleValue(rdb,zn->score)) == -1)
00731                     \textcolor{keywordflow}{return} -1;
00732                 nwritten += n;
00733                 zn = zn->backward;
00734             \}
00735         \} \textcolor{keywordflow}{else} \{
00736             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown sorted set encoding"});
00737         \}
00738     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH}) \{
00739         \textcolor{comment}{/* Save a hash value */}
00740         \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST}) \{
00741             size\_t l = ziplistBlobLen((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)o->ptr);
00742 
00743             \textcolor{keywordflow}{if} ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) \textcolor{keywordflow}{return} -1;
00744             nwritten += n;
00745 
00746         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
00747             dictIterator *di = dictGetIterator(o->ptr);
00748             dictEntry *de;
00749 
00750             \textcolor{keywordflow}{if} ((n = rdbSaveLen(rdb,\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}((dict*)o->ptr))) == -1) \textcolor{keywordflow}{return} -1;
00751             nwritten += n;
00752 
00753             \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
00754                 sds field = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
00755                 sds value = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
00756 
00757                 \textcolor{keywordflow}{if} ((n = rdbSaveRawString(rdb,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)field,
00758                         sdslen(field))) == -1) \textcolor{keywordflow}{return} -1;
00759                 nwritten += n;
00760                 \textcolor{keywordflow}{if} ((n = rdbSaveRawString(rdb,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)value,
00761                         sdslen(value))) == -1) \textcolor{keywordflow}{return} -1;
00762                 nwritten += n;
00763             \}
00764             dictReleaseIterator(di);
00765         \} \textcolor{keywordflow}{else} \{
00766             \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown hash encoding"});
00767         \}
00768     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a2c2cc41300ca6b9daca7ea8a6d66edc6}{OBJ\_STREAM}) \{
00769         \textcolor{comment}{/* Store how many listpacks we have inside the radix tree. */}
00770         stream *s = o->ptr;
00771         rax *rax = s->rax;
00772         \textcolor{keywordflow}{if} ((n = rdbSaveLen(rdb,raxSize(rax))) == -1) \textcolor{keywordflow}{return} -1;
00773         nwritten += n;
00774 
00775         \textcolor{comment}{/* Serialize all the listpacks inside the radix tree as they are,}
00776 \textcolor{comment}{         * when loading back, we'll use the first entry of each listpack}
00777 \textcolor{comment}{         * to insert it back into the radix tree. */}
00778         \hyperlink{structraxIterator}{raxIterator} ri;
00779         raxStart(&ri,rax);
00780         raxSeek(&ri,\textcolor{stringliteral}{"^"},NULL,0);
00781         \textcolor{keywordflow}{while} (raxNext(&ri)) \{
00782             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lp = ri.data;
00783             size\_t lp\_bytes = lpBytes(lp);
00784             \textcolor{keywordflow}{if} ((n = rdbSaveRawString(rdb,ri.key,ri.key\_len)) == -1) \textcolor{keywordflow}{return} -1;
00785             nwritten += n;
00786             \textcolor{keywordflow}{if} ((n = rdbSaveRawString(rdb,lp,lp\_bytes)) == -1) \textcolor{keywordflow}{return} -1;
00787             nwritten += n;
00788         \}
00789         raxStop(&ri);
00790 
00791         \textcolor{comment}{/* Save the number of elements inside the stream. We cannot obtain}
00792 \textcolor{comment}{         * this easily later, since our macro nodes should be checked for}
00793 \textcolor{comment}{         * number of items: not a great CPU / space tradeoff. */}
00794         \textcolor{keywordflow}{if} ((n = rdbSaveLen(rdb,s->length)) == -1) \textcolor{keywordflow}{return} -1;
00795         nwritten += n;
00796         \textcolor{comment}{/* Save the last entry ID. */}
00797         \textcolor{keywordflow}{if} ((n = rdbSaveLen(rdb,s->last\_id.ms)) == -1) \textcolor{keywordflow}{return} -1;
00798         nwritten += n;
00799         \textcolor{keywordflow}{if} ((n = rdbSaveLen(rdb,s->last\_id.seq)) == -1) \textcolor{keywordflow}{return} -1;
00800         nwritten += n;
00801     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (o->type == \hyperlink{server_8h_a92c1fed85f709180fda0ff10d37d649b}{OBJ\_MODULE}) \{
00802         \textcolor{comment}{/* Save a module-specific value. */}
00803         \hyperlink{structRedisModuleIO}{RedisModuleIO} io;
00804         moduleValue *mv = o->ptr;
00805         moduleType *mt = mv->type;
00806         \hyperlink{server_8h_abe94415e34ee463788c4c863dc029908}{moduleInitIOContext}(io,mt,rdb);
00807 
00808         \textcolor{comment}{/* Write the "module" identifier as prefix, so that we'll be able}
00809 \textcolor{comment}{         * to call the right module during loading. */}
00810         \textcolor{keywordtype}{int} retval = rdbSaveLen(rdb,mt->id);
00811         \textcolor{keywordflow}{if} (retval == -1) \textcolor{keywordflow}{return} -1;
00812         io.bytes += retval;
00813 
00814         \textcolor{comment}{/* Then write the module-specific representation + EOF marker. */}
00815         mt->rdb\_save(&io,mv->value);
00816         retval = rdbSaveLen(rdb,\hyperlink{rdb_8h_a905d414d752c18bdea4cf67b498fee52}{RDB\_MODULE\_OPCODE\_EOF});
00817         \textcolor{keywordflow}{if} (retval == -1) \textcolor{keywordflow}{return} -1;
00818         io.bytes += retval;
00819 
00820         \textcolor{keywordflow}{if} (io.ctx) \{
00821             moduleFreeContext(io.ctx);
00822             zfree(io.ctx);
00823         \}
00824         \textcolor{keywordflow}{return} io.error ? -1 : (ssize\_t)io.bytes;
00825     \} \textcolor{keywordflow}{else} \{
00826         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown object type"});
00827     \}
00828     \textcolor{keywordflow}{return} nwritten;
00829 \}
00830 
00831 \textcolor{comment}{/* Return the length the object will have on disk if saved with}
00832 \textcolor{comment}{ * the rdbSaveObject() function. Currently we use a trick to get}
00833 \textcolor{comment}{ * this length with very little changes to the code. In the future}
00834 \textcolor{comment}{ * we could switch to a faster solution. */}
00835 size\_t rdbSavedObjectLen(robj *o) \{
00836     ssize\_t len = rdbSaveObject(NULL,o);
00837     \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(NULL,o,len != -1);
00838     \textcolor{keywordflow}{return} len;
00839 \}
00840 
00841 \textcolor{comment}{/* Save a key-value pair, with expire time, type, key, value.}
00842 \textcolor{comment}{ * On error -1 is returned.}
00843 \textcolor{comment}{ * On success if the key was actually saved 1 is returned, otherwise 0}
00844 \textcolor{comment}{ * is returned (the key was already expired). */}
00845 \textcolor{keywordtype}{int} rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val,
00846                         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} expiretime, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} now)
00847 \{
00848     \textcolor{comment}{/* Save the expire time */}
00849     \textcolor{keywordflow}{if} (expiretime != -1) \{
00850         \textcolor{comment}{/* If this key is already expired skip it */}
00851         \textcolor{keywordflow}{if} (expiretime < now) \textcolor{keywordflow}{return} 0;
00852         \textcolor{keywordflow}{if} (rdbSaveType(rdb,\hyperlink{rdb_8h_a718021856b2b0cf1c9c907a3a91a39c4}{RDB\_OPCODE\_EXPIRETIME\_MS}) == -1) \textcolor{keywordflow}{return} -1;
00853         \textcolor{keywordflow}{if} (rdbSaveMillisecondTime(rdb,expiretime) == -1) \textcolor{keywordflow}{return} -1;
00854     \}
00855 
00856     \textcolor{comment}{/* Save type, key, value */}
00857     \textcolor{keywordflow}{if} (rdbSaveObjectType(rdb,val) == -1) \textcolor{keywordflow}{return} -1;
00858     \textcolor{keywordflow}{if} (rdbSaveStringObject(rdb,key) == -1) \textcolor{keywordflow}{return} -1;
00859     \textcolor{keywordflow}{if} (rdbSaveObject(rdb,val) == -1) \textcolor{keywordflow}{return} -1;
00860     \textcolor{keywordflow}{return} 1;
00861 \}
00862 
00863 \textcolor{comment}{/* Save an AUX field. */}
00864 \textcolor{keywordtype}{int} rdbSaveAuxField(rio *rdb, \textcolor{keywordtype}{void} *key, size\_t keylen, \textcolor{keywordtype}{void} *val, size\_t vallen) \{
00865     \textcolor{keywordflow}{if} (rdbSaveType(rdb,\hyperlink{rdb_8h_ab0c62f54bb9377a6a75dbe331a2936bd}{RDB\_OPCODE\_AUX}) == -1) \textcolor{keywordflow}{return} -1;
00866     \textcolor{keywordflow}{if} (rdbSaveRawString(rdb,key,keylen) == -1) \textcolor{keywordflow}{return} -1;
00867     \textcolor{keywordflow}{if} (rdbSaveRawString(rdb,val,vallen) == -1) \textcolor{keywordflow}{return} -1;
00868     \textcolor{keywordflow}{return} 1;
00869 \}
00870 
00871 \textcolor{comment}{/* Wrapper for rdbSaveAuxField() used when key/val length can be obtained}
00872 \textcolor{comment}{ * with strlen(). */}
00873 \textcolor{keywordtype}{int} rdbSaveAuxFieldStrStr(rio *rdb, \textcolor{keywordtype}{char} *key, \textcolor{keywordtype}{char} *val) \{
00874     \textcolor{keywordflow}{return} rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));
00875 \}
00876 
00877 \textcolor{comment}{/* Wrapper for strlen(key) + integer type (up to long long range). */}
00878 \textcolor{keywordtype}{int} rdbSaveAuxFieldStrInt(rio *rdb, \textcolor{keywordtype}{char} *key, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val) \{
00879     \textcolor{keywordtype}{char} buf[\hyperlink{server_8h_a39ec35278876f65fc1ef70b049856ca3}{LONG\_STR\_SIZE}];
00880     \textcolor{keywordtype}{int} vlen = ll2string(buf,\textcolor{keyword}{sizeof}(buf),val);
00881     \textcolor{keywordflow}{return} rdbSaveAuxField(rdb,key,strlen(key),buf,vlen);
00882 \}
00883 
00884 \textcolor{comment}{/* Save a few default AUX fields with information about the RDB generated. */}
00885 \textcolor{keywordtype}{int} rdbSaveInfoAuxFields(rio *rdb, \textcolor{keywordtype}{int} flags, rdbSaveInfo *rsi) \{
00886     \textcolor{keywordtype}{int} redis\_bits = (\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*) == 8) ? 64 : 32;
00887     \textcolor{keywordtype}{int} aof\_preamble = (flags & \hyperlink{rdb_8h_a0bafda4fc4a08ebf980ba8e2a1bd3b78}{RDB\_SAVE\_AOF\_PREAMBLE}) != 0;
00888 
00889     \textcolor{comment}{/* Add a few fields about the state when the RDB was created. */}
00890     \textcolor{keywordflow}{if} (rdbSaveAuxFieldStrStr(rdb,\textcolor{stringliteral}{"redis-ver"},\hyperlink{version_8h_a357a0d302ef7fbb42bf2db0632b9f7fe}{REDIS\_VERSION}) == -1) \textcolor{keywordflow}{return} -1;
00891     \textcolor{keywordflow}{if} (rdbSaveAuxFieldStrInt(rdb,\textcolor{stringliteral}{"redis-bits"},redis\_bits) == -1) \textcolor{keywordflow}{return} -1;
00892     \textcolor{keywordflow}{if} (rdbSaveAuxFieldStrInt(rdb,\textcolor{stringliteral}{"ctime"},time(NULL)) == -1) \textcolor{keywordflow}{return} -1;
00893     \textcolor{keywordflow}{if} (rdbSaveAuxFieldStrInt(rdb,\textcolor{stringliteral}{"used-mem"},zmalloc\_used\_memory()) == -1) \textcolor{keywordflow}{return} -1;
00894 
00895     \textcolor{comment}{/* Handle saving options that generate aux fields. */}
00896     \textcolor{keywordflow}{if} (rsi) \{
00897         \textcolor{keywordflow}{if} (rdbSaveAuxFieldStrInt(rdb,\textcolor{stringliteral}{"repl-stream-db"},rsi->repl\_stream\_db)
00898             == -1) \textcolor{keywordflow}{return} -1;
00899         \textcolor{keywordflow}{if} (rdbSaveAuxFieldStrStr(rdb,\textcolor{stringliteral}{"repl-id"},server.replid)
00900             == -1) \textcolor{keywordflow}{return} -1;
00901         \textcolor{keywordflow}{if} (rdbSaveAuxFieldStrInt(rdb,\textcolor{stringliteral}{"repl-offset"},server.master\_repl\_offset)
00902             == -1) \textcolor{keywordflow}{return} -1;
00903     \}
00904     \textcolor{keywordflow}{if} (rdbSaveAuxFieldStrInt(rdb,\textcolor{stringliteral}{"aof-preamble"},aof\_preamble) == -1) \textcolor{keywordflow}{return} -1;
00905     \textcolor{keywordflow}{return} 1;
00906 \}
00907 
00908 \textcolor{comment}{/* Produces a dump of the database in RDB format sending it to the specified}
00909 \textcolor{comment}{ * Redis I/O channel. On success C\_OK is returned, otherwise C\_ERR}
00910 \textcolor{comment}{ * is returned and part of the output, or all the output, can be}
00911 \textcolor{comment}{ * missing because of I/O errors.}
00912 \textcolor{comment}{ *}
00913 \textcolor{comment}{ * When the function returns C\_ERR and if 'error' is not NULL, the}
00914 \textcolor{comment}{ * integer pointed by 'error' is set to the value of errno just after the I/O}
00915 \textcolor{comment}{ * error. */}
00916 \textcolor{keywordtype}{int} rdbSaveRio(rio *rdb, \textcolor{keywordtype}{int} *error, \textcolor{keywordtype}{int} flags, rdbSaveInfo *rsi) \{
00917     dictIterator *di = NULL;
00918     dictEntry *de;
00919     \textcolor{keywordtype}{char} magic[10];
00920     \textcolor{keywordtype}{int} j;
00921     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} now = mstime();
00922     uint64\_t cksum;
00923     size\_t processed = 0;
00924 
00925     \textcolor{keywordflow}{if} (server.rdb\_checksum)
00926         rdb->update\_cksum = rioGenericUpdateChecksum;
00927     snprintf(magic,\textcolor{keyword}{sizeof}(magic),\textcolor{stringliteral}{"REDIS%04d"},\hyperlink{rdb_8h_ae34418fdbb9794fb7558a4f58bdc1cad}{RDB\_VERSION});
00928     \textcolor{keywordflow}{if} (rdbWriteRaw(rdb,magic,9) == -1) \textcolor{keywordflow}{goto} werr;
00929     \textcolor{keywordflow}{if} (rdbSaveInfoAuxFields(rdb,flags,rsi) == -1) \textcolor{keywordflow}{goto} werr;
00930 
00931     \textcolor{keywordflow}{for} (j = 0; j < server.dbnum; j++) \{
00932         redisDb *db = server.db+j;
00933         dict *d = db->dict;
00934         \textcolor{keywordflow}{if} (\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(d) == 0) \textcolor{keywordflow}{continue};
00935         di = dictGetSafeIterator(d);
00936         \textcolor{keywordflow}{if} (!di) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00937 
00938         \textcolor{comment}{/* Write the SELECT DB opcode */}
00939         \textcolor{keywordflow}{if} (rdbSaveType(rdb,\hyperlink{rdb_8h_a08e0489a0baf79997ee8411e850d6c70}{RDB\_OPCODE\_SELECTDB}) == -1) \textcolor{keywordflow}{goto} werr;
00940         \textcolor{keywordflow}{if} (rdbSaveLen(rdb,j) == -1) \textcolor{keywordflow}{goto} werr;
00941 
00942         \textcolor{comment}{/* Write the RESIZE DB opcode. We trim the size to UINT32\_MAX, which}
00943 \textcolor{comment}{         * is currently the largest type we are able to represent in RDB sizes.}
00944 \textcolor{comment}{         * However this does not limit the actual size of the DB to load since}
00945 \textcolor{comment}{         * these sizes are just hints to resize the hash tables. */}
00946         uint32\_t db\_size, expires\_size;
00947         db\_size = (\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(db->dict) <= UINT32\_MAX) ?
00948                                 \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(db->dict) :
00949                                 UINT32\_MAX;
00950         expires\_size = (\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(db->expires) <= UINT32\_MAX) ?
00951                                 \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(db->expires) :
00952                                 UINT32\_MAX;
00953         \textcolor{keywordflow}{if} (rdbSaveType(rdb,\hyperlink{rdb_8h_ad1f63cee59a3066446beecae389a8758}{RDB\_OPCODE\_RESIZEDB}) == -1) \textcolor{keywordflow}{goto} werr;
00954         \textcolor{keywordflow}{if} (rdbSaveLen(rdb,db\_size) == -1) \textcolor{keywordflow}{goto} werr;
00955         \textcolor{keywordflow}{if} (rdbSaveLen(rdb,expires\_size) == -1) \textcolor{keywordflow}{goto} werr;
00956 
00957         \textcolor{comment}{/* Iterate this DB writing every entry */}
00958         \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
00959             sds keystr = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
00960             robj key, *o = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
00961             \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} expire;
00962 
00963             \hyperlink{server_8h_abb4d561af9c6476a52e9236bcae5408d}{initStaticStringObject}(key,keystr);
00964             expire = getExpire(db,&key);
00965             \textcolor{keywordflow}{if} (rdbSaveKeyValuePair(rdb,&key,o,expire,now) == -1) \textcolor{keywordflow}{goto} werr;
00966 
00967             \textcolor{comment}{/* When this RDB is produced as part of an AOF rewrite, move}
00968 \textcolor{comment}{             * accumulated diff from parent to child while rewriting in}
00969 \textcolor{comment}{             * order to have a smaller final write. */}
00970             \textcolor{keywordflow}{if} (flags & \hyperlink{rdb_8h_a0bafda4fc4a08ebf980ba8e2a1bd3b78}{RDB\_SAVE\_AOF\_PREAMBLE} &&
00971                 rdb->processed\_bytes > processed+
      \hyperlink{server_8h_a0044e793bf429aa6921aa7924a2b62e5}{AOF\_READ\_DIFF\_INTERVAL\_BYTES})
00972             \{
00973                 processed = rdb->processed\_bytes;
00974                 aofReadDiffFromParent();
00975             \}
00976         \}
00977         dictReleaseIterator(di);
00978     \}
00979     di = NULL; \textcolor{comment}{/* So that we don't release it again on error. */}
00980 
00981     \textcolor{comment}{/* If we are storing the replication information on disk, persist}
00982 \textcolor{comment}{     * the script cache as well: on successful PSYNC after a restart, we need}
00983 \textcolor{comment}{     * to be able to process any EVALSHA inside the replication backlog the}
00984 \textcolor{comment}{     * master will send us. */}
00985     \textcolor{keywordflow}{if} (rsi && \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.lua\_scripts)) \{
00986         di = dictGetIterator(server.lua\_scripts);
00987         \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
00988             robj *body = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
00989             \textcolor{keywordflow}{if} (rdbSaveAuxField(rdb,\textcolor{stringliteral}{"lua"},3,body->ptr,sdslen(body->ptr)) == -1)
00990                 \textcolor{keywordflow}{goto} werr;
00991         \}
00992         dictReleaseIterator(di);
00993     \}
00994 
00995     \textcolor{comment}{/* EOF opcode */}
00996     \textcolor{keywordflow}{if} (rdbSaveType(rdb,\hyperlink{rdb_8h_af4c616d96f3dc8d44911f7fff2a712da}{RDB\_OPCODE\_EOF}) == -1) \textcolor{keywordflow}{goto} werr;
00997 
00998     \textcolor{comment}{/* CRC64 checksum. It will be zero if checksum computation is disabled, the}
00999 \textcolor{comment}{     * loading code skips the check in this case. */}
01000     cksum = rdb->cksum;
01001     \hyperlink{endianconv_8h_aa311b9f944c3b988f3601698a95890c1}{memrev64ifbe}(&cksum);
01002     \textcolor{keywordflow}{if} (rioWrite(rdb,&cksum,8) == 0) \textcolor{keywordflow}{goto} werr;
01003     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01004 
01005 werr:
01006     \textcolor{keywordflow}{if} (error) *error = errno;
01007     \textcolor{keywordflow}{if} (di) dictReleaseIterator(di);
01008     \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01009 \}
01010 
01011 \textcolor{comment}{/* This is just a wrapper to rdbSaveRio() that additionally adds a prefix}
01012 \textcolor{comment}{ * and a suffix to the generated RDB dump. The prefix is:}
01013 \textcolor{comment}{ *}
01014 \textcolor{comment}{ * $EOF:<40 bytes unguessable hex string>\(\backslash\)r\(\backslash\)n}
01015 \textcolor{comment}{ *}
01016 \textcolor{comment}{ * While the suffix is the 40 bytes hex string we announced in the prefix.}
01017 \textcolor{comment}{ * This way processes receiving the payload can understand when it ends}
01018 \textcolor{comment}{ * without doing any processing of the content. */}
01019 \textcolor{keywordtype}{int} rdbSaveRioWithEOFMark(rio *rdb, \textcolor{keywordtype}{int} *error, rdbSaveInfo *rsi) \{
01020     \textcolor{keywordtype}{char} eofmark[\hyperlink{server_8h_ae0ddcb5f14fe8c5d812f514c9cf2b70b}{RDB\_EOF\_MARK\_SIZE}];
01021 
01022     getRandomHexChars(eofmark,\hyperlink{server_8h_ae0ddcb5f14fe8c5d812f514c9cf2b70b}{RDB\_EOF\_MARK\_SIZE});
01023     \textcolor{keywordflow}{if} (error) *error = 0;
01024     \textcolor{keywordflow}{if} (rioWrite(rdb,\textcolor{stringliteral}{"$EOF:"},5) == 0) \textcolor{keywordflow}{goto} werr;
01025     \textcolor{keywordflow}{if} (rioWrite(rdb,eofmark,\hyperlink{server_8h_ae0ddcb5f14fe8c5d812f514c9cf2b70b}{RDB\_EOF\_MARK\_SIZE}) == 0) \textcolor{keywordflow}{goto} werr;
01026     \textcolor{keywordflow}{if} (rioWrite(rdb,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"},2) == 0) \textcolor{keywordflow}{goto} werr;
01027     \textcolor{keywordflow}{if} (rdbSaveRio(rdb,error,\hyperlink{rdb_8h_a2f6a651ce17c73ec98c3a4ac25bc2aa7}{RDB\_SAVE\_NONE},rsi) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \textcolor{keywordflow}{goto} werr;
01028     \textcolor{keywordflow}{if} (rioWrite(rdb,eofmark,\hyperlink{server_8h_ae0ddcb5f14fe8c5d812f514c9cf2b70b}{RDB\_EOF\_MARK\_SIZE}) == 0) \textcolor{keywordflow}{goto} werr;
01029     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01030 
01031 werr: \textcolor{comment}{/* Write error. */}
01032     \textcolor{comment}{/* Set 'error' only if not already set by rdbSaveRio() call. */}
01033     \textcolor{keywordflow}{if} (error && *error == 0) *error = errno;
01034     \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01035 \}
01036 
01037 \textcolor{comment}{/* Save the DB on disk. Return C\_ERR on error, C\_OK on success. */}
01038 \textcolor{keywordtype}{int} rdbSave(\textcolor{keywordtype}{char} *filename, rdbSaveInfo *rsi) \{
01039     \textcolor{keywordtype}{char} tmpfile[256];
01040     \textcolor{keywordtype}{char} cwd[MAXPATHLEN]; \textcolor{comment}{/* Current working dir path for error messages. */}
01041     FILE *fp;
01042     rio rdb;
01043     \textcolor{keywordtype}{int} error = 0;
01044 
01045     snprintf(tmpfile,256,\textcolor{stringliteral}{"temp-%d.rdb"}, (\textcolor{keywordtype}{int}) getpid());
01046     fp = fopen(tmpfile,\textcolor{stringliteral}{"w"});
01047     \textcolor{keywordflow}{if} (!fp) \{
01048         \textcolor{keywordtype}{char} *cwdp = getcwd(cwd,MAXPATHLEN);
01049         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01050             \textcolor{stringliteral}{"Failed opening the RDB file %s (in server root dir %s) "}
01051             \textcolor{stringliteral}{"for saving: %s"},
01052             filename,
01053             cwdp ? cwdp : \textcolor{stringliteral}{"unknown"},
01054             strerror(errno));
01055         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01056     \}
01057 
01058     rioInitWithFile(&rdb,fp);
01059     \textcolor{keywordflow}{if} (rdbSaveRio(&rdb,&error,\hyperlink{rdb_8h_a2f6a651ce17c73ec98c3a4ac25bc2aa7}{RDB\_SAVE\_NONE},rsi) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
01060         errno = error;
01061         \textcolor{keywordflow}{goto} werr;
01062     \}
01063 
01064     \textcolor{comment}{/* Make sure data will not remain on the OS's output buffers */}
01065     \textcolor{keywordflow}{if} (fflush(fp) == EOF) \textcolor{keywordflow}{goto} werr;
01066     \textcolor{keywordflow}{if} (fsync(fileno(fp)) == -1) \textcolor{keywordflow}{goto} werr;
01067     \textcolor{keywordflow}{if} (fclose(fp) == EOF) \textcolor{keywordflow}{goto} werr;
01068 
01069     \textcolor{comment}{/* Use RENAME to make sure the DB file is changed atomically only}
01070 \textcolor{comment}{     * if the generate DB file is ok. */}
01071     \textcolor{keywordflow}{if} (rename(tmpfile,filename) == -1) \{
01072         \textcolor{keywordtype}{char} *cwdp = getcwd(cwd,MAXPATHLEN);
01073         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01074             \textcolor{stringliteral}{"Error moving temp DB file %s on the final "}
01075             \textcolor{stringliteral}{"destination %s (in server root dir %s): %s"},
01076             tmpfile,
01077             filename,
01078             cwdp ? cwdp : \textcolor{stringliteral}{"unknown"},
01079             strerror(errno));
01080         unlink(tmpfile);
01081         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01082     \}
01083 
01084     serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"DB saved on disk"});
01085     server.dirty = 0;
01086     server.lastsave = time(NULL);
01087     server.lastbgsave\_status = \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01088     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01089 
01090 werr:
01091     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Write error saving DB on disk: %s"}, strerror(errno));
01092     fclose(fp);
01093     unlink(tmpfile);
01094     \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01095 \}
01096 
01097 \textcolor{keywordtype}{int} rdbSaveBackground(\textcolor{keywordtype}{char} *filename, rdbSaveInfo *rsi) \{
01098     pid\_t childpid;
01099     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} start;
01100 
01101     \textcolor{keywordflow}{if} (server.aof\_child\_pid != -1 || server.rdb\_child\_pid != -1) \textcolor{keywordflow}{return} 
      \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01102 
01103     server.dirty\_before\_bgsave = server.dirty;
01104     server.lastbgsave\_try = time(NULL);
01105     openChildInfoPipe();
01106 
01107     start = ustime();
01108     \textcolor{keywordflow}{if} ((childpid = fork()) == 0) \{
01109         \textcolor{keywordtype}{int} retval;
01110 
01111         \textcolor{comment}{/* Child */}
01112         closeListeningSockets(0);
01113         redisSetProcTitle(\textcolor{stringliteral}{"redis-rdb-bgsave"});
01114         retval = rdbSave(filename,rsi);
01115         \textcolor{keywordflow}{if} (retval == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
01116             size\_t private\_dirty = zmalloc\_get\_private\_dirty(-1);
01117 
01118             \textcolor{keywordflow}{if} (private\_dirty) \{
01119                 serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01120                     \textcolor{stringliteral}{"RDB: %zu MB of memory used by copy-on-write"},
01121                     private\_dirty/(1024*1024));
01122             \}
01123 
01124             server.child\_info\_data.cow\_size = private\_dirty;
01125             sendChildInfo(\hyperlink{server_8h_a878f18d9e3d0af58b81a17d764a81dbe}{CHILD\_INFO\_TYPE\_RDB});
01126         \}
01127         exitFromChild((retval == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) ? 0 : 1);
01128     \} \textcolor{keywordflow}{else} \{
01129         \textcolor{comment}{/* Parent */}
01130         server.stat\_fork\_time = ustime()-start;
01131         server.stat\_fork\_rate = (\textcolor{keywordtype}{double}) zmalloc\_used\_memory() * 1000000 / server.stat\_fork\_time / (
      1024*1024*1024); \textcolor{comment}{/* GB per second. */}
01132         \hyperlink{latency_8h_a77922ab34035890c90f98831a9071359}{latencyAddSampleIfNeeded}(\textcolor{stringliteral}{"fork"},server.stat\_fork\_time/1000);
01133         \textcolor{keywordflow}{if} (childpid == -1) \{
01134             closeChildInfoPipe();
01135             server.lastbgsave\_status = \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01136             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Can't save in background: fork: %s"},
01137                 strerror(errno));
01138             \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01139         \}
01140         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Background saving started by pid %d"},childpid);
01141         server.rdb\_save\_time\_start = time(NULL);
01142         server.rdb\_child\_pid = childpid;
01143         server.rdb\_child\_type = \hyperlink{server_8h_a9d886e992717fa246dd7954244ff6bdf}{RDB\_CHILD\_TYPE\_DISK};
01144         updateDictResizePolicy();
01145         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01146     \}
01147     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}; \textcolor{comment}{/* unreached */}
01148 \}
01149 
01150 \textcolor{keywordtype}{void} rdbRemoveTempFile(pid\_t childpid) \{
01151     \textcolor{keywordtype}{char} tmpfile[256];
01152 
01153     snprintf(tmpfile,\textcolor{keyword}{sizeof}(tmpfile),\textcolor{stringliteral}{"temp-%d.rdb"}, (\textcolor{keywordtype}{int}) childpid);
01154     unlink(tmpfile);
01155 \}
01156 
01157 \textcolor{comment}{/* This function is called by rdbLoadObject() when the code is in RDB-check}
01158 \textcolor{comment}{ * mode and we find a module value of type 2 that can be parsed without}
01159 \textcolor{comment}{ * the need of the actual module. The value is parsed for errors, finally}
01160 \textcolor{comment}{ * a dummy redis object is returned just to conform to the API. */}
01161 robj *rdbLoadCheckModuleValue(rio *rdb, \textcolor{keywordtype}{char} *modulename) \{
01162     uint64\_t opcode;
01163     \textcolor{keywordflow}{while}((opcode = rdbLoadLen(rdb,NULL)) != \hyperlink{rdb_8h_a905d414d752c18bdea4cf67b498fee52}{RDB\_MODULE\_OPCODE\_EOF}) \{
01164         \textcolor{keywordflow}{if} (opcode == \hyperlink{rdb_8h_a687c158b5c4c8a139b8980145f4aec5d}{RDB\_MODULE\_OPCODE\_SINT} ||
01165             opcode == \hyperlink{rdb_8h_a51400e437b171bb1d6206058b48e9938}{RDB\_MODULE\_OPCODE\_UINT})
01166         \{
01167             uint64\_t len;
01168             \textcolor{keywordflow}{if} (rdbLoadLenByRef(rdb,NULL,&len) == -1) \{
01169                 \hyperlink{rdb_8c_afb34e310c0e5dfd9f8c2bebbec59c7f7}{rdbExitReportCorruptRDB}(
01170                     \textcolor{stringliteral}{"Error reading integer from module %s value"}, modulename);
01171             \}
01172         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (opcode == \hyperlink{rdb_8h_aba61dd3092856fb28a71a7e0032d82f1}{RDB\_MODULE\_OPCODE\_STRING}) \{
01173             robj *o = rdbGenericLoadStringObject(rdb,\hyperlink{rdb_8h_aa6539176570d3833856d0b6c71077c67}{RDB\_LOAD\_NONE},NULL);
01174             \textcolor{keywordflow}{if} (o == NULL) \{
01175                 \hyperlink{rdb_8c_afb34e310c0e5dfd9f8c2bebbec59c7f7}{rdbExitReportCorruptRDB}(
01176                     \textcolor{stringliteral}{"Error reading string from module %s value"}, modulename);
01177             \}
01178             decrRefCount(o);
01179         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (opcode == \hyperlink{rdb_8h_ac6c932476609f11914ab1172688f247e}{RDB\_MODULE\_OPCODE\_FLOAT}) \{
01180             \textcolor{keywordtype}{float} val;
01181             \textcolor{keywordflow}{if} (rdbLoadBinaryFloatValue(rdb,&val) == -1) \{
01182                 \hyperlink{rdb_8c_afb34e310c0e5dfd9f8c2bebbec59c7f7}{rdbExitReportCorruptRDB}(
01183                     \textcolor{stringliteral}{"Error reading float from module %s value"}, modulename);
01184             \}
01185         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (opcode == \hyperlink{rdb_8h_a657fe8be09e7e9b7b4e071da54d2a5f7}{RDB\_MODULE\_OPCODE\_DOUBLE}) \{
01186             \textcolor{keywordtype}{double} val;
01187             \textcolor{keywordflow}{if} (rdbLoadBinaryDoubleValue(rdb,&val) == -1) \{
01188                 \hyperlink{rdb_8c_afb34e310c0e5dfd9f8c2bebbec59c7f7}{rdbExitReportCorruptRDB}(
01189                     \textcolor{stringliteral}{"Error reading double from module %s value"}, modulename);
01190             \}
01191         \}
01192     \}
01193     \textcolor{keywordflow}{return} createStringObject(\textcolor{stringliteral}{"module-dummy-value"},18);
01194 \}
01195 
01196 \textcolor{comment}{/* Load a Redis object of the specified type from the specified file.}
01197 \textcolor{comment}{ * On success a newly allocated object is returned, otherwise NULL. */}
01198 robj *rdbLoadObject(\textcolor{keywordtype}{int} rdbtype, rio *rdb) \{
01199     robj *o = NULL, *ele, *dec;
01200     uint64\_t len;
01201     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i;
01202 
01203     \textcolor{keywordflow}{if} (rdbtype == \hyperlink{rdb_8h_ab64d2f599807d211a63337781c241c41}{RDB\_TYPE\_STRING}) \{
01204         \textcolor{comment}{/* Read string value */}
01205         \textcolor{keywordflow}{if} ((o = rdbLoadEncodedStringObject(rdb)) == NULL) \textcolor{keywordflow}{return} NULL;
01206         o = tryObjectEncoding(o);
01207     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rdbtype == \hyperlink{rdb_8h_aaa1836beb7e9668740980b593fb09978}{RDB\_TYPE\_LIST}) \{
01208         \textcolor{comment}{/* Read list value */}
01209         \textcolor{keywordflow}{if} ((len = rdbLoadLen(rdb,NULL)) == \hyperlink{rdb_8h_aa66b6ad7261656029e6a67cf78432b2d}{RDB\_LENERR}) \textcolor{keywordflow}{return} NULL;
01210 
01211         o = createQuicklistObject();
01212         quicklistSetOptions(o->ptr, server.list\_max\_ziplist\_size,
01213                             server.list\_compress\_depth);
01214 
01215         \textcolor{comment}{/* Load every single element of the list */}
01216         \textcolor{keywordflow}{while}(len--) \{
01217             \textcolor{keywordflow}{if} ((ele = rdbLoadEncodedStringObject(rdb)) == NULL) \textcolor{keywordflow}{return} NULL;
01218             dec = getDecodedObject(ele);
01219             size\_t len = sdslen(dec->ptr);
01220             quicklistPushTail(o->ptr, dec->ptr, len);
01221             decrRefCount(dec);
01222             decrRefCount(ele);
01223         \}
01224     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rdbtype == \hyperlink{rdb_8h_a164174151582b9f8ce35cda22215abf5}{RDB\_TYPE\_SET}) \{
01225         \textcolor{comment}{/* Read Set value */}
01226         \textcolor{keywordflow}{if} ((len = rdbLoadLen(rdb,NULL)) == \hyperlink{rdb_8h_aa66b6ad7261656029e6a67cf78432b2d}{RDB\_LENERR}) \textcolor{keywordflow}{return} NULL;
01227 
01228         \textcolor{comment}{/* Use a regular set when there are too many entries. */}
01229         \textcolor{keywordflow}{if} (len > server.set\_max\_intset\_entries) \{
01230             o = createSetObject();
01231             \textcolor{comment}{/* It's faster to expand the dict to the right size asap in order}
01232 \textcolor{comment}{             * to avoid rehashing */}
01233             \textcolor{keywordflow}{if} (len > \hyperlink{dict_8h_aff97c19d1616cf2c697573ee3f515692}{DICT\_HT\_INITIAL\_SIZE})
01234                 dictExpand(o->ptr,len);
01235         \} \textcolor{keywordflow}{else} \{
01236             o = createIntsetObject();
01237         \}
01238 
01239         \textcolor{comment}{/* Load every single element of the set */}
01240         \textcolor{keywordflow}{for} (i = 0; i < len; i++) \{
01241             \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} llval;
01242             sds sdsele;
01243 
01244             \textcolor{keywordflow}{if} ((sdsele = rdbGenericLoadStringObject(rdb,\hyperlink{rdb_8h_ad15f5cc8e1a7789cc35b66f017e98a18}{RDB\_LOAD\_SDS},NULL))
01245                 == NULL) \textcolor{keywordflow}{return} NULL;
01246 
01247             \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET}) \{
01248                 \textcolor{comment}{/* Fetch integer value from element. */}
01249                 \textcolor{keywordflow}{if} (isSdsRepresentableAsLongLong(sdsele,&llval) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
01250                     o->ptr = intsetAdd(o->ptr,llval,NULL);
01251                 \} \textcolor{keywordflow}{else} \{
01252                     setTypeConvert(o,\hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT});
01253                     dictExpand(o->ptr,len);
01254                 \}
01255             \}
01256 
01257             \textcolor{comment}{/* This will also be called when the set was just converted}
01258 \textcolor{comment}{             * to a regular hash table encoded set. */}
01259             \textcolor{keywordflow}{if} (o->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT}) \{
01260                 dictAdd((dict*)o->ptr,sdsele,NULL);
01261             \} \textcolor{keywordflow}{else} \{
01262                 sdsfree(sdsele);
01263             \}
01264         \}
01265     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rdbtype == \hyperlink{rdb_8h_adc645c9007ce7ce91f18bc88a7ea6918}{RDB\_TYPE\_ZSET\_2} || rdbtype == 
      \hyperlink{rdb_8h_ad3e3b26518a5116df59e48fcf2a2ef68}{RDB\_TYPE\_ZSET}) \{
01266         \textcolor{comment}{/* Read list/set value. */}
01267         uint64\_t zsetlen;
01268         size\_t maxelelen = 0;
01269         zset *zs;
01270 
01271         \textcolor{keywordflow}{if} ((zsetlen = rdbLoadLen(rdb,NULL)) == \hyperlink{rdb_8h_aa66b6ad7261656029e6a67cf78432b2d}{RDB\_LENERR}) \textcolor{keywordflow}{return} NULL;
01272         o = createZsetObject();
01273         zs = o->ptr;
01274 
01275         \textcolor{comment}{/* Load every single element of the sorted set. */}
01276         \textcolor{keywordflow}{while}(zsetlen--) \{
01277             sds sdsele;
01278             \textcolor{keywordtype}{double} score;
01279             zskiplistNode *znode;
01280 
01281             \textcolor{keywordflow}{if} ((sdsele = rdbGenericLoadStringObject(rdb,\hyperlink{rdb_8h_ad15f5cc8e1a7789cc35b66f017e98a18}{RDB\_LOAD\_SDS},NULL))
01282                 == NULL) \textcolor{keywordflow}{return} NULL;
01283 
01284             \textcolor{keywordflow}{if} (rdbtype == \hyperlink{rdb_8h_adc645c9007ce7ce91f18bc88a7ea6918}{RDB\_TYPE\_ZSET\_2}) \{
01285                 \textcolor{keywordflow}{if} (rdbLoadBinaryDoubleValue(rdb,&score) == -1) \textcolor{keywordflow}{return} NULL;
01286             \} \textcolor{keywordflow}{else} \{
01287                 \textcolor{keywordflow}{if} (rdbLoadDoubleValue(rdb,&score) == -1) \textcolor{keywordflow}{return} NULL;
01288             \}
01289 
01290             \textcolor{comment}{/* Don't care about integer-encoded strings. */}
01291             \textcolor{keywordflow}{if} (sdslen(sdsele) > maxelelen) maxelelen = sdslen(sdsele);
01292 
01293             znode = zslInsert(zs->zsl,score,sdsele);
01294             dictAdd(zs->dict,sdsele,&znode->score);
01295         \}
01296 
01297         \textcolor{comment}{/* Convert *after* loading, since sorted sets are not stored ordered. */}
01298         \textcolor{keywordflow}{if} (zsetLength(o) <= server.zset\_max\_ziplist\_entries &&
01299             maxelelen <= server.zset\_max\_ziplist\_value)
01300                 zsetConvert(o,\hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST});
01301     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rdbtype == \hyperlink{rdb_8h_a61a89168792f4d82b4e5b0e3b02a68ca}{RDB\_TYPE\_HASH}) \{
01302         uint64\_t len;
01303         \textcolor{keywordtype}{int} ret;
01304         sds field, value;
01305 
01306         len = rdbLoadLen(rdb, NULL);
01307         \textcolor{keywordflow}{if} (len == \hyperlink{rdb_8h_aa66b6ad7261656029e6a67cf78432b2d}{RDB\_LENERR}) \textcolor{keywordflow}{return} NULL;
01308 
01309         o = createHashObject();
01310 
01311         \textcolor{comment}{/* Too many entries? Use a hash table. */}
01312         \textcolor{keywordflow}{if} (len > server.hash\_max\_ziplist\_entries)
01313             hashTypeConvert(o, \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT});
01314 
01315         \textcolor{comment}{/* Load every field and value into the ziplist */}
01316         \textcolor{keywordflow}{while} (o->encoding == \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST} && len > 0) \{
01317             len--;
01318             \textcolor{comment}{/* Load raw strings */}
01319             \textcolor{keywordflow}{if} ((field = rdbGenericLoadStringObject(rdb,\hyperlink{rdb_8h_ad15f5cc8e1a7789cc35b66f017e98a18}{RDB\_LOAD\_SDS},NULL))
01320                 == NULL) \textcolor{keywordflow}{return} NULL;
01321             \textcolor{keywordflow}{if} ((value = rdbGenericLoadStringObject(rdb,\hyperlink{rdb_8h_ad15f5cc8e1a7789cc35b66f017e98a18}{RDB\_LOAD\_SDS},NULL))
01322                 == NULL) \textcolor{keywordflow}{return} NULL;
01323 
01324             \textcolor{comment}{/* Add pair to ziplist */}
01325             o->ptr = ziplistPush(o->ptr, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)field,
01326                     sdslen(field), \hyperlink{ziplist_8h_a25d058a2c2c0db0f131f84d23ede6ba2}{ZIPLIST\_TAIL});
01327             o->ptr = ziplistPush(o->ptr, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)value,
01328                     sdslen(value), \hyperlink{ziplist_8h_a25d058a2c2c0db0f131f84d23ede6ba2}{ZIPLIST\_TAIL});
01329 
01330             \textcolor{comment}{/* Convert to hash table if size threshold is exceeded */}
01331             \textcolor{keywordflow}{if} (sdslen(field) > server.hash\_max\_ziplist\_value ||
01332                 sdslen(value) > server.hash\_max\_ziplist\_value)
01333             \{
01334                 sdsfree(field);
01335                 sdsfree(value);
01336                 hashTypeConvert(o, \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT});
01337                 \textcolor{keywordflow}{break};
01338             \}
01339             sdsfree(field);
01340             sdsfree(value);
01341         \}
01342 
01343         \textcolor{comment}{/* Load remaining fields and values into the hash table */}
01344         \textcolor{keywordflow}{while} (o->encoding == \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT} && len > 0) \{
01345             len--;
01346             \textcolor{comment}{/* Load encoded strings */}
01347             \textcolor{keywordflow}{if} ((field = rdbGenericLoadStringObject(rdb,\hyperlink{rdb_8h_ad15f5cc8e1a7789cc35b66f017e98a18}{RDB\_LOAD\_SDS},NULL))
01348                 == NULL) \textcolor{keywordflow}{return} NULL;
01349             \textcolor{keywordflow}{if} ((value = rdbGenericLoadStringObject(rdb,\hyperlink{rdb_8h_ad15f5cc8e1a7789cc35b66f017e98a18}{RDB\_LOAD\_SDS},NULL))
01350                 == NULL) \textcolor{keywordflow}{return} NULL;
01351 
01352             \textcolor{comment}{/* Add pair to hash table */}
01353             ret = dictAdd((dict*)o->ptr, field, value);
01354             \textcolor{keywordflow}{if} (ret == \hyperlink{dict_8h_a6ce31f31f044b1570d335e8fa0c388c6}{DICT\_ERR}) \{
01355                 \hyperlink{rdb_8c_afb34e310c0e5dfd9f8c2bebbec59c7f7}{rdbExitReportCorruptRDB}(\textcolor{stringliteral}{"Duplicate keys detected"});
01356             \}
01357         \}
01358 
01359         \textcolor{comment}{/* All pairs should be read by now */}
01360         \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(len == 0);
01361     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rdbtype == \hyperlink{rdb_8h_a391dc0622a3b5f1b3b10c5b5e59eb095}{RDB\_TYPE\_LIST\_QUICKLIST}) \{
01362         \textcolor{keywordflow}{if} ((len = rdbLoadLen(rdb,NULL)) == \hyperlink{rdb_8h_aa66b6ad7261656029e6a67cf78432b2d}{RDB\_LENERR}) \textcolor{keywordflow}{return} NULL;
01363         o = createQuicklistObject();
01364         quicklistSetOptions(o->ptr, server.list\_max\_ziplist\_size,
01365                             server.list\_compress\_depth);
01366 
01367         \textcolor{keywordflow}{while} (len--) \{
01368             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl =
01369                 rdbGenericLoadStringObject(rdb,\hyperlink{rdb_8h_a5579c0ff24afa891ad41006def040a25}{RDB\_LOAD\_PLAIN},NULL);
01370             \textcolor{keywordflow}{if} (zl == NULL) \textcolor{keywordflow}{return} NULL;
01371             quicklistAppendZiplist(o->ptr, zl);
01372         \}
01373     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rdbtype == \hyperlink{rdb_8h_ada37d3f42c37fc3b8894f5c541df5033}{RDB\_TYPE\_HASH\_ZIPMAP}  ||
01374                rdbtype == \hyperlink{rdb_8h_a404cb257f5c3d725f89417ba4f0142c5}{RDB\_TYPE\_LIST\_ZIPLIST} ||
01375                rdbtype == \hyperlink{rdb_8h_a0a267bc10fe879463d503d5182865b86}{RDB\_TYPE\_SET\_INTSET}   ||
01376                rdbtype == \hyperlink{rdb_8h_a844a39336653d28b5a222404cb4a5bd2}{RDB\_TYPE\_ZSET\_ZIPLIST} ||
01377                rdbtype == \hyperlink{rdb_8h_af7ff565f65a30ccd4bf55f1503b63946}{RDB\_TYPE\_HASH\_ZIPLIST})
01378     \{
01379         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *encoded =
01380             rdbGenericLoadStringObject(rdb,\hyperlink{rdb_8h_a5579c0ff24afa891ad41006def040a25}{RDB\_LOAD\_PLAIN},NULL);
01381         \textcolor{keywordflow}{if} (encoded == NULL) \textcolor{keywordflow}{return} NULL;
01382         o = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},encoded); \textcolor{comment}{/* Obj type fixed below. */}
01383 
01384         \textcolor{comment}{/* Fix the object encoding, and make sure to convert the encoded}
01385 \textcolor{comment}{         * data type into the base type if accordingly to the current}
01386 \textcolor{comment}{         * configuration there are too many elements in the encoded data}
01387 \textcolor{comment}{         * type. Note that we only check the length and not max element}
01388 \textcolor{comment}{         * size as this is an O(N) scan. Eventually everything will get}
01389 \textcolor{comment}{         * converted. */}
01390         \textcolor{keywordflow}{switch}(rdbtype) \{
01391             \textcolor{keywordflow}{case} \hyperlink{rdb_8h_ada37d3f42c37fc3b8894f5c541df5033}{RDB\_TYPE\_HASH\_ZIPMAP}:
01392                 \textcolor{comment}{/* Convert to ziplist encoded hash. This must be deprecated}
01393 \textcolor{comment}{                 * when loading dumps created by Redis 2.4 gets deprecated. */}
01394                 \{
01395                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zl = ziplistNew();
01396                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zi = zipmapRewind(o->ptr);
01397                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *fstr, *vstr;
01398                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} flen, vlen;
01399                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} maxlen = 0;
01400 
01401                     \textcolor{keywordflow}{while} ((zi = zipmapNext(zi, &fstr, &flen, &vstr, &vlen)) != NULL) \{
01402                         \textcolor{keywordflow}{if} (flen > maxlen) maxlen = flen;
01403                         \textcolor{keywordflow}{if} (vlen > maxlen) maxlen = vlen;
01404                         zl = ziplistPush(zl, fstr, flen, \hyperlink{ziplist_8h_a25d058a2c2c0db0f131f84d23ede6ba2}{ZIPLIST\_TAIL});
01405                         zl = ziplistPush(zl, vstr, vlen, \hyperlink{ziplist_8h_a25d058a2c2c0db0f131f84d23ede6ba2}{ZIPLIST\_TAIL});
01406                     \}
01407 
01408                     zfree(o->ptr);
01409                     o->ptr = zl;
01410                     o->type = \hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH};
01411                     o->encoding = \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST};
01412 
01413                     \textcolor{keywordflow}{if} (hashTypeLength(o) > server.hash\_max\_ziplist\_entries ||
01414                         maxlen > server.hash\_max\_ziplist\_value)
01415                     \{
01416                         hashTypeConvert(o, \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT});
01417                     \}
01418                 \}
01419                 \textcolor{keywordflow}{break};
01420             \textcolor{keywordflow}{case} \hyperlink{rdb_8h_a404cb257f5c3d725f89417ba4f0142c5}{RDB\_TYPE\_LIST\_ZIPLIST}:
01421                 o->type = \hyperlink{server_8h_a4a5f22a280949c97a0cb0d4213275126}{OBJ\_LIST};
01422                 o->encoding = \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST};
01423                 listTypeConvert(o,\hyperlink{server_8h_aec792aeed6d4bf83966672e6a23043b8}{OBJ\_ENCODING\_QUICKLIST});
01424                 \textcolor{keywordflow}{break};
01425             \textcolor{keywordflow}{case} \hyperlink{rdb_8h_a0a267bc10fe879463d503d5182865b86}{RDB\_TYPE\_SET\_INTSET}:
01426                 o->type = \hyperlink{server_8h_a8d179375a4aac33d3fa7aa80c8ccc75f}{OBJ\_SET};
01427                 o->encoding = \hyperlink{server_8h_a214173987de21c3b7661fddd42b05873}{OBJ\_ENCODING\_INTSET};
01428                 \textcolor{keywordflow}{if} (intsetLen(o->ptr) > server.set\_max\_intset\_entries)
01429                     setTypeConvert(o,\hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT});
01430                 \textcolor{keywordflow}{break};
01431             \textcolor{keywordflow}{case} \hyperlink{rdb_8h_a844a39336653d28b5a222404cb4a5bd2}{RDB\_TYPE\_ZSET\_ZIPLIST}:
01432                 o->type = \hyperlink{server_8h_a8c356422ddbc03bd77694880a30a1953}{OBJ\_ZSET};
01433                 o->encoding = \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST};
01434                 \textcolor{keywordflow}{if} (zsetLength(o) > server.zset\_max\_ziplist\_entries)
01435                     zsetConvert(o,\hyperlink{server_8h_acfb35db5cb30ed113ed23aeb1a224c4c}{OBJ\_ENCODING\_SKIPLIST});
01436                 \textcolor{keywordflow}{break};
01437             \textcolor{keywordflow}{case} \hyperlink{rdb_8h_af7ff565f65a30ccd4bf55f1503b63946}{RDB\_TYPE\_HASH\_ZIPLIST}:
01438                 o->type = \hyperlink{server_8h_a87c05ba4f7f36741864277f02a4423fb}{OBJ\_HASH};
01439                 o->encoding = \hyperlink{server_8h_aabf064ede983103f1fd0df2086e84eee}{OBJ\_ENCODING\_ZIPLIST};
01440                 \textcolor{keywordflow}{if} (hashTypeLength(o) > server.hash\_max\_ziplist\_entries)
01441                     hashTypeConvert(o, \hyperlink{server_8h_a9c10219f68afc557d510d108257d238b}{OBJ\_ENCODING\_HT});
01442                 \textcolor{keywordflow}{break};
01443             \textcolor{keywordflow}{default}:
01444                 \hyperlink{rdb_8c_afb34e310c0e5dfd9f8c2bebbec59c7f7}{rdbExitReportCorruptRDB}(\textcolor{stringliteral}{"Unknown RDB encoding type %d"},rdbtype)
      ;
01445                 \textcolor{keywordflow}{break};
01446         \}
01447     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rdbtype == \hyperlink{rdb_8h_a6552781f513eb80def691fe64e90000c}{RDB\_TYPE\_STREAM\_LISTPACKS}) \{
01448         o = createStreamObject();
01449         stream *s = o->ptr;
01450         uint64\_t listpacks = rdbLoadLen(rdb,NULL);
01451 
01452         \textcolor{keywordflow}{while}(listpacks--) \{
01453             \textcolor{comment}{/* Get the master ID, the one we'll use as key of the radix tree}
01454 \textcolor{comment}{             * node: the entries inside the listpack itself are delta-encoded}
01455 \textcolor{comment}{             * relatively to this ID. */}
01456             sds nodekey = rdbGenericLoadStringObject(rdb,\hyperlink{rdb_8h_ad15f5cc8e1a7789cc35b66f017e98a18}{RDB\_LOAD\_SDS},NULL);
01457             \textcolor{keywordflow}{if} (sdslen(nodekey) != \textcolor{keyword}{sizeof}(streamID)) \{
01458                 \hyperlink{rdb_8c_afb34e310c0e5dfd9f8c2bebbec59c7f7}{rdbExitReportCorruptRDB}(\textcolor{stringliteral}{"Stream node key entry is not the "}
01459                                         \textcolor{stringliteral}{"size of a stream ID"});
01460             \}
01461 
01462             \textcolor{comment}{/* Load the listpack. */}
01463             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *lp =
01464                 rdbGenericLoadStringObject(rdb,\hyperlink{rdb_8h_a5579c0ff24afa891ad41006def040a25}{RDB\_LOAD\_PLAIN},NULL);
01465             \textcolor{keywordflow}{if} (lp == NULL) \textcolor{keywordflow}{return} NULL;
01466             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *first = lpFirst(lp);
01467             \textcolor{keywordflow}{if} (first == NULL) \{
01468                 \textcolor{comment}{/* Serialized listpacks should never be empty, since on}
01469 \textcolor{comment}{                 * deletion we should remove the radix tree key if the}
01470 \textcolor{comment}{                 * resulting listpack is emtpy. */}
01471                 \hyperlink{rdb_8c_afb34e310c0e5dfd9f8c2bebbec59c7f7}{rdbExitReportCorruptRDB}(\textcolor{stringliteral}{"Empty listpack inside stream"});
01472             \}
01473 
01474             \textcolor{comment}{/* Insert the key in the radix tree. */}
01475             \textcolor{keywordtype}{int} retval = raxInsert(s->rax,
01476                 (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)nodekey,\textcolor{keyword}{sizeof}(streamID),lp,NULL);
01477             sdsfree(nodekey);
01478             \textcolor{keywordflow}{if} (!retval)
01479                 \hyperlink{rdb_8c_afb34e310c0e5dfd9f8c2bebbec59c7f7}{rdbExitReportCorruptRDB}(\textcolor{stringliteral}{"Listpack re-added with existing key"});
01480         \}
01481         \textcolor{comment}{/* Load total number of items inside the stream. */}
01482         s->length = rdbLoadLen(rdb,NULL);
01483         \textcolor{comment}{/* Load the last entry ID. */}
01484         s->last\_id.ms = rdbLoadLen(rdb,NULL);
01485         s->last\_id.seq = rdbLoadLen(rdb,NULL);
01486     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rdbtype == \hyperlink{rdb_8h_a2aaf3a047c290427775427aeef4399e4}{RDB\_TYPE\_MODULE} || rdbtype == 
      \hyperlink{rdb_8h_a9a996d2f95870c7165faaa316a6f8931}{RDB\_TYPE\_MODULE\_2}) \{
01487         uint64\_t moduleid = rdbLoadLen(rdb,NULL);
01488         moduleType *mt = moduleTypeLookupModuleByID(moduleid);
01489         \textcolor{keywordtype}{char} name[10];
01490 
01491         \textcolor{keywordflow}{if} (rdbCheckMode && rdbtype == \hyperlink{rdb_8h_a9a996d2f95870c7165faaa316a6f8931}{RDB\_TYPE\_MODULE\_2})
01492             \textcolor{keywordflow}{return} rdbLoadCheckModuleValue(rdb,name);
01493 
01494         \textcolor{keywordflow}{if} (mt == NULL) \{
01495             moduleTypeNameByID(name,moduleid);
01496             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"The RDB file contains module data I can't load: no
       matching module '%s'"}, name);
01497             exit(1);
01498         \}
01499         \hyperlink{structRedisModuleIO}{RedisModuleIO} io;
01500         \hyperlink{server_8h_abe94415e34ee463788c4c863dc029908}{moduleInitIOContext}(io,mt,rdb);
01501         io.ver = (rdbtype == \hyperlink{rdb_8h_a2aaf3a047c290427775427aeef4399e4}{RDB\_TYPE\_MODULE}) ? 1 : 2;
01502         \textcolor{comment}{/* Call the rdb\_load method of the module providing the 10 bit}
01503 \textcolor{comment}{         * encoding version in the lower 10 bits of the module ID. */}
01504         \textcolor{keywordtype}{void} *ptr = mt->rdb\_load(&io,moduleid&1023);
01505         \textcolor{keywordflow}{if} (io.ctx) \{
01506             moduleFreeContext(io.ctx);
01507             zfree(io.ctx);
01508         \}
01509 
01510         \textcolor{comment}{/* Module v2 serialization has an EOF mark at the end. */}
01511         \textcolor{keywordflow}{if} (io.ver == 2) \{
01512             uint64\_t eof = rdbLoadLen(rdb,NULL);
01513             \textcolor{keywordflow}{if} (eof != \hyperlink{rdb_8h_a905d414d752c18bdea4cf67b498fee52}{RDB\_MODULE\_OPCODE\_EOF}) \{
01514                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"The RDB file contains module data for the module '%s'
       that is not terminated by the proper module value EOF marker"}, name);
01515                 exit(1);
01516             \}
01517         \}
01518 
01519         \textcolor{keywordflow}{if} (ptr == NULL) \{
01520             moduleTypeNameByID(name,moduleid);
01521             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"The RDB file contains module data for the module type
       '%s', that the responsible module is not able to load. Check for modules log above for additional clues."}, name)
      ;
01522             exit(1);
01523         \}
01524         o = createModuleObject(mt,ptr);
01525     \} \textcolor{keywordflow}{else} \{
01526         \hyperlink{rdb_8c_afb34e310c0e5dfd9f8c2bebbec59c7f7}{rdbExitReportCorruptRDB}(\textcolor{stringliteral}{"Unknown RDB encoding type %d"},rdbtype);
01527     \}
01528     \textcolor{keywordflow}{return} o;
01529 \}
01530 
01531 \textcolor{comment}{/* Mark that we are loading in the global state and setup the fields}
01532 \textcolor{comment}{ * needed to provide loading stats. */}
01533 \textcolor{keywordtype}{void} startLoading(FILE *fp) \{
01534     \textcolor{keyword}{struct} stat sb;
01535 
01536     \textcolor{comment}{/* Load the DB */}
01537     server.loading = 1;
01538     server.loading\_start\_time = time(NULL);
01539     server.loading\_loaded\_bytes = 0;
01540     \textcolor{keywordflow}{if} (fstat(fileno(fp), &sb) == -1) \{
01541         server.loading\_total\_bytes = 0;
01542     \} \textcolor{keywordflow}{else} \{
01543         server.loading\_total\_bytes = sb.st\_size;
01544     \}
01545 \}
01546 
01547 \textcolor{comment}{/* Refresh the loading progress info */}
01548 \textcolor{keywordtype}{void} loadingProgress(off\_t pos) \{
01549     server.loading\_loaded\_bytes = pos;
01550     \textcolor{keywordflow}{if} (server.stat\_peak\_memory < zmalloc\_used\_memory())
01551         server.stat\_peak\_memory = zmalloc\_used\_memory();
01552 \}
01553 
01554 \textcolor{comment}{/* Loading finished */}
01555 \textcolor{keywordtype}{void} stopLoading(\textcolor{keywordtype}{void}) \{
01556     server.loading = 0;
01557 \}
01558 
01559 \textcolor{comment}{/* Track loading progress in order to serve client's from time to time}
01560 \textcolor{comment}{   and if needed calculate rdb checksum  */}
01561 \textcolor{keywordtype}{void} rdbLoadProgressCallback(rio *r, \textcolor{keyword}{const} \textcolor{keywordtype}{void} *buf, size\_t len) \{
01562     \textcolor{keywordflow}{if} (server.rdb\_checksum)
01563         rioGenericUpdateChecksum(r, buf, len);
01564     \textcolor{keywordflow}{if} (server.loading\_process\_events\_interval\_bytes &&
01565         (r->processed\_bytes + len)/server.loading\_process\_events\_interval\_bytes > r->processed\_bytes/
      server.loading\_process\_events\_interval\_bytes)
01566     \{
01567         \textcolor{comment}{/* The DB can take some non trivial amount of time to load. Update}
01568 \textcolor{comment}{         * our cached time since it is used to create and update the last}
01569 \textcolor{comment}{         * interaction time with clients and for other important things. */}
01570         updateCachedTime();
01571         \textcolor{keywordflow}{if} (server.masterhost && server.repl\_state == \hyperlink{server_8h_a1d27594a2d9c8d24e4ed5a2e88d1113e}{REPL\_STATE\_TRANSFER})
01572             replicationSendNewlineToMaster();
01573         loadingProgress(r->processed\_bytes);
01574         processEventsWhileBlocked();
01575     \}
01576 \}
01577 
01578 \textcolor{comment}{/* Load an RDB file from the rio stream 'rdb'. On success C\_OK is returned,}
01579 \textcolor{comment}{ * otherwise C\_ERR is returned and 'errno' is set accordingly. */}
01580 \textcolor{keywordtype}{int} rdbLoadRio(rio *rdb, rdbSaveInfo *rsi) \{
01581     uint64\_t dbid;
01582     \textcolor{keywordtype}{int} type, rdbver;
01583     redisDb *db = server.db+0;
01584     \textcolor{keywordtype}{char} buf[1024];
01585     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} expiretime, now = mstime();
01586 
01587     rdb->update\_cksum = rdbLoadProgressCallback;
01588     rdb->max\_processing\_chunk = server.loading\_process\_events\_interval\_bytes;
01589     \textcolor{keywordflow}{if} (rioRead(rdb,buf,9) == 0) \textcolor{keywordflow}{goto} eoferr;
01590     buf[9] = \textcolor{stringliteral}{'\(\backslash\)0'};
01591     \textcolor{keywordflow}{if} (memcmp(buf,\textcolor{stringliteral}{"REDIS"},5) != 0) \{
01592         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Wrong signature trying to load DB from file"});
01593         errno = EINVAL;
01594         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01595     \}
01596     rdbver = atoi(buf+5);
01597     \textcolor{keywordflow}{if} (rdbver < 1 || rdbver > \hyperlink{rdb_8h_ae34418fdbb9794fb7558a4f58bdc1cad}{RDB\_VERSION}) \{
01598         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Can't handle RDB format version %d"},rdbver);
01599         errno = EINVAL;
01600         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01601     \}
01602 
01603     \textcolor{keywordflow}{while}(1) \{
01604         robj *key, *val;
01605         expiretime = -1;
01606 
01607         \textcolor{comment}{/* Read type. */}
01608         \textcolor{keywordflow}{if} ((type = rdbLoadType(rdb)) == -1) \textcolor{keywordflow}{goto} eoferr;
01609 
01610         \textcolor{comment}{/* Handle special types. */}
01611         \textcolor{keywordflow}{if} (type == \hyperlink{rdb_8h_a32013d8fe12eeff5f8c1de859aae8a55}{RDB\_OPCODE\_EXPIRETIME}) \{
01612             \textcolor{comment}{/* EXPIRETIME: load an expire associated with the next key}
01613 \textcolor{comment}{             * to load. Note that after loading an expire we need to}
01614 \textcolor{comment}{             * load the actual type, and continue. */}
01615             \textcolor{keywordflow}{if} ((expiretime = rdbLoadTime(rdb)) == -1) \textcolor{keywordflow}{goto} eoferr;
01616             \textcolor{comment}{/* We read the time so we need to read the object type again. */}
01617             \textcolor{keywordflow}{if} ((type = rdbLoadType(rdb)) == -1) \textcolor{keywordflow}{goto} eoferr;
01618             \textcolor{comment}{/* the EXPIRETIME opcode specifies time in seconds, so convert}
01619 \textcolor{comment}{             * into milliseconds. */}
01620             expiretime *= 1000;
01621         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == \hyperlink{rdb_8h_a718021856b2b0cf1c9c907a3a91a39c4}{RDB\_OPCODE\_EXPIRETIME\_MS}) \{
01622             \textcolor{comment}{/* EXPIRETIME\_MS: milliseconds precision expire times introduced}
01623 \textcolor{comment}{             * with RDB v3. Like EXPIRETIME but no with more precision. */}
01624             \textcolor{keywordflow}{if} ((expiretime = rdbLoadMillisecondTime(rdb)) == -1) \textcolor{keywordflow}{goto} eoferr;
01625             \textcolor{comment}{/* We read the time so we need to read the object type again. */}
01626             \textcolor{keywordflow}{if} ((type = rdbLoadType(rdb)) == -1) \textcolor{keywordflow}{goto} eoferr;
01627         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == \hyperlink{rdb_8h_af4c616d96f3dc8d44911f7fff2a712da}{RDB\_OPCODE\_EOF}) \{
01628             \textcolor{comment}{/* EOF: End of file, exit the main loop. */}
01629             \textcolor{keywordflow}{break};
01630         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == \hyperlink{rdb_8h_a08e0489a0baf79997ee8411e850d6c70}{RDB\_OPCODE\_SELECTDB}) \{
01631             \textcolor{comment}{/* SELECTDB: Select the specified database. */}
01632             \textcolor{keywordflow}{if} ((dbid = rdbLoadLen(rdb,NULL)) == \hyperlink{rdb_8h_aa66b6ad7261656029e6a67cf78432b2d}{RDB\_LENERR})
01633                 \textcolor{keywordflow}{goto} eoferr;
01634             \textcolor{keywordflow}{if} (dbid >= (\textcolor{keywordtype}{unsigned})server.dbnum) \{
01635                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01636                     \textcolor{stringliteral}{"FATAL: Data file was created with a Redis "}
01637                     \textcolor{stringliteral}{"server configured to handle more than %d "}
01638                     \textcolor{stringliteral}{"databases. Exiting\(\backslash\)n"}, server.dbnum);
01639                 exit(1);
01640             \}
01641             db = server.db+dbid;
01642             \textcolor{keywordflow}{continue}; \textcolor{comment}{/* Read type again. */}
01643         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == \hyperlink{rdb_8h_ad1f63cee59a3066446beecae389a8758}{RDB\_OPCODE\_RESIZEDB}) \{
01644             \textcolor{comment}{/* RESIZEDB: Hint about the size of the keys in the currently}
01645 \textcolor{comment}{             * selected data base, in order to avoid useless rehashing. */}
01646             uint64\_t db\_size, expires\_size;
01647             \textcolor{keywordflow}{if} ((db\_size = rdbLoadLen(rdb,NULL)) == \hyperlink{rdb_8h_aa66b6ad7261656029e6a67cf78432b2d}{RDB\_LENERR})
01648                 \textcolor{keywordflow}{goto} eoferr;
01649             \textcolor{keywordflow}{if} ((expires\_size = rdbLoadLen(rdb,NULL)) == \hyperlink{rdb_8h_aa66b6ad7261656029e6a67cf78432b2d}{RDB\_LENERR})
01650                 \textcolor{keywordflow}{goto} eoferr;
01651             dictExpand(db->dict,db\_size);
01652             dictExpand(db->expires,expires\_size);
01653             \textcolor{keywordflow}{continue}; \textcolor{comment}{/* Read type again. */}
01654         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == \hyperlink{rdb_8h_ab0c62f54bb9377a6a75dbe331a2936bd}{RDB\_OPCODE\_AUX}) \{
01655             \textcolor{comment}{/* AUX: generic string-string fields. Use to add state to RDB}
01656 \textcolor{comment}{             * which is backward compatible. Implementations of RDB loading}
01657 \textcolor{comment}{             * are requierd to skip AUX fields they don't understand.}
01658 \textcolor{comment}{             *}
01659 \textcolor{comment}{             * An AUX field is composed of two strings: key and value. */}
01660             robj *auxkey, *auxval;
01661             \textcolor{keywordflow}{if} ((auxkey = rdbLoadStringObject(rdb)) == NULL) \textcolor{keywordflow}{goto} eoferr;
01662             \textcolor{keywordflow}{if} ((auxval = rdbLoadStringObject(rdb)) == NULL) \textcolor{keywordflow}{goto} eoferr;
01663 
01664             \textcolor{keywordflow}{if} (((\textcolor{keywordtype}{char}*)auxkey->ptr)[0] == \textcolor{stringliteral}{'%'}) \{
01665                 \textcolor{comment}{/* All the fields with a name staring with '%' are considered}
01666 \textcolor{comment}{                 * information fields and are logged at startup with a log}
01667 \textcolor{comment}{                 * level of NOTICE. */}
01668                 serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"RDB '%s': %s"},
01669                     (\textcolor{keywordtype}{char}*)auxkey->ptr,
01670                     (\textcolor{keywordtype}{char}*)auxval->ptr);
01671             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(auxkey->ptr,\textcolor{stringliteral}{"repl-stream-db"})) \{
01672                 \textcolor{keywordflow}{if} (rsi) rsi->repl\_stream\_db = atoi(auxval->ptr);
01673             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(auxkey->ptr,\textcolor{stringliteral}{"repl-id"})) \{
01674                 \textcolor{keywordflow}{if} (rsi && sdslen(auxval->ptr) == \hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}) \{
01675                     memcpy(rsi->repl\_id,auxval->ptr,\hyperlink{server_8h_aba6794fa3ee28f85165eaed93190f1df}{CONFIG\_RUN\_ID\_SIZE}+1);
01676                     rsi->repl\_id\_is\_set = 1;
01677                 \}
01678             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(auxkey->ptr,\textcolor{stringliteral}{"repl-offset"})) \{
01679                 \textcolor{keywordflow}{if} (rsi) rsi->repl\_offset = strtoll(auxval->ptr,NULL,10);
01680             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(auxkey->ptr,\textcolor{stringliteral}{"lua"})) \{
01681                 \textcolor{comment}{/* Load the script back in memory. */}
01682                 \textcolor{keywordflow}{if} (luaCreateFunction(NULL,server.lua,auxval) == NULL) \{
01683                     \hyperlink{rdb_8c_afb34e310c0e5dfd9f8c2bebbec59c7f7}{rdbExitReportCorruptRDB}(
01684                         \textcolor{stringliteral}{"Can't load Lua script from RDB file! "}
01685                         \textcolor{stringliteral}{"BODY: %s"}, auxval->ptr);
01686                 \}
01687             \} \textcolor{keywordflow}{else} \{
01688                 \textcolor{comment}{/* We ignore fields we don't understand, as by AUX field}
01689 \textcolor{comment}{                 * contract. */}
01690                 serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG},\textcolor{stringliteral}{"Unrecognized RDB AUX field: '%s'"},
01691                     (\textcolor{keywordtype}{char}*)auxkey->ptr);
01692             \}
01693 
01694             decrRefCount(auxkey);
01695             decrRefCount(auxval);
01696             \textcolor{keywordflow}{continue}; \textcolor{comment}{/* Read type again. */}
01697         \}
01698 
01699         \textcolor{comment}{/* Read key */}
01700         \textcolor{keywordflow}{if} ((key = rdbLoadStringObject(rdb)) == NULL) \textcolor{keywordflow}{goto} eoferr;
01701         \textcolor{comment}{/* Read value */}
01702         \textcolor{keywordflow}{if} ((val = rdbLoadObject(type,rdb)) == NULL) \textcolor{keywordflow}{goto} eoferr;
01703         \textcolor{comment}{/* Check if the key already expired. This function is used when loading}
01704 \textcolor{comment}{         * an RDB file from disk, either at startup, or when an RDB was}
01705 \textcolor{comment}{         * received from the master. In the latter case, the master is}
01706 \textcolor{comment}{         * responsible for key expiry. If we would expire keys here, the}
01707 \textcolor{comment}{         * snapshot taken by the master may not be reflected on the slave. */}
01708         \textcolor{keywordflow}{if} (server.masterhost == NULL && expiretime != -1 && expiretime < now) \{
01709             decrRefCount(key);
01710             decrRefCount(val);
01711             \textcolor{keywordflow}{continue};
01712         \}
01713         \textcolor{comment}{/* Add the new object in the hash table */}
01714         dbAdd(db,key,val);
01715 
01716         \textcolor{comment}{/* Set the expire time if needed */}
01717         \textcolor{keywordflow}{if} (expiretime != -1) setExpire(NULL,db,key,expiretime);
01718 
01719         decrRefCount(key);
01720     \}
01721     \textcolor{comment}{/* Verify the checksum if RDB version is >= 5 */}
01722     \textcolor{keywordflow}{if} (rdbver >= 5 && server.rdb\_checksum) \{
01723         uint64\_t cksum, expected = rdb->cksum;
01724 
01725         \textcolor{keywordflow}{if} (rioRead(rdb,&cksum,8) == 0) \textcolor{keywordflow}{goto} eoferr;
01726         \hyperlink{endianconv_8h_aa311b9f944c3b988f3601698a95890c1}{memrev64ifbe}(&cksum);
01727         \textcolor{keywordflow}{if} (cksum == 0) \{
01728             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"RDB file was saved with checksum disabled: no check
       performed."});
01729         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (cksum != expected) \{
01730             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Wrong RDB checksum. Aborting now."});
01731             \hyperlink{rdb_8c_afb34e310c0e5dfd9f8c2bebbec59c7f7}{rdbExitReportCorruptRDB}(\textcolor{stringliteral}{"RDB CRC error"});
01732         \}
01733     \}
01734     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01735 
01736 eoferr: \textcolor{comment}{/* unexpected end of file is handled here with a fatal exit */}
01737     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Short read or OOM loading DB. Unrecoverable error, aborting now."})
      ;
01738     \hyperlink{rdb_8c_afb34e310c0e5dfd9f8c2bebbec59c7f7}{rdbExitReportCorruptRDB}(\textcolor{stringliteral}{"Unexpected EOF reading RDB file"});
01739     \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}; \textcolor{comment}{/* Just to avoid warning */}
01740 \}
01741 
01742 \textcolor{comment}{/* Like rdbLoadRio() but takes a filename instead of a rio stream. The}
01743 \textcolor{comment}{ * filename is open for reading and a rio stream object created in order}
01744 \textcolor{comment}{ * to do the actual loading. Moreover the ETA displayed in the INFO}
01745 \textcolor{comment}{ * output is initialized and finalized.}
01746 \textcolor{comment}{ *}
01747 \textcolor{comment}{ * If you pass an 'rsi' structure initialied with RDB\_SAVE\_OPTION\_INIT, the}
01748 \textcolor{comment}{ * loading code will fiil the information fields in the structure. */}
01749 \textcolor{keywordtype}{int} rdbLoad(\textcolor{keywordtype}{char} *filename, rdbSaveInfo *rsi) \{
01750     FILE *fp;
01751     rio rdb;
01752     \textcolor{keywordtype}{int} retval;
01753 
01754     \textcolor{keywordflow}{if} ((fp = fopen(filename,\textcolor{stringliteral}{"r"})) == NULL) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01755     startLoading(fp);
01756     rioInitWithFile(&rdb,fp);
01757     retval = rdbLoadRio(&rdb,rsi);
01758     fclose(fp);
01759     stopLoading();
01760     \textcolor{keywordflow}{return} retval;
01761 \}
01762 
01763 \textcolor{comment}{/* A background saving child (BGSAVE) terminated its work. Handle this.}
01764 \textcolor{comment}{ * This function covers the case of actual BGSAVEs. */}
01765 \textcolor{keywordtype}{void} backgroundSaveDoneHandlerDisk(\textcolor{keywordtype}{int} exitcode, \textcolor{keywordtype}{int} bysignal) \{
01766     \textcolor{keywordflow}{if} (!bysignal && exitcode == 0) \{
01767         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01768             \textcolor{stringliteral}{"Background saving terminated with success"});
01769         server.dirty = server.dirty - server.dirty\_before\_bgsave;
01770         server.lastsave = time(NULL);
01771         server.lastbgsave\_status = \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01772     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!bysignal && exitcode != 0) \{
01773         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"Background saving error"});
01774         server.lastbgsave\_status = \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01775     \} \textcolor{keywordflow}{else} \{
01776         mstime\_t latency;
01777 
01778         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01779             \textcolor{stringliteral}{"Background saving terminated by signal %d"}, bysignal);
01780         \hyperlink{latency_8h_a87d7b5b368dad97457f13466d760b0e1}{latencyStartMonitor}(latency);
01781         rdbRemoveTempFile(server.rdb\_child\_pid);
01782         \hyperlink{latency_8h_a88461aee20da0a648fe3332b5f068df7}{latencyEndMonitor}(latency);
01783         \hyperlink{latency_8h_a77922ab34035890c90f98831a9071359}{latencyAddSampleIfNeeded}(\textcolor{stringliteral}{"rdb-unlink-temp-file"},latency);
01784         \textcolor{comment}{/* SIGUSR1 is whitelisted, so we have a way to kill a child without}
01785 \textcolor{comment}{         * tirggering an error conditon. */}
01786         \textcolor{keywordflow}{if} (bysignal != SIGUSR1)
01787             server.lastbgsave\_status = \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01788     \}
01789     server.rdb\_child\_pid = -1;
01790     server.rdb\_child\_type = \hyperlink{server_8h_acfd6e0670ac08e8f4c13f33c8a2c6b5e}{RDB\_CHILD\_TYPE\_NONE};
01791     server.rdb\_save\_time\_last = time(NULL)-server.rdb\_save\_time\_start;
01792     server.rdb\_save\_time\_start = -1;
01793     \textcolor{comment}{/* Possibly there are slaves waiting for a BGSAVE in order to be served}
01794 \textcolor{comment}{     * (the first stage of SYNC is a bulk transfer of dump.rdb) */}
01795     updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK} : 
      \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}, \hyperlink{server_8h_a9d886e992717fa246dd7954244ff6bdf}{RDB\_CHILD\_TYPE\_DISK});
01796 \}
01797 
01798 \textcolor{comment}{/* A background saving child (BGSAVE) terminated its work. Handle this.}
01799 \textcolor{comment}{ * This function covers the case of RDB -> Salves socket transfers for}
01800 \textcolor{comment}{ * diskless replication. */}
01801 \textcolor{keywordtype}{void} backgroundSaveDoneHandlerSocket(\textcolor{keywordtype}{int} exitcode, \textcolor{keywordtype}{int} bysignal) \{
01802     uint64\_t *ok\_slaves;
01803 
01804     \textcolor{keywordflow}{if} (!bysignal && exitcode == 0) \{
01805         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01806             \textcolor{stringliteral}{"Background RDB transfer terminated with success"});
01807     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!bysignal && exitcode != 0) \{
01808         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"Background transfer error"});
01809     \} \textcolor{keywordflow}{else} \{
01810         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01811             \textcolor{stringliteral}{"Background transfer terminated by signal %d"}, bysignal);
01812     \}
01813     server.rdb\_child\_pid = -1;
01814     server.rdb\_child\_type = \hyperlink{server_8h_acfd6e0670ac08e8f4c13f33c8a2c6b5e}{RDB\_CHILD\_TYPE\_NONE};
01815     server.rdb\_save\_time\_start = -1;
01816 
01817     \textcolor{comment}{/* If the child returns an OK exit code, read the set of slave client}
01818 \textcolor{comment}{     * IDs and the associated status code. We'll terminate all the slaves}
01819 \textcolor{comment}{     * in error state.}
01820 \textcolor{comment}{     *}
01821 \textcolor{comment}{     * If the process returned an error, consider the list of slaves that}
01822 \textcolor{comment}{     * can continue to be emtpy, so that it's just a special case of the}
01823 \textcolor{comment}{     * normal code path. */}
01824     ok\_slaves = zmalloc(\textcolor{keyword}{sizeof}(uint64\_t)); \textcolor{comment}{/* Make space for the count. */}
01825     ok\_slaves[0] = 0;
01826     \textcolor{keywordflow}{if} (!bysignal && exitcode == 0) \{
01827         \textcolor{keywordtype}{int} readlen = \textcolor{keyword}{sizeof}(uint64\_t);
01828 
01829         \textcolor{keywordflow}{if} (read(server.rdb\_pipe\_read\_result\_from\_child, ok\_slaves, readlen) ==
01830                  readlen)
01831         \{
01832             readlen = ok\_slaves[0]*\textcolor{keyword}{sizeof}(uint64\_t)*2;
01833 
01834             \textcolor{comment}{/* Make space for enough elements as specified by the first}
01835 \textcolor{comment}{             * uint64\_t element in the array. */}
01836             ok\_slaves = zrealloc(ok\_slaves,\textcolor{keyword}{sizeof}(uint64\_t)+readlen);
01837             \textcolor{keywordflow}{if} (readlen &&
01838                 read(server.rdb\_pipe\_read\_result\_from\_child, ok\_slaves+1,
01839                      readlen) != readlen)
01840             \{
01841                 ok\_slaves[0] = 0;
01842             \}
01843         \}
01844     \}
01845 
01846     close(server.rdb\_pipe\_read\_result\_from\_child);
01847     close(server.rdb\_pipe\_write\_result\_to\_parent);
01848 
01849     \textcolor{comment}{/* We can continue the replication process with all the slaves that}
01850 \textcolor{comment}{     * correctly received the full payload. Others are terminated. */}
01851     listNode *ln;
01852     listIter li;
01853 
01854     listRewind(server.slaves,&li);
01855     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
01856         \hyperlink{structclient}{client} *slave = ln->value;
01857 
01858         \textcolor{keywordflow}{if} (slave->replstate == \hyperlink{server_8h_a2a1b586e8f326f831f6ab466c8c3f38a}{SLAVE\_STATE\_WAIT\_BGSAVE\_END}) \{
01859             uint64\_t j;
01860             \textcolor{keywordtype}{int} errorcode = 0;
01861 
01862             \textcolor{comment}{/* Search for the slave ID in the reply. In order for a slave to}
01863 \textcolor{comment}{             * continue the replication process, we need to find it in the list,}
01864 \textcolor{comment}{             * and it must have an error code set to 0 (which means success). */}
01865             \textcolor{keywordflow}{for} (j = 0; j < ok\_slaves[0]; j++) \{
01866                 \textcolor{keywordflow}{if} (slave->id == ok\_slaves[2*j+1]) \{
01867                     errorcode = ok\_slaves[2*j+2];
01868                     \textcolor{keywordflow}{break}; \textcolor{comment}{/* Found in slaves list. */}
01869                 \}
01870             \}
01871             \textcolor{keywordflow}{if} (j == ok\_slaves[0] || errorcode != 0) \{
01872                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01873                 \textcolor{stringliteral}{"Closing slave %s: child->slave RDB transfer failed: %s"},
01874                     replicationGetSlaveName(slave),
01875                     (errorcode == 0) ? \textcolor{stringliteral}{"RDB transfer child aborted"}
01876                                      : strerror(errorcode));
01877                 freeClient(slave);
01878             \} \textcolor{keywordflow}{else} \{
01879                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01880                 \textcolor{stringliteral}{"Slave %s correctly received the streamed RDB file."},
01881                     replicationGetSlaveName(slave));
01882                 \textcolor{comment}{/* Restore the socket as non-blocking. */}
01883                 anetNonBlock(NULL,slave->fd);
01884                 anetSendTimeout(NULL,slave->fd,0);
01885             \}
01886         \}
01887     \}
01888     zfree(ok\_slaves);
01889 
01890     updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK} : 
      \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}, \hyperlink{server_8h_acdbf61346e1d2f54716e2ab6fe73e954}{RDB\_CHILD\_TYPE\_SOCKET});
01891 \}
01892 
01893 \textcolor{comment}{/* When a background RDB saving/transfer terminates, call the right handler. */}
01894 \textcolor{keywordtype}{void} backgroundSaveDoneHandler(\textcolor{keywordtype}{int} exitcode, \textcolor{keywordtype}{int} bysignal) \{
01895     \textcolor{keywordflow}{switch}(server.rdb\_child\_type) \{
01896     \textcolor{keywordflow}{case} \hyperlink{server_8h_a9d886e992717fa246dd7954244ff6bdf}{RDB\_CHILD\_TYPE\_DISK}:
01897         backgroundSaveDoneHandlerDisk(exitcode,bysignal);
01898         \textcolor{keywordflow}{break};
01899     \textcolor{keywordflow}{case} \hyperlink{server_8h_acdbf61346e1d2f54716e2ab6fe73e954}{RDB\_CHILD\_TYPE\_SOCKET}:
01900         backgroundSaveDoneHandlerSocket(exitcode,bysignal);
01901         \textcolor{keywordflow}{break};
01902     \textcolor{keywordflow}{default}:
01903         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown RDB child type."});
01904         \textcolor{keywordflow}{break};
01905     \}
01906 \}
01907 
01908 \textcolor{comment}{/* Spawn an RDB child that writes the RDB to the sockets of the slaves}
01909 \textcolor{comment}{ * that are currently in SLAVE\_STATE\_WAIT\_BGSAVE\_START state. */}
01910 \textcolor{keywordtype}{int} rdbSaveToSlavesSockets(rdbSaveInfo *rsi) \{
01911     \textcolor{keywordtype}{int} *fds;
01912     uint64\_t *clientids;
01913     \textcolor{keywordtype}{int} numfds;
01914     listNode *ln;
01915     listIter li;
01916     pid\_t childpid;
01917     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} start;
01918     \textcolor{keywordtype}{int} pipefds[2];
01919 
01920     \textcolor{keywordflow}{if} (server.aof\_child\_pid != -1 || server.rdb\_child\_pid != -1) \textcolor{keywordflow}{return} 
      \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01921 
01922     \textcolor{comment}{/* Before to fork, create a pipe that will be used in order to}
01923 \textcolor{comment}{     * send back to the parent the IDs of the slaves that successfully}
01924 \textcolor{comment}{     * received all the writes. */}
01925     \textcolor{keywordflow}{if} (pipe(pipefds) == -1) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01926     server.rdb\_pipe\_read\_result\_from\_child = pipefds[0];
01927     server.rdb\_pipe\_write\_result\_to\_parent = pipefds[1];
01928 
01929     \textcolor{comment}{/* Collect the file descriptors of the slaves we want to transfer}
01930 \textcolor{comment}{     * the RDB to, which are i WAIT\_BGSAVE\_START state. */}
01931     fds = zmalloc(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int})*\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.slaves));
01932     \textcolor{comment}{/* We also allocate an array of corresponding client IDs. This will}
01933 \textcolor{comment}{     * be useful for the child process in order to build the report}
01934 \textcolor{comment}{     * (sent via unix pipe) that will be sent to the parent. */}
01935     clientids = zmalloc(\textcolor{keyword}{sizeof}(uint64\_t)*\hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.slaves));
01936     numfds = 0;
01937 
01938     listRewind(server.slaves,&li);
01939     \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
01940         \hyperlink{structclient}{client} *slave = ln->value;
01941 
01942         \textcolor{keywordflow}{if} (slave->replstate == \hyperlink{server_8h_a170ee2dd8cfefaf0d112edcc3152f8d7}{SLAVE\_STATE\_WAIT\_BGSAVE\_START}) \{
01943             clientids[numfds] = slave->id;
01944             fds[numfds++] = slave->fd;
01945             replicationSetupSlaveForFullResync(slave,getPsyncInitialOffset());
01946             \textcolor{comment}{/* Put the socket in blocking mode to simplify RDB transfer.}
01947 \textcolor{comment}{             * We'll restore it when the children returns (since duped socket}
01948 \textcolor{comment}{             * will share the O\_NONBLOCK attribute with the parent). */}
01949             anetBlock(NULL,slave->fd);
01950             anetSendTimeout(NULL,slave->fd,server.repl\_timeout*1000);
01951         \}
01952     \}
01953 
01954     \textcolor{comment}{/* Create the child process. */}
01955     openChildInfoPipe();
01956     start = ustime();
01957     \textcolor{keywordflow}{if} ((childpid = fork()) == 0) \{
01958         \textcolor{comment}{/* Child */}
01959         \textcolor{keywordtype}{int} retval;
01960         rio slave\_sockets;
01961 
01962         rioInitWithFdset(&slave\_sockets,fds,numfds);
01963         zfree(fds);
01964 
01965         closeListeningSockets(0);
01966         redisSetProcTitle(\textcolor{stringliteral}{"redis-rdb-to-slaves"});
01967 
01968         retval = rdbSaveRioWithEOFMark(&slave\_sockets,NULL,rsi);
01969         \textcolor{keywordflow}{if} (retval == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK} && rioFlush(&slave\_sockets) == 0)
01970             retval = \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01971 
01972         \textcolor{keywordflow}{if} (retval == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
01973             size\_t private\_dirty = zmalloc\_get\_private\_dirty(-1);
01974 
01975             \textcolor{keywordflow}{if} (private\_dirty) \{
01976                 serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01977                     \textcolor{stringliteral}{"RDB: %zu MB of memory used by copy-on-write"},
01978                     private\_dirty/(1024*1024));
01979             \}
01980 
01981             server.child\_info\_data.cow\_size = private\_dirty;
01982             sendChildInfo(\hyperlink{server_8h_a878f18d9e3d0af58b81a17d764a81dbe}{CHILD\_INFO\_TYPE\_RDB});
01983 
01984             \textcolor{comment}{/* If we are returning OK, at least one slave was served}
01985 \textcolor{comment}{             * with the RDB file as expected, so we need to send a report}
01986 \textcolor{comment}{             * to the parent via the pipe. The format of the message is:}
01987 \textcolor{comment}{             *}
01988 \textcolor{comment}{             * <len> <slave[0].id> <slave[0].error> ...}
01989 \textcolor{comment}{             *}
01990 \textcolor{comment}{             * len, slave IDs, and slave errors, are all uint64\_t integers,}
01991 \textcolor{comment}{             * so basically the reply is composed of 64 bits for the len field}
01992 \textcolor{comment}{             * plus 2 additional 64 bit integers for each entry, for a total}
01993 \textcolor{comment}{             * of 'len' entries.}
01994 \textcolor{comment}{             *}
01995 \textcolor{comment}{             * The 'id' represents the slave's client ID, so that the master}
01996 \textcolor{comment}{             * can match the report with a specific slave, and 'error' is}
01997 \textcolor{comment}{             * set to 0 if the replication process terminated with a success}
01998 \textcolor{comment}{             * or the error code if an error occurred. */}
01999             \textcolor{keywordtype}{void} *msg = zmalloc(\textcolor{keyword}{sizeof}(uint64\_t)*(1+2*numfds));
02000             uint64\_t *len = msg;
02001             uint64\_t *ids = len+1;
02002             \textcolor{keywordtype}{int} j, msglen;
02003 
02004             *len = numfds;
02005             \textcolor{keywordflow}{for} (j = 0; j < numfds; j++) \{
02006                 *ids++ = clientids[j];
02007                 *ids++ = slave\_sockets.io.fdset.state[j];
02008             \}
02009 
02010             \textcolor{comment}{/* Write the message to the parent. If we have no good slaves or}
02011 \textcolor{comment}{             * we are unable to transfer the message to the parent, we exit}
02012 \textcolor{comment}{             * with an error so that the parent will abort the replication}
02013 \textcolor{comment}{             * process with all the childre that were waiting. */}
02014             msglen = \textcolor{keyword}{sizeof}(uint64\_t)*(1+2*numfds);
02015             \textcolor{keywordflow}{if} (*len == 0 ||
02016                 write(server.rdb\_pipe\_write\_result\_to\_parent,msg,msglen)
02017                 != msglen)
02018             \{
02019                 retval = \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
02020             \}
02021             zfree(msg);
02022         \}
02023         zfree(clientids);
02024         rioFreeFdset(&slave\_sockets);
02025         exitFromChild((retval == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) ? 0 : 1);
02026     \} \textcolor{keywordflow}{else} \{
02027         \textcolor{comment}{/* Parent */}
02028         \textcolor{keywordflow}{if} (childpid == -1) \{
02029             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Can't save in background: fork: %s"},
02030                 strerror(errno));
02031 
02032             \textcolor{comment}{/* Undo the state change. The caller will perform cleanup on}
02033 \textcolor{comment}{             * all the slaves in BGSAVE\_START state, but an early call to}
02034 \textcolor{comment}{             * replicationSetupSlaveForFullResync() turned it into BGSAVE\_END */}
02035             listRewind(server.slaves,&li);
02036             \textcolor{keywordflow}{while}((ln = listNext(&li))) \{
02037                 \hyperlink{structclient}{client} *slave = ln->value;
02038                 \textcolor{keywordtype}{int} j;
02039 
02040                 \textcolor{keywordflow}{for} (j = 0; j < numfds; j++) \{
02041                     \textcolor{keywordflow}{if} (slave->id == clientids[j]) \{
02042                         slave->replstate = \hyperlink{server_8h_a170ee2dd8cfefaf0d112edcc3152f8d7}{SLAVE\_STATE\_WAIT\_BGSAVE\_START};
02043                         \textcolor{keywordflow}{break};
02044                     \}
02045                 \}
02046             \}
02047             close(pipefds[0]);
02048             close(pipefds[1]);
02049             closeChildInfoPipe();
02050         \} \textcolor{keywordflow}{else} \{
02051             server.stat\_fork\_time = ustime()-start;
02052             server.stat\_fork\_rate = (\textcolor{keywordtype}{double}) zmalloc\_used\_memory() * 1000000 / server.stat\_fork\_time /
       (1024*1024*1024); \textcolor{comment}{/* GB per second. */}
02053             \hyperlink{latency_8h_a77922ab34035890c90f98831a9071359}{latencyAddSampleIfNeeded}(\textcolor{stringliteral}{"fork"},server.stat\_fork\_time/1000);
02054 
02055             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Background RDB transfer started by pid %d"},
02056                 childpid);
02057             server.rdb\_save\_time\_start = time(NULL);
02058             server.rdb\_child\_pid = childpid;
02059             server.rdb\_child\_type = \hyperlink{server_8h_acdbf61346e1d2f54716e2ab6fe73e954}{RDB\_CHILD\_TYPE\_SOCKET};
02060             updateDictResizePolicy();
02061         \}
02062         zfree(clientids);
02063         zfree(fds);
02064         \textcolor{keywordflow}{return} (childpid == -1) ? \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR} : \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
02065     \}
02066     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}; \textcolor{comment}{/* Unreached. */}
02067 \}
02068 
02069 \textcolor{keywordtype}{void} saveCommand(\hyperlink{structclient}{client} *c) \{
02070     \textcolor{keywordflow}{if} (server.rdb\_child\_pid != -1) \{
02071         addReplyError(c,\textcolor{stringliteral}{"Background save already in progress"});
02072         \textcolor{keywordflow}{return};
02073     \}
02074     rdbSaveInfo rsi, *rsiptr;
02075     rsiptr = rdbPopulateSaveInfo(&rsi);
02076     \textcolor{keywordflow}{if} (rdbSave(server.rdb\_filename,rsiptr) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
02077         addReply(c,shared.ok);
02078     \} \textcolor{keywordflow}{else} \{
02079         addReply(c,shared.err);
02080     \}
02081 \}
02082 
02083 \textcolor{comment}{/* BGSAVE [SCHEDULE] */}
02084 \textcolor{keywordtype}{void} bgsaveCommand(\hyperlink{structclient}{client} *c) \{
02085     \textcolor{keywordtype}{int} schedule = 0;
02086 
02087     \textcolor{comment}{/* The SCHEDULE option changes the behavior of BGSAVE when an AOF rewrite}
02088 \textcolor{comment}{     * is in progress. Instead of returning an error a BGSAVE gets scheduled. */}
02089     \textcolor{keywordflow}{if} (c->argc > 1) \{
02090         \textcolor{keywordflow}{if} (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"schedule"})) \{
02091             schedule = 1;
02092         \} \textcolor{keywordflow}{else} \{
02093             addReply(c,shared.syntaxerr);
02094             \textcolor{keywordflow}{return};
02095         \}
02096     \}
02097 
02098     rdbSaveInfo rsi, *rsiptr;
02099     rsiptr = rdbPopulateSaveInfo(&rsi);
02100 
02101     \textcolor{keywordflow}{if} (server.rdb\_child\_pid != -1) \{
02102         addReplyError(c,\textcolor{stringliteral}{"Background save already in progress"});
02103     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.aof\_child\_pid != -1) \{
02104         \textcolor{keywordflow}{if} (schedule) \{
02105             server.rdb\_bgsave\_scheduled = 1;
02106             addReplyStatus(c,\textcolor{stringliteral}{"Background saving scheduled"});
02107         \} \textcolor{keywordflow}{else} \{
02108             addReplyError(c,
02109                 \textcolor{stringliteral}{"An AOF log rewriting in progress: can't BGSAVE right now. "}
02110                 \textcolor{stringliteral}{"Use BGSAVE SCHEDULE in order to schedule a BGSAVE whenever "}
02111                 \textcolor{stringliteral}{"possible."});
02112         \}
02113     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (rdbSaveBackground(server.rdb\_filename,rsiptr) == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
02114         addReplyStatus(c,\textcolor{stringliteral}{"Background saving started"});
02115     \} \textcolor{keywordflow}{else} \{
02116         addReply(c,shared.err);
02117     \}
02118 \}
02119 
02120 \textcolor{comment}{/* Populate the rdbSaveInfo structure used to persist the replication}
02121 \textcolor{comment}{ * information inside the RDB file. Currently the structure explicitly}
02122 \textcolor{comment}{ * contains just the currently selected DB from the master stream, however}
02123 \textcolor{comment}{ * if the rdbSave*() family functions receive a NULL rsi structure also}
02124 \textcolor{comment}{ * the Replication ID/offset is not saved. The function popultes 'rsi'}
02125 \textcolor{comment}{ * that is normally stack-allocated in the caller, returns the populated}
02126 \textcolor{comment}{ * pointer if the instance has a valid master client, otherwise NULL}
02127 \textcolor{comment}{ * is returned, and the RDB saving will not persist any replication related}
02128 \textcolor{comment}{ * information. */}
02129 rdbSaveInfo *rdbPopulateSaveInfo(rdbSaveInfo *rsi) \{
02130     rdbSaveInfo rsi\_init = \hyperlink{server_8h_a694b5ed5268bee8c50cc5b38fbec99ce}{RDB\_SAVE\_INFO\_INIT};
02131     *rsi = rsi\_init;
02132 
02133     \textcolor{comment}{/* If the instance is a master, we can populate the replication info}
02134 \textcolor{comment}{     * only when repl\_backlog is not NULL. If the repl\_backlog is NULL,}
02135 \textcolor{comment}{     * it means that the instance isn't in any replication chains. In this}
02136 \textcolor{comment}{     * scenario the replication info is useless, because when a slave}
02137 \textcolor{comment}{     * connects to us, the NULL repl\_backlog will trigger a full}
02138 \textcolor{comment}{     * synchronization, at the same time we will use a new replid and clear}
02139 \textcolor{comment}{     * replid2. */}
02140     \textcolor{keywordflow}{if} (!server.masterhost && server.repl\_backlog) \{
02141         \textcolor{comment}{/* Note that when server.slaveseldb is -1, it means that this master}
02142 \textcolor{comment}{         * didn't apply any write commands after a full synchronization.}
02143 \textcolor{comment}{         * So we can let repl\_stream\_db be 0, this allows a restarted slave}
02144 \textcolor{comment}{         * to reload replication ID/offset, it's safe because the next write}
02145 \textcolor{comment}{         * command must generate a SELECT statement. */}
02146         rsi->repl\_stream\_db = server.slaveseldb == -1 ? 0 : server.slaveseldb;
02147         \textcolor{keywordflow}{return} rsi;
02148     \}
02149 
02150     \textcolor{comment}{/* If the instance is a slave we need a connected master}
02151 \textcolor{comment}{     * in order to fetch the currently selected DB. */}
02152     \textcolor{keywordflow}{if} (server.master) \{
02153         rsi->repl\_stream\_db = server.master->db->id;
02154         \textcolor{keywordflow}{return} rsi;
02155     \}
02156 
02157     \textcolor{comment}{/* If we have a cached master we can use it in order to populate the}
02158 \textcolor{comment}{     * replication selected DB info inside the RDB file: the slave can}
02159 \textcolor{comment}{     * increment the master\_repl\_offset only from data arriving from the}
02160 \textcolor{comment}{     * master, so if we are disconnected the offset in the cached master}
02161 \textcolor{comment}{     * is valid. */}
02162     \textcolor{keywordflow}{if} (server.cached\_master) \{
02163         rsi->repl\_stream\_db = server.cached\_master->db->id;
02164         \textcolor{keywordflow}{return} rsi;
02165     \}
02166     \textcolor{keywordflow}{return} NULL;
02167 \}
\end{DoxyCode}
