\hypertarget{cluster_8c_source}{}\section{cluster.\+c}
\label{cluster_8c_source}\index{src/cluster.\+c@{src/cluster.\+c}}

\begin{DoxyCode}
00001 \textcolor{comment}{/* Redis Cluster implementation.}
00002 \textcolor{comment}{ *}
00003 \textcolor{comment}{ * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>}
00004 \textcolor{comment}{ * All rights reserved.}
00005 \textcolor{comment}{ *}
00006 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}
00007 \textcolor{comment}{ * modification, are permitted provided that the following conditions are met:}
00008 \textcolor{comment}{ *}
00009 \textcolor{comment}{ *   * Redistributions of source code must retain the above copyright notice,}
00010 \textcolor{comment}{ *     this list of conditions and the following disclaimer.}
00011 \textcolor{comment}{ *   * Redistributions in binary form must reproduce the above copyright}
00012 \textcolor{comment}{ *     notice, this list of conditions and the following disclaimer in the}
00013 \textcolor{comment}{ *     documentation and/or other materials provided with the distribution.}
00014 \textcolor{comment}{ *   * Neither the name of Redis nor the names of its contributors may be used}
00015 \textcolor{comment}{ *     to endorse or promote products derived from this software without}
00016 \textcolor{comment}{ *     specific prior written permission.}
00017 \textcolor{comment}{ *}
00018 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"}
00019 \textcolor{comment}{ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}
00020 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE}
00021 \textcolor{comment}{ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE}
00022 \textcolor{comment}{ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR}
00023 \textcolor{comment}{ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF}
00024 \textcolor{comment}{ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS}
00025 \textcolor{comment}{ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN}
00026 \textcolor{comment}{ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)}
00027 \textcolor{comment}{ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE}
00028 \textcolor{comment}{ * POSSIBILITY OF SUCH DAMAGE.}
00029 \textcolor{comment}{ */}
00030 
00031 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{server_8h}{"server.h"}
00032 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{cluster_8h}{"cluster.h"}
00033 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \hyperlink{endianconv_8h}{"endianconv.h"}
00034 
00035 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{types}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00036 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{socket}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00037 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{arpa}\textcolor{preprocessor}{/}\textcolor{preprocessor}{inet}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00038 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{fcntl}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00039 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{unistd}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00040 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{stat}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00041 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{sys}\textcolor{preprocessor}{/}\textcolor{preprocessor}{file}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00042 \textcolor{preprocessor}{#}\textcolor{preprocessor}{include} \textcolor{preprocessor}{<}\textcolor{preprocessor}{math}\textcolor{preprocessor}{.}\textcolor{preprocessor}{h}\textcolor{preprocessor}{>}
00043 
00044 \textcolor{comment}{/* A global reference to myself is handy to make code more clear.}
00045 \textcolor{comment}{ * Myself always points to server.cluster->myself, that is, the clusterNode}
00046 \textcolor{comment}{ * that represents this node. */}
00047 clusterNode *myself = NULL;
00048 
00049 clusterNode *createClusterNode(\textcolor{keywordtype}{char} *nodename, \textcolor{keywordtype}{int} flags);
00050 \textcolor{keywordtype}{int} clusterAddNode(clusterNode *node);
00051 \textcolor{keywordtype}{void} clusterAcceptHandler(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask);
00052 \textcolor{keywordtype}{void} clusterReadHandler(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask);
00053 \textcolor{keywordtype}{void} clusterSendPing(clusterLink *link, \textcolor{keywordtype}{int} type);
00054 \textcolor{keywordtype}{void} clusterSendFail(\textcolor{keywordtype}{char} *nodename);
00055 \textcolor{keywordtype}{void} clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request);
00056 \textcolor{keywordtype}{void} clusterUpdateState(\textcolor{keywordtype}{void});
00057 \textcolor{keywordtype}{int} clusterNodeGetSlotBit(clusterNode *n, \textcolor{keywordtype}{int} slot);
00058 sds clusterGenNodesDescription(\textcolor{keywordtype}{int} filter);
00059 clusterNode *clusterLookupNode(\textcolor{keywordtype}{char} *name);
00060 \textcolor{keywordtype}{int} clusterNodeAddSlave(clusterNode *master, clusterNode *slave);
00061 \textcolor{keywordtype}{int} clusterAddSlot(clusterNode *n, \textcolor{keywordtype}{int} slot);
00062 \textcolor{keywordtype}{int} clusterDelSlot(\textcolor{keywordtype}{int} slot);
00063 \textcolor{keywordtype}{int} clusterDelNodeSlots(clusterNode *node);
00064 \textcolor{keywordtype}{int} clusterNodeSetSlotBit(clusterNode *n, \textcolor{keywordtype}{int} slot);
00065 \textcolor{keywordtype}{void} clusterSetMaster(clusterNode *n);
00066 \textcolor{keywordtype}{void} clusterHandleSlaveFailover(\textcolor{keywordtype}{void});
00067 \textcolor{keywordtype}{void} clusterHandleSlaveMigration(\textcolor{keywordtype}{int} max\_slaves);
00068 \textcolor{keywordtype}{int} bitmapTestBit(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *bitmap, \textcolor{keywordtype}{int} pos);
00069 \textcolor{keywordtype}{void} clusterDoBeforeSleep(\textcolor{keywordtype}{int} flags);
00070 \textcolor{keywordtype}{void} clusterSendUpdate(clusterLink *link, clusterNode *node);
00071 \textcolor{keywordtype}{void} resetManualFailover(\textcolor{keywordtype}{void});
00072 \textcolor{keywordtype}{void} clusterCloseAllSlots(\textcolor{keywordtype}{void});
00073 \textcolor{keywordtype}{void} clusterSetNodeAsMaster(clusterNode *n);
00074 \textcolor{keywordtype}{void} clusterDelNode(clusterNode *delnode);
00075 sds representClusterNodeFlags(sds ci, uint16\_t flags);
00076 uint64\_t clusterGetMaxEpoch(\textcolor{keywordtype}{void});
00077 \textcolor{keywordtype}{int} clusterBumpConfigEpochWithoutConsensus(\textcolor{keywordtype}{void});
00078 
00079 \textcolor{comment}{/* -----------------------------------------------------------------------------}
00080 \textcolor{comment}{ * Initialization}
00081 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
00082 
00083 \textcolor{comment}{/* Load the cluster config from 'filename'.}
00084 \textcolor{comment}{ *}
00085 \textcolor{comment}{ * If the file does not exist or is zero-length (this may happen because}
00086 \textcolor{comment}{ * when we lock the nodes.conf file, we create a zero-length one for the}
00087 \textcolor{comment}{ * sake of locking if it does not already exist), C\_ERR is returned.}
00088 \textcolor{comment}{ * If the configuration was loaded from the file, C\_OK is returned. */}
00089 \textcolor{keywordtype}{int} clusterLoadConfig(\textcolor{keywordtype}{char} *filename) \{
00090     FILE *fp = fopen(filename,\textcolor{stringliteral}{"r"});
00091     \textcolor{keyword}{struct} stat sb;
00092     \textcolor{keywordtype}{char} *line;
00093     \textcolor{keywordtype}{int} maxline, j;
00094 
00095     \textcolor{keywordflow}{if} (fp == NULL) \{
00096         \textcolor{keywordflow}{if} (errno == ENOENT) \{
00097             \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00098         \} \textcolor{keywordflow}{else} \{
00099             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
00100                 \textcolor{stringliteral}{"Loading the cluster node config from %s: %s"},
00101                 filename, strerror(errno));
00102             exit(1);
00103         \}
00104     \}
00105 
00106     \textcolor{comment}{/* Check if the file is zero-length: if so return C\_ERR to signal}
00107 \textcolor{comment}{     * we have to write the config. */}
00108     \textcolor{keywordflow}{if} (fstat(fileno(fp),&sb) != -1 && sb.st\_size == 0) \{
00109         fclose(fp);
00110         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00111     \}
00112 
00113     \textcolor{comment}{/* Parse the file. Note that single lines of the cluster config file can}
00114 \textcolor{comment}{     * be really long as they include all the hash slots of the node.}
00115 \textcolor{comment}{     * This means in the worst possible case, half of the Redis slots will be}
00116 \textcolor{comment}{     * present in a single line, possibly in importing or migrating state, so}
00117 \textcolor{comment}{     * together with the node ID of the sender/receiver.}
00118 \textcolor{comment}{     *}
00119 \textcolor{comment}{     * To simplify we allocate 1024+CLUSTER\_SLOTS*128 bytes per line. */}
00120     maxline = 1024+\hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}*128;
00121     line = zmalloc(maxline);
00122     \textcolor{keywordflow}{while}(fgets(line,maxline,fp) != NULL) \{
00123         \textcolor{keywordtype}{int} argc;
00124         sds *argv;
00125         clusterNode *n, *master;
00126         \textcolor{keywordtype}{char} *p, *s;
00127 
00128         \textcolor{comment}{/* Skip blank lines, they can be created either by users manually}
00129 \textcolor{comment}{         * editing nodes.conf or by the config writing process if stopped}
00130 \textcolor{comment}{         * before the truncate() call. */}
00131         \textcolor{keywordflow}{if} (line[0] == \textcolor{stringliteral}{'\(\backslash\)n'} || line[0] == \textcolor{stringliteral}{'\(\backslash\)0'}) \textcolor{keywordflow}{continue};
00132 
00133         \textcolor{comment}{/* Split the line into arguments for processing. */}
00134         argv = sdssplitargs(line,&argc);
00135         \textcolor{keywordflow}{if} (argv == NULL) \textcolor{keywordflow}{goto} fmterr;
00136 
00137         \textcolor{comment}{/* Handle the special "vars" line. Don't pretend it is the last}
00138 \textcolor{comment}{         * line even if it actually is when generated by Redis. */}
00139         \textcolor{keywordflow}{if} (strcasecmp(argv[0],\textcolor{stringliteral}{"vars"}) == 0) \{
00140             \textcolor{keywordflow}{for} (j = 1; j < argc; j += 2) \{
00141                 \textcolor{keywordflow}{if} (strcasecmp(argv[j],\textcolor{stringliteral}{"currentEpoch"}) == 0) \{
00142                     server.cluster->currentEpoch =
00143                             strtoull(argv[j+1],NULL,10);
00144                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (strcasecmp(argv[j],\textcolor{stringliteral}{"lastVoteEpoch"}) == 0) \{
00145                     server.cluster->lastVoteEpoch =
00146                             strtoull(argv[j+1],NULL,10);
00147                 \} \textcolor{keywordflow}{else} \{
00148                     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
00149                         \textcolor{stringliteral}{"Skipping unknown cluster config variable '%s'"},
00150                         argv[j]);
00151                 \}
00152             \}
00153             sdsfreesplitres(argv,argc);
00154             \textcolor{keywordflow}{continue};
00155         \}
00156 
00157         \textcolor{comment}{/* Regular config lines have at least eight fields */}
00158         \textcolor{keywordflow}{if} (argc < 8) \textcolor{keywordflow}{goto} fmterr;
00159 
00160         \textcolor{comment}{/* Create this node if it does not exist */}
00161         n = clusterLookupNode(argv[0]);
00162         \textcolor{keywordflow}{if} (!n) \{
00163             n = createClusterNode(argv[0],0);
00164             clusterAddNode(n);
00165         \}
00166         \textcolor{comment}{/* Address and port */}
00167         \textcolor{keywordflow}{if} ((p = strrchr(argv[1],\textcolor{stringliteral}{':'})) == NULL) \textcolor{keywordflow}{goto} fmterr;
00168         *p = \textcolor{stringliteral}{'\(\backslash\)0'};
00169         memcpy(n->ip,argv[1],strlen(argv[1])+1);
00170         \textcolor{keywordtype}{char} *port = p+1;
00171         \textcolor{keywordtype}{char} *busp = strchr(port,\textcolor{stringliteral}{'@'});
00172         \textcolor{keywordflow}{if} (busp) \{
00173             *busp = \textcolor{stringliteral}{'\(\backslash\)0'};
00174             busp++;
00175         \}
00176         n->port = atoi(port);
00177         \textcolor{comment}{/* In older versions of nodes.conf the "@busport" part is missing.}
00178 \textcolor{comment}{         * In this case we set it to the default offset of 10000 from the}
00179 \textcolor{comment}{         * base port. */}
00180         n->cport = busp ? atoi(busp) : n->port + \hyperlink{cluster_8h_ac619a9ae48ab1431daa590fb5e75cea8}{CLUSTER\_PORT\_INCR};
00181 
00182         \textcolor{comment}{/* Parse flags */}
00183         p = s = argv[2];
00184         \textcolor{keywordflow}{while}(p) \{
00185             p = strchr(s,\textcolor{stringliteral}{','});
00186             \textcolor{keywordflow}{if} (p) *p = \textcolor{stringliteral}{'\(\backslash\)0'};
00187             \textcolor{keywordflow}{if} (!strcasecmp(s,\textcolor{stringliteral}{"myself"})) \{
00188                 \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(server.cluster->myself == NULL);
00189                 myself = server.cluster->myself = n;
00190                 n->flags |= \hyperlink{cluster_8h_afee946c4e74c08465e9b4ead5e3659e6}{CLUSTER\_NODE\_MYSELF};
00191             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(s,\textcolor{stringliteral}{"master"})) \{
00192                 n->flags |= \hyperlink{cluster_8h_a5dcea846e31b55b73244aa2e496a31bf}{CLUSTER\_NODE\_MASTER};
00193             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(s,\textcolor{stringliteral}{"slave"})) \{
00194                 n->flags |= \hyperlink{cluster_8h_a34b7bfd1f810397be68c3b5d13d4d134}{CLUSTER\_NODE\_SLAVE};
00195             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(s,\textcolor{stringliteral}{"fail?"})) \{
00196                 n->flags |= \hyperlink{cluster_8h_a5306c1ae8988b8be0a1a02bd9162dfa1}{CLUSTER\_NODE\_PFAIL};
00197             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(s,\textcolor{stringliteral}{"fail"})) \{
00198                 n->flags |= \hyperlink{cluster_8h_ad211e85c7baf8a5a59acd747e4e9005a}{CLUSTER\_NODE\_FAIL};
00199                 n->fail\_time = mstime();
00200             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(s,\textcolor{stringliteral}{"handshake"})) \{
00201                 n->flags |= \hyperlink{cluster_8h_a60571342a067f1e5772a04b36feff6a6}{CLUSTER\_NODE\_HANDSHAKE};
00202             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(s,\textcolor{stringliteral}{"noaddr"})) \{
00203                 n->flags |= \hyperlink{cluster_8h_a2bbed8bf0615871a01ca8b7f691b56d8}{CLUSTER\_NODE\_NOADDR};
00204             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(s,\textcolor{stringliteral}{"noflags"})) \{
00205                 \textcolor{comment}{/* nothing to do */}
00206             \} \textcolor{keywordflow}{else} \{
00207                 \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unknown flag in redis cluster config file"});
00208             \}
00209             \textcolor{keywordflow}{if} (p) s = p+1;
00210         \}
00211 
00212         \textcolor{comment}{/* Get master if any. Set the master and populate master's}
00213 \textcolor{comment}{         * slave list. */}
00214         \textcolor{keywordflow}{if} (argv[3][0] != \textcolor{stringliteral}{'-'}) \{
00215             master = clusterLookupNode(argv[3]);
00216             \textcolor{keywordflow}{if} (!master) \{
00217                 master = createClusterNode(argv[3],0);
00218                 clusterAddNode(master);
00219             \}
00220             n->slaveof = master;
00221             clusterNodeAddSlave(master,n);
00222         \}
00223 
00224         \textcolor{comment}{/* Set ping sent / pong received timestamps */}
00225         \textcolor{keywordflow}{if} (atoi(argv[4])) n->ping\_sent = mstime();
00226         \textcolor{keywordflow}{if} (atoi(argv[5])) n->pong\_received = mstime();
00227 
00228         \textcolor{comment}{/* Set configEpoch for this node. */}
00229         n->configEpoch = strtoull(argv[6],NULL,10);
00230 
00231         \textcolor{comment}{/* Populate hash slots served by this instance. */}
00232         \textcolor{keywordflow}{for} (j = 8; j < argc; j++) \{
00233             \textcolor{keywordtype}{int} start, stop;
00234 
00235             \textcolor{keywordflow}{if} (argv[j][0] == \textcolor{stringliteral}{'['}) \{
00236                 \textcolor{comment}{/* Here we handle migrating / importing slots */}
00237                 \textcolor{keywordtype}{int} slot;
00238                 \textcolor{keywordtype}{char} direction;
00239                 clusterNode *cn;
00240 
00241                 p = strchr(argv[j],\textcolor{stringliteral}{'-'});
00242                 \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(p != NULL);
00243                 *p = \textcolor{stringliteral}{'\(\backslash\)0'};
00244                 direction = p[1]; \textcolor{comment}{/* Either '>' or '<' */}
00245                 slot = atoi(argv[j]+1);
00246                 \textcolor{keywordflow}{if} (slot < 0 || slot >= \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}) \textcolor{keywordflow}{goto} fmterr;
00247                 p += 3;
00248                 cn = clusterLookupNode(p);
00249                 \textcolor{keywordflow}{if} (!cn) \{
00250                     cn = createClusterNode(p,0);
00251                     clusterAddNode(cn);
00252                 \}
00253                 \textcolor{keywordflow}{if} (direction == \textcolor{stringliteral}{'>'}) \{
00254                     server.cluster->migrating\_slots\_to[slot] = cn;
00255                 \} \textcolor{keywordflow}{else} \{
00256                     server.cluster->importing\_slots\_from[slot] = cn;
00257                 \}
00258                 \textcolor{keywordflow}{continue};
00259             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((p = strchr(argv[j],\textcolor{stringliteral}{'-'})) != NULL) \{
00260                 *p = \textcolor{stringliteral}{'\(\backslash\)0'};
00261                 start = atoi(argv[j]);
00262                 stop = atoi(p+1);
00263             \} \textcolor{keywordflow}{else} \{
00264                 start = stop = atoi(argv[j]);
00265             \}
00266             \textcolor{keywordflow}{if} (start < 0 || start >= \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}) \textcolor{keywordflow}{goto} fmterr;
00267             \textcolor{keywordflow}{if} (stop < 0 || stop >= \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}) \textcolor{keywordflow}{goto} fmterr;
00268             \textcolor{keywordflow}{while}(start <= stop) clusterAddSlot(n, start++);
00269         \}
00270 
00271         sdsfreesplitres(argv,argc);
00272     \}
00273     \textcolor{comment}{/* Config sanity check */}
00274     \textcolor{keywordflow}{if} (server.cluster->myself == NULL) \textcolor{keywordflow}{goto} fmterr;
00275 
00276     zfree(line);
00277     fclose(fp);
00278 
00279     serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Node configuration loaded, I'm %.40s"}, myself->name);
00280 
00281     \textcolor{comment}{/* Something that should never happen: currentEpoch smaller than}
00282 \textcolor{comment}{     * the max epoch found in the nodes configuration. However we handle this}
00283 \textcolor{comment}{     * as some form of protection against manual editing of critical files. */}
00284     \textcolor{keywordflow}{if} (clusterGetMaxEpoch() > server.cluster->currentEpoch) \{
00285         server.cluster->currentEpoch = clusterGetMaxEpoch();
00286     \}
00287     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00288 
00289 fmterr:
00290     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
00291         \textcolor{stringliteral}{"Unrecoverable error: corrupted cluster config file."});
00292     zfree(line);
00293     \textcolor{keywordflow}{if} (fp) fclose(fp);
00294     exit(1);
00295 \}
00296 
00297 \textcolor{comment}{/* Cluster node configuration is exactly the same as CLUSTER NODES output.}
00298 \textcolor{comment}{ *}
00299 \textcolor{comment}{ * This function writes the node config and returns 0, on error -1}
00300 \textcolor{comment}{ * is returned.}
00301 \textcolor{comment}{ *}
00302 \textcolor{comment}{ * Note: we need to write the file in an atomic way from the point of view}
00303 \textcolor{comment}{ * of the POSIX filesystem semantics, so that if the server is stopped}
00304 \textcolor{comment}{ * or crashes during the write, we'll end with either the old file or the}
00305 \textcolor{comment}{ * new one. Since we have the full payload to write available we can use}
00306 \textcolor{comment}{ * a single write to write the whole file. If the pre-existing file was}
00307 \textcolor{comment}{ * bigger we pad our payload with newlines that are anyway ignored and truncate}
00308 \textcolor{comment}{ * the file afterward. */}
00309 \textcolor{keywordtype}{int} clusterSaveConfig(\textcolor{keywordtype}{int} do\_fsync) \{
00310     sds ci;
00311     size\_t content\_size;
00312     \textcolor{keyword}{struct} stat sb;
00313     \textcolor{keywordtype}{int} fd;
00314 
00315     server.cluster->todo\_before\_sleep &= ~\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG};
00316 
00317     \textcolor{comment}{/* Get the nodes description and concatenate our "vars" directive to}
00318 \textcolor{comment}{     * save currentEpoch and lastVoteEpoch. */}
00319     ci = clusterGenNodesDescription(\hyperlink{cluster_8h_a60571342a067f1e5772a04b36feff6a6}{CLUSTER\_NODE\_HANDSHAKE});
00320     ci = sdscatprintf(ci,\textcolor{stringliteral}{"vars currentEpoch %llu lastVoteEpoch %llu\(\backslash\)n"},
00321         (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) server.cluster->currentEpoch,
00322         (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) server.cluster->lastVoteEpoch);
00323     content\_size = sdslen(ci);
00324 
00325     \textcolor{keywordflow}{if} ((fd = open(server.cluster\_configfile,O\_WRONLY|O\_CREAT,0644))
00326         == -1) \textcolor{keywordflow}{goto} err;
00327 
00328     \textcolor{comment}{/* Pad the new payload if the existing file length is greater. */}
00329     \textcolor{keywordflow}{if} (fstat(fd,&sb) != -1) \{
00330         \textcolor{keywordflow}{if} (sb.st\_size > (off\_t)content\_size) \{
00331             ci = sdsgrowzero(ci,sb.st\_size);
00332             memset(ci+content\_size,\textcolor{stringliteral}{'\(\backslash\)n'},sb.st\_size-content\_size);
00333         \}
00334     \}
00335     \textcolor{keywordflow}{if} (write(fd,ci,sdslen(ci)) != (ssize\_t)sdslen(ci)) \textcolor{keywordflow}{goto} err;
00336     \textcolor{keywordflow}{if} (do\_fsync) \{
00337         server.cluster->todo\_before\_sleep &= ~\hyperlink{cluster_8h_accc9a00230cd04789db2398bb3ab715a}{CLUSTER\_TODO\_FSYNC\_CONFIG};
00338         fsync(fd);
00339     \}
00340 
00341     \textcolor{comment}{/* Truncate the file if needed to remove the final \(\backslash\)n padding that}
00342 \textcolor{comment}{     * is just garbage. */}
00343     \textcolor{keywordflow}{if} (content\_size != sdslen(ci) && ftruncate(fd,content\_size) == -1) \{
00344         \textcolor{comment}{/* ftruncate() failing is not a critical error. */}
00345     \}
00346     close(fd);
00347     sdsfree(ci);
00348     \textcolor{keywordflow}{return} 0;
00349 
00350 err:
00351     \textcolor{keywordflow}{if} (fd != -1) close(fd);
00352     sdsfree(ci);
00353     \textcolor{keywordflow}{return} -1;
00354 \}
00355 
00356 \textcolor{keywordtype}{void} clusterSaveConfigOrDie(\textcolor{keywordtype}{int} do\_fsync) \{
00357     \textcolor{keywordflow}{if} (clusterSaveConfig(do\_fsync) == -1) \{
00358         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Fatal: can't update cluster config file."});
00359         exit(1);
00360     \}
00361 \}
00362 
00363 \textcolor{comment}{/* Lock the cluster config using flock(), and leaks the file descritor used to}
00364 \textcolor{comment}{ * acquire the lock so that the file will be locked forever.}
00365 \textcolor{comment}{ *}
00366 \textcolor{comment}{ * This works because we always update nodes.conf with a new version}
00367 \textcolor{comment}{ * in-place, reopening the file, and writing to it in place (later adjusting}
00368 \textcolor{comment}{ * the length with ftruncate()).}
00369 \textcolor{comment}{ *}
00370 \textcolor{comment}{ * On success C\_OK is returned, otherwise an error is logged and}
00371 \textcolor{comment}{ * the function returns C\_ERR to signal a lock was not acquired. */}
00372 \textcolor{keywordtype}{int} clusterLockConfig(\textcolor{keywordtype}{char} *filename) \{
00373 \textcolor{comment}{/* flock() does not exist on Solaris}
00374 \textcolor{comment}{ * and a fcntl-based solution won't help, as we constantly re-open that file,}
00375 \textcolor{comment}{ * which will release \_all\_ locks anyway}
00376 \textcolor{comment}{ */}
00377 \textcolor{preprocessor}{#}\textcolor{preprocessor}{if} \textcolor{preprocessor}{!}\textcolor{preprocessor}{defined}\textcolor{preprocessor}{(}\textcolor{preprocessor}{\_\_sun}\textcolor{preprocessor}{)}
00378     \textcolor{comment}{/* To lock it, we need to open the file in a way it is created if}
00379 \textcolor{comment}{     * it does not exist, otherwise there is a race condition with other}
00380 \textcolor{comment}{     * processes. */}
00381     \textcolor{keywordtype}{int} fd = open(filename,O\_WRONLY|O\_CREAT,0644);
00382     \textcolor{keywordflow}{if} (fd == -1) \{
00383         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
00384             \textcolor{stringliteral}{"Can't open %s in order to acquire a lock: %s"},
00385             filename, strerror(errno));
00386         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00387     \}
00388 
00389     \textcolor{keywordflow}{if} (flock(fd,LOCK\_EX|LOCK\_NB) == -1) \{
00390         \textcolor{keywordflow}{if} (errno == EWOULDBLOCK) \{
00391             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
00392                  \textcolor{stringliteral}{"Sorry, the cluster configuration file %s is already used "}
00393                  \textcolor{stringliteral}{"by a different Redis Cluster node. Please make sure that "}
00394                  \textcolor{stringliteral}{"different nodes use different cluster configuration "}
00395                  \textcolor{stringliteral}{"files."}, filename);
00396         \} \textcolor{keywordflow}{else} \{
00397             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
00398                 \textcolor{stringliteral}{"Impossible to lock %s: %s"}, filename, strerror(errno));
00399         \}
00400         close(fd);
00401         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00402     \}
00403     \textcolor{comment}{/* Lock acquired: leak the 'fd' by not closing it, so that we'll retain the}
00404 \textcolor{comment}{     * lock to the file as long as the process exists. */}
00405 \textcolor{preprocessor}{#}\textcolor{preprocessor}{endif} \textcolor{comment}{/* \_\_sun */}
00406 
00407     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00408 \}
00409 
00410 \textcolor{keywordtype}{void} clusterInit(\textcolor{keywordtype}{void}) \{
00411     \textcolor{keywordtype}{int} saveconf = 0;
00412 
00413     server.cluster = zmalloc(\textcolor{keyword}{sizeof}(clusterState));
00414     server.cluster->myself = NULL;
00415     server.cluster->currentEpoch = 0;
00416     server.cluster->state = \hyperlink{cluster_8h_a4a46e6d5b85c594d08283dc6da2a32bf}{CLUSTER\_FAIL};
00417     server.cluster->size = 1;
00418     server.cluster->todo\_before\_sleep = 0;
00419     server.cluster->nodes = dictCreate(&clusterNodesDictType,NULL);
00420     server.cluster->nodes\_black\_list =
00421         dictCreate(&clusterNodesBlackListDictType,NULL);
00422     server.cluster->failover\_auth\_time = 0;
00423     server.cluster->failover\_auth\_count = 0;
00424     server.cluster->failover\_auth\_rank = 0;
00425     server.cluster->failover\_auth\_epoch = 0;
00426     server.cluster->cant\_failover\_reason = \hyperlink{cluster_8h_a9a55c4c18a5113bc3c8272f62a983c96}{CLUSTER\_CANT\_FAILOVER\_NONE};
00427     server.cluster->lastVoteEpoch = 0;
00428     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < \hyperlink{cluster_8h_a6222c464c1f2125f42271d2abd63853e}{CLUSTERMSG\_TYPE\_COUNT}; i++) \{
00429         server.cluster->stats\_bus\_messages\_sent[i] = 0;
00430         server.cluster->stats\_bus\_messages\_received[i] = 0;
00431     \}
00432     server.cluster->stats\_pfail\_nodes = 0;
00433     memset(server.cluster->slots,0, \textcolor{keyword}{sizeof}(server.cluster->slots));
00434     clusterCloseAllSlots();
00435 
00436     \textcolor{comment}{/* Lock the cluster config file to make sure every node uses}
00437 \textcolor{comment}{     * its own nodes.conf. */}
00438     \textcolor{keywordflow}{if} (clusterLockConfig(server.cluster\_configfile) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR})
00439         exit(1);
00440 
00441     \textcolor{comment}{/* Load or create a new nodes configuration. */}
00442     \textcolor{keywordflow}{if} (clusterLoadConfig(server.cluster\_configfile) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR}) \{
00443         \textcolor{comment}{/* No configuration found. We will just use the random name provided}
00444 \textcolor{comment}{         * by the createClusterNode() function. */}
00445         myself = server.cluster->myself =
00446             createClusterNode(NULL,\hyperlink{cluster_8h_afee946c4e74c08465e9b4ead5e3659e6}{CLUSTER\_NODE\_MYSELF}|
      \hyperlink{cluster_8h_a5dcea846e31b55b73244aa2e496a31bf}{CLUSTER\_NODE\_MASTER});
00447         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"No cluster configuration found, I'm %.40s"},
00448             myself->name);
00449         clusterAddNode(myself);
00450         saveconf = 1;
00451     \}
00452     \textcolor{keywordflow}{if} (saveconf) clusterSaveConfigOrDie(1);
00453 
00454     \textcolor{comment}{/* We need a listening TCP port for our cluster messaging needs. */}
00455     server.cfd\_count = 0;
00456 
00457     \textcolor{comment}{/* Port sanity check II}
00458 \textcolor{comment}{     * The other handshake port check is triggered too late to stop}
00459 \textcolor{comment}{     * us from trying to use a too-high cluster port number. */}
00460     \textcolor{keywordflow}{if} (server.port > (65535-\hyperlink{cluster_8h_ac619a9ae48ab1431daa590fb5e75cea8}{CLUSTER\_PORT\_INCR})) \{
00461         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"Redis port number too high. "}
00462                    \textcolor{stringliteral}{"Cluster communication port is 10,000 port "}
00463                    \textcolor{stringliteral}{"numbers higher than your Redis port. "}
00464                    \textcolor{stringliteral}{"Your Redis port number must be "}
00465                    \textcolor{stringliteral}{"lower than 55535."});
00466         exit(1);
00467     \}
00468 
00469     \textcolor{keywordflow}{if} (listenToPort(server.port+\hyperlink{cluster_8h_ac619a9ae48ab1431daa590fb5e75cea8}{CLUSTER\_PORT\_INCR},
00470         server.cfd,&server.cfd\_count) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR})
00471     \{
00472         exit(1);
00473     \} \textcolor{keywordflow}{else} \{
00474         \textcolor{keywordtype}{int} j;
00475 
00476         \textcolor{keywordflow}{for} (j = 0; j < server.cfd\_count; j++) \{
00477             \textcolor{keywordflow}{if} (aeCreateFileEvent(server.el, server.cfd[j], \hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE},
00478                 clusterAcceptHandler, NULL) == \hyperlink{ae_8h_aa16dcf7effdf8f8df97f51b1cb51a9df}{AE\_ERR})
00479                     \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"Unrecoverable error creating Redis Cluster "}
00480                                 \textcolor{stringliteral}{"file event."});
00481         \}
00482     \}
00483 
00484     \textcolor{comment}{/* The slots -> keys map is a radix tree. Initialize it here. */}
00485     server.cluster->slots\_to\_keys = raxNew();
00486     memset(server.cluster->slots\_keys\_count,0,
00487            \textcolor{keyword}{sizeof}(server.cluster->slots\_keys\_count));
00488 
00489     \textcolor{comment}{/* Set myself->port / cport to my listening ports, we'll just need to}
00490 \textcolor{comment}{     * discover the IP address via MEET messages. */}
00491     myself->port = server.port;
00492     myself->cport = server.port+\hyperlink{cluster_8h_ac619a9ae48ab1431daa590fb5e75cea8}{CLUSTER\_PORT\_INCR};
00493     \textcolor{keywordflow}{if} (server.cluster\_announce\_port)
00494         myself->port = server.cluster\_announce\_port;
00495     \textcolor{keywordflow}{if} (server.cluster\_announce\_bus\_port)
00496         myself->cport = server.cluster\_announce\_bus\_port;
00497 
00498     server.cluster->mf\_end = 0;
00499     resetManualFailover();
00500 \}
00501 
00502 \textcolor{comment}{/* Reset a node performing a soft or hard reset:}
00503 \textcolor{comment}{ *}
00504 \textcolor{comment}{ * 1) All other nodes are forget.}
00505 \textcolor{comment}{ * 2) All the assigned / open slots are released.}
00506 \textcolor{comment}{ * 3) If the node is a slave, it turns into a master.}
00507 \textcolor{comment}{ * 5) Only for hard reset: a new Node ID is generated.}
00508 \textcolor{comment}{ * 6) Only for hard reset: currentEpoch and configEpoch are set to 0.}
00509 \textcolor{comment}{ * 7) The new configuration is saved and the cluster state updated.}
00510 \textcolor{comment}{ * 8) If the node was a slave, the whole data set is flushed away. */}
00511 \textcolor{keywordtype}{void} clusterReset(\textcolor{keywordtype}{int} hard) \{
00512     dictIterator *di;
00513     dictEntry *de;
00514     \textcolor{keywordtype}{int} j;
00515 
00516     \textcolor{comment}{/* Turn into master. */}
00517     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(myself)) \{
00518         clusterSetNodeAsMaster(myself);
00519         replicationUnsetMaster();
00520         emptyDb(-1,\hyperlink{server_8h_a83a0ecde3a9f1f6bbcae9f4b966a509b}{EMPTYDB\_NO\_FLAGS},NULL);
00521     \}
00522 
00523     \textcolor{comment}{/* Close slots, reset manual failover state. */}
00524     clusterCloseAllSlots();
00525     resetManualFailover();
00526 
00527     \textcolor{comment}{/* Unassign all the slots. */}
00528     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}; j++) clusterDelSlot(j);
00529 
00530     \textcolor{comment}{/* Forget all the nodes, but myself. */}
00531     di = dictGetSafeIterator(server.cluster->nodes);
00532     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
00533         clusterNode *node = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
00534 
00535         \textcolor{keywordflow}{if} (node == myself) \textcolor{keywordflow}{continue};
00536         clusterDelNode(node);
00537     \}
00538     dictReleaseIterator(di);
00539 
00540     \textcolor{comment}{/* Hard reset only: set epochs to 0, change node ID. */}
00541     \textcolor{keywordflow}{if} (hard) \{
00542         sds oldname;
00543 
00544         server.cluster->currentEpoch = 0;
00545         server.cluster->lastVoteEpoch = 0;
00546         myself->configEpoch = 0;
00547         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"configEpoch set to 0 via CLUSTER RESET HARD"});
00548 
00549         \textcolor{comment}{/* To change the Node ID we need to remove the old name from the}
00550 \textcolor{comment}{         * nodes table, change the ID, and re-add back with new name. */}
00551         oldname = sdsnewlen(myself->name, \hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN});
00552         dictDelete(server.cluster->nodes,oldname);
00553         sdsfree(oldname);
00554         getRandomHexChars(myself->name, \hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN});
00555         clusterAddNode(myself);
00556         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},\textcolor{stringliteral}{"Node hard reset, now I'm %.40s"}, myself->name);
00557     \}
00558 
00559     \textcolor{comment}{/* Make sure to persist the new config and update the state. */}
00560     clusterDoBeforeSleep(\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG}|
00561                          \hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE}|
00562                          \hyperlink{cluster_8h_accc9a00230cd04789db2398bb3ab715a}{CLUSTER\_TODO\_FSYNC\_CONFIG});
00563 \}
00564 
00565 \textcolor{comment}{/* -----------------------------------------------------------------------------}
00566 \textcolor{comment}{ * CLUSTER communication link}
00567 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
00568 
00569 clusterLink *createClusterLink(clusterNode *node) \{
00570     clusterLink *link = zmalloc(\textcolor{keyword}{sizeof}(*link));
00571     link->ctime = mstime();
00572     link->sndbuf = sdsempty();
00573     link->rcvbuf = sdsempty();
00574     link->node = node;
00575     link->fd = -1;
00576     \textcolor{keywordflow}{return} link;
00577 \}
00578 
00579 \textcolor{comment}{/* Free a cluster link, but does not free the associated node of course.}
00580 \textcolor{comment}{ * This function will just make sure that the original node associated}
00581 \textcolor{comment}{ * with this link will have the 'link' field set to NULL. */}
00582 \textcolor{keywordtype}{void} freeClusterLink(clusterLink *link) \{
00583     \textcolor{keywordflow}{if} (link->fd != -1) \{
00584         aeDeleteFileEvent(server.el, link->fd, \hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE});
00585         aeDeleteFileEvent(server.el, link->fd, \hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE});
00586     \}
00587     sdsfree(link->sndbuf);
00588     sdsfree(link->rcvbuf);
00589     \textcolor{keywordflow}{if} (link->node)
00590         link->node->link = NULL;
00591     close(link->fd);
00592     zfree(link);
00593 \}
00594 
00595 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{MAX\_CLUSTER\_ACCEPTS\_PER\_CALL} 1000
00596 \textcolor{keywordtype}{void} clusterAcceptHandler(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask) \{
00597     \textcolor{keywordtype}{int} cport, cfd;
00598     \textcolor{keywordtype}{int} max = \hyperlink{cluster_8c_aa33746b19367347d43a13080ca87b871}{MAX\_CLUSTER\_ACCEPTS\_PER\_CALL};
00599     \textcolor{keywordtype}{char} cip[\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN}];
00600     clusterLink *link;
00601     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(el);
00602     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(mask);
00603     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(privdata);
00604 
00605     \textcolor{comment}{/* If the server is starting up, don't accept cluster connections:}
00606 \textcolor{comment}{     * UPDATE messages may interact with the database content. */}
00607     \textcolor{keywordflow}{if} (server.masterhost == NULL && server.loading) \textcolor{keywordflow}{return};
00608 
00609     \textcolor{keywordflow}{while}(max--) \{
00610         cfd = anetTcpAccept(server.neterr, fd, cip, \textcolor{keyword}{sizeof}(cip), &cport);
00611         \textcolor{keywordflow}{if} (cfd == \hyperlink{anet_8h_a0697b7774a7e0f4ef141839fe93536fe}{ANET\_ERR}) \{
00612             \textcolor{keywordflow}{if} (errno != EWOULDBLOCK)
00613                 serverLog(\hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE},
00614                     \textcolor{stringliteral}{"Error accepting cluster node: %s"}, server.neterr);
00615             \textcolor{keywordflow}{return};
00616         \}
00617         anetNonBlock(NULL,cfd);
00618         anetEnableTcpNoDelay(NULL,cfd);
00619 
00620         \textcolor{comment}{/* Use non-blocking I/O for cluster messages. */}
00621         serverLog(\hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE},\textcolor{stringliteral}{"Accepted cluster node %s:%d"}, cip, cport);
00622         \textcolor{comment}{/* Create a link object we use to handle the connection.}
00623 \textcolor{comment}{         * It gets passed to the readable handler when data is available.}
00624 \textcolor{comment}{         * Initiallly the link->node pointer is set to NULL as we don't know}
00625 \textcolor{comment}{         * which node is, but the right node is references once we know the}
00626 \textcolor{comment}{         * node identity. */}
00627         link = createClusterLink(NULL);
00628         link->fd = cfd;
00629         aeCreateFileEvent(server.el,cfd,\hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE},clusterReadHandler,link);
00630     \}
00631 \}
00632 
00633 \textcolor{comment}{/* -----------------------------------------------------------------------------}
00634 \textcolor{comment}{ * Key space handling}
00635 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
00636 
00637 \textcolor{comment}{/* We have 16384 hash slots. The hash slot of a given key is obtained}
00638 \textcolor{comment}{ * as the least significant 14 bits of the crc16 of the key.}
00639 \textcolor{comment}{ *}
00640 \textcolor{comment}{ * However if the key contains the \{...\} pattern, only the part between}
00641 \textcolor{comment}{ * \{ and \} is hashed. This may be useful in the future to force certain}
00642 \textcolor{comment}{ * keys to be in the same node (assuming no resharding is in progress). */}
00643 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} keyHashSlot(\textcolor{keywordtype}{char} *key, \textcolor{keywordtype}{int} keylen) \{
00644     \textcolor{keywordtype}{int} s, e; \textcolor{comment}{/* start-end indexes of \{ and \} */}
00645 
00646     \textcolor{keywordflow}{for} (s = 0; s < keylen; s++)
00647         \textcolor{keywordflow}{if} (key[s] == \textcolor{stringliteral}{'\{'}) \textcolor{keywordflow}{break};
00648 
00649     \textcolor{comment}{/* No '\{' ? Hash the whole key. This is the base case. */}
00650     \textcolor{keywordflow}{if} (s == keylen) \textcolor{keywordflow}{return} crc16(key,keylen) & 0x3FFF;
00651 
00652     \textcolor{comment}{/* '\{' found? Check if we have the corresponding '\}'. */}
00653     \textcolor{keywordflow}{for} (e = s+1; e < keylen; e++)
00654         \textcolor{keywordflow}{if} (key[e] == \textcolor{stringliteral}{'\}'}) \textcolor{keywordflow}{break};
00655 
00656     \textcolor{comment}{/* No '\}' or nothing between \{\} ? Hash the whole key. */}
00657     \textcolor{keywordflow}{if} (e == keylen || e == s+1) \textcolor{keywordflow}{return} crc16(key,keylen) & 0x3FFF;
00658 
00659     \textcolor{comment}{/* If we are here there is both a \{ and a \} on its right. Hash}
00660 \textcolor{comment}{     * what is in the middle between \{ and \}. */}
00661     \textcolor{keywordflow}{return} crc16(key+s+1,e-s-1) & 0x3FFF;
00662 \}
00663 
00664 \textcolor{comment}{/* -----------------------------------------------------------------------------}
00665 \textcolor{comment}{ * CLUSTER node API}
00666 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
00667 
00668 \textcolor{comment}{/* Create a new cluster node, with the specified flags.}
00669 \textcolor{comment}{ * If "nodename" is NULL this is considered a first handshake and a random}
00670 \textcolor{comment}{ * node name is assigned to this node (it will be fixed later when we'll}
00671 \textcolor{comment}{ * receive the first pong).}
00672 \textcolor{comment}{ *}
00673 \textcolor{comment}{ * The node is created and returned to the user, but it is not automatically}
00674 \textcolor{comment}{ * added to the nodes hash table. */}
00675 clusterNode *createClusterNode(\textcolor{keywordtype}{char} *nodename, \textcolor{keywordtype}{int} flags) \{
00676     clusterNode *node = zmalloc(\textcolor{keyword}{sizeof}(*node));
00677 
00678     \textcolor{keywordflow}{if} (nodename)
00679         memcpy(node->name, nodename, \hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN});
00680     \textcolor{keywordflow}{else}
00681         getRandomHexChars(node->name, \hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN});
00682     node->ctime = mstime();
00683     node->configEpoch = 0;
00684     node->flags = flags;
00685     memset(node->slots,0,\textcolor{keyword}{sizeof}(node->slots));
00686     node->numslots = 0;
00687     node->numslaves = 0;
00688     node->slaves = NULL;
00689     node->slaveof = NULL;
00690     node->ping\_sent = node->pong\_received = 0;
00691     node->fail\_time = 0;
00692     node->link = NULL;
00693     memset(node->ip,0,\textcolor{keyword}{sizeof}(node->ip));
00694     node->port = 0;
00695     node->cport = 0;
00696     node->fail\_reports = listCreate();
00697     node->voted\_time = 0;
00698     node->orphaned\_time = 0;
00699     node->repl\_offset\_time = 0;
00700     node->repl\_offset = 0;
00701     \hyperlink{adlist_8h_a648e4a2d20decff3182a72a608b0b8f2}{listSetFreeMethod}(node->fail\_reports,zfree);
00702     \textcolor{keywordflow}{return} node;
00703 \}
00704 
00705 \textcolor{comment}{/* This function is called every time we get a failure report from a node.}
00706 \textcolor{comment}{ * The side effect is to populate the fail\_reports list (or to update}
00707 \textcolor{comment}{ * the timestamp of an existing report).}
00708 \textcolor{comment}{ *}
00709 \textcolor{comment}{ * 'failing' is the node that is in failure state according to the}
00710 \textcolor{comment}{ * 'sender' node.}
00711 \textcolor{comment}{ *}
00712 \textcolor{comment}{ * The function returns 0 if it just updates a timestamp of an existing}
00713 \textcolor{comment}{ * failure report from the same sender. 1 is returned if a new failure}
00714 \textcolor{comment}{ * report is created. */}
00715 \textcolor{keywordtype}{int} clusterNodeAddFailureReport(clusterNode *failing, clusterNode *sender) \{
00716     list *l = failing->fail\_reports;
00717     listNode *ln;
00718     listIter li;
00719     clusterNodeFailReport *fr;
00720 
00721     \textcolor{comment}{/* If a failure report from the same sender already exists, just update}
00722 \textcolor{comment}{     * the timestamp. */}
00723     listRewind(l,&li);
00724     \textcolor{keywordflow}{while} ((ln = listNext(&li)) != NULL) \{
00725         fr = ln->value;
00726         \textcolor{keywordflow}{if} (fr->node == sender) \{
00727             fr->time = mstime();
00728             \textcolor{keywordflow}{return} 0;
00729         \}
00730     \}
00731 
00732     \textcolor{comment}{/* Otherwise create a new report. */}
00733     fr = zmalloc(\textcolor{keyword}{sizeof}(*fr));
00734     fr->node = sender;
00735     fr->time = mstime();
00736     listAddNodeTail(l,fr);
00737     \textcolor{keywordflow}{return} 1;
00738 \}
00739 
00740 \textcolor{comment}{/* Remove failure reports that are too old, where too old means reasonably}
00741 \textcolor{comment}{ * older than the global node timeout. Note that anyway for a node to be}
00742 \textcolor{comment}{ * flagged as FAIL we need to have a local PFAIL state that is at least}
00743 \textcolor{comment}{ * older than the global node timeout, so we don't just trust the number}
00744 \textcolor{comment}{ * of failure reports from other nodes. */}
00745 \textcolor{keywordtype}{void} clusterNodeCleanupFailureReports(clusterNode *node) \{
00746     list *l = node->fail\_reports;
00747     listNode *ln;
00748     listIter li;
00749     clusterNodeFailReport *fr;
00750     mstime\_t maxtime = server.cluster\_node\_timeout *
00751                      \hyperlink{cluster_8h_a6679b8ca82e8f5b657759a896fa9c1ac}{CLUSTER\_FAIL\_REPORT\_VALIDITY\_MULT};
00752     mstime\_t now = mstime();
00753 
00754     listRewind(l,&li);
00755     \textcolor{keywordflow}{while} ((ln = listNext(&li)) != NULL) \{
00756         fr = ln->value;
00757         \textcolor{keywordflow}{if} (now - fr->time > maxtime) listDelNode(l,ln);
00758     \}
00759 \}
00760 
00761 \textcolor{comment}{/* Remove the failing report for 'node' if it was previously considered}
00762 \textcolor{comment}{ * failing by 'sender'. This function is called when a node informs us via}
00763 \textcolor{comment}{ * gossip that a node is OK from its point of view (no FAIL or PFAIL flags).}
00764 \textcolor{comment}{ *}
00765 \textcolor{comment}{ * Note that this function is called relatively often as it gets called even}
00766 \textcolor{comment}{ * when there are no nodes failing, and is O(N), however when the cluster is}
00767 \textcolor{comment}{ * fine the failure reports list is empty so the function runs in constant}
00768 \textcolor{comment}{ * time.}
00769 \textcolor{comment}{ *}
00770 \textcolor{comment}{ * The function returns 1 if the failure report was found and removed.}
00771 \textcolor{comment}{ * Otherwise 0 is returned. */}
00772 \textcolor{keywordtype}{int} clusterNodeDelFailureReport(clusterNode *node, clusterNode *sender) \{
00773     list *l = node->fail\_reports;
00774     listNode *ln;
00775     listIter li;
00776     clusterNodeFailReport *fr;
00777 
00778     \textcolor{comment}{/* Search for a failure report from this sender. */}
00779     listRewind(l,&li);
00780     \textcolor{keywordflow}{while} ((ln = listNext(&li)) != NULL) \{
00781         fr = ln->value;
00782         \textcolor{keywordflow}{if} (fr->node == sender) \textcolor{keywordflow}{break};
00783     \}
00784     \textcolor{keywordflow}{if} (!ln) \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* No failure report from this sender. */}
00785 
00786     \textcolor{comment}{/* Remove the failure report. */}
00787     listDelNode(l,ln);
00788     clusterNodeCleanupFailureReports(node);
00789     \textcolor{keywordflow}{return} 1;
00790 \}
00791 
00792 \textcolor{comment}{/* Return the number of external nodes that believe 'node' is failing,}
00793 \textcolor{comment}{ * not including this node, that may have a PFAIL or FAIL state for this}
00794 \textcolor{comment}{ * node as well. */}
00795 \textcolor{keywordtype}{int} clusterNodeFailureReportsCount(clusterNode *node) \{
00796     clusterNodeCleanupFailureReports(node);
00797     \textcolor{keywordflow}{return} \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(node->fail\_reports);
00798 \}
00799 
00800 \textcolor{keywordtype}{int} clusterNodeRemoveSlave(clusterNode *master, clusterNode *slave) \{
00801     \textcolor{keywordtype}{int} j;
00802 
00803     \textcolor{keywordflow}{for} (j = 0; j < master->numslaves; j++) \{
00804         \textcolor{keywordflow}{if} (master->slaves[j] == slave) \{
00805             \textcolor{keywordflow}{if} ((j+1) < master->numslaves) \{
00806                 \textcolor{keywordtype}{int} remaining\_slaves = (master->numslaves - j) - 1;
00807                 memmove(master->slaves+j,master->slaves+(j+1),
00808                         (\textcolor{keyword}{sizeof}(*master->slaves) * remaining\_slaves));
00809             \}
00810             master->numslaves--;
00811             \textcolor{keywordflow}{if} (master->numslaves == 0)
00812                 master->flags &= ~\hyperlink{cluster_8h_a1d5a62356ed9f5986613c2315a358119}{CLUSTER\_NODE\_MIGRATE\_TO};
00813             \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00814         \}
00815     \}
00816     \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00817 \}
00818 
00819 \textcolor{keywordtype}{int} clusterNodeAddSlave(clusterNode *master, clusterNode *slave) \{
00820     \textcolor{keywordtype}{int} j;
00821 
00822     \textcolor{comment}{/* If it's already a slave, don't add it again. */}
00823     \textcolor{keywordflow}{for} (j = 0; j < master->numslaves; j++)
00824         \textcolor{keywordflow}{if} (master->slaves[j] == slave) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00825     master->slaves = zrealloc(master->slaves,
00826         \textcolor{keyword}{sizeof}(clusterNode*)*(master->numslaves+1));
00827     master->slaves[master->numslaves] = slave;
00828     master->numslaves++;
00829     master->flags |= \hyperlink{cluster_8h_a1d5a62356ed9f5986613c2315a358119}{CLUSTER\_NODE\_MIGRATE\_TO};
00830     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
00831 \}
00832 
00833 \textcolor{keywordtype}{int} clusterCountNonFailingSlaves(clusterNode *n) \{
00834     \textcolor{keywordtype}{int} j, okslaves = 0;
00835 
00836     \textcolor{keywordflow}{for} (j = 0; j < n->numslaves; j++)
00837         \textcolor{keywordflow}{if} (!\hyperlink{cluster_8h_a6a31c614ff4f5ac8ebaa630b0a921c3d}{nodeFailed}(n->slaves[j])) okslaves++;
00838     \textcolor{keywordflow}{return} okslaves;
00839 \}
00840 
00841 \textcolor{comment}{/* Low level cleanup of the node structure. Only called by clusterDelNode(). */}
00842 \textcolor{keywordtype}{void} freeClusterNode(clusterNode *n) \{
00843     sds nodename;
00844     \textcolor{keywordtype}{int} j;
00845 
00846     \textcolor{comment}{/* If the node has associated slaves, we have to set}
00847 \textcolor{comment}{     * all the slaves->slaveof fields to NULL (unknown). */}
00848     \textcolor{keywordflow}{for} (j = 0; j < n->numslaves; j++)
00849         n->slaves[j]->slaveof = NULL;
00850 
00851     \textcolor{comment}{/* Remove this node from the list of slaves of its master. */}
00852     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(n) && n->slaveof) clusterNodeRemoveSlave(n->slaveof,n);
00853 
00854     \textcolor{comment}{/* Unlink from the set of nodes. */}
00855     nodename = sdsnewlen(n->name, \hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN});
00856     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(dictDelete(server.cluster->nodes,nodename) == 
      \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK});
00857     sdsfree(nodename);
00858 
00859     \textcolor{comment}{/* Release link and associated data structures. */}
00860     \textcolor{keywordflow}{if} (n->link) freeClusterLink(n->link);
00861     listRelease(n->fail\_reports);
00862     zfree(n->slaves);
00863     zfree(n);
00864 \}
00865 
00866 \textcolor{comment}{/* Add a node to the nodes hash table */}
00867 \textcolor{keywordtype}{int} clusterAddNode(clusterNode *node) \{
00868     \textcolor{keywordtype}{int} retval;
00869 
00870     retval = dictAdd(server.cluster->nodes,
00871             sdsnewlen(node->name,\hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN}), node);
00872     \textcolor{keywordflow}{return} (retval == \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK}) ? \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK} : \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
00873 \}
00874 
00875 \textcolor{comment}{/* Remove a node from the cluster. The functio performs the high level}
00876 \textcolor{comment}{ * cleanup, calling freeClusterNode() for the low level cleanup.}
00877 \textcolor{comment}{ * Here we do the following:}
00878 \textcolor{comment}{ *}
00879 \textcolor{comment}{ * 1) Mark all the slots handled by it as unassigned.}
00880 \textcolor{comment}{ * 2) Remove all the failure reports sent by this node and referenced by}
00881 \textcolor{comment}{ *    other nodes.}
00882 \textcolor{comment}{ * 3) Free the node with freeClusterNode() that will in turn remove it}
00883 \textcolor{comment}{ *    from the hash table and from the list of slaves of its master, if}
00884 \textcolor{comment}{ *    it is a slave node.}
00885 \textcolor{comment}{ */}
00886 \textcolor{keywordtype}{void} clusterDelNode(clusterNode *delnode) \{
00887     \textcolor{keywordtype}{int} j;
00888     dictIterator *di;
00889     dictEntry *de;
00890 
00891     \textcolor{comment}{/* 1) Mark slots as unassigned. */}
00892     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}; j++) \{
00893         \textcolor{keywordflow}{if} (server.cluster->importing\_slots\_from[j] == delnode)
00894             server.cluster->importing\_slots\_from[j] = NULL;
00895         \textcolor{keywordflow}{if} (server.cluster->migrating\_slots\_to[j] == delnode)
00896             server.cluster->migrating\_slots\_to[j] = NULL;
00897         \textcolor{keywordflow}{if} (server.cluster->slots[j] == delnode)
00898             clusterDelSlot(j);
00899     \}
00900 
00901     \textcolor{comment}{/* 2) Remove failure reports. */}
00902     di = dictGetSafeIterator(server.cluster->nodes);
00903     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
00904         clusterNode *node = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
00905 
00906         \textcolor{keywordflow}{if} (node == delnode) \textcolor{keywordflow}{continue};
00907         clusterNodeDelFailureReport(node,delnode);
00908     \}
00909     dictReleaseIterator(di);
00910 
00911     \textcolor{comment}{/* 3) Free the node, unlinking it from the cluster. */}
00912     freeClusterNode(delnode);
00913 \}
00914 
00915 \textcolor{comment}{/* Node lookup by name */}
00916 clusterNode *clusterLookupNode(\textcolor{keywordtype}{char} *name) \{
00917     sds s = sdsnewlen(name, \hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN});
00918     dictEntry *de;
00919 
00920     de = dictFind(server.cluster->nodes,s);
00921     sdsfree(s);
00922     \textcolor{keywordflow}{if} (de == NULL) \textcolor{keywordflow}{return} NULL;
00923     \textcolor{keywordflow}{return} \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
00924 \}
00925 
00926 \textcolor{comment}{/* This is only used after the handshake. When we connect a given IP/PORT}
00927 \textcolor{comment}{ * as a result of CLUSTER MEET we don't have the node name yet, so we}
00928 \textcolor{comment}{ * pick a random one, and will fix it when we receive the PONG request using}
00929 \textcolor{comment}{ * this function. */}
00930 \textcolor{keywordtype}{void} clusterRenameNode(clusterNode *node, \textcolor{keywordtype}{char} *newname) \{
00931     \textcolor{keywordtype}{int} retval;
00932     sds s = sdsnewlen(node->name, \hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN});
00933 
00934     serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG},\textcolor{stringliteral}{"Renaming node %.40s into %.40s"},
00935         node->name, newname);
00936     retval = dictDelete(server.cluster->nodes, s);
00937     sdsfree(s);
00938     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(retval == \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK});
00939     memcpy(node->name, newname, \hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN});
00940     clusterAddNode(node);
00941 \}
00942 
00943 \textcolor{comment}{/* -----------------------------------------------------------------------------}
00944 \textcolor{comment}{ * CLUSTER config epoch handling}
00945 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
00946 
00947 \textcolor{comment}{/* Return the greatest configEpoch found in the cluster, or the current}
00948 \textcolor{comment}{ * epoch if greater than any node configEpoch. */}
00949 uint64\_t clusterGetMaxEpoch(\textcolor{keywordtype}{void}) \{
00950     uint64\_t max = 0;
00951     dictIterator *di;
00952     dictEntry *de;
00953 
00954     di = dictGetSafeIterator(server.cluster->nodes);
00955     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
00956         clusterNode *node = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
00957         \textcolor{keywordflow}{if} (node->configEpoch > max) max = node->configEpoch;
00958     \}
00959     dictReleaseIterator(di);
00960     \textcolor{keywordflow}{if} (max < server.cluster->currentEpoch) max = server.cluster->currentEpoch;
00961     \textcolor{keywordflow}{return} max;
00962 \}
00963 
00964 \textcolor{comment}{/* If this node epoch is zero or is not already the greatest across the}
00965 \textcolor{comment}{ * cluster (from the POV of the local configuration), this function will:}
00966 \textcolor{comment}{ *}
00967 \textcolor{comment}{ * 1) Generate a new config epoch, incrementing the current epoch.}
00968 \textcolor{comment}{ * 2) Assign the new epoch to this node, WITHOUT any consensus.}
00969 \textcolor{comment}{ * 3) Persist the configuration on disk before sending packets with the}
00970 \textcolor{comment}{ *    new configuration.}
00971 \textcolor{comment}{ *}
00972 \textcolor{comment}{ * If the new config epoch is generated and assigend, C\_OK is returned,}
00973 \textcolor{comment}{ * otherwise C\_ERR is returned (since the node has already the greatest}
00974 \textcolor{comment}{ * configuration around) and no operation is performed.}
00975 \textcolor{comment}{ *}
00976 \textcolor{comment}{ * Important note: this function violates the principle that config epochs}
00977 \textcolor{comment}{ * should be generated with consensus and should be unique across the cluster.}
00978 \textcolor{comment}{ * However Redis Cluster uses this auto-generated new config epochs in two}
00979 \textcolor{comment}{ * cases:}
00980 \textcolor{comment}{ *}
00981 \textcolor{comment}{ * 1) When slots are closed after importing. Otherwise resharding would be}
00982 \textcolor{comment}{ *    too expensive.}
00983 \textcolor{comment}{ * 2) When CLUSTER FAILOVER is called with options that force a slave to}
00984 \textcolor{comment}{ *    failover its master even if there is not master majority able to}
00985 \textcolor{comment}{ *    create a new configuration epoch.}
00986 \textcolor{comment}{ *}
00987 \textcolor{comment}{ * Redis Cluster will not explode using this function, even in the case of}
00988 \textcolor{comment}{ * a collision between this node and another node, generating the same}
00989 \textcolor{comment}{ * configuration epoch unilaterally, because the config epoch conflict}
00990 \textcolor{comment}{ * resolution algorithm will eventually move colliding nodes to different}
00991 \textcolor{comment}{ * config epochs. However using this function may violate the "last failover}
00992 \textcolor{comment}{ * wins" rule, so should only be used with care. */}
00993 \textcolor{keywordtype}{int} clusterBumpConfigEpochWithoutConsensus(\textcolor{keywordtype}{void}) \{
00994     uint64\_t maxEpoch = clusterGetMaxEpoch();
00995 
00996     \textcolor{keywordflow}{if} (myself->configEpoch == 0 ||
00997         myself->configEpoch != maxEpoch)
00998     \{
00999         server.cluster->currentEpoch++;
01000         myself->configEpoch = server.cluster->currentEpoch;
01001         clusterDoBeforeSleep(\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG}|
01002                              \hyperlink{cluster_8h_accc9a00230cd04789db2398bb3ab715a}{CLUSTER\_TODO\_FSYNC\_CONFIG});
01003         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01004             \textcolor{stringliteral}{"New configEpoch set to %llu"},
01005             (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) myself->configEpoch);
01006         \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
01007     \} \textcolor{keywordflow}{else} \{
01008         \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
01009     \}
01010 \}
01011 
01012 \textcolor{comment}{/* This function is called when this node is a master, and we receive from}
01013 \textcolor{comment}{ * another master a configuration epoch that is equal to our configuration}
01014 \textcolor{comment}{ * epoch.}
01015 \textcolor{comment}{ *}
01016 \textcolor{comment}{ * BACKGROUND}
01017 \textcolor{comment}{ *}
01018 \textcolor{comment}{ * It is not possible that different slaves get the same config}
01019 \textcolor{comment}{ * epoch during a failover election, because the slaves need to get voted}
01020 \textcolor{comment}{ * by a majority. However when we perform a manual resharding of the cluster}
01021 \textcolor{comment}{ * the node will assign a configuration epoch to itself without to ask}
01022 \textcolor{comment}{ * for agreement. Usually resharding happens when the cluster is working well}
01023 \textcolor{comment}{ * and is supervised by the sysadmin, however it is possible for a failover}
01024 \textcolor{comment}{ * to happen exactly while the node we are resharding a slot to assigns itself}
01025 \textcolor{comment}{ * a new configuration epoch, but before it is able to propagate it.}
01026 \textcolor{comment}{ *}
01027 \textcolor{comment}{ * So technically it is possible in this condition that two nodes end with}
01028 \textcolor{comment}{ * the same configuration epoch.}
01029 \textcolor{comment}{ *}
01030 \textcolor{comment}{ * Another possibility is that there are bugs in the implementation causing}
01031 \textcolor{comment}{ * this to happen.}
01032 \textcolor{comment}{ *}
01033 \textcolor{comment}{ * Moreover when a new cluster is created, all the nodes start with the same}
01034 \textcolor{comment}{ * configEpoch. This collision resolution code allows nodes to automatically}
01035 \textcolor{comment}{ * end with a different configEpoch at startup automatically.}
01036 \textcolor{comment}{ *}
01037 \textcolor{comment}{ * In all the cases, we want a mechanism that resolves this issue automatically}
01038 \textcolor{comment}{ * as a safeguard. The same configuration epoch for masters serving different}
01039 \textcolor{comment}{ * set of slots is not harmful, but it is if the nodes end serving the same}
01040 \textcolor{comment}{ * slots for some reason (manual errors or software bugs) without a proper}
01041 \textcolor{comment}{ * failover procedure.}
01042 \textcolor{comment}{ *}
01043 \textcolor{comment}{ * In general we want a system that eventually always ends with different}
01044 \textcolor{comment}{ * masters having different configuration epochs whatever happened, since}
01045 \textcolor{comment}{ * nothign is worse than a split-brain condition in a distributed system.}
01046 \textcolor{comment}{ *}
01047 \textcolor{comment}{ * BEHAVIOR}
01048 \textcolor{comment}{ *}
01049 \textcolor{comment}{ * When this function gets called, what happens is that if this node}
01050 \textcolor{comment}{ * has the lexicographically smaller Node ID compared to the other node}
01051 \textcolor{comment}{ * with the conflicting epoch (the 'sender' node), it will assign itself}
01052 \textcolor{comment}{ * the greatest configuration epoch currently detected among nodes plus 1.}
01053 \textcolor{comment}{ *}
01054 \textcolor{comment}{ * This means that even if there are multiple nodes colliding, the node}
01055 \textcolor{comment}{ * with the greatest Node ID never moves forward, so eventually all the nodes}
01056 \textcolor{comment}{ * end with a different configuration epoch.}
01057 \textcolor{comment}{ */}
01058 \textcolor{keywordtype}{void} clusterHandleConfigEpochCollision(clusterNode *sender) \{
01059     \textcolor{comment}{/* Prerequisites: nodes have the same configEpoch and are both masters. */}
01060     \textcolor{keywordflow}{if} (sender->configEpoch != myself->configEpoch ||
01061         !\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(sender) || !\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(myself)) \textcolor{keywordflow}{return};
01062     \textcolor{comment}{/* Don't act if the colliding node has a smaller Node ID. */}
01063     \textcolor{keywordflow}{if} (memcmp(sender->name,myself->name,\hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN}) <= 0) \textcolor{keywordflow}{return};
01064     \textcolor{comment}{/* Get the next ID available at the best of this node knowledge. */}
01065     server.cluster->currentEpoch++;
01066     myself->configEpoch = server.cluster->currentEpoch;
01067     clusterSaveConfigOrDie(1);
01068     serverLog(\hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE},
01069         \textcolor{stringliteral}{"WARNING: configEpoch collision with node %.40s."}
01070         \textcolor{stringliteral}{" configEpoch set to %llu"},
01071         sender->name,
01072         (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) myself->configEpoch);
01073 \}
01074 
01075 \textcolor{comment}{/* -----------------------------------------------------------------------------}
01076 \textcolor{comment}{ * CLUSTER nodes blacklist}
01077 \textcolor{comment}{ *}
01078 \textcolor{comment}{ * The nodes blacklist is just a way to ensure that a given node with a given}
01079 \textcolor{comment}{ * Node ID is not readded before some time elapsed (this time is specified}
01080 \textcolor{comment}{ * in seconds in CLUSTER\_BLACKLIST\_TTL).}
01081 \textcolor{comment}{ *}
01082 \textcolor{comment}{ * This is useful when we want to remove a node from the cluster completely:}
01083 \textcolor{comment}{ * when CLUSTER FORGET is called, it also puts the node into the blacklist so}
01084 \textcolor{comment}{ * that even if we receive gossip messages from other nodes that still remember}
01085 \textcolor{comment}{ * about the node we want to remove, we don't re-add it before some time.}
01086 \textcolor{comment}{ *}
01087 \textcolor{comment}{ * Currently the CLUSTER\_BLACKLIST\_TTL is set to 1 minute, this means}
01088 \textcolor{comment}{ * that redis-trib has 60 seconds to send CLUSTER FORGET messages to nodes}
01089 \textcolor{comment}{ * in the cluster without dealing with the problem of other nodes re-adding}
01090 \textcolor{comment}{ * back the node to nodes we already sent the FORGET command to.}
01091 \textcolor{comment}{ *}
01092 \textcolor{comment}{ * The data structure used is a hash table with an sds string representing}
01093 \textcolor{comment}{ * the node ID as key, and the time when it is ok to re-add the node as}
01094 \textcolor{comment}{ * value.}
01095 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
01096 
01097 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLUSTER\_BLACKLIST\_TTL} 60      \textcolor{comment}{/* 1 minute. */}
01098 
01099 
01100 \textcolor{comment}{/* Before of the addNode() or Exists() operations we always remove expired}
01101 \textcolor{comment}{ * entries from the black list. This is an O(N) operation but it is not a}
01102 \textcolor{comment}{ * problem since add / exists operations are called very infrequently and}
01103 \textcolor{comment}{ * the hash table is supposed to contain very little elements at max.}
01104 \textcolor{comment}{ * However without the cleanup during long uptimes and with some automated}
01105 \textcolor{comment}{ * node add/removal procedures, entries could accumulate. */}
01106 \textcolor{keywordtype}{void} clusterBlacklistCleanup(\textcolor{keywordtype}{void}) \{
01107     dictIterator *di;
01108     dictEntry *de;
01109 
01110     di = dictGetSafeIterator(server.cluster->nodes\_black\_list);
01111     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
01112         int64\_t expire = \hyperlink{dict_8h_ad65abe818fa141e537800699668a7f09}{dictGetUnsignedIntegerVal}(de);
01113 
01114         \textcolor{keywordflow}{if} (expire < server.unixtime)
01115             dictDelete(server.cluster->nodes\_black\_list,\hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de));
01116     \}
01117     dictReleaseIterator(di);
01118 \}
01119 
01120 \textcolor{comment}{/* Cleanup the blacklist and add a new node ID to the black list. */}
01121 \textcolor{keywordtype}{void} clusterBlacklistAddNode(clusterNode *node) \{
01122     dictEntry *de;
01123     sds id = sdsnewlen(node->name,\hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN});
01124 
01125     clusterBlacklistCleanup();
01126     \textcolor{keywordflow}{if} (dictAdd(server.cluster->nodes\_black\_list,id,NULL) == \hyperlink{dict_8h_a2afecbeab8f7efbc183048f52f6d17e5}{DICT\_OK}) \{
01127         \textcolor{comment}{/* If the key was added, duplicate the sds string representation of}
01128 \textcolor{comment}{         * the key for the next lookup. We'll free it at the end. */}
01129         id = sdsdup(id);
01130     \}
01131     de = dictFind(server.cluster->nodes\_black\_list,id);
01132     \hyperlink{dict_8h_aa846a3c28ad69004259435fd44246e10}{dictSetUnsignedIntegerVal}(de,time(NULL)+
      \hyperlink{cluster_8c_a8fb5fdcd1cd5787957afc9ea62519937}{CLUSTER\_BLACKLIST\_TTL});
01133     sdsfree(id);
01134 \}
01135 
01136 \textcolor{comment}{/* Return non-zero if the specified node ID exists in the blacklist.}
01137 \textcolor{comment}{ * You don't need to pass an sds string here, any pointer to 40 bytes}
01138 \textcolor{comment}{ * will work. */}
01139 \textcolor{keywordtype}{int} clusterBlacklistExists(\textcolor{keywordtype}{char} *nodeid) \{
01140     sds id = sdsnewlen(nodeid,\hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN});
01141     \textcolor{keywordtype}{int} retval;
01142 
01143     clusterBlacklistCleanup();
01144     retval = dictFind(server.cluster->nodes\_black\_list,id) != NULL;
01145     sdsfree(id);
01146     \textcolor{keywordflow}{return} retval;
01147 \}
01148 
01149 \textcolor{comment}{/* -----------------------------------------------------------------------------}
01150 \textcolor{comment}{ * CLUSTER messages exchange - PING/PONG and gossip}
01151 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
01152 
01153 \textcolor{comment}{/* This function checks if a given node should be marked as FAIL.}
01154 \textcolor{comment}{ * It happens if the following conditions are met:}
01155 \textcolor{comment}{ *}
01156 \textcolor{comment}{ * 1) We received enough failure reports from other master nodes via gossip.}
01157 \textcolor{comment}{ *    Enough means that the majority of the masters signaled the node is}
01158 \textcolor{comment}{ *    down recently.}
01159 \textcolor{comment}{ * 2) We believe this node is in PFAIL state.}
01160 \textcolor{comment}{ *}
01161 \textcolor{comment}{ * If a failure is detected we also inform the whole cluster about this}
01162 \textcolor{comment}{ * event trying to force every other node to set the FAIL flag for the node.}
01163 \textcolor{comment}{ *}
01164 \textcolor{comment}{ * Note that the form of agreement used here is weak, as we collect the majority}
01165 \textcolor{comment}{ * of masters state during some time, and even if we force agreement by}
01166 \textcolor{comment}{ * propagating the FAIL message, because of partitions we may not reach every}
01167 \textcolor{comment}{ * node. However:}
01168 \textcolor{comment}{ *}
01169 \textcolor{comment}{ * 1) Either we reach the majority and eventually the FAIL state will propagate}
01170 \textcolor{comment}{ *    to all the cluster.}
01171 \textcolor{comment}{ * 2) Or there is no majority so no slave promotion will be authorized and the}
01172 \textcolor{comment}{ *    FAIL flag will be cleared after some time.}
01173 \textcolor{comment}{ */}
01174 \textcolor{keywordtype}{void} markNodeAsFailingIfNeeded(clusterNode *node) \{
01175     \textcolor{keywordtype}{int} failures;
01176     \textcolor{keywordtype}{int} needed\_quorum = (server.cluster->size / 2) + 1;
01177 
01178     \textcolor{keywordflow}{if} (!\hyperlink{cluster_8h_ac0ab1cbdbc2a49b30c98d73640476e32}{nodeTimedOut}(node)) \textcolor{keywordflow}{return}; \textcolor{comment}{/* We can reach it. */}
01179     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a6a31c614ff4f5ac8ebaa630b0a921c3d}{nodeFailed}(node)) \textcolor{keywordflow}{return}; \textcolor{comment}{/* Already FAILing. */}
01180 
01181     failures = clusterNodeFailureReportsCount(node);
01182     \textcolor{comment}{/* Also count myself as a voter if I'm a master. */}
01183     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(myself)) failures++;
01184     \textcolor{keywordflow}{if} (failures < needed\_quorum) \textcolor{keywordflow}{return}; \textcolor{comment}{/* No weak agreement from masters. */}
01185 
01186     serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01187         \textcolor{stringliteral}{"Marking node %.40s as failing (quorum reached)."}, node->name);
01188 
01189     \textcolor{comment}{/* Mark the node as failing. */}
01190     node->flags &= ~\hyperlink{cluster_8h_a5306c1ae8988b8be0a1a02bd9162dfa1}{CLUSTER\_NODE\_PFAIL};
01191     node->flags |= \hyperlink{cluster_8h_ad211e85c7baf8a5a59acd747e4e9005a}{CLUSTER\_NODE\_FAIL};
01192     node->fail\_time = mstime();
01193 
01194     \textcolor{comment}{/* Broadcast the failing node name to everybody, forcing all the other}
01195 \textcolor{comment}{     * reachable nodes to flag the node as FAIL. */}
01196     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(myself)) clusterSendFail(node->name);
01197     clusterDoBeforeSleep(\hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE}|
      \hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG});
01198 \}
01199 
01200 \textcolor{comment}{/* This function is called only if a node is marked as FAIL, but we are able}
01201 \textcolor{comment}{ * to reach it again. It checks if there are the conditions to undo the FAIL}
01202 \textcolor{comment}{ * state. */}
01203 \textcolor{keywordtype}{void} clearNodeFailureIfNeeded(clusterNode *node) \{
01204     mstime\_t now = mstime();
01205 
01206     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(\hyperlink{cluster_8h_a6a31c614ff4f5ac8ebaa630b0a921c3d}{nodeFailed}(node));
01207 
01208     \textcolor{comment}{/* For slaves we always clear the FAIL flag if we can contact the}
01209 \textcolor{comment}{     * node again. */}
01210     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(node) || node->numslots == 0) \{
01211         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01212             \textcolor{stringliteral}{"Clear FAIL state for node %.40s: %s is reachable again."},
01213                 node->name,
01214                 \hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(node) ? \textcolor{stringliteral}{"slave"} : \textcolor{stringliteral}{"master without slots"});
01215         node->flags &= ~\hyperlink{cluster_8h_ad211e85c7baf8a5a59acd747e4e9005a}{CLUSTER\_NODE\_FAIL};
01216         clusterDoBeforeSleep(\hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE}|
      \hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG});
01217     \}
01218 
01219     \textcolor{comment}{/* If it is a master and...}
01220 \textcolor{comment}{     * 1) The FAIL state is old enough.}
01221 \textcolor{comment}{     * 2) It is yet serving slots from our point of view (not failed over).}
01222 \textcolor{comment}{     * Apparently no one is going to fix these slots, clear the FAIL flag. */}
01223     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(node) && node->numslots > 0 &&
01224         (now - node->fail\_time) >
01225         (server.cluster\_node\_timeout * \hyperlink{cluster_8h_a91dcc2950ab29bc6fa0706069bd64e35}{CLUSTER\_FAIL\_UNDO\_TIME\_MULT}))
01226     \{
01227         serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01228             \textcolor{stringliteral}{"Clear FAIL state for node %.40s: is reachable again and nobody is serving its slots after
       some time."},
01229                 node->name);
01230         node->flags &= ~\hyperlink{cluster_8h_ad211e85c7baf8a5a59acd747e4e9005a}{CLUSTER\_NODE\_FAIL};
01231         clusterDoBeforeSleep(\hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE}|
      \hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG});
01232     \}
01233 \}
01234 
01235 \textcolor{comment}{/* Return true if we already have a node in HANDSHAKE state matching the}
01236 \textcolor{comment}{ * specified ip address and port number. This function is used in order to}
01237 \textcolor{comment}{ * avoid adding a new handshake node for the same address multiple times. */}
01238 \textcolor{keywordtype}{int} clusterHandshakeInProgress(\textcolor{keywordtype}{char} *ip, \textcolor{keywordtype}{int} port, \textcolor{keywordtype}{int} cport) \{
01239     dictIterator *di;
01240     dictEntry *de;
01241 
01242     di = dictGetSafeIterator(server.cluster->nodes);
01243     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
01244         clusterNode *node = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
01245 
01246         \textcolor{keywordflow}{if} (!\hyperlink{cluster_8h_a70f1a5bb82f54ce5d17b13de42176790}{nodeInHandshake}(node)) \textcolor{keywordflow}{continue};
01247         \textcolor{keywordflow}{if} (!strcasecmp(node->ip,ip) &&
01248             node->port == port &&
01249             node->cport == cport) \textcolor{keywordflow}{break};
01250     \}
01251     dictReleaseIterator(di);
01252     \textcolor{keywordflow}{return} de != NULL;
01253 \}
01254 
01255 \textcolor{comment}{/* Start an handshake with the specified address if there is not one}
01256 \textcolor{comment}{ * already in progress. Returns non-zero if the handshake was actually}
01257 \textcolor{comment}{ * started. On error zero is returned and errno is set to one of the}
01258 \textcolor{comment}{ * following values:}
01259 \textcolor{comment}{ *}
01260 \textcolor{comment}{ * EAGAIN - There is already an handshake in progress for this address.}
01261 \textcolor{comment}{ * EINVAL - IP or port are not valid. */}
01262 \textcolor{keywordtype}{int} clusterStartHandshake(\textcolor{keywordtype}{char} *ip, \textcolor{keywordtype}{int} port, \textcolor{keywordtype}{int} cport) \{
01263     clusterNode *n;
01264     \textcolor{keywordtype}{char} norm\_ip[\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN}];
01265     \textcolor{keyword}{struct} sockaddr\_storage sa;
01266 
01267     \textcolor{comment}{/* IP sanity check */}
01268     \textcolor{keywordflow}{if} (inet\_pton(AF\_INET,ip,
01269             &(((\textcolor{keyword}{struct} sockaddr\_in *)&sa)->sin\_addr)))
01270     \{
01271         sa.ss\_family = AF\_INET;
01272     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (inet\_pton(AF\_INET6,ip,
01273             &(((\textcolor{keyword}{struct} sockaddr\_in6 *)&sa)->sin6\_addr)))
01274     \{
01275         sa.ss\_family = AF\_INET6;
01276     \} \textcolor{keywordflow}{else} \{
01277         errno = EINVAL;
01278         \textcolor{keywordflow}{return} 0;
01279     \}
01280 
01281     \textcolor{comment}{/* Port sanity check */}
01282     \textcolor{keywordflow}{if} (port <= 0 || port > 65535 || cport <= 0 || cport > 65535) \{
01283         errno = EINVAL;
01284         \textcolor{keywordflow}{return} 0;
01285     \}
01286 
01287     \textcolor{comment}{/* Set norm\_ip as the normalized string representation of the node}
01288 \textcolor{comment}{     * IP address. */}
01289     memset(norm\_ip,0,\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN});
01290     \textcolor{keywordflow}{if} (sa.ss\_family == AF\_INET)
01291         inet\_ntop(AF\_INET,
01292             (\textcolor{keywordtype}{void}*)&(((\textcolor{keyword}{struct} sockaddr\_in *)&sa)->sin\_addr),
01293             norm\_ip,\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN});
01294     \textcolor{keywordflow}{else}
01295         inet\_ntop(AF\_INET6,
01296             (\textcolor{keywordtype}{void}*)&(((\textcolor{keyword}{struct} sockaddr\_in6 *)&sa)->sin6\_addr),
01297             norm\_ip,\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN});
01298 
01299     \textcolor{keywordflow}{if} (clusterHandshakeInProgress(norm\_ip,port,cport)) \{
01300         errno = EAGAIN;
01301         \textcolor{keywordflow}{return} 0;
01302     \}
01303 
01304     \textcolor{comment}{/* Add the node with a random address (NULL as first argument to}
01305 \textcolor{comment}{     * createClusterNode()). Everything will be fixed during the}
01306 \textcolor{comment}{     * handshake. */}
01307     n = createClusterNode(NULL,\hyperlink{cluster_8h_a60571342a067f1e5772a04b36feff6a6}{CLUSTER\_NODE\_HANDSHAKE}|
      \hyperlink{cluster_8h_ad992a5c70af8bc805aae5405106ff9f7}{CLUSTER\_NODE\_MEET});
01308     memcpy(n->ip,norm\_ip,\textcolor{keyword}{sizeof}(n->ip));
01309     n->port = port;
01310     n->cport = cport;
01311     clusterAddNode(n);
01312     \textcolor{keywordflow}{return} 1;
01313 \}
01314 
01315 \textcolor{comment}{/* Process the gossip section of PING or PONG packets.}
01316 \textcolor{comment}{ * Note that this function assumes that the packet is already sanity-checked}
01317 \textcolor{comment}{ * by the caller, not in the content of the gossip section, but in the}
01318 \textcolor{comment}{ * length. */}
01319 \textcolor{keywordtype}{void} clusterProcessGossipSection(clusterMsg *hdr, clusterLink *link) \{
01320     uint16\_t count = ntohs(hdr->count);
01321     clusterMsgDataGossip *g = (clusterMsgDataGossip*) hdr->data.ping.gossip;
01322     clusterNode *sender = link->node ? link->node : clusterLookupNode(hdr->sender);
01323 
01324     \textcolor{keywordflow}{while}(count--) \{
01325         uint16\_t flags = ntohs(g->flags);
01326         clusterNode *node;
01327         sds ci;
01328 
01329         \textcolor{keywordflow}{if} (server.verbosity == \hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG}) \{
01330             ci = representClusterNodeFlags(sdsempty(), flags);
01331             serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG},\textcolor{stringliteral}{"GOSSIP %.40s %s:%d@%d %s"},
01332                 g->nodename,
01333                 g->ip,
01334                 ntohs(g->port),
01335                 ntohs(g->cport),
01336                 ci);
01337             sdsfree(ci);
01338         \}
01339 
01340         \textcolor{comment}{/* Update our state accordingly to the gossip sections */}
01341         node = clusterLookupNode(g->nodename);
01342         \textcolor{keywordflow}{if} (node) \{
01343             \textcolor{comment}{/* We already know this node.}
01344 \textcolor{comment}{               Handle failure reports, only when the sender is a master. */}
01345             \textcolor{keywordflow}{if} (sender && \hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(sender) && node != myself) \{
01346                 \textcolor{keywordflow}{if} (flags & (\hyperlink{cluster_8h_ad211e85c7baf8a5a59acd747e4e9005a}{CLUSTER\_NODE\_FAIL}|
      \hyperlink{cluster_8h_a5306c1ae8988b8be0a1a02bd9162dfa1}{CLUSTER\_NODE\_PFAIL})) \{
01347                     \textcolor{keywordflow}{if} (clusterNodeAddFailureReport(node,sender)) \{
01348                         serverLog(\hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE},
01349                             \textcolor{stringliteral}{"Node %.40s reported node %.40s as not reachable."},
01350                             sender->name, node->name);
01351                     \}
01352                     markNodeAsFailingIfNeeded(node);
01353                 \} \textcolor{keywordflow}{else} \{
01354                     \textcolor{keywordflow}{if} (clusterNodeDelFailureReport(node,sender)) \{
01355                         serverLog(\hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE},
01356                             \textcolor{stringliteral}{"Node %.40s reported node %.40s is back online."},
01357                             sender->name, node->name);
01358                     \}
01359                 \}
01360             \}
01361 
01362             \textcolor{comment}{/* If from our POV the node is up (no failure flags are set),}
01363 \textcolor{comment}{             * we have no pending ping for the node, nor we have failure}
01364 \textcolor{comment}{             * reports for this node, update the last pong time with the}
01365 \textcolor{comment}{             * one we see from the other nodes. */}
01366             \textcolor{keywordflow}{if} (!(flags & (\hyperlink{cluster_8h_ad211e85c7baf8a5a59acd747e4e9005a}{CLUSTER\_NODE\_FAIL}|
      \hyperlink{cluster_8h_a5306c1ae8988b8be0a1a02bd9162dfa1}{CLUSTER\_NODE\_PFAIL})) &&
01367                 node->ping\_sent == 0 &&
01368                 clusterNodeFailureReportsCount(node) == 0)
01369             \{
01370                 mstime\_t pongtime = ntohl(g->pong\_received);
01371                 pongtime *= 1000; \textcolor{comment}{/* Convert back to milliseconds. */}
01372 
01373                 \textcolor{comment}{/* Replace the pong time with the received one only if}
01374 \textcolor{comment}{                 * it's greater than our view but is not in the future}
01375 \textcolor{comment}{                 * (with 500 milliseconds tolerance) from the POV of our}
01376 \textcolor{comment}{                 * clock. */}
01377                 \textcolor{keywordflow}{if} (pongtime <= (server.mstime+500) &&
01378                     pongtime > node->pong\_received)
01379                 \{
01380                     node->pong\_received = pongtime;
01381                 \}
01382             \}
01383 
01384             \textcolor{comment}{/* If we already know this node, but it is not reachable, and}
01385 \textcolor{comment}{             * we see a different address in the gossip section of a node that}
01386 \textcolor{comment}{             * can talk with this other node, update the address, disconnect}
01387 \textcolor{comment}{             * the old link if any, so that we'll attempt to connect with the}
01388 \textcolor{comment}{             * new address. */}
01389             \textcolor{keywordflow}{if} (node->flags & (\hyperlink{cluster_8h_ad211e85c7baf8a5a59acd747e4e9005a}{CLUSTER\_NODE\_FAIL}|
      \hyperlink{cluster_8h_a5306c1ae8988b8be0a1a02bd9162dfa1}{CLUSTER\_NODE\_PFAIL}) &&
01390                 !(flags & \hyperlink{cluster_8h_a2bbed8bf0615871a01ca8b7f691b56d8}{CLUSTER\_NODE\_NOADDR}) &&
01391                 !(flags & (\hyperlink{cluster_8h_ad211e85c7baf8a5a59acd747e4e9005a}{CLUSTER\_NODE\_FAIL}|
      \hyperlink{cluster_8h_a5306c1ae8988b8be0a1a02bd9162dfa1}{CLUSTER\_NODE\_PFAIL})) &&
01392                 (strcasecmp(node->ip,g->ip) ||
01393                  node->port != ntohs(g->port) ||
01394                  node->cport != ntohs(g->cport)))
01395             \{
01396                 \textcolor{keywordflow}{if} (node->link) freeClusterLink(node->link);
01397                 memcpy(node->ip,g->ip,\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN});
01398                 node->port = ntohs(g->port);
01399                 node->cport = ntohs(g->cport);
01400                 node->flags &= ~\hyperlink{cluster_8h_a2bbed8bf0615871a01ca8b7f691b56d8}{CLUSTER\_NODE\_NOADDR};
01401             \}
01402         \} \textcolor{keywordflow}{else} \{
01403             \textcolor{comment}{/* If it's not in NOADDR state and we don't have it, we}
01404 \textcolor{comment}{             * start a handshake process against this IP/PORT pairs.}
01405 \textcolor{comment}{             *}
01406 \textcolor{comment}{             * Note that we require that the sender of this gossip message}
01407 \textcolor{comment}{             * is a well known node in our cluster, otherwise we risk}
01408 \textcolor{comment}{             * joining another cluster. */}
01409             \textcolor{keywordflow}{if} (sender &&
01410                 !(flags & \hyperlink{cluster_8h_a2bbed8bf0615871a01ca8b7f691b56d8}{CLUSTER\_NODE\_NOADDR}) &&
01411                 !clusterBlacklistExists(g->nodename))
01412             \{
01413                 clusterStartHandshake(g->ip,ntohs(g->port),ntohs(g->cport));
01414             \}
01415         \}
01416 
01417         \textcolor{comment}{/* Next node */}
01418         g++;
01419     \}
01420 \}
01421 
01422 \textcolor{comment}{/* IP -> string conversion. 'buf' is supposed to at least be 46 bytes.}
01423 \textcolor{comment}{ * If 'announced\_ip' length is non-zero, it is used instead of extracting}
01424 \textcolor{comment}{ * the IP from the socket peer address. */}
01425 \textcolor{keywordtype}{void} nodeIp2String(\textcolor{keywordtype}{char} *buf, clusterLink *link, \textcolor{keywordtype}{char} *announced\_ip) \{
01426     \textcolor{keywordflow}{if} (announced\_ip[0] != \textcolor{stringliteral}{'\(\backslash\)0'}) \{
01427         memcpy(buf,announced\_ip,\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN});
01428         buf[\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN}-1] = \textcolor{stringliteral}{'\(\backslash\)0'}; \textcolor{comment}{/* We are not sure the input is sane. */}
01429     \} \textcolor{keywordflow}{else} \{
01430         anetPeerToString(link->fd, buf, \hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN}, NULL);
01431     \}
01432 \}
01433 
01434 \textcolor{comment}{/* Update the node address to the IP address that can be extracted}
01435 \textcolor{comment}{ * from link->fd, or if hdr->myip is non empty, to the address the node}
01436 \textcolor{comment}{ * is announcing us. The port is taken from the packet header as well.}
01437 \textcolor{comment}{ *}
01438 \textcolor{comment}{ * If the address or port changed, disconnect the node link so that we'll}
01439 \textcolor{comment}{ * connect again to the new address.}
01440 \textcolor{comment}{ *}
01441 \textcolor{comment}{ * If the ip/port pair are already correct no operation is performed at}
01442 \textcolor{comment}{ * all.}
01443 \textcolor{comment}{ *}
01444 \textcolor{comment}{ * The function returns 0 if the node address is still the same,}
01445 \textcolor{comment}{ * otherwise 1 is returned. */}
01446 \textcolor{keywordtype}{int} nodeUpdateAddressIfNeeded(clusterNode *node, clusterLink *link,
01447                               clusterMsg *hdr)
01448 \{
01449     \textcolor{keywordtype}{char} ip[\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN}] = \{0\};
01450     \textcolor{keywordtype}{int} port = ntohs(hdr->port);
01451     \textcolor{keywordtype}{int} cport = ntohs(hdr->cport);
01452 
01453     \textcolor{comment}{/* We don't proceed if the link is the same as the sender link, as this}
01454 \textcolor{comment}{     * function is designed to see if the node link is consistent with the}
01455 \textcolor{comment}{     * symmetric link that is used to receive PINGs from the node.}
01456 \textcolor{comment}{     *}
01457 \textcolor{comment}{     * As a side effect this function never frees the passed 'link', so}
01458 \textcolor{comment}{     * it is safe to call during packet processing. */}
01459     \textcolor{keywordflow}{if} (link == node->link) \textcolor{keywordflow}{return} 0;
01460 
01461     nodeIp2String(ip,link,hdr->myip);
01462     \textcolor{keywordflow}{if} (node->port == port && node->cport == cport &&
01463         strcmp(ip,node->ip) == 0) \textcolor{keywordflow}{return} 0;
01464 
01465     \textcolor{comment}{/* IP / port is different, update it. */}
01466     memcpy(node->ip,ip,\textcolor{keyword}{sizeof}(ip));
01467     node->port = port;
01468     node->cport = cport;
01469     \textcolor{keywordflow}{if} (node->link) freeClusterLink(node->link);
01470     node->flags &= ~\hyperlink{cluster_8h_a2bbed8bf0615871a01ca8b7f691b56d8}{CLUSTER\_NODE\_NOADDR};
01471     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Address updated for node %.40s, now %s:%d"},
01472         node->name, node->ip, node->port);
01473 
01474     \textcolor{comment}{/* Check if this is our master and we have to change the}
01475 \textcolor{comment}{     * replication target as well. */}
01476     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(myself) && myself->slaveof == node)
01477         replicationSetMaster(node->ip, node->port);
01478     \textcolor{keywordflow}{return} 1;
01479 \}
01480 
01481 \textcolor{comment}{/* Reconfigure the specified node 'n' as a master. This function is called when}
01482 \textcolor{comment}{ * a node that we believed to be a slave is now acting as master in order to}
01483 \textcolor{comment}{ * update the state of the node. */}
01484 \textcolor{keywordtype}{void} clusterSetNodeAsMaster(clusterNode *n) \{
01485     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(n)) \textcolor{keywordflow}{return};
01486 
01487     \textcolor{keywordflow}{if} (n->slaveof) \{
01488         clusterNodeRemoveSlave(n->slaveof,n);
01489         \textcolor{keywordflow}{if} (n != myself) n->flags |= \hyperlink{cluster_8h_a1d5a62356ed9f5986613c2315a358119}{CLUSTER\_NODE\_MIGRATE\_TO};
01490     \}
01491     n->flags &= ~\hyperlink{cluster_8h_a34b7bfd1f810397be68c3b5d13d4d134}{CLUSTER\_NODE\_SLAVE};
01492     n->flags |= \hyperlink{cluster_8h_a5dcea846e31b55b73244aa2e496a31bf}{CLUSTER\_NODE\_MASTER};
01493     n->slaveof = NULL;
01494 
01495     \textcolor{comment}{/* Update config and state. */}
01496     clusterDoBeforeSleep(\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG}|
01497                          \hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE});
01498 \}
01499 
01500 \textcolor{comment}{/* This function is called when we receive a master configuration via a}
01501 \textcolor{comment}{ * PING, PONG or UPDATE packet. What we receive is a node, a configEpoch of the}
01502 \textcolor{comment}{ * node, and the set of slots claimed under this configEpoch.}
01503 \textcolor{comment}{ *}
01504 \textcolor{comment}{ * What we do is to rebind the slots with newer configuration compared to our}
01505 \textcolor{comment}{ * local configuration, and if needed, we turn ourself into a replica of the}
01506 \textcolor{comment}{ * node (see the function comments for more info).}
01507 \textcolor{comment}{ *}
01508 \textcolor{comment}{ * The 'sender' is the node for which we received a configuration update.}
01509 \textcolor{comment}{ * Sometimes it is not actually the "Sender" of the information, like in the}
01510 \textcolor{comment}{ * case we receive the info via an UPDATE packet. */}
01511 \textcolor{keywordtype}{void} clusterUpdateSlotsConfigWith(clusterNode *sender, uint64\_t senderConfigEpoch, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *
      slots) \{
01512     \textcolor{keywordtype}{int} j;
01513     clusterNode *curmaster, *newmaster = NULL;
01514     \textcolor{comment}{/* The dirty slots list is a list of slots for which we lose the ownership}
01515 \textcolor{comment}{     * while having still keys inside. This usually happens after a failover}
01516 \textcolor{comment}{     * or after a manual cluster reconfiguration operated by the admin.}
01517 \textcolor{comment}{     *}
01518 \textcolor{comment}{     * If the update message is not able to demote a master to slave (in this}
01519 \textcolor{comment}{     * case we'll resync with the master updating the whole key space), we}
01520 \textcolor{comment}{     * need to delete all the keys in the slots we lost ownership. */}
01521     uint16\_t dirty\_slots[\hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}];
01522     \textcolor{keywordtype}{int} dirty\_slots\_count = 0;
01523 
01524     \textcolor{comment}{/* Here we set curmaster to this node or the node this node}
01525 \textcolor{comment}{     * replicates to if it's a slave. In the for loop we are}
01526 \textcolor{comment}{     * interested to check if slots are taken away from curmaster. */}
01527     curmaster = \hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(myself) ? myself : myself->slaveof;
01528 
01529     \textcolor{keywordflow}{if} (sender == myself) \{
01530         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Discarding UPDATE message about myself."});
01531         \textcolor{keywordflow}{return};
01532     \}
01533 
01534     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}; j++) \{
01535         \textcolor{keywordflow}{if} (bitmapTestBit(slots,j)) \{
01536             \textcolor{comment}{/* The slot is already bound to the sender of this message. */}
01537             \textcolor{keywordflow}{if} (server.cluster->slots[j] == sender) \textcolor{keywordflow}{continue};
01538 
01539             \textcolor{comment}{/* The slot is in importing state, it should be modified only}
01540 \textcolor{comment}{             * manually via redis-trib (example: a resharding is in progress}
01541 \textcolor{comment}{             * and the migrating side slot was already closed and is advertising}
01542 \textcolor{comment}{             * a new config. We still want the slot to be closed manually). */}
01543             \textcolor{keywordflow}{if} (server.cluster->importing\_slots\_from[j]) \textcolor{keywordflow}{continue};
01544 
01545             \textcolor{comment}{/* We rebind the slot to the new node claiming it if:}
01546 \textcolor{comment}{             * 1) The slot was unassigned or the new node claims it with a}
01547 \textcolor{comment}{             *    greater configEpoch.}
01548 \textcolor{comment}{             * 2) We are not currently importing the slot. */}
01549             \textcolor{keywordflow}{if} (server.cluster->slots[j] == NULL ||
01550                 server.cluster->slots[j]->configEpoch < senderConfigEpoch)
01551             \{
01552                 \textcolor{comment}{/* Was this slot mine, and still contains keys? Mark it as}
01553 \textcolor{comment}{                 * a dirty slot. */}
01554                 \textcolor{keywordflow}{if} (server.cluster->slots[j] == myself &&
01555                     countKeysInSlot(j) &&
01556                     sender != myself)
01557                 \{
01558                     dirty\_slots[dirty\_slots\_count] = j;
01559                     dirty\_slots\_count++;
01560                 \}
01561 
01562                 \textcolor{keywordflow}{if} (server.cluster->slots[j] == curmaster)
01563                     newmaster = sender;
01564                 clusterDelSlot(j);
01565                 clusterAddSlot(sender,j);
01566                 clusterDoBeforeSleep(\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG}|
01567                                      \hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE}|
01568                                      \hyperlink{cluster_8h_accc9a00230cd04789db2398bb3ab715a}{CLUSTER\_TODO\_FSYNC\_CONFIG});
01569             \}
01570         \}
01571     \}
01572 
01573     \textcolor{comment}{/* If at least one slot was reassigned from a node to another node}
01574 \textcolor{comment}{     * with a greater configEpoch, it is possible that:}
01575 \textcolor{comment}{     * 1) We are a master left without slots. This means that we were}
01576 \textcolor{comment}{     *    failed over and we should turn into a replica of the new}
01577 \textcolor{comment}{     *    master.}
01578 \textcolor{comment}{     * 2) We are a slave and our master is left without slots. We need}
01579 \textcolor{comment}{     *    to replicate to the new slots owner. */}
01580     \textcolor{keywordflow}{if} (newmaster && curmaster->numslots == 0) \{
01581         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01582             \textcolor{stringliteral}{"Configuration change detected. Reconfiguring myself "}
01583             \textcolor{stringliteral}{"as a replica of %.40s"}, sender->name);
01584         clusterSetMaster(sender);
01585         clusterDoBeforeSleep(\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG}|
01586                              \hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE}|
01587                              \hyperlink{cluster_8h_accc9a00230cd04789db2398bb3ab715a}{CLUSTER\_TODO\_FSYNC\_CONFIG});
01588     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (dirty\_slots\_count) \{
01589         \textcolor{comment}{/* If we are here, we received an update message which removed}
01590 \textcolor{comment}{         * ownership for certain slots we still have keys about, but still}
01591 \textcolor{comment}{         * we are serving some slots, so this master node was not demoted to}
01592 \textcolor{comment}{         * a slave.}
01593 \textcolor{comment}{         *}
01594 \textcolor{comment}{         * In order to maintain a consistent state between keys and slots}
01595 \textcolor{comment}{         * we need to remove all the keys from the slots we lost. */}
01596         \textcolor{keywordflow}{for} (j = 0; j < dirty\_slots\_count; j++)
01597             delKeysInSlot(dirty\_slots[j]);
01598     \}
01599 \}
01600 
01601 \textcolor{comment}{/* When this function is called, there is a packet to process starting}
01602 \textcolor{comment}{ * at node->rcvbuf. Releasing the buffer is up to the caller, so this}
01603 \textcolor{comment}{ * function should just handle the higher level stuff of processing the}
01604 \textcolor{comment}{ * packet, modifying the cluster state if needed.}
01605 \textcolor{comment}{ *}
01606 \textcolor{comment}{ * The function returns 1 if the link is still valid after the packet}
01607 \textcolor{comment}{ * was processed, otherwise 0 if the link was freed since the packet}
01608 \textcolor{comment}{ * processing lead to some inconsistency error (for instance a PONG}
01609 \textcolor{comment}{ * received from the wrong sender ID). */}
01610 \textcolor{keywordtype}{int} clusterProcessPacket(clusterLink *link) \{
01611     clusterMsg *hdr = (clusterMsg*) link->rcvbuf;
01612     uint32\_t totlen = ntohl(hdr->totlen);
01613     uint16\_t type = ntohs(hdr->type);
01614 
01615     \textcolor{keywordflow}{if} (type < \hyperlink{cluster_8h_a6222c464c1f2125f42271d2abd63853e}{CLUSTERMSG\_TYPE\_COUNT})
01616         server.cluster->stats\_bus\_messages\_received[type]++;
01617     serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG},\textcolor{stringliteral}{"--- Processing packet of type %d, %lu bytes"},
01618         type, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}) totlen);
01619 
01620     \textcolor{comment}{/* Perform sanity checks */}
01621     \textcolor{keywordflow}{if} (totlen < 16) \textcolor{keywordflow}{return} 1; \textcolor{comment}{/* At least signature, version, totlen, count. */}
01622     \textcolor{keywordflow}{if} (totlen > sdslen(link->rcvbuf)) \textcolor{keywordflow}{return} 1;
01623 
01624     \textcolor{keywordflow}{if} (ntohs(hdr->ver) != \hyperlink{cluster_8h_ad93688d5eca033b109b1a00bfb03cebe}{CLUSTER\_PROTO\_VER}) \{
01625         \textcolor{comment}{/* Can't handle messages of different versions. */}
01626         \textcolor{keywordflow}{return} 1;
01627     \}
01628 
01629     uint16\_t flags = ntohs(hdr->flags);
01630     uint64\_t senderCurrentEpoch = 0, senderConfigEpoch = 0;
01631     clusterNode *sender;
01632 
01633     \textcolor{keywordflow}{if} (type == \hyperlink{cluster_8h_aeb8a936505e22f64e5039523a3c96d4c}{CLUSTERMSG\_TYPE\_PING} || type == 
      \hyperlink{cluster_8h_a33e9439f462f28177a31dfc74de0c16b}{CLUSTERMSG\_TYPE\_PONG} ||
01634         type == \hyperlink{cluster_8h_aaf264f57ae1869c57093fd9fbc6fc5bc}{CLUSTERMSG\_TYPE\_MEET})
01635     \{
01636         uint16\_t count = ntohs(hdr->count);
01637         uint32\_t explen; \textcolor{comment}{/* expected length of this packet */}
01638 
01639         explen = \textcolor{keyword}{sizeof}(clusterMsg)-\textcolor{keyword}{sizeof}(\textcolor{keyword}{union} \hyperlink{unionclusterMsgData}{clusterMsgData});
01640         explen += (\textcolor{keyword}{sizeof}(clusterMsgDataGossip)*count);
01641         \textcolor{keywordflow}{if} (totlen != explen) \textcolor{keywordflow}{return} 1;
01642     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == \hyperlink{cluster_8h_af5d51e3ad9965074b2124aabe1895d59}{CLUSTERMSG\_TYPE\_FAIL}) \{
01643         uint32\_t explen = \textcolor{keyword}{sizeof}(clusterMsg)-\textcolor{keyword}{sizeof}(\textcolor{keyword}{union} \hyperlink{unionclusterMsgData}{clusterMsgData});
01644 
01645         explen += \textcolor{keyword}{sizeof}(clusterMsgDataFail);
01646         \textcolor{keywordflow}{if} (totlen != explen) \textcolor{keywordflow}{return} 1;
01647     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == \hyperlink{cluster_8h_a874fecfd3ff886c2c697f5649ebee5ee}{CLUSTERMSG\_TYPE\_PUBLISH}) \{
01648         uint32\_t explen = \textcolor{keyword}{sizeof}(clusterMsg)-\textcolor{keyword}{sizeof}(\textcolor{keyword}{union} \hyperlink{unionclusterMsgData}{clusterMsgData});
01649 
01650         explen += \textcolor{keyword}{sizeof}(clusterMsgDataPublish) -
01651                 8 +
01652                 ntohl(hdr->data.publish.msg.channel\_len) +
01653                 ntohl(hdr->data.publish.msg.message\_len);
01654         \textcolor{keywordflow}{if} (totlen != explen) \textcolor{keywordflow}{return} 1;
01655     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == \hyperlink{cluster_8h_a739009308ed4cb5b19630a5f872408d2}{CLUSTERMSG\_TYPE\_FAILOVER\_AUTH\_REQUEST} ||
01656                type == \hyperlink{cluster_8h_ae0db3a998d7da521c5359bdd8708f5f6}{CLUSTERMSG\_TYPE\_FAILOVER\_AUTH\_ACK} ||
01657                type == \hyperlink{cluster_8h_aa875273b4b11ae73d3cd3a8aea4ddcba}{CLUSTERMSG\_TYPE\_MFSTART})
01658     \{
01659         uint32\_t explen = \textcolor{keyword}{sizeof}(clusterMsg)-\textcolor{keyword}{sizeof}(\textcolor{keyword}{union} \hyperlink{unionclusterMsgData}{clusterMsgData});
01660 
01661         \textcolor{keywordflow}{if} (totlen != explen) \textcolor{keywordflow}{return} 1;
01662     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == \hyperlink{cluster_8h_a51dc58bb78128fcae1751d654130ec0f}{CLUSTERMSG\_TYPE\_UPDATE}) \{
01663         uint32\_t explen = \textcolor{keyword}{sizeof}(clusterMsg)-\textcolor{keyword}{sizeof}(\textcolor{keyword}{union} \hyperlink{unionclusterMsgData}{clusterMsgData});
01664 
01665         explen += \textcolor{keyword}{sizeof}(clusterMsgDataUpdate);
01666         \textcolor{keywordflow}{if} (totlen != explen) \textcolor{keywordflow}{return} 1;
01667     \}
01668 
01669     \textcolor{comment}{/* Check if the sender is a known node. */}
01670     sender = clusterLookupNode(hdr->sender);
01671     \textcolor{keywordflow}{if} (sender && !\hyperlink{cluster_8h_a70f1a5bb82f54ce5d17b13de42176790}{nodeInHandshake}(sender)) \{
01672         \textcolor{comment}{/* Update our curretEpoch if we see a newer epoch in the cluster. */}
01673         senderCurrentEpoch = \hyperlink{endianconv_8h_ab6e7416a2faac85cd6d50180e7348a1b}{ntohu64}(hdr->currentEpoch);
01674         senderConfigEpoch = \hyperlink{endianconv_8h_ab6e7416a2faac85cd6d50180e7348a1b}{ntohu64}(hdr->configEpoch);
01675         \textcolor{keywordflow}{if} (senderCurrentEpoch > server.cluster->currentEpoch)
01676             server.cluster->currentEpoch = senderCurrentEpoch;
01677         \textcolor{comment}{/* Update the sender configEpoch if it is publishing a newer one. */}
01678         \textcolor{keywordflow}{if} (senderConfigEpoch > sender->configEpoch) \{
01679             sender->configEpoch = senderConfigEpoch;
01680             clusterDoBeforeSleep(\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG}|
01681                                  \hyperlink{cluster_8h_accc9a00230cd04789db2398bb3ab715a}{CLUSTER\_TODO\_FSYNC\_CONFIG});
01682         \}
01683         \textcolor{comment}{/* Update the replication offset info for this node. */}
01684         sender->repl\_offset = \hyperlink{endianconv_8h_ab6e7416a2faac85cd6d50180e7348a1b}{ntohu64}(hdr->offset);
01685         sender->repl\_offset\_time = mstime();
01686         \textcolor{comment}{/* If we are a slave performing a manual failover and our master}
01687 \textcolor{comment}{         * sent its offset while already paused, populate the MF state. */}
01688         \textcolor{keywordflow}{if} (server.cluster->mf\_end &&
01689             \hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(myself) &&
01690             myself->slaveof == sender &&
01691             hdr->mflags[0] & \hyperlink{cluster_8h_aa7da3a662e6241de4f004fa1a4519cf2}{CLUSTERMSG\_FLAG0\_PAUSED} &&
01692             server.cluster->mf\_master\_offset == 0)
01693         \{
01694             server.cluster->mf\_master\_offset = sender->repl\_offset;
01695             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
01696                 \textcolor{stringliteral}{"Received replication offset for paused "}
01697                 \textcolor{stringliteral}{"master manual failover: %lld"},
01698                 server.cluster->mf\_master\_offset);
01699         \}
01700     \}
01701 
01702     \textcolor{comment}{/* Initial processing of PING and MEET requests replying with a PONG. */}
01703     \textcolor{keywordflow}{if} (type == \hyperlink{cluster_8h_aeb8a936505e22f64e5039523a3c96d4c}{CLUSTERMSG\_TYPE\_PING} || type == 
      \hyperlink{cluster_8h_aaf264f57ae1869c57093fd9fbc6fc5bc}{CLUSTERMSG\_TYPE\_MEET}) \{
01704         serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG},\textcolor{stringliteral}{"Ping packet received: %p"}, (\textcolor{keywordtype}{void}*)link->node);
01705 
01706         \textcolor{comment}{/* We use incoming MEET messages in order to set the address}
01707 \textcolor{comment}{         * for 'myself', since only other cluster nodes will send us}
01708 \textcolor{comment}{         * MEET messages on handshakes, when the cluster joins, or}
01709 \textcolor{comment}{         * later if we changed address, and those nodes will use our}
01710 \textcolor{comment}{         * official address to connect to us. So by obtaining this address}
01711 \textcolor{comment}{         * from the socket is a simple way to discover / update our own}
01712 \textcolor{comment}{         * address in the cluster without it being hardcoded in the config.}
01713 \textcolor{comment}{         *}
01714 \textcolor{comment}{         * However if we don't have an address at all, we update the address}
01715 \textcolor{comment}{         * even with a normal PING packet. If it's wrong it will be fixed}
01716 \textcolor{comment}{         * by MEET later. */}
01717         \textcolor{keywordflow}{if} ((type == \hyperlink{cluster_8h_aaf264f57ae1869c57093fd9fbc6fc5bc}{CLUSTERMSG\_TYPE\_MEET} || myself->ip[0] == \textcolor{stringliteral}{'\(\backslash\)0'}) &&
01718             server.cluster\_announce\_ip == NULL)
01719         \{
01720             \textcolor{keywordtype}{char} ip[\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN}];
01721 
01722             \textcolor{keywordflow}{if} (anetSockName(link->fd,ip,\textcolor{keyword}{sizeof}(ip),NULL) != -1 &&
01723                 strcmp(ip,myself->ip))
01724             \{
01725                 memcpy(myself->ip,ip,\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN});
01726                 serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"IP address for this node updated to %s"},
01727                     myself->ip);
01728                 clusterDoBeforeSleep(\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG});
01729             \}
01730         \}
01731 
01732         \textcolor{comment}{/* Add this node if it is new for us and the msg type is MEET.}
01733 \textcolor{comment}{         * In this stage we don't try to add the node with the right}
01734 \textcolor{comment}{         * flags, slaveof pointer, and so forth, as this details will be}
01735 \textcolor{comment}{         * resolved when we'll receive PONGs from the node. */}
01736         \textcolor{keywordflow}{if} (!sender && type == \hyperlink{cluster_8h_aaf264f57ae1869c57093fd9fbc6fc5bc}{CLUSTERMSG\_TYPE\_MEET}) \{
01737             clusterNode *node;
01738 
01739             node = createClusterNode(NULL,\hyperlink{cluster_8h_a60571342a067f1e5772a04b36feff6a6}{CLUSTER\_NODE\_HANDSHAKE});
01740             nodeIp2String(node->ip,link,hdr->myip);
01741             node->port = ntohs(hdr->port);
01742             node->cport = ntohs(hdr->cport);
01743             clusterAddNode(node);
01744             clusterDoBeforeSleep(\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG});
01745         \}
01746 
01747         \textcolor{comment}{/* If this is a MEET packet from an unknown node, we still process}
01748 \textcolor{comment}{         * the gossip section here since we have to trust the sender because}
01749 \textcolor{comment}{         * of the message type. */}
01750         \textcolor{keywordflow}{if} (!sender && type == \hyperlink{cluster_8h_aaf264f57ae1869c57093fd9fbc6fc5bc}{CLUSTERMSG\_TYPE\_MEET})
01751             clusterProcessGossipSection(hdr,link);
01752 
01753         \textcolor{comment}{/* Anyway reply with a PONG */}
01754         clusterSendPing(link,\hyperlink{cluster_8h_a33e9439f462f28177a31dfc74de0c16b}{CLUSTERMSG\_TYPE\_PONG});
01755     \}
01756 
01757     \textcolor{comment}{/* PING, PONG, MEET: process config information. */}
01758     \textcolor{keywordflow}{if} (type == \hyperlink{cluster_8h_aeb8a936505e22f64e5039523a3c96d4c}{CLUSTERMSG\_TYPE\_PING} || type == 
      \hyperlink{cluster_8h_a33e9439f462f28177a31dfc74de0c16b}{CLUSTERMSG\_TYPE\_PONG} ||
01759         type == \hyperlink{cluster_8h_aaf264f57ae1869c57093fd9fbc6fc5bc}{CLUSTERMSG\_TYPE\_MEET})
01760     \{
01761         serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG},\textcolor{stringliteral}{"%s packet received: %p"},
01762             type == \hyperlink{cluster_8h_aeb8a936505e22f64e5039523a3c96d4c}{CLUSTERMSG\_TYPE\_PING} ? \textcolor{stringliteral}{"ping"} : \textcolor{stringliteral}{"pong"},
01763             (\textcolor{keywordtype}{void}*)link->node);
01764         \textcolor{keywordflow}{if} (link->node) \{
01765             \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a70f1a5bb82f54ce5d17b13de42176790}{nodeInHandshake}(link->node)) \{
01766                 \textcolor{comment}{/* If we already have this node, try to change the}
01767 \textcolor{comment}{                 * IP/port of the node with the new one. */}
01768                 \textcolor{keywordflow}{if} (sender) \{
01769                     serverLog(\hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE},
01770                         \textcolor{stringliteral}{"Handshake: we already know node %.40s, "}
01771                         \textcolor{stringliteral}{"updating the address if needed."}, sender->name);
01772                     \textcolor{keywordflow}{if} (nodeUpdateAddressIfNeeded(sender,link,hdr))
01773                     \{
01774                         clusterDoBeforeSleep(\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG}|
01775                                              \hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE});
01776                     \}
01777                     \textcolor{comment}{/* Free this node as we already have it. This will}
01778 \textcolor{comment}{                     * cause the link to be freed as well. */}
01779                     clusterDelNode(link->node);
01780                     \textcolor{keywordflow}{return} 0;
01781                 \}
01782 
01783                 \textcolor{comment}{/* First thing to do is replacing the random name with the}
01784 \textcolor{comment}{                 * right node name if this was a handshake stage. */}
01785                 clusterRenameNode(link->node, hdr->sender);
01786                 serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG},\textcolor{stringliteral}{"Handshake with node %.40s completed."},
01787                     link->node->name);
01788                 link->node->flags &= ~\hyperlink{cluster_8h_a60571342a067f1e5772a04b36feff6a6}{CLUSTER\_NODE\_HANDSHAKE};
01789                 link->node->flags |= flags&(\hyperlink{cluster_8h_a5dcea846e31b55b73244aa2e496a31bf}{CLUSTER\_NODE\_MASTER}|
      \hyperlink{cluster_8h_a34b7bfd1f810397be68c3b5d13d4d134}{CLUSTER\_NODE\_SLAVE});
01790                 clusterDoBeforeSleep(\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG});
01791             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (memcmp(link->node->name,hdr->sender,
01792                         \hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN}) != 0)
01793             \{
01794                 \textcolor{comment}{/* If the reply has a non matching node ID we}
01795 \textcolor{comment}{                 * disconnect this node and set it as not having an associated}
01796 \textcolor{comment}{                 * address. */}
01797                 serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG},\textcolor{stringliteral}{"PONG contains mismatching sender ID. About node %.40s
       added %d ms ago, having flags %d"},
01798                     link->node->name,
01799                     (\textcolor{keywordtype}{int})(mstime()-(link->node->ctime)),
01800                     link->node->flags);
01801                 link->node->flags |= \hyperlink{cluster_8h_a2bbed8bf0615871a01ca8b7f691b56d8}{CLUSTER\_NODE\_NOADDR};
01802                 link->node->ip[0] = \textcolor{stringliteral}{'\(\backslash\)0'};
01803                 link->node->port = 0;
01804                 link->node->cport = 0;
01805                 freeClusterLink(link);
01806                 clusterDoBeforeSleep(\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG});
01807                 \textcolor{keywordflow}{return} 0;
01808             \}
01809         \}
01810 
01811         \textcolor{comment}{/* Update the node address if it changed. */}
01812         \textcolor{keywordflow}{if} (sender && type == \hyperlink{cluster_8h_aeb8a936505e22f64e5039523a3c96d4c}{CLUSTERMSG\_TYPE\_PING} &&
01813             !\hyperlink{cluster_8h_a70f1a5bb82f54ce5d17b13de42176790}{nodeInHandshake}(sender) &&
01814             nodeUpdateAddressIfNeeded(sender,link,hdr))
01815         \{
01816             clusterDoBeforeSleep(\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG}|
01817                                  \hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE});
01818         \}
01819 
01820         \textcolor{comment}{/* Update our info about the node */}
01821         \textcolor{keywordflow}{if} (link->node && type == \hyperlink{cluster_8h_a33e9439f462f28177a31dfc74de0c16b}{CLUSTERMSG\_TYPE\_PONG}) \{
01822             link->node->pong\_received = mstime();
01823             link->node->ping\_sent = 0;
01824 
01825             \textcolor{comment}{/* The PFAIL condition can be reversed without external}
01826 \textcolor{comment}{             * help if it is momentary (that is, if it does not}
01827 \textcolor{comment}{             * turn into a FAIL state).}
01828 \textcolor{comment}{             *}
01829 \textcolor{comment}{             * The FAIL condition is also reversible under specific}
01830 \textcolor{comment}{             * conditions detected by clearNodeFailureIfNeeded(). */}
01831             \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_ac0ab1cbdbc2a49b30c98d73640476e32}{nodeTimedOut}(link->node)) \{
01832                 link->node->flags &= ~\hyperlink{cluster_8h_a5306c1ae8988b8be0a1a02bd9162dfa1}{CLUSTER\_NODE\_PFAIL};
01833                 clusterDoBeforeSleep(\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG}|
01834                                      \hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE});
01835             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a6a31c614ff4f5ac8ebaa630b0a921c3d}{nodeFailed}(link->node)) \{
01836                 clearNodeFailureIfNeeded(link->node);
01837             \}
01838         \}
01839 
01840         \textcolor{comment}{/* Check for role switch: slave -> master or master -> slave. */}
01841         \textcolor{keywordflow}{if} (sender) \{
01842             \textcolor{keywordflow}{if} (!memcmp(hdr->slaveof,\hyperlink{cluster_8h_ac8300cbcbca7ec5ef6a3afde258204e6}{CLUSTER\_NODE\_NULL\_NAME},
01843                 \textcolor{keyword}{sizeof}(hdr->slaveof)))
01844             \{
01845                 \textcolor{comment}{/* Node is a master. */}
01846                 clusterSetNodeAsMaster(sender);
01847             \} \textcolor{keywordflow}{else} \{
01848                 \textcolor{comment}{/* Node is a slave. */}
01849                 clusterNode *master = clusterLookupNode(hdr->slaveof);
01850 
01851                 \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(sender)) \{
01852                     \textcolor{comment}{/* Master turned into a slave! Reconfigure the node. */}
01853                     clusterDelNodeSlots(sender);
01854                     sender->flags &= ~(\hyperlink{cluster_8h_a5dcea846e31b55b73244aa2e496a31bf}{CLUSTER\_NODE\_MASTER}|
01855                                        \hyperlink{cluster_8h_a1d5a62356ed9f5986613c2315a358119}{CLUSTER\_NODE\_MIGRATE\_TO});
01856                     sender->flags |= \hyperlink{cluster_8h_a34b7bfd1f810397be68c3b5d13d4d134}{CLUSTER\_NODE\_SLAVE};
01857 
01858                     \textcolor{comment}{/* Update config and state. */}
01859                     clusterDoBeforeSleep(\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG}|
01860                                          \hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE});
01861                 \}
01862 
01863                 \textcolor{comment}{/* Master node changed for this slave? */}
01864                 \textcolor{keywordflow}{if} (master && sender->slaveof != master) \{
01865                     \textcolor{keywordflow}{if} (sender->slaveof)
01866                         clusterNodeRemoveSlave(sender->slaveof,sender);
01867                     clusterNodeAddSlave(master,sender);
01868                     sender->slaveof = master;
01869 
01870                     \textcolor{comment}{/* Update config. */}
01871                     clusterDoBeforeSleep(\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG});
01872                 \}
01873             \}
01874         \}
01875 
01876         \textcolor{comment}{/* Update our info about served slots.}
01877 \textcolor{comment}{         *}
01878 \textcolor{comment}{         * Note: this MUST happen after we update the master/slave state}
01879 \textcolor{comment}{         * so that CLUSTER\_NODE\_MASTER flag will be set. */}
01880 
01881         \textcolor{comment}{/* Many checks are only needed if the set of served slots this}
01882 \textcolor{comment}{         * instance claims is different compared to the set of slots we have}
01883 \textcolor{comment}{         * for it. Check this ASAP to avoid other computational expansive}
01884 \textcolor{comment}{         * checks later. */}
01885         clusterNode *sender\_master = NULL; \textcolor{comment}{/* Sender or its master if slave. */}
01886         \textcolor{keywordtype}{int} dirty\_slots = 0; \textcolor{comment}{/* Sender claimed slots don't match my view? */}
01887 
01888         \textcolor{keywordflow}{if} (sender) \{
01889             sender\_master = \hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(sender) ? sender : sender->slaveof;
01890             \textcolor{keywordflow}{if} (sender\_master) \{
01891                 dirty\_slots = memcmp(sender\_master->slots,
01892                         hdr->myslots,\textcolor{keyword}{sizeof}(hdr->myslots)) != 0;
01893             \}
01894         \}
01895 
01896         \textcolor{comment}{/* 1) If the sender of the message is a master, and we detected that}
01897 \textcolor{comment}{         *    the set of slots it claims changed, scan the slots to see if we}
01898 \textcolor{comment}{         *    need to update our configuration. */}
01899         \textcolor{keywordflow}{if} (sender && \hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(sender) && dirty\_slots)
01900             clusterUpdateSlotsConfigWith(sender,senderConfigEpoch,hdr->myslots);
01901 
01902         \textcolor{comment}{/* 2) We also check for the reverse condition, that is, the sender}
01903 \textcolor{comment}{         *    claims to serve slots we know are served by a master with a}
01904 \textcolor{comment}{         *    greater configEpoch. If this happens we inform the sender.}
01905 \textcolor{comment}{         *}
01906 \textcolor{comment}{         * This is useful because sometimes after a partition heals, a}
01907 \textcolor{comment}{         * reappearing master may be the last one to claim a given set of}
01908 \textcolor{comment}{         * hash slots, but with a configuration that other instances know to}
01909 \textcolor{comment}{         * be deprecated. Example:}
01910 \textcolor{comment}{         *}
01911 \textcolor{comment}{         * A and B are master and slave for slots 1,2,3.}
01912 \textcolor{comment}{         * A is partitioned away, B gets promoted.}
01913 \textcolor{comment}{         * B is partitioned away, and A returns available.}
01914 \textcolor{comment}{         *}
01915 \textcolor{comment}{         * Usually B would PING A publishing its set of served slots and its}
01916 \textcolor{comment}{         * configEpoch, but because of the partition B can't inform A of the}
01917 \textcolor{comment}{         * new configuration, so other nodes that have an updated table must}
01918 \textcolor{comment}{         * do it. In this way A will stop to act as a master (or can try to}
01919 \textcolor{comment}{         * failover if there are the conditions to win the election). */}
01920         \textcolor{keywordflow}{if} (sender && dirty\_slots) \{
01921             \textcolor{keywordtype}{int} j;
01922 
01923             \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}; j++) \{
01924                 \textcolor{keywordflow}{if} (bitmapTestBit(hdr->myslots,j)) \{
01925                     \textcolor{keywordflow}{if} (server.cluster->slots[j] == sender ||
01926                         server.cluster->slots[j] == NULL) \textcolor{keywordflow}{continue};
01927                     \textcolor{keywordflow}{if} (server.cluster->slots[j]->configEpoch >
01928                         senderConfigEpoch)
01929                     \{
01930                         serverLog(\hyperlink{server_8h_a479b60032f8da6d8ad72e1a9d0809950}{LL\_VERBOSE},
01931                             \textcolor{stringliteral}{"Node %.40s has old slots configuration, sending "}
01932                             \textcolor{stringliteral}{"an UPDATE message about %.40s"},
01933                                 sender->name, server.cluster->slots[j]->name);
01934                         clusterSendUpdate(sender->link,
01935                             server.cluster->slots[j]);
01936 
01937                         \textcolor{comment}{/* TODO: instead of exiting the loop send every other}
01938 \textcolor{comment}{                         * UPDATE packet for other nodes that are the new owner}
01939 \textcolor{comment}{                         * of sender's slots. */}
01940                         \textcolor{keywordflow}{break};
01941                     \}
01942                 \}
01943             \}
01944         \}
01945 
01946         \textcolor{comment}{/* If our config epoch collides with the sender's try to fix}
01947 \textcolor{comment}{         * the problem. */}
01948         \textcolor{keywordflow}{if} (sender &&
01949             \hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(myself) && \hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(sender) &&
01950             senderConfigEpoch == myself->configEpoch)
01951         \{
01952             clusterHandleConfigEpochCollision(sender);
01953         \}
01954 
01955         \textcolor{comment}{/* Get info from the gossip section */}
01956         \textcolor{keywordflow}{if} (sender) clusterProcessGossipSection(hdr,link);
01957     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == \hyperlink{cluster_8h_af5d51e3ad9965074b2124aabe1895d59}{CLUSTERMSG\_TYPE\_FAIL}) \{
01958         clusterNode *failing;
01959 
01960         \textcolor{keywordflow}{if} (sender) \{
01961             failing = clusterLookupNode(hdr->data.fail.about.nodename);
01962             \textcolor{keywordflow}{if} (failing &&
01963                 !(failing->flags & (\hyperlink{cluster_8h_ad211e85c7baf8a5a59acd747e4e9005a}{CLUSTER\_NODE\_FAIL}|
      \hyperlink{cluster_8h_afee946c4e74c08465e9b4ead5e3659e6}{CLUSTER\_NODE\_MYSELF})))
01964             \{
01965                 serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01966                     \textcolor{stringliteral}{"FAIL message received from %.40s about %.40s"},
01967                     hdr->sender, hdr->data.fail.about.nodename);
01968                 failing->flags |= \hyperlink{cluster_8h_ad211e85c7baf8a5a59acd747e4e9005a}{CLUSTER\_NODE\_FAIL};
01969                 failing->fail\_time = mstime();
01970                 failing->flags &= ~\hyperlink{cluster_8h_a5306c1ae8988b8be0a1a02bd9162dfa1}{CLUSTER\_NODE\_PFAIL};
01971                 clusterDoBeforeSleep(\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG}|
01972                                      \hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE});
01973             \}
01974         \} \textcolor{keywordflow}{else} \{
01975             serverLog(\hyperlink{server_8h_a8c54c191e436c7dd3012167212692401}{LL\_NOTICE},
01976                 \textcolor{stringliteral}{"Ignoring FAIL message from unknown node %.40s about %.40s"},
01977                 hdr->sender, hdr->data.fail.about.nodename);
01978         \}
01979     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == \hyperlink{cluster_8h_a874fecfd3ff886c2c697f5649ebee5ee}{CLUSTERMSG\_TYPE\_PUBLISH}) \{
01980         robj *channel, *message;
01981         uint32\_t channel\_len, message\_len;
01982 
01983         \textcolor{comment}{/* Don't bother creating useless objects if there are no}
01984 \textcolor{comment}{         * Pub/Sub subscribers. */}
01985         \textcolor{keywordflow}{if} (\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.pubsub\_channels) ||
01986            \hyperlink{adlist_8h_afde0ab079f934670e82119b43120e94b}{listLength}(server.pubsub\_patterns))
01987         \{
01988             channel\_len = ntohl(hdr->data.publish.msg.channel\_len);
01989             message\_len = ntohl(hdr->data.publish.msg.message\_len);
01990             channel = createStringObject(
01991                         (\textcolor{keywordtype}{char}*)hdr->data.publish.msg.bulk\_data,channel\_len);
01992             message = createStringObject(
01993                         (\textcolor{keywordtype}{char}*)hdr->data.publish.msg.bulk\_data+channel\_len,
01994                         message\_len);
01995             pubsubPublishMessage(channel,message);
01996             decrRefCount(channel);
01997             decrRefCount(message);
01998         \}
01999     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == \hyperlink{cluster_8h_a739009308ed4cb5b19630a5f872408d2}{CLUSTERMSG\_TYPE\_FAILOVER\_AUTH\_REQUEST}) \{
02000         \textcolor{keywordflow}{if} (!sender) \textcolor{keywordflow}{return} 1;  \textcolor{comment}{/* We don't know that node. */}
02001         clusterSendFailoverAuthIfNeeded(sender,hdr);
02002     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == \hyperlink{cluster_8h_ae0db3a998d7da521c5359bdd8708f5f6}{CLUSTERMSG\_TYPE\_FAILOVER\_AUTH\_ACK}) \{
02003         \textcolor{keywordflow}{if} (!sender) \textcolor{keywordflow}{return} 1;  \textcolor{comment}{/* We don't know that node. */}
02004         \textcolor{comment}{/* We consider this vote only if the sender is a master serving}
02005 \textcolor{comment}{         * a non zero number of slots, and its currentEpoch is greater or}
02006 \textcolor{comment}{         * equal to epoch where this node started the election. */}
02007         \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(sender) && sender->numslots > 0 &&
02008             senderCurrentEpoch >= server.cluster->failover\_auth\_epoch)
02009         \{
02010             server.cluster->failover\_auth\_count++;
02011             \textcolor{comment}{/* Maybe we reached a quorum here, set a flag to make sure}
02012 \textcolor{comment}{             * we check ASAP. */}
02013             clusterDoBeforeSleep(\hyperlink{cluster_8h_afb969dfe84cf59e2340ed10cbf334a47}{CLUSTER\_TODO\_HANDLE\_FAILOVER});
02014         \}
02015     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == \hyperlink{cluster_8h_aa875273b4b11ae73d3cd3a8aea4ddcba}{CLUSTERMSG\_TYPE\_MFSTART}) \{
02016         \textcolor{comment}{/* This message is acceptable only if I'm a master and the sender}
02017 \textcolor{comment}{         * is one of my slaves. */}
02018         \textcolor{keywordflow}{if} (!sender || sender->slaveof != myself) \textcolor{keywordflow}{return} 1;
02019         \textcolor{comment}{/* Manual failover requested from slaves. Initialize the state}
02020 \textcolor{comment}{         * accordingly. */}
02021         resetManualFailover();
02022         server.cluster->mf\_end = mstime() + \hyperlink{cluster_8h_a869ee97118edc95fc7ba2abe472ef79e}{CLUSTER\_MF\_TIMEOUT};
02023         server.cluster->mf\_slave = sender;
02024         pauseClients(mstime()+(\hyperlink{cluster_8h_a869ee97118edc95fc7ba2abe472ef79e}{CLUSTER\_MF\_TIMEOUT}*2));
02025         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Manual failover requested by slave %.40s."},
02026             sender->name);
02027     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == \hyperlink{cluster_8h_a51dc58bb78128fcae1751d654130ec0f}{CLUSTERMSG\_TYPE\_UPDATE}) \{
02028         clusterNode *n; \textcolor{comment}{/* The node the update is about. */}
02029         uint64\_t reportedConfigEpoch =
02030                     \hyperlink{endianconv_8h_ab6e7416a2faac85cd6d50180e7348a1b}{ntohu64}(hdr->data.update.nodecfg.configEpoch);
02031 
02032         \textcolor{keywordflow}{if} (!sender) \textcolor{keywordflow}{return} 1;  \textcolor{comment}{/* We don't know the sender. */}
02033         n = clusterLookupNode(hdr->data.update.nodecfg.nodename);
02034         \textcolor{keywordflow}{if} (!n) \textcolor{keywordflow}{return} 1;   \textcolor{comment}{/* We don't know the reported node. */}
02035         \textcolor{keywordflow}{if} (n->configEpoch >= reportedConfigEpoch) \textcolor{keywordflow}{return} 1; \textcolor{comment}{/* Nothing new. */}
02036 
02037         \textcolor{comment}{/* If in our current config the node is a slave, set it as a master. */}
02038         \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(n)) clusterSetNodeAsMaster(n);
02039 
02040         \textcolor{comment}{/* Update the node's configEpoch. */}
02041         n->configEpoch = reportedConfigEpoch;
02042         clusterDoBeforeSleep(\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG}|
02043                              \hyperlink{cluster_8h_accc9a00230cd04789db2398bb3ab715a}{CLUSTER\_TODO\_FSYNC\_CONFIG});
02044 
02045         \textcolor{comment}{/* Check the bitmap of served slots and update our}
02046 \textcolor{comment}{         * config accordingly. */}
02047         clusterUpdateSlotsConfigWith(n,reportedConfigEpoch,
02048             hdr->data.update.nodecfg.slots);
02049     \} \textcolor{keywordflow}{else} \{
02050         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Received unknown packet type: %d"}, type);
02051     \}
02052     \textcolor{keywordflow}{return} 1;
02053 \}
02054 
02055 \textcolor{comment}{/* This function is called when we detect the link with this node is lost.}
02056 \textcolor{comment}{   We set the node as no longer connected. The Cluster Cron will detect}
02057 \textcolor{comment}{   this connection and will try to get it connected again.}
02058 \textcolor{comment}{}
02059 \textcolor{comment}{   Instead if the node is a temporary node used to accept a query, we}
02060 \textcolor{comment}{   completely free the node on error. */}
02061 \textcolor{keywordtype}{void} handleLinkIOError(clusterLink *link) \{
02062     freeClusterLink(link);
02063 \}
02064 
02065 \textcolor{comment}{/* Send data. This is handled using a trivial send buffer that gets}
02066 \textcolor{comment}{ * consumed by write(). We don't try to optimize this for speed too much}
02067 \textcolor{comment}{ * as this is a very low traffic channel. */}
02068 \textcolor{keywordtype}{void} clusterWriteHandler(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask) \{
02069     clusterLink *link = (clusterLink*) privdata;
02070     ssize\_t nwritten;
02071     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(el);
02072     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(mask);
02073 
02074     nwritten = write(fd, link->sndbuf, sdslen(link->sndbuf));
02075     \textcolor{keywordflow}{if} (nwritten <= 0) \{
02076         serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG},\textcolor{stringliteral}{"I/O error writing to node link: %s"},
02077             strerror(errno));
02078         handleLinkIOError(link);
02079         \textcolor{keywordflow}{return};
02080     \}
02081     sdsrange(link->sndbuf,nwritten,-1);
02082     \textcolor{keywordflow}{if} (sdslen(link->sndbuf) == 0)
02083         aeDeleteFileEvent(server.el, link->fd, \hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE});
02084 \}
02085 
02086 \textcolor{comment}{/* Read data. Try to read the first field of the header first to check the}
02087 \textcolor{comment}{ * full length of the packet. When a whole packet is in memory this function}
02088 \textcolor{comment}{ * will call the function to process the packet. And so forth. */}
02089 \textcolor{keywordtype}{void} clusterReadHandler(aeEventLoop *el, \textcolor{keywordtype}{int} fd, \textcolor{keywordtype}{void} *privdata, \textcolor{keywordtype}{int} mask) \{
02090     \textcolor{keywordtype}{char} buf[\textcolor{keyword}{sizeof}(clusterMsg)];
02091     ssize\_t nread;
02092     clusterMsg *hdr;
02093     clusterLink *link = (clusterLink*) privdata;
02094     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} readlen, rcvbuflen;
02095     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(el);
02096     \hyperlink{server_8h_ae7c9dc8f13568a9c856573751f1ee1ec}{UNUSED}(mask);
02097 
02098     \textcolor{keywordflow}{while}(1) \{ \textcolor{comment}{/* Read as long as there is data to read. */}
02099         rcvbuflen = sdslen(link->rcvbuf);
02100         \textcolor{keywordflow}{if} (rcvbuflen < 8) \{
02101             \textcolor{comment}{/* First, obtain the first 8 bytes to get the full message}
02102 \textcolor{comment}{             * length. */}
02103             readlen = 8 - rcvbuflen;
02104         \} \textcolor{keywordflow}{else} \{
02105             \textcolor{comment}{/* Finally read the full message. */}
02106             hdr = (clusterMsg*) link->rcvbuf;
02107             \textcolor{keywordflow}{if} (rcvbuflen == 8) \{
02108                 \textcolor{comment}{/* Perform some sanity check on the message signature}
02109 \textcolor{comment}{                 * and length. */}
02110                 \textcolor{keywordflow}{if} (memcmp(hdr->sig,\textcolor{stringliteral}{"RCmb"},4) != 0 ||
02111                     ntohl(hdr->totlen) < \hyperlink{cluster_8h_a92c33a8bb7f8a960845347ca63c4659e}{CLUSTERMSG\_MIN\_LEN})
02112                 \{
02113                     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
02114                         \textcolor{stringliteral}{"Bad message length or signature received "}
02115                         \textcolor{stringliteral}{"from Cluster bus."});
02116                     handleLinkIOError(link);
02117                     \textcolor{keywordflow}{return};
02118                 \}
02119             \}
02120             readlen = ntohl(hdr->totlen) - rcvbuflen;
02121             \textcolor{keywordflow}{if} (readlen > \textcolor{keyword}{sizeof}(buf)) readlen = \textcolor{keyword}{sizeof}(buf);
02122         \}
02123 
02124         nread = read(fd,buf,readlen);
02125         \textcolor{keywordflow}{if} (nread == -1 && errno == EAGAIN) \textcolor{keywordflow}{return}; \textcolor{comment}{/* No more data ready. */}
02126 
02127         \textcolor{keywordflow}{if} (nread <= 0) \{
02128             \textcolor{comment}{/* I/O error... */}
02129             serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG},\textcolor{stringliteral}{"I/O error reading from node link: %s"},
02130                 (nread == 0) ? \textcolor{stringliteral}{"connection closed"} : strerror(errno));
02131             handleLinkIOError(link);
02132             \textcolor{keywordflow}{return};
02133         \} \textcolor{keywordflow}{else} \{
02134             \textcolor{comment}{/* Read data and recast the pointer to the new buffer. */}
02135             link->rcvbuf = sdscatlen(link->rcvbuf,buf,nread);
02136             hdr = (clusterMsg*) link->rcvbuf;
02137             rcvbuflen += nread;
02138         \}
02139 
02140         \textcolor{comment}{/* Total length obtained? Process this packet. */}
02141         \textcolor{keywordflow}{if} (rcvbuflen >= 8 && rcvbuflen == ntohl(hdr->totlen)) \{
02142             \textcolor{keywordflow}{if} (clusterProcessPacket(link)) \{
02143                 sdsfree(link->rcvbuf);
02144                 link->rcvbuf = sdsempty();
02145             \} \textcolor{keywordflow}{else} \{
02146                 \textcolor{keywordflow}{return}; \textcolor{comment}{/* Link no longer valid. */}
02147             \}
02148         \}
02149     \}
02150 \}
02151 
02152 \textcolor{comment}{/* Put stuff into the send buffer.}
02153 \textcolor{comment}{ *}
02154 \textcolor{comment}{ * It is guaranteed that this function will never have as a side effect}
02155 \textcolor{comment}{ * the link to be invalidated, so it is safe to call this function}
02156 \textcolor{comment}{ * from event handlers that will do stuff with the same link later. */}
02157 \textcolor{keywordtype}{void} clusterSendMessage(clusterLink *link, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *msg, size\_t msglen) \{
02158     \textcolor{keywordflow}{if} (sdslen(link->sndbuf) == 0 && msglen != 0)
02159         aeCreateFileEvent(server.el,link->fd,\hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE},
02160                     clusterWriteHandler,link);
02161 
02162     link->sndbuf = sdscatlen(link->sndbuf, msg, msglen);
02163 
02164     \textcolor{comment}{/* Populate sent messages stats. */}
02165     clusterMsg *hdr = (clusterMsg*) msg;
02166     uint16\_t type = ntohs(hdr->type);
02167     \textcolor{keywordflow}{if} (type < \hyperlink{cluster_8h_a6222c464c1f2125f42271d2abd63853e}{CLUSTERMSG\_TYPE\_COUNT})
02168         server.cluster->stats\_bus\_messages\_sent[type]++;
02169 \}
02170 
02171 \textcolor{comment}{/* Send a message to all the nodes that are part of the cluster having}
02172 \textcolor{comment}{ * a connected link.}
02173 \textcolor{comment}{ *}
02174 \textcolor{comment}{ * It is guaranteed that this function will never have as a side effect}
02175 \textcolor{comment}{ * some node->link to be invalidated, so it is safe to call this function}
02176 \textcolor{comment}{ * from event handlers that will do stuff with node links later. */}
02177 \textcolor{keywordtype}{void} clusterBroadcastMessage(\textcolor{keywordtype}{void} *buf, size\_t len) \{
02178     dictIterator *di;
02179     dictEntry *de;
02180 
02181     di = dictGetSafeIterator(server.cluster->nodes);
02182     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
02183         clusterNode *node = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
02184 
02185         \textcolor{keywordflow}{if} (!node->link) \textcolor{keywordflow}{continue};
02186         \textcolor{keywordflow}{if} (node->flags & (\hyperlink{cluster_8h_afee946c4e74c08465e9b4ead5e3659e6}{CLUSTER\_NODE\_MYSELF}|
      \hyperlink{cluster_8h_a60571342a067f1e5772a04b36feff6a6}{CLUSTER\_NODE\_HANDSHAKE}))
02187             \textcolor{keywordflow}{continue};
02188         clusterSendMessage(node->link,buf,len);
02189     \}
02190     dictReleaseIterator(di);
02191 \}
02192 
02193 \textcolor{comment}{/* Build the message header. hdr must point to a buffer at least}
02194 \textcolor{comment}{ * sizeof(clusterMsg) in bytes. */}
02195 \textcolor{keywordtype}{void} clusterBuildMessageHdr(clusterMsg *hdr, \textcolor{keywordtype}{int} type) \{
02196     \textcolor{keywordtype}{int} totlen = 0;
02197     uint64\_t offset;
02198     clusterNode *master;
02199 
02200     \textcolor{comment}{/* If this node is a master, we send its slots bitmap and configEpoch.}
02201 \textcolor{comment}{     * If this node is a slave we send the master's information instead (the}
02202 \textcolor{comment}{     * node is flagged as slave so the receiver knows that it is NOT really}
02203 \textcolor{comment}{     * in charge for this slots. */}
02204     master = (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(myself) && myself->slaveof) ?
02205               myself->slaveof : myself;
02206 
02207     memset(hdr,0,\textcolor{keyword}{sizeof}(*hdr));
02208     hdr->ver = htons(\hyperlink{cluster_8h_ad93688d5eca033b109b1a00bfb03cebe}{CLUSTER\_PROTO\_VER});
02209     hdr->sig[0] = \textcolor{stringliteral}{'R'};
02210     hdr->sig[1] = \textcolor{stringliteral}{'C'};
02211     hdr->sig[2] = \textcolor{stringliteral}{'m'};
02212     hdr->sig[3] = \textcolor{stringliteral}{'b'};
02213     hdr->type = htons(type);
02214     memcpy(hdr->sender,myself->name,\hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN});
02215 
02216     \textcolor{comment}{/* If cluster-announce-ip option is enabled, force the receivers of our}
02217 \textcolor{comment}{     * packets to use the specified address for this node. Otherwise if the}
02218 \textcolor{comment}{     * first byte is zero, they'll do auto discovery. */}
02219     memset(hdr->myip,0,\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN});
02220     \textcolor{keywordflow}{if} (server.cluster\_announce\_ip) \{
02221         strncpy(hdr->myip,server.cluster\_announce\_ip,\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN});
02222         hdr->myip[\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN}-1] = \textcolor{stringliteral}{'\(\backslash\)0'};
02223     \}
02224 
02225     \textcolor{comment}{/* Handle cluster-announce-port as well. */}
02226     \textcolor{keywordtype}{int} announced\_port = server.cluster\_announce\_port ?
02227                          server.cluster\_announce\_port : server.port;
02228     \textcolor{keywordtype}{int} announced\_cport = server.cluster\_announce\_bus\_port ?
02229                           server.cluster\_announce\_bus\_port :
02230                           (server.port + \hyperlink{cluster_8h_ac619a9ae48ab1431daa590fb5e75cea8}{CLUSTER\_PORT\_INCR});
02231 
02232     memcpy(hdr->myslots,master->slots,\textcolor{keyword}{sizeof}(hdr->myslots));
02233     memset(hdr->slaveof,0,\hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN});
02234     \textcolor{keywordflow}{if} (myself->slaveof != NULL)
02235         memcpy(hdr->slaveof,myself->slaveof->name, \hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN});
02236     hdr->port = htons(announced\_port);
02237     hdr->cport = htons(announced\_cport);
02238     hdr->flags = htons(myself->flags);
02239     hdr->state = server.cluster->state;
02240 
02241     \textcolor{comment}{/* Set the currentEpoch and configEpochs. */}
02242     hdr->currentEpoch = \hyperlink{endianconv_8h_a41a6b64ba8dec362f605f615e528fcf3}{htonu64}(server.cluster->currentEpoch);
02243     hdr->configEpoch = \hyperlink{endianconv_8h_a41a6b64ba8dec362f605f615e528fcf3}{htonu64}(master->configEpoch);
02244 
02245     \textcolor{comment}{/* Set the replication offset. */}
02246     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(myself))
02247         offset = replicationGetSlaveOffset();
02248     \textcolor{keywordflow}{else}
02249         offset = server.master\_repl\_offset;
02250     hdr->offset = \hyperlink{endianconv_8h_a41a6b64ba8dec362f605f615e528fcf3}{htonu64}(offset);
02251 
02252     \textcolor{comment}{/* Set the message flags. */}
02253     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(myself) && server.cluster->mf\_end)
02254         hdr->mflags[0] |= \hyperlink{cluster_8h_aa7da3a662e6241de4f004fa1a4519cf2}{CLUSTERMSG\_FLAG0\_PAUSED};
02255 
02256     \textcolor{comment}{/* Compute the message length for certain messages. For other messages}
02257 \textcolor{comment}{     * this is up to the caller. */}
02258     \textcolor{keywordflow}{if} (type == \hyperlink{cluster_8h_af5d51e3ad9965074b2124aabe1895d59}{CLUSTERMSG\_TYPE\_FAIL}) \{
02259         totlen = \textcolor{keyword}{sizeof}(clusterMsg)-\textcolor{keyword}{sizeof}(\textcolor{keyword}{union} \hyperlink{unionclusterMsgData}{clusterMsgData});
02260         totlen += \textcolor{keyword}{sizeof}(clusterMsgDataFail);
02261     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == \hyperlink{cluster_8h_a51dc58bb78128fcae1751d654130ec0f}{CLUSTERMSG\_TYPE\_UPDATE}) \{
02262         totlen = \textcolor{keyword}{sizeof}(clusterMsg)-\textcolor{keyword}{sizeof}(\textcolor{keyword}{union} \hyperlink{unionclusterMsgData}{clusterMsgData});
02263         totlen += \textcolor{keyword}{sizeof}(clusterMsgDataUpdate);
02264     \}
02265     hdr->totlen = htonl(totlen);
02266     \textcolor{comment}{/* For PING, PONG, and MEET, fixing the totlen field is up to the caller. */}
02267 \}
02268 
02269 \textcolor{comment}{/* Return non zero if the node is already present in the gossip section of the}
02270 \textcolor{comment}{ * message pointed by 'hdr' and having 'count' gossip entries. Otherwise}
02271 \textcolor{comment}{ * zero is returned. Helper for clusterSendPing(). */}
02272 \textcolor{keywordtype}{int} clusterNodeIsInGossipSection(clusterMsg *hdr, \textcolor{keywordtype}{int} count, clusterNode *n) \{
02273     \textcolor{keywordtype}{int} j;
02274     \textcolor{keywordflow}{for} (j = 0; j < count; j++) \{
02275         \textcolor{keywordflow}{if} (memcmp(hdr->data.ping.gossip[j].nodename,n->name,
02276                 \hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN}) == 0) \textcolor{keywordflow}{break};
02277     \}
02278     \textcolor{keywordflow}{return} j != count;
02279 \}
02280 
02281 \textcolor{comment}{/* Set the i-th entry of the gossip section in the message pointed by 'hdr'}
02282 \textcolor{comment}{ * to the info of the specified node 'n'. */}
02283 \textcolor{keywordtype}{void} clusterSetGossipEntry(clusterMsg *hdr, \textcolor{keywordtype}{int} i, clusterNode *n) \{
02284     clusterMsgDataGossip *gossip;
02285     gossip = &(hdr->data.ping.gossip[i]);
02286     memcpy(gossip->nodename,n->name,\hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN});
02287     gossip->ping\_sent = htonl(n->ping\_sent/1000);
02288     gossip->pong\_received = htonl(n->pong\_received/1000);
02289     memcpy(gossip->ip,n->ip,\textcolor{keyword}{sizeof}(n->ip));
02290     gossip->port = htons(n->port);
02291     gossip->cport = htons(n->cport);
02292     gossip->flags = htons(n->flags);
02293     gossip->notused1 = 0;
02294 \}
02295 
02296 \textcolor{comment}{/* Send a PING or PONG packet to the specified node, making sure to add enough}
02297 \textcolor{comment}{ * gossip informations. */}
02298 \textcolor{keywordtype}{void} clusterSendPing(clusterLink *link, \textcolor{keywordtype}{int} type) \{
02299     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buf;
02300     clusterMsg *hdr;
02301     \textcolor{keywordtype}{int} gossipcount = 0; \textcolor{comment}{/* Number of gossip sections added so far. */}
02302     \textcolor{keywordtype}{int} wanted; \textcolor{comment}{/* Number of gossip sections we want to append if possible. */}
02303     \textcolor{keywordtype}{int} totlen; \textcolor{comment}{/* Total packet length. */}
02304     \textcolor{comment}{/* freshnodes is the max number of nodes we can hope to append at all:}
02305 \textcolor{comment}{     * nodes available minus two (ourself and the node we are sending the}
02306 \textcolor{comment}{     * message to). However practically there may be less valid nodes since}
02307 \textcolor{comment}{     * nodes in handshake state, disconnected, are not considered. */}
02308     \textcolor{keywordtype}{int} freshnodes = \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.cluster->nodes)-2;
02309 
02310     \textcolor{comment}{/* How many gossip sections we want to add? 1/10 of the number of nodes}
02311 \textcolor{comment}{     * and anyway at least 3. Why 1/10?}
02312 \textcolor{comment}{     *}
02313 \textcolor{comment}{     * If we have N masters, with N/10 entries, and we consider that in}
02314 \textcolor{comment}{     * node\_timeout we exchange with each other node at least 4 packets}
02315 \textcolor{comment}{     * (we ping in the worst case in node\_timeout/2 time, and we also}
02316 \textcolor{comment}{     * receive two pings from the host), we have a total of 8 packets}
02317 \textcolor{comment}{     * in the node\_timeout*2 falure reports validity time. So we have}
02318 \textcolor{comment}{     * that, for a single PFAIL node, we can expect to receive the following}
02319 \textcolor{comment}{     * number of failure reports (in the specified window of time):}
02320 \textcolor{comment}{     *}
02321 \textcolor{comment}{     * PROB * GOSSIP\_ENTRIES\_PER\_PACKET * TOTAL\_PACKETS:}
02322 \textcolor{comment}{     *}
02323 \textcolor{comment}{     * PROB = probability of being featured in a single gossip entry,}
02324 \textcolor{comment}{     *        which is 1 / NUM\_OF\_NODES.}
02325 \textcolor{comment}{     * ENTRIES = 10.}
02326 \textcolor{comment}{     * TOTAL\_PACKETS = 2 * 4 * NUM\_OF\_MASTERS.}
02327 \textcolor{comment}{     *}
02328 \textcolor{comment}{     * If we assume we have just masters (so num of nodes and num of masters}
02329 \textcolor{comment}{     * is the same), with 1/10 we always get over the majority, and specifically}
02330 \textcolor{comment}{     * 80% of the number of nodes, to account for many masters failing at the}
02331 \textcolor{comment}{     * same time.}
02332 \textcolor{comment}{     *}
02333 \textcolor{comment}{     * Since we have non-voting slaves that lower the probability of an entry}
02334 \textcolor{comment}{     * to feature our node, we set the number of entires per packet as}
02335 \textcolor{comment}{     * 10% of the total nodes we have. */}
02336     wanted = floor(\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.cluster->nodes)/10);
02337     \textcolor{keywordflow}{if} (wanted < 3) wanted = 3;
02338     \textcolor{keywordflow}{if} (wanted > freshnodes) wanted = freshnodes;
02339 
02340     \textcolor{comment}{/* Include all the nodes in PFAIL state, so that failure reports are}
02341 \textcolor{comment}{     * faster to propagate to go from PFAIL to FAIL state. */}
02342     \textcolor{keywordtype}{int} pfail\_wanted = server.cluster->stats\_pfail\_nodes;
02343 
02344     \textcolor{comment}{/* Compute the maxium totlen to allocate our buffer. We'll fix the totlen}
02345 \textcolor{comment}{     * later according to the number of gossip sections we really were able}
02346 \textcolor{comment}{     * to put inside the packet. */}
02347     totlen = \textcolor{keyword}{sizeof}(clusterMsg)-\textcolor{keyword}{sizeof}(\textcolor{keyword}{union} \hyperlink{unionclusterMsgData}{clusterMsgData});
02348     totlen += (\textcolor{keyword}{sizeof}(clusterMsgDataGossip)*(wanted+pfail\_wanted));
02349     \textcolor{comment}{/* Note: clusterBuildMessageHdr() expects the buffer to be always at least}
02350 \textcolor{comment}{     * sizeof(clusterMsg) or more. */}
02351     \textcolor{keywordflow}{if} (totlen < (\textcolor{keywordtype}{int})\textcolor{keyword}{sizeof}(clusterMsg)) totlen = \textcolor{keyword}{sizeof}(clusterMsg);
02352     buf = zcalloc(totlen);
02353     hdr = (clusterMsg*) buf;
02354 
02355     \textcolor{comment}{/* Populate the header. */}
02356     \textcolor{keywordflow}{if} (link->node && type == \hyperlink{cluster_8h_aeb8a936505e22f64e5039523a3c96d4c}{CLUSTERMSG\_TYPE\_PING})
02357         link->node->ping\_sent = mstime();
02358     clusterBuildMessageHdr(hdr,type);
02359 
02360     \textcolor{comment}{/* Populate the gossip fields */}
02361     \textcolor{keywordtype}{int} maxiterations = wanted*3;
02362     \textcolor{keywordflow}{while}(freshnodes > 0 && gossipcount < wanted && maxiterations--) \{
02363         dictEntry *de = dictGetRandomKey(server.cluster->nodes);
02364         clusterNode *\textcolor{keyword}{this} = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
02365 
02366         \textcolor{comment}{/* Don't include this node: the whole packet header is about us}
02367 \textcolor{comment}{         * already, so we just gossip about other nodes. */}
02368         \textcolor{keywordflow}{if} (\textcolor{keyword}{this} == myself) \textcolor{keywordflow}{continue};
02369 
02370         \textcolor{comment}{/* PFAIL nodes will be added later. */}
02371         \textcolor{keywordflow}{if} (\textcolor{keyword}{this}->flags & \hyperlink{cluster_8h_a5306c1ae8988b8be0a1a02bd9162dfa1}{CLUSTER\_NODE\_PFAIL}) \textcolor{keywordflow}{continue};
02372 
02373         \textcolor{comment}{/* In the gossip section don't include:}
02374 \textcolor{comment}{         * 1) Nodes in HANDSHAKE state.}
02375 \textcolor{comment}{         * 3) Nodes with the NOADDR flag set.}
02376 \textcolor{comment}{         * 4) Disconnected nodes if they don't have configured slots.}
02377 \textcolor{comment}{         */}
02378         \textcolor{keywordflow}{if} (\textcolor{keyword}{this}->flags & (\hyperlink{cluster_8h_a60571342a067f1e5772a04b36feff6a6}{CLUSTER\_NODE\_HANDSHAKE}|
      \hyperlink{cluster_8h_a2bbed8bf0615871a01ca8b7f691b56d8}{CLUSTER\_NODE\_NOADDR}) ||
02379             (\textcolor{keyword}{this}->link == NULL && \textcolor{keyword}{this}->numslots == 0))
02380         \{
02381             freshnodes--; \textcolor{comment}{/* Tecnically not correct, but saves CPU. */}
02382             \textcolor{keywordflow}{continue};
02383         \}
02384 
02385         \textcolor{comment}{/* Do not add a node we already have. */}
02386         \textcolor{keywordflow}{if} (clusterNodeIsInGossipSection(hdr,gossipcount,\textcolor{keyword}{this})) \textcolor{keywordflow}{continue};
02387 
02388         \textcolor{comment}{/* Add it */}
02389         clusterSetGossipEntry(hdr,gossipcount,\textcolor{keyword}{this});
02390         freshnodes--;
02391         gossipcount++;
02392     \}
02393 
02394     \textcolor{comment}{/* If there are PFAIL nodes, add them at the end. */}
02395     \textcolor{keywordflow}{if} (pfail\_wanted) \{
02396         dictIterator *di;
02397         dictEntry *de;
02398 
02399         di = dictGetSafeIterator(server.cluster->nodes);
02400         \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL && pfail\_wanted > 0) \{
02401             clusterNode *node = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
02402             \textcolor{keywordflow}{if} (node->flags & \hyperlink{cluster_8h_a60571342a067f1e5772a04b36feff6a6}{CLUSTER\_NODE\_HANDSHAKE}) \textcolor{keywordflow}{continue};
02403             \textcolor{keywordflow}{if} (node->flags & \hyperlink{cluster_8h_a2bbed8bf0615871a01ca8b7f691b56d8}{CLUSTER\_NODE\_NOADDR}) \textcolor{keywordflow}{continue};
02404             \textcolor{keywordflow}{if} (!(node->flags & \hyperlink{cluster_8h_a5306c1ae8988b8be0a1a02bd9162dfa1}{CLUSTER\_NODE\_PFAIL})) \textcolor{keywordflow}{continue};
02405             clusterSetGossipEntry(hdr,gossipcount,node);
02406             freshnodes--;
02407             gossipcount++;
02408             \textcolor{comment}{/* We take the count of the slots we allocated, since the}
02409 \textcolor{comment}{             * PFAIL stats may not match perfectly with the current number}
02410 \textcolor{comment}{             * of PFAIL nodes. */}
02411             pfail\_wanted--;
02412         \}
02413         dictReleaseIterator(di);
02414     \}
02415 
02416     \textcolor{comment}{/* Ready to send... fix the totlen fiend and queue the message in the}
02417 \textcolor{comment}{     * output buffer. */}
02418     totlen = \textcolor{keyword}{sizeof}(clusterMsg)-\textcolor{keyword}{sizeof}(\textcolor{keyword}{union} \hyperlink{unionclusterMsgData}{clusterMsgData});
02419     totlen += (\textcolor{keyword}{sizeof}(clusterMsgDataGossip)*gossipcount);
02420     hdr->count = htons(gossipcount);
02421     hdr->totlen = htonl(totlen);
02422     clusterSendMessage(link,buf,totlen);
02423     zfree(buf);
02424 \}
02425 
02426 \textcolor{comment}{/* Send a PONG packet to every connected node that's not in handshake state}
02427 \textcolor{comment}{ * and for which we have a valid link.}
02428 \textcolor{comment}{ *}
02429 \textcolor{comment}{ * In Redis Cluster pongs are not used just for failure detection, but also}
02430 \textcolor{comment}{ * to carry important configuration information. So broadcasting a pong is}
02431 \textcolor{comment}{ * useful when something changes in the configuration and we want to make}
02432 \textcolor{comment}{ * the cluster aware ASAP (for instance after a slave promotion).}
02433 \textcolor{comment}{ *}
02434 \textcolor{comment}{ * The 'target' argument specifies the receiving instances using the}
02435 \textcolor{comment}{ * defines below:}
02436 \textcolor{comment}{ *}
02437 \textcolor{comment}{ * CLUSTER\_BROADCAST\_ALL -> All known instances.}
02438 \textcolor{comment}{ * CLUSTER\_BROADCAST\_LOCAL\_SLAVES -> All slaves in my master-slaves ring.}
02439 \textcolor{comment}{ */}
02440 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLUSTER\_BROADCAST\_ALL} 0
02441 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLUSTER\_BROADCAST\_LOCAL\_SLAVES} 1
02442 \textcolor{keywordtype}{void} clusterBroadcastPong(\textcolor{keywordtype}{int} target) \{
02443     dictIterator *di;
02444     dictEntry *de;
02445 
02446     di = dictGetSafeIterator(server.cluster->nodes);
02447     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
02448         clusterNode *node = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
02449 
02450         \textcolor{keywordflow}{if} (!node->link) \textcolor{keywordflow}{continue};
02451         \textcolor{keywordflow}{if} (node == myself || \hyperlink{cluster_8h_a70f1a5bb82f54ce5d17b13de42176790}{nodeInHandshake}(node)) \textcolor{keywordflow}{continue};
02452         \textcolor{keywordflow}{if} (target == \hyperlink{cluster_8c_a49481f5cedbd75ce025011b331021822}{CLUSTER\_BROADCAST\_LOCAL\_SLAVES}) \{
02453             \textcolor{keywordtype}{int} local\_slave =
02454                 \hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(node) && node->slaveof &&
02455                 (node->slaveof == myself || node->slaveof == myself->slaveof);
02456             \textcolor{keywordflow}{if} (!local\_slave) \textcolor{keywordflow}{continue};
02457         \}
02458         clusterSendPing(node->link,\hyperlink{cluster_8h_a33e9439f462f28177a31dfc74de0c16b}{CLUSTERMSG\_TYPE\_PONG});
02459     \}
02460     dictReleaseIterator(di);
02461 \}
02462 
02463 \textcolor{comment}{/* Send a PUBLISH message.}
02464 \textcolor{comment}{ *}
02465 \textcolor{comment}{ * If link is NULL, then the message is broadcasted to the whole cluster. */}
02466 \textcolor{keywordtype}{void} clusterSendPublish(clusterLink *link, robj *channel, robj *message) \{
02467     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[\textcolor{keyword}{sizeof}(clusterMsg)], *payload;
02468     clusterMsg *hdr = (clusterMsg*) buf;
02469     uint32\_t totlen;
02470     uint32\_t channel\_len, message\_len;
02471 
02472     channel = getDecodedObject(channel);
02473     message = getDecodedObject(message);
02474     channel\_len = sdslen(channel->ptr);
02475     message\_len = sdslen(message->ptr);
02476 
02477     clusterBuildMessageHdr(hdr,\hyperlink{cluster_8h_a874fecfd3ff886c2c697f5649ebee5ee}{CLUSTERMSG\_TYPE\_PUBLISH});
02478     totlen = \textcolor{keyword}{sizeof}(clusterMsg)-\textcolor{keyword}{sizeof}(\textcolor{keyword}{union} \hyperlink{unionclusterMsgData}{clusterMsgData});
02479     totlen += \textcolor{keyword}{sizeof}(clusterMsgDataPublish) - 8 + channel\_len + message\_len;
02480 
02481     hdr->data.publish.msg.channel\_len = htonl(channel\_len);
02482     hdr->data.publish.msg.message\_len = htonl(message\_len);
02483     hdr->totlen = htonl(totlen);
02484 
02485     \textcolor{comment}{/* Try to use the local buffer if possible */}
02486     \textcolor{keywordflow}{if} (totlen < \textcolor{keyword}{sizeof}(buf)) \{
02487         payload = buf;
02488     \} \textcolor{keywordflow}{else} \{
02489         payload = zmalloc(totlen);
02490         memcpy(payload,hdr,\textcolor{keyword}{sizeof}(*hdr));
02491         hdr = (clusterMsg*) payload;
02492     \}
02493     memcpy(hdr->data.publish.msg.bulk\_data,channel->ptr,sdslen(channel->ptr));
02494     memcpy(hdr->data.publish.msg.bulk\_data+sdslen(channel->ptr),
02495         message->ptr,sdslen(message->ptr));
02496 
02497     \textcolor{keywordflow}{if} (link)
02498         clusterSendMessage(link,payload,totlen);
02499     \textcolor{keywordflow}{else}
02500         clusterBroadcastMessage(payload,totlen);
02501 
02502     decrRefCount(channel);
02503     decrRefCount(message);
02504     \textcolor{keywordflow}{if} (payload != buf) zfree(payload);
02505 \}
02506 
02507 \textcolor{comment}{/* Send a FAIL message to all the nodes we are able to contact.}
02508 \textcolor{comment}{ * The FAIL message is sent when we detect that a node is failing}
02509 \textcolor{comment}{ * (CLUSTER\_NODE\_PFAIL) and we also receive a gossip confirmation of this:}
02510 \textcolor{comment}{ * we switch the node state to CLUSTER\_NODE\_FAIL and ask all the other}
02511 \textcolor{comment}{ * nodes to do the same ASAP. */}
02512 \textcolor{keywordtype}{void} clusterSendFail(\textcolor{keywordtype}{char} *nodename) \{
02513     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[\textcolor{keyword}{sizeof}(clusterMsg)];
02514     clusterMsg *hdr = (clusterMsg*) buf;
02515 
02516     clusterBuildMessageHdr(hdr,\hyperlink{cluster_8h_af5d51e3ad9965074b2124aabe1895d59}{CLUSTERMSG\_TYPE\_FAIL});
02517     memcpy(hdr->data.fail.about.nodename,nodename,\hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN});
02518     clusterBroadcastMessage(buf,ntohl(hdr->totlen));
02519 \}
02520 
02521 \textcolor{comment}{/* Send an UPDATE message to the specified link carrying the specified 'node'}
02522 \textcolor{comment}{ * slots configuration. The node name, slots bitmap, and configEpoch info}
02523 \textcolor{comment}{ * are included. */}
02524 \textcolor{keywordtype}{void} clusterSendUpdate(clusterLink *link, clusterNode *node) \{
02525     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[\textcolor{keyword}{sizeof}(clusterMsg)];
02526     clusterMsg *hdr = (clusterMsg*) buf;
02527 
02528     \textcolor{keywordflow}{if} (link == NULL) \textcolor{keywordflow}{return};
02529     clusterBuildMessageHdr(hdr,\hyperlink{cluster_8h_a51dc58bb78128fcae1751d654130ec0f}{CLUSTERMSG\_TYPE\_UPDATE});
02530     memcpy(hdr->data.update.nodecfg.nodename,node->name,\hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN});
02531     hdr->data.update.nodecfg.configEpoch = \hyperlink{endianconv_8h_a41a6b64ba8dec362f605f615e528fcf3}{htonu64}(node->configEpoch);
02532     memcpy(hdr->data.update.nodecfg.slots,node->slots,\textcolor{keyword}{sizeof}(node->slots));
02533     clusterSendMessage(link,buf,ntohl(hdr->totlen));
02534 \}
02535 
02536 \textcolor{comment}{/* -----------------------------------------------------------------------------}
02537 \textcolor{comment}{ * CLUSTER Pub/Sub support}
02538 \textcolor{comment}{ *}
02539 \textcolor{comment}{ * For now we do very little, just propagating PUBLISH messages across the whole}
02540 \textcolor{comment}{ * cluster. In the future we'll try to get smarter and avoiding propagating those}
02541 \textcolor{comment}{ * messages to hosts without receives for a given channel.}
02542 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
02543 \textcolor{keywordtype}{void} clusterPropagatePublish(robj *channel, robj *message) \{
02544     clusterSendPublish(NULL, channel, message);
02545 \}
02546 
02547 \textcolor{comment}{/* -----------------------------------------------------------------------------}
02548 \textcolor{comment}{ * SLAVE node specific functions}
02549 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
02550 
02551 \textcolor{comment}{/* This function sends a FAILOVE\_AUTH\_REQUEST message to every node in order to}
02552 \textcolor{comment}{ * see if there is the quorum for this slave instance to failover its failing}
02553 \textcolor{comment}{ * master.}
02554 \textcolor{comment}{ *}
02555 \textcolor{comment}{ * Note that we send the failover request to everybody, master and slave nodes,}
02556 \textcolor{comment}{ * but only the masters are supposed to reply to our query. */}
02557 \textcolor{keywordtype}{void} clusterRequestFailoverAuth(\textcolor{keywordtype}{void}) \{
02558     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[\textcolor{keyword}{sizeof}(clusterMsg)];
02559     clusterMsg *hdr = (clusterMsg*) buf;
02560     uint32\_t totlen;
02561 
02562     clusterBuildMessageHdr(hdr,\hyperlink{cluster_8h_a739009308ed4cb5b19630a5f872408d2}{CLUSTERMSG\_TYPE\_FAILOVER\_AUTH\_REQUEST}
      );
02563     \textcolor{comment}{/* If this is a manual failover, set the CLUSTERMSG\_FLAG0\_FORCEACK bit}
02564 \textcolor{comment}{     * in the header to communicate the nodes receiving the message that}
02565 \textcolor{comment}{     * they should authorized the failover even if the master is working. */}
02566     \textcolor{keywordflow}{if} (server.cluster->mf\_end) hdr->mflags[0] |= \hyperlink{cluster_8h_a28600533c792367de5ec4fe2e8434376}{CLUSTERMSG\_FLAG0\_FORCEACK};
02567     totlen = \textcolor{keyword}{sizeof}(clusterMsg)-\textcolor{keyword}{sizeof}(\textcolor{keyword}{union} \hyperlink{unionclusterMsgData}{clusterMsgData});
02568     hdr->totlen = htonl(totlen);
02569     clusterBroadcastMessage(buf,totlen);
02570 \}
02571 
02572 \textcolor{comment}{/* Send a FAILOVER\_AUTH\_ACK message to the specified node. */}
02573 \textcolor{keywordtype}{void} clusterSendFailoverAuth(clusterNode *node) \{
02574     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[\textcolor{keyword}{sizeof}(clusterMsg)];
02575     clusterMsg *hdr = (clusterMsg*) buf;
02576     uint32\_t totlen;
02577 
02578     \textcolor{keywordflow}{if} (!node->link) \textcolor{keywordflow}{return};
02579     clusterBuildMessageHdr(hdr,\hyperlink{cluster_8h_ae0db3a998d7da521c5359bdd8708f5f6}{CLUSTERMSG\_TYPE\_FAILOVER\_AUTH\_ACK});
02580     totlen = \textcolor{keyword}{sizeof}(clusterMsg)-\textcolor{keyword}{sizeof}(\textcolor{keyword}{union} \hyperlink{unionclusterMsgData}{clusterMsgData});
02581     hdr->totlen = htonl(totlen);
02582     clusterSendMessage(node->link,buf,totlen);
02583 \}
02584 
02585 \textcolor{comment}{/* Send a MFSTART message to the specified node. */}
02586 \textcolor{keywordtype}{void} clusterSendMFStart(clusterNode *node) \{
02587     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[\textcolor{keyword}{sizeof}(clusterMsg)];
02588     clusterMsg *hdr = (clusterMsg*) buf;
02589     uint32\_t totlen;
02590 
02591     \textcolor{keywordflow}{if} (!node->link) \textcolor{keywordflow}{return};
02592     clusterBuildMessageHdr(hdr,\hyperlink{cluster_8h_aa875273b4b11ae73d3cd3a8aea4ddcba}{CLUSTERMSG\_TYPE\_MFSTART});
02593     totlen = \textcolor{keyword}{sizeof}(clusterMsg)-\textcolor{keyword}{sizeof}(\textcolor{keyword}{union} \hyperlink{unionclusterMsgData}{clusterMsgData});
02594     hdr->totlen = htonl(totlen);
02595     clusterSendMessage(node->link,buf,totlen);
02596 \}
02597 
02598 \textcolor{comment}{/* Vote for the node asking for our vote if there are the conditions. */}
02599 \textcolor{keywordtype}{void} clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) \{
02600     clusterNode *master = node->slaveof;
02601     uint64\_t requestCurrentEpoch = \hyperlink{endianconv_8h_ab6e7416a2faac85cd6d50180e7348a1b}{ntohu64}(request->currentEpoch);
02602     uint64\_t requestConfigEpoch = \hyperlink{endianconv_8h_ab6e7416a2faac85cd6d50180e7348a1b}{ntohu64}(request->configEpoch);
02603     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *claimed\_slots = request->myslots;
02604     \textcolor{keywordtype}{int} force\_ack = request->mflags[0] & \hyperlink{cluster_8h_a28600533c792367de5ec4fe2e8434376}{CLUSTERMSG\_FLAG0\_FORCEACK};
02605     \textcolor{keywordtype}{int} j;
02606 
02607     \textcolor{comment}{/* IF we are not a master serving at least 1 slot, we don't have the}
02608 \textcolor{comment}{     * right to vote, as the cluster size in Redis Cluster is the number}
02609 \textcolor{comment}{     * of masters serving at least one slot, and quorum is the cluster}
02610 \textcolor{comment}{     * size + 1 */}
02611     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(myself) || myself->numslots == 0) \textcolor{keywordflow}{return};
02612 
02613     \textcolor{comment}{/* Request epoch must be >= our currentEpoch.}
02614 \textcolor{comment}{     * Note that it is impossible for it to actually be greater since}
02615 \textcolor{comment}{     * our currentEpoch was updated as a side effect of receiving this}
02616 \textcolor{comment}{     * request, if the request epoch was greater. */}
02617     \textcolor{keywordflow}{if} (requestCurrentEpoch < server.cluster->currentEpoch) \{
02618         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
02619             \textcolor{stringliteral}{"Failover auth denied to %.40s: reqEpoch (%llu) < curEpoch(%llu)"},
02620             node->name,
02621             (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) requestCurrentEpoch,
02622             (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) server.cluster->currentEpoch);
02623         \textcolor{keywordflow}{return};
02624     \}
02625 
02626     \textcolor{comment}{/* I already voted for this epoch? Return ASAP. */}
02627     \textcolor{keywordflow}{if} (server.cluster->lastVoteEpoch == server.cluster->currentEpoch) \{
02628         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
02629                 \textcolor{stringliteral}{"Failover auth denied to %.40s: already voted for epoch %llu"},
02630                 node->name,
02631                 (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) server.cluster->currentEpoch);
02632         \textcolor{keywordflow}{return};
02633     \}
02634 
02635     \textcolor{comment}{/* Node must be a slave and its master down.}
02636 \textcolor{comment}{     * The master can be non failing if the request is flagged}
02637 \textcolor{comment}{     * with CLUSTERMSG\_FLAG0\_FORCEACK (manual failover). */}
02638     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(node) || master == NULL ||
02639         (!\hyperlink{cluster_8h_a6a31c614ff4f5ac8ebaa630b0a921c3d}{nodeFailed}(master) && !force\_ack))
02640     \{
02641         \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(node)) \{
02642             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
02643                     \textcolor{stringliteral}{"Failover auth denied to %.40s: it is a master node"},
02644                     node->name);
02645         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (master == NULL) \{
02646             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
02647                     \textcolor{stringliteral}{"Failover auth denied to %.40s: I don't know its master"},
02648                     node->name);
02649         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!\hyperlink{cluster_8h_a6a31c614ff4f5ac8ebaa630b0a921c3d}{nodeFailed}(master)) \{
02650             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
02651                     \textcolor{stringliteral}{"Failover auth denied to %.40s: its master is up"},
02652                     node->name);
02653         \}
02654         \textcolor{keywordflow}{return};
02655     \}
02656 
02657     \textcolor{comment}{/* We did not voted for a slave about this master for two}
02658 \textcolor{comment}{     * times the node timeout. This is not strictly needed for correctness}
02659 \textcolor{comment}{     * of the algorithm but makes the base case more linear. */}
02660     \textcolor{keywordflow}{if} (mstime() - node->slaveof->voted\_time < server.cluster\_node\_timeout * 2)
02661     \{
02662         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
02663                 \textcolor{stringliteral}{"Failover auth denied to %.40s: "}
02664                 \textcolor{stringliteral}{"can't vote about this master before %lld milliseconds"},
02665                 node->name,
02666                 (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) ((server.cluster\_node\_timeout*2)-
02667                              (mstime() - node->slaveof->voted\_time)));
02668         \textcolor{keywordflow}{return};
02669     \}
02670 
02671     \textcolor{comment}{/* The slave requesting the vote must have a configEpoch for the claimed}
02672 \textcolor{comment}{     * slots that is >= the one of the masters currently serving the same}
02673 \textcolor{comment}{     * slots in the current configuration. */}
02674     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}; j++) \{
02675         \textcolor{keywordflow}{if} (bitmapTestBit(claimed\_slots, j) == 0) \textcolor{keywordflow}{continue};
02676         \textcolor{keywordflow}{if} (server.cluster->slots[j] == NULL ||
02677             server.cluster->slots[j]->configEpoch <= requestConfigEpoch)
02678         \{
02679             \textcolor{keywordflow}{continue};
02680         \}
02681         \textcolor{comment}{/* If we reached this point we found a slot that in our current slots}
02682 \textcolor{comment}{         * is served by a master with a greater configEpoch than the one claimed}
02683 \textcolor{comment}{         * by the slave requesting our vote. Refuse to vote for this slave. */}
02684         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
02685                 \textcolor{stringliteral}{"Failover auth denied to %.40s: "}
02686                 \textcolor{stringliteral}{"slot %d epoch (%llu) > reqEpoch (%llu)"},
02687                 node->name, j,
02688                 (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) server.cluster->slots[j]->configEpoch,
02689                 (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) requestConfigEpoch);
02690         \textcolor{keywordflow}{return};
02691     \}
02692 
02693     \textcolor{comment}{/* We can vote for this slave. */}
02694     clusterSendFailoverAuth(node);
02695     server.cluster->lastVoteEpoch = server.cluster->currentEpoch;
02696     node->slaveof->voted\_time = mstime();
02697     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"Failover auth granted to %.40s for epoch %llu"},
02698         node->name, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) server.cluster->currentEpoch);
02699 \}
02700 
02701 \textcolor{comment}{/* This function returns the "rank" of this instance, a slave, in the context}
02702 \textcolor{comment}{ * of its master-slaves ring. The rank of the slave is given by the number of}
02703 \textcolor{comment}{ * other slaves for the same master that have a better replication offset}
02704 \textcolor{comment}{ * compared to the local one (better means, greater, so they claim more data).}
02705 \textcolor{comment}{ *}
02706 \textcolor{comment}{ * A slave with rank 0 is the one with the greatest (most up to date)}
02707 \textcolor{comment}{ * replication offset, and so forth. Note that because how the rank is computed}
02708 \textcolor{comment}{ * multiple slaves may have the same rank, in case they have the same offset.}
02709 \textcolor{comment}{ *}
02710 \textcolor{comment}{ * The slave rank is used to add a delay to start an election in order to}
02711 \textcolor{comment}{ * get voted and replace a failing master. Slaves with better replication}
02712 \textcolor{comment}{ * offsets are more likely to win. */}
02713 \textcolor{keywordtype}{int} clusterGetSlaveRank(\textcolor{keywordtype}{void}) \{
02714     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} myoffset;
02715     \textcolor{keywordtype}{int} j, rank = 0;
02716     clusterNode *master;
02717 
02718     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(myself));
02719     master = myself->slaveof;
02720     \textcolor{keywordflow}{if} (master == NULL) \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* Never called by slaves without master. */}
02721 
02722     myoffset = replicationGetSlaveOffset();
02723     \textcolor{keywordflow}{for} (j = 0; j < master->numslaves; j++)
02724         \textcolor{keywordflow}{if} (master->slaves[j] != myself &&
02725             master->slaves[j]->repl\_offset > myoffset) rank++;
02726     \textcolor{keywordflow}{return} rank;
02727 \}
02728 
02729 \textcolor{comment}{/* This function is called by clusterHandleSlaveFailover() in order to}
02730 \textcolor{comment}{ * let the slave log why it is not able to failover. Sometimes there are}
02731 \textcolor{comment}{ * not the conditions, but since the failover function is called again and}
02732 \textcolor{comment}{ * again, we can't log the same things continuously.}
02733 \textcolor{comment}{ *}
02734 \textcolor{comment}{ * This function works by logging only if a given set of conditions are}
02735 \textcolor{comment}{ * true:}
02736 \textcolor{comment}{ *}
02737 \textcolor{comment}{ * 1) The reason for which the failover can't be initiated changed.}
02738 \textcolor{comment}{ *    The reasons also include a NONE reason we reset the state to}
02739 \textcolor{comment}{ *    when the slave finds that its master is fine (no FAIL flag).}
02740 \textcolor{comment}{ * 2) Also, the log is emitted again if the master is still down and}
02741 \textcolor{comment}{ *    the reason for not failing over is still the same, but more than}
02742 \textcolor{comment}{ *    CLUSTER\_CANT\_FAILOVER\_RELOG\_PERIOD seconds elapsed.}
02743 \textcolor{comment}{ * 3) Finally, the function only logs if the slave is down for more than}
02744 \textcolor{comment}{ *    five seconds + NODE\_TIMEOUT. This way nothing is logged when a}
02745 \textcolor{comment}{ *    failover starts in a reasonable time.}
02746 \textcolor{comment}{ *}
02747 \textcolor{comment}{ * The function is called with the reason why the slave can't failover}
02748 \textcolor{comment}{ * which is one of the integer macros CLUSTER\_CANT\_FAILOVER\_*.}
02749 \textcolor{comment}{ *}
02750 \textcolor{comment}{ * The function is guaranteed to be called only if 'myself' is a slave. */}
02751 \textcolor{keywordtype}{void} clusterLogCantFailover(\textcolor{keywordtype}{int} reason) \{
02752     \textcolor{keywordtype}{char} *msg;
02753     \textcolor{keyword}{static} time\_t lastlog\_time = 0;
02754     mstime\_t nolog\_fail\_time = server.cluster\_node\_timeout + 5000;
02755 
02756     \textcolor{comment}{/* Don't log if we have the same reason for some time. */}
02757     \textcolor{keywordflow}{if} (reason == server.cluster->cant\_failover\_reason &&
02758         time(NULL)-lastlog\_time < \hyperlink{cluster_8h_aacc3855ff190c34f59896bb99655dcf8}{CLUSTER\_CANT\_FAILOVER\_RELOG\_PERIOD}
      )
02759         \textcolor{keywordflow}{return};
02760 
02761     server.cluster->cant\_failover\_reason = reason;
02762 
02763     \textcolor{comment}{/* We also don't emit any log if the master failed no long ago, the}
02764 \textcolor{comment}{     * goal of this function is to log slaves in a stalled condition for}
02765 \textcolor{comment}{     * a long time. */}
02766     \textcolor{keywordflow}{if} (myself->slaveof &&
02767         \hyperlink{cluster_8h_a6a31c614ff4f5ac8ebaa630b0a921c3d}{nodeFailed}(myself->slaveof) &&
02768         (mstime() - myself->slaveof->fail\_time) < nolog\_fail\_time) \textcolor{keywordflow}{return};
02769 
02770     \textcolor{keywordflow}{switch}(reason) \{
02771     \textcolor{keywordflow}{case} \hyperlink{cluster_8h_a0ad102e4aecc3451096624e2201f4285}{CLUSTER\_CANT\_FAILOVER\_DATA\_AGE}:
02772         msg = \textcolor{stringliteral}{"Disconnected from master for longer than allowed. "}
02773               \textcolor{stringliteral}{"Please check the 'cluster-slave-validity-factor' configuration "}
02774               \textcolor{stringliteral}{"option."};
02775         \textcolor{keywordflow}{break};
02776     \textcolor{keywordflow}{case} \hyperlink{cluster_8h_a40e58ef928e66a27912835d7e6a1c97a}{CLUSTER\_CANT\_FAILOVER\_WAITING\_DELAY}:
02777         msg = \textcolor{stringliteral}{"Waiting the delay before I can start a new failover."};
02778         \textcolor{keywordflow}{break};
02779     \textcolor{keywordflow}{case} \hyperlink{cluster_8h_af0085657cacf54e82c477680571f7509}{CLUSTER\_CANT\_FAILOVER\_EXPIRED}:
02780         msg = \textcolor{stringliteral}{"Failover attempt expired."};
02781         \textcolor{keywordflow}{break};
02782     \textcolor{keywordflow}{case} \hyperlink{cluster_8h_abaf73be169ccef9db0795134adfd4847}{CLUSTER\_CANT\_FAILOVER\_WAITING\_VOTES}:
02783         msg = \textcolor{stringliteral}{"Waiting for votes, but majority still not reached."};
02784         \textcolor{keywordflow}{break};
02785     \textcolor{keywordflow}{default}:
02786         msg = \textcolor{stringliteral}{"Unknown reason code."};
02787         \textcolor{keywordflow}{break};
02788     \}
02789     lastlog\_time = time(NULL);
02790     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Currently unable to failover: %s"}, msg);
02791 \}
02792 
02793 \textcolor{comment}{/* This function implements the final part of automatic and manual failovers,}
02794 \textcolor{comment}{ * where the slave grabs its master's hash slots, and propagates the new}
02795 \textcolor{comment}{ * configuration.}
02796 \textcolor{comment}{ *}
02797 \textcolor{comment}{ * Note that it's up to the caller to be sure that the node got a new}
02798 \textcolor{comment}{ * configuration epoch already. */}
02799 \textcolor{keywordtype}{void} clusterFailoverReplaceYourMaster(\textcolor{keywordtype}{void}) \{
02800     \textcolor{keywordtype}{int} j;
02801     clusterNode *oldmaster = myself->slaveof;
02802 
02803     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(myself) || oldmaster == NULL) \textcolor{keywordflow}{return};
02804 
02805     \textcolor{comment}{/* 1) Turn this node into a master. */}
02806     clusterSetNodeAsMaster(myself);
02807     replicationUnsetMaster();
02808 
02809     \textcolor{comment}{/* 2) Claim all the slots assigned to our master. */}
02810     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}; j++) \{
02811         \textcolor{keywordflow}{if} (clusterNodeGetSlotBit(oldmaster,j)) \{
02812             clusterDelSlot(j);
02813             clusterAddSlot(myself,j);
02814         \}
02815     \}
02816 
02817     \textcolor{comment}{/* 3) Update state and save config. */}
02818     clusterUpdateState();
02819     clusterSaveConfigOrDie(1);
02820 
02821     \textcolor{comment}{/* 4) Pong all the other nodes so that they can update the state}
02822 \textcolor{comment}{     *    accordingly and detect that we switched to master role. */}
02823     clusterBroadcastPong(\hyperlink{cluster_8c_af8bfa0b87c4592863c3ece5242dc4dc4}{CLUSTER\_BROADCAST\_ALL});
02824 
02825     \textcolor{comment}{/* 5) If there was a manual failover in progress, clear the state. */}
02826     resetManualFailover();
02827 \}
02828 
02829 \textcolor{comment}{/* This function is called if we are a slave node and our master serving}
02830 \textcolor{comment}{ * a non-zero amount of hash slots is in FAIL state.}
02831 \textcolor{comment}{ *}
02832 \textcolor{comment}{ * The gaol of this function is:}
02833 \textcolor{comment}{ * 1) To check if we are able to perform a failover, is our data updated?}
02834 \textcolor{comment}{ * 2) Try to get elected by masters.}
02835 \textcolor{comment}{ * 3) Perform the failover informing all the other nodes.}
02836 \textcolor{comment}{ */}
02837 \textcolor{keywordtype}{void} clusterHandleSlaveFailover(\textcolor{keywordtype}{void}) \{
02838     mstime\_t data\_age;
02839     mstime\_t auth\_age = mstime() - server.cluster->failover\_auth\_time;
02840     \textcolor{keywordtype}{int} needed\_quorum = (server.cluster->size / 2) + 1;
02841     \textcolor{keywordtype}{int} manual\_failover = server.cluster->mf\_end != 0 &&
02842                           server.cluster->mf\_can\_start;
02843     mstime\_t auth\_timeout, auth\_retry\_time;
02844 
02845     server.cluster->todo\_before\_sleep &= ~\hyperlink{cluster_8h_afb969dfe84cf59e2340ed10cbf334a47}{CLUSTER\_TODO\_HANDLE\_FAILOVER};
02846 
02847     \textcolor{comment}{/* Compute the failover timeout (the max time we have to send votes}
02848 \textcolor{comment}{     * and wait for replies), and the failover retry time (the time to wait}
02849 \textcolor{comment}{     * before trying to get voted again).}
02850 \textcolor{comment}{     *}
02851 \textcolor{comment}{     * Timeout is MAX(NODE\_TIMEOUT*2,2000) milliseconds.}
02852 \textcolor{comment}{     * Retry is two times the Timeout.}
02853 \textcolor{comment}{     */}
02854     auth\_timeout = server.cluster\_node\_timeout*2;
02855     \textcolor{keywordflow}{if} (auth\_timeout < 2000) auth\_timeout = 2000;
02856     auth\_retry\_time = auth\_timeout*2;
02857 
02858     \textcolor{comment}{/* Pre conditions to run the function, that must be met both in case}
02859 \textcolor{comment}{     * of an automatic or manual failover:}
02860 \textcolor{comment}{     * 1) We are a slave.}
02861 \textcolor{comment}{     * 2) Our master is flagged as FAIL, or this is a manual failover.}
02862 \textcolor{comment}{     * 3) It is serving slots. */}
02863     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(myself) ||
02864         myself->slaveof == NULL ||
02865         (!\hyperlink{cluster_8h_a6a31c614ff4f5ac8ebaa630b0a921c3d}{nodeFailed}(myself->slaveof) && !manual\_failover) ||
02866         myself->slaveof->numslots == 0)
02867     \{
02868         \textcolor{comment}{/* There are no reasons to failover, so we set the reason why we}
02869 \textcolor{comment}{         * are returning without failing over to NONE. */}
02870         server.cluster->cant\_failover\_reason = \hyperlink{cluster_8h_a9a55c4c18a5113bc3c8272f62a983c96}{CLUSTER\_CANT\_FAILOVER\_NONE};
02871         \textcolor{keywordflow}{return};
02872     \}
02873 
02874     \textcolor{comment}{/* Set data\_age to the number of seconds we are disconnected from}
02875 \textcolor{comment}{     * the master. */}
02876     \textcolor{keywordflow}{if} (server.repl\_state == \hyperlink{server_8h_aed693b3a9cdfc05cf5ab7551a8c86fbe}{REPL\_STATE\_CONNECTED}) \{
02877         data\_age = (mstime\_t)(server.unixtime - server.master->lastinteraction)
02878                    * 1000;
02879     \} \textcolor{keywordflow}{else} \{
02880         data\_age = (mstime\_t)(server.unixtime - server.repl\_down\_since) * 1000;
02881     \}
02882 
02883     \textcolor{comment}{/* Remove the node timeout from the data age as it is fine that we are}
02884 \textcolor{comment}{     * disconnected from our master at least for the time it was down to be}
02885 \textcolor{comment}{     * flagged as FAIL, that's the baseline. */}
02886     \textcolor{keywordflow}{if} (data\_age > server.cluster\_node\_timeout)
02887         data\_age -= server.cluster\_node\_timeout;
02888 
02889     \textcolor{comment}{/* Check if our data is recent enough according to the slave validity}
02890 \textcolor{comment}{     * factor configured by the user.}
02891 \textcolor{comment}{     *}
02892 \textcolor{comment}{     * Check bypassed for manual failovers. */}
02893     \textcolor{keywordflow}{if} (server.cluster\_slave\_validity\_factor &&
02894         data\_age >
02895         (((mstime\_t)server.repl\_ping\_slave\_period * 1000) +
02896          (server.cluster\_node\_timeout * server.cluster\_slave\_validity\_factor)))
02897     \{
02898         \textcolor{keywordflow}{if} (!manual\_failover) \{
02899             clusterLogCantFailover(\hyperlink{cluster_8h_a0ad102e4aecc3451096624e2201f4285}{CLUSTER\_CANT\_FAILOVER\_DATA\_AGE});
02900             \textcolor{keywordflow}{return};
02901         \}
02902     \}
02903 
02904     \textcolor{comment}{/* If the previous failover attempt timedout and the retry time has}
02905 \textcolor{comment}{     * elapsed, we can setup a new one. */}
02906     \textcolor{keywordflow}{if} (auth\_age > auth\_retry\_time) \{
02907         server.cluster->failover\_auth\_time = mstime() +
02908             500 + \textcolor{comment}{/* Fixed delay of 500 milliseconds, let FAIL msg propagate. */}
02909             random() % 500; \textcolor{comment}{/* Random delay between 0 and 500 milliseconds. */}
02910         server.cluster->failover\_auth\_count = 0;
02911         server.cluster->failover\_auth\_sent = 0;
02912         server.cluster->failover\_auth\_rank = clusterGetSlaveRank();
02913         \textcolor{comment}{/* We add another delay that is proportional to the slave rank.}
02914 \textcolor{comment}{         * Specifically 1 second * rank. This way slaves that have a probably}
02915 \textcolor{comment}{         * less updated replication offset, are penalized. */}
02916         server.cluster->failover\_auth\_time +=
02917             server.cluster->failover\_auth\_rank * 1000;
02918         \textcolor{comment}{/* However if this is a manual failover, no delay is needed. */}
02919         \textcolor{keywordflow}{if} (server.cluster->mf\_end) \{
02920             server.cluster->failover\_auth\_time = mstime();
02921             server.cluster->failover\_auth\_rank = 0;
02922         \}
02923         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
02924             \textcolor{stringliteral}{"Start of election delayed for %lld milliseconds "}
02925             \textcolor{stringliteral}{"(rank #%d, offset %lld)."},
02926             server.cluster->failover\_auth\_time - mstime(),
02927             server.cluster->failover\_auth\_rank,
02928             replicationGetSlaveOffset());
02929         \textcolor{comment}{/* Now that we have a scheduled election, broadcast our offset}
02930 \textcolor{comment}{         * to all the other slaves so that they'll updated their offsets}
02931 \textcolor{comment}{         * if our offset is better. */}
02932         clusterBroadcastPong(\hyperlink{cluster_8c_a49481f5cedbd75ce025011b331021822}{CLUSTER\_BROADCAST\_LOCAL\_SLAVES});
02933         \textcolor{keywordflow}{return};
02934     \}
02935 
02936     \textcolor{comment}{/* It is possible that we received more updated offsets from other}
02937 \textcolor{comment}{     * slaves for the same master since we computed our election delay.}
02938 \textcolor{comment}{     * Update the delay if our rank changed.}
02939 \textcolor{comment}{     *}
02940 \textcolor{comment}{     * Not performed if this is a manual failover. */}
02941     \textcolor{keywordflow}{if} (server.cluster->failover\_auth\_sent == 0 &&
02942         server.cluster->mf\_end == 0)
02943     \{
02944         \textcolor{keywordtype}{int} newrank = clusterGetSlaveRank();
02945         \textcolor{keywordflow}{if} (newrank > server.cluster->failover\_auth\_rank) \{
02946             \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} added\_delay =
02947                 (newrank - server.cluster->failover\_auth\_rank) * 1000;
02948             server.cluster->failover\_auth\_time += added\_delay;
02949             server.cluster->failover\_auth\_rank = newrank;
02950             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
02951                 \textcolor{stringliteral}{"Slave rank updated to #%d, added %lld milliseconds of delay."},
02952                 newrank, added\_delay);
02953         \}
02954     \}
02955 
02956     \textcolor{comment}{/* Return ASAP if we can't still start the election. */}
02957     \textcolor{keywordflow}{if} (mstime() < server.cluster->failover\_auth\_time) \{
02958         clusterLogCantFailover(\hyperlink{cluster_8h_a40e58ef928e66a27912835d7e6a1c97a}{CLUSTER\_CANT\_FAILOVER\_WAITING\_DELAY})
      ;
02959         \textcolor{keywordflow}{return};
02960     \}
02961 
02962     \textcolor{comment}{/* Return ASAP if the election is too old to be valid. */}
02963     \textcolor{keywordflow}{if} (auth\_age > auth\_timeout) \{
02964         clusterLogCantFailover(\hyperlink{cluster_8h_af0085657cacf54e82c477680571f7509}{CLUSTER\_CANT\_FAILOVER\_EXPIRED});
02965         \textcolor{keywordflow}{return};
02966     \}
02967 
02968     \textcolor{comment}{/* Ask for votes if needed. */}
02969     \textcolor{keywordflow}{if} (server.cluster->failover\_auth\_sent == 0) \{
02970         server.cluster->currentEpoch++;
02971         server.cluster->failover\_auth\_epoch = server.cluster->currentEpoch;
02972         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Starting a failover election for epoch %llu."},
02973             (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) server.cluster->currentEpoch);
02974         clusterRequestFailoverAuth();
02975         server.cluster->failover\_auth\_sent = 1;
02976         clusterDoBeforeSleep(\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG}|
02977                              \hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE}|
02978                              \hyperlink{cluster_8h_accc9a00230cd04789db2398bb3ab715a}{CLUSTER\_TODO\_FSYNC\_CONFIG});
02979         \textcolor{keywordflow}{return}; \textcolor{comment}{/* Wait for replies. */}
02980     \}
02981 
02982     \textcolor{comment}{/* Check if we reached the quorum. */}
02983     \textcolor{keywordflow}{if} (server.cluster->failover\_auth\_count >= needed\_quorum) \{
02984         \textcolor{comment}{/* We have the quorum, we can finally failover the master. */}
02985 
02986         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
02987             \textcolor{stringliteral}{"Failover election won: I'm the new master."});
02988 
02989         \textcolor{comment}{/* Update my configEpoch to the epoch of the election. */}
02990         \textcolor{keywordflow}{if} (myself->configEpoch < server.cluster->failover\_auth\_epoch) \{
02991             myself->configEpoch = server.cluster->failover\_auth\_epoch;
02992             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
02993                 \textcolor{stringliteral}{"configEpoch set to %llu after successful failover"},
02994                 (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) myself->configEpoch);
02995         \}
02996 
02997         \textcolor{comment}{/* Take responsability for the cluster slots. */}
02998         clusterFailoverReplaceYourMaster();
02999     \} \textcolor{keywordflow}{else} \{
03000         clusterLogCantFailover(\hyperlink{cluster_8h_abaf73be169ccef9db0795134adfd4847}{CLUSTER\_CANT\_FAILOVER\_WAITING\_VOTES})
      ;
03001     \}
03002 \}
03003 
03004 \textcolor{comment}{/* -----------------------------------------------------------------------------}
03005 \textcolor{comment}{ * CLUSTER slave migration}
03006 \textcolor{comment}{ *}
03007 \textcolor{comment}{ * Slave migration is the process that allows a slave of a master that is}
03008 \textcolor{comment}{ * already covered by at least another slave, to "migrate" to a master that}
03009 \textcolor{comment}{ * is orpaned, that is, left with no working slaves.}
03010 \textcolor{comment}{ * ------------------------------------------------------------------------- */}
03011 
03012 \textcolor{comment}{/* This function is responsible to decide if this replica should be migrated}
03013 \textcolor{comment}{ * to a different (orphaned) master. It is called by the clusterCron() function}
03014 \textcolor{comment}{ * only if:}
03015 \textcolor{comment}{ *}
03016 \textcolor{comment}{ * 1) We are a slave node.}
03017 \textcolor{comment}{ * 2) It was detected that there is at least one orphaned master in}
03018 \textcolor{comment}{ *    the cluster.}
03019 \textcolor{comment}{ * 3) We are a slave of one of the masters with the greatest number of}
03020 \textcolor{comment}{ *    slaves.}
03021 \textcolor{comment}{ *}
03022 \textcolor{comment}{ * This checks are performed by the caller since it requires to iterate}
03023 \textcolor{comment}{ * the nodes anyway, so we spend time into clusterHandleSlaveMigration()}
03024 \textcolor{comment}{ * if definitely needed.}
03025 \textcolor{comment}{ *}
03026 \textcolor{comment}{ * The fuction is called with a pre-computed max\_slaves, that is the max}
03027 \textcolor{comment}{ * number of working (not in FAIL state) slaves for a single master.}
03028 \textcolor{comment}{ *}
03029 \textcolor{comment}{ * Additional conditions for migration are examined inside the function.}
03030 \textcolor{comment}{ */}
03031 \textcolor{keywordtype}{void} clusterHandleSlaveMigration(\textcolor{keywordtype}{int} max\_slaves) \{
03032     \textcolor{keywordtype}{int} j, okslaves = 0;
03033     clusterNode *mymaster = myself->slaveof, *target = NULL, *candidate = NULL;
03034     dictIterator *di;
03035     dictEntry *de;
03036 
03037     \textcolor{comment}{/* Step 1: Don't migrate if the cluster state is not ok. */}
03038     \textcolor{keywordflow}{if} (server.cluster->state != \hyperlink{cluster_8h_adbda03922c45cac3cfc98a5c34a9d2d2}{CLUSTER\_OK}) \textcolor{keywordflow}{return};
03039 
03040     \textcolor{comment}{/* Step 2: Don't migrate if my master will not be left with at least}
03041 \textcolor{comment}{     *         'migration-barrier' slaves after my migration. */}
03042     \textcolor{keywordflow}{if} (mymaster == NULL) \textcolor{keywordflow}{return};
03043     \textcolor{keywordflow}{for} (j = 0; j < mymaster->numslaves; j++)
03044         \textcolor{keywordflow}{if} (!\hyperlink{cluster_8h_a6a31c614ff4f5ac8ebaa630b0a921c3d}{nodeFailed}(mymaster->slaves[j]) &&
03045             !\hyperlink{cluster_8h_ac0ab1cbdbc2a49b30c98d73640476e32}{nodeTimedOut}(mymaster->slaves[j])) okslaves++;
03046     \textcolor{keywordflow}{if} (okslaves <= server.cluster\_migration\_barrier) \textcolor{keywordflow}{return};
03047 
03048     \textcolor{comment}{/* Step 3: Idenitfy a candidate for migration, and check if among the}
03049 \textcolor{comment}{     * masters with the greatest number of ok slaves, I'm the one with the}
03050 \textcolor{comment}{     * smallest node ID (the "candidate slave").}
03051 \textcolor{comment}{     *}
03052 \textcolor{comment}{     * Note: this means that eventually a replica migration will occurr}
03053 \textcolor{comment}{     * since slaves that are reachable again always have their FAIL flag}
03054 \textcolor{comment}{     * cleared, so eventually there must be a candidate. At the same time}
03055 \textcolor{comment}{     * this does not mean that there are no race conditions possible (two}
03056 \textcolor{comment}{     * slaves migrating at the same time), but this is unlikely to}
03057 \textcolor{comment}{     * happen, and harmless when happens. */}
03058     candidate = myself;
03059     di = dictGetSafeIterator(server.cluster->nodes);
03060     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
03061         clusterNode *node = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
03062         \textcolor{keywordtype}{int} okslaves = 0, is\_orphaned = 1;
03063 
03064         \textcolor{comment}{/* We want to migrate only if this master is working, orphaned, and}
03065 \textcolor{comment}{         * used to have slaves or if failed over a master that had slaves}
03066 \textcolor{comment}{         * (MIGRATE\_TO flag). This way we only migrate to instances that were}
03067 \textcolor{comment}{         * supposed to have replicas. */}
03068         \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(node) || \hyperlink{cluster_8h_a6a31c614ff4f5ac8ebaa630b0a921c3d}{nodeFailed}(node)) is\_orphaned = 0;
03069         \textcolor{keywordflow}{if} (!(node->flags & \hyperlink{cluster_8h_a1d5a62356ed9f5986613c2315a358119}{CLUSTER\_NODE\_MIGRATE\_TO})) is\_orphaned = 0;
03070 
03071         \textcolor{comment}{/* Check number of working slaves. */}
03072         \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(node)) okslaves = clusterCountNonFailingSlaves(node);
03073         \textcolor{keywordflow}{if} (okslaves > 0) is\_orphaned = 0;
03074 
03075         \textcolor{keywordflow}{if} (is\_orphaned) \{
03076             \textcolor{keywordflow}{if} (!target && node->numslots > 0) target = node;
03077 
03078             \textcolor{comment}{/* Track the starting time of the orphaned condition for this}
03079 \textcolor{comment}{             * master. */}
03080             \textcolor{keywordflow}{if} (!node->orphaned\_time) node->orphaned\_time = mstime();
03081         \} \textcolor{keywordflow}{else} \{
03082             node->orphaned\_time = 0;
03083         \}
03084 
03085         \textcolor{comment}{/* Check if I'm the slave candidate for the migration: attached}
03086 \textcolor{comment}{         * to a master with the maximum number of slaves and with the smallest}
03087 \textcolor{comment}{         * node ID. */}
03088         \textcolor{keywordflow}{if} (okslaves == max\_slaves) \{
03089             \textcolor{keywordflow}{for} (j = 0; j < node->numslaves; j++) \{
03090                 \textcolor{keywordflow}{if} (memcmp(node->slaves[j]->name,
03091                            candidate->name,
03092                            \hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN}) < 0)
03093                 \{
03094                     candidate = node->slaves[j];
03095                 \}
03096             \}
03097         \}
03098     \}
03099     dictReleaseIterator(di);
03100 
03101     \textcolor{comment}{/* Step 4: perform the migration if there is a target, and if I'm the}
03102 \textcolor{comment}{     * candidate, but only if the master is continuously orphaned for a}
03103 \textcolor{comment}{     * couple of seconds, so that during failovers, we give some time to}
03104 \textcolor{comment}{     * the natural slaves of this instance to advertise their switch from}
03105 \textcolor{comment}{     * the old master to the new one. */}
03106     \textcolor{keywordflow}{if} (target && candidate == myself &&
03107         (mstime()-target->orphaned\_time) > \hyperlink{cluster_8h_a6379f60d426f37f755440776cb9cc88e}{CLUSTER\_SLAVE\_MIGRATION\_DELAY})
03108     \{
03109         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Migrating to orphaned master %.40s"},
03110             target->name);
03111         clusterSetMaster(target);
03112     \}
03113 \}
03114 
03115 \textcolor{comment}{/* -----------------------------------------------------------------------------}
03116 \textcolor{comment}{ * CLUSTER manual failover}
03117 \textcolor{comment}{ *}
03118 \textcolor{comment}{ * This are the important steps performed by slaves during a manual failover:}
03119 \textcolor{comment}{ * 1) User send CLUSTER FAILOVER command. The failover state is initialized}
03120 \textcolor{comment}{ *    setting mf\_end to the millisecond unix time at which we'll abort the}
03121 \textcolor{comment}{ *    attempt.}
03122 \textcolor{comment}{ * 2) Slave sends a MFSTART message to the master requesting to pause clients}
03123 \textcolor{comment}{ *    for two times the manual failover timeout CLUSTER\_MF\_TIMEOUT.}
03124 \textcolor{comment}{ *    When master is paused for manual failover, it also starts to flag}
03125 \textcolor{comment}{ *    packets with CLUSTERMSG\_FLAG0\_PAUSED.}
03126 \textcolor{comment}{ * 3) Slave waits for master to send its replication offset flagged as PAUSED.}
03127 \textcolor{comment}{ * 4) If slave received the offset from the master, and its offset matches,}
03128 \textcolor{comment}{ *    mf\_can\_start is set to 1, and clusterHandleSlaveFailover() will perform}
03129 \textcolor{comment}{ *    the failover as usually, with the difference that the vote request}
03130 \textcolor{comment}{ *    will be modified to force masters to vote for a slave that has a}
03131 \textcolor{comment}{ *    working master.}
03132 \textcolor{comment}{ *}
03133 \textcolor{comment}{ * From the point of view of the master things are simpler: when a}
03134 \textcolor{comment}{ * PAUSE\_CLIENTS packet is received the master sets mf\_end as well and}
03135 \textcolor{comment}{ * the sender in mf\_slave. During the time limit for the manual failover}
03136 \textcolor{comment}{ * the master will just send PINGs more often to this slave, flagged with}
03137 \textcolor{comment}{ * the PAUSED flag, so that the slave will set mf\_master\_offset when receiving}
03138 \textcolor{comment}{ * a packet from the master with this flag set.}
03139 \textcolor{comment}{ *}
03140 \textcolor{comment}{ * The gaol of the manual failover is to perform a fast failover without}
03141 \textcolor{comment}{ * data loss due to the asynchronous master-slave replication.}
03142 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
03143 
03144 \textcolor{comment}{/* Reset the manual failover state. This works for both masters and slavesa}
03145 \textcolor{comment}{ * as all the state about manual failover is cleared.}
03146 \textcolor{comment}{ *}
03147 \textcolor{comment}{ * The function can be used both to initialize the manual failover state at}
03148 \textcolor{comment}{ * startup or to abort a manual failover in progress. */}
03149 \textcolor{keywordtype}{void} resetManualFailover(\textcolor{keywordtype}{void}) \{
03150     \textcolor{keywordflow}{if} (server.cluster->mf\_end && clientsArePaused()) \{
03151         server.clients\_pause\_end\_time = 0;
03152         clientsArePaused(); \textcolor{comment}{/* Just use the side effect of the function. */}
03153     \}
03154     server.cluster->mf\_end = 0; \textcolor{comment}{/* No manual failover in progress. */}
03155     server.cluster->mf\_can\_start = 0;
03156     server.cluster->mf\_slave = NULL;
03157     server.cluster->mf\_master\_offset = 0;
03158 \}
03159 
03160 \textcolor{comment}{/* If a manual failover timed out, abort it. */}
03161 \textcolor{keywordtype}{void} manualFailoverCheckTimeout(\textcolor{keywordtype}{void}) \{
03162     \textcolor{keywordflow}{if} (server.cluster->mf\_end && server.cluster->mf\_end < mstime()) \{
03163         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Manual failover timed out."});
03164         resetManualFailover();
03165     \}
03166 \}
03167 
03168 \textcolor{comment}{/* This function is called from the cluster cron function in order to go}
03169 \textcolor{comment}{ * forward with a manual failover state machine. */}
03170 \textcolor{keywordtype}{void} clusterHandleManualFailover(\textcolor{keywordtype}{void}) \{
03171     \textcolor{comment}{/* Return ASAP if no manual failover is in progress. */}
03172     \textcolor{keywordflow}{if} (server.cluster->mf\_end == 0) \textcolor{keywordflow}{return};
03173 
03174     \textcolor{comment}{/* If mf\_can\_start is non-zero, the failover was already triggered so the}
03175 \textcolor{comment}{     * next steps are performed by clusterHandleSlaveFailover(). */}
03176     \textcolor{keywordflow}{if} (server.cluster->mf\_can\_start) \textcolor{keywordflow}{return};
03177 
03178     \textcolor{keywordflow}{if} (server.cluster->mf\_master\_offset == 0) \textcolor{keywordflow}{return}; \textcolor{comment}{/* Wait for offset... */}
03179 
03180     \textcolor{keywordflow}{if} (server.cluster->mf\_master\_offset == replicationGetSlaveOffset()) \{
03181         \textcolor{comment}{/* Our replication offset matches the master replication offset}
03182 \textcolor{comment}{         * announced after clients were paused. We can start the failover. */}
03183         server.cluster->mf\_can\_start = 1;
03184         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
03185             \textcolor{stringliteral}{"All master replication stream processed, "}
03186             \textcolor{stringliteral}{"manual failover can start."});
03187     \}
03188 \}
03189 
03190 \textcolor{comment}{/* -----------------------------------------------------------------------------}
03191 \textcolor{comment}{ * CLUSTER cron job}
03192 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
03193 
03194 \textcolor{comment}{/* This is executed 10 times every second */}
03195 \textcolor{keywordtype}{void} clusterCron(\textcolor{keywordtype}{void}) \{
03196     dictIterator *di;
03197     dictEntry *de;
03198     \textcolor{keywordtype}{int} update\_state = 0;
03199     \textcolor{keywordtype}{int} orphaned\_masters; \textcolor{comment}{/* How many masters there are without ok slaves. */}
03200     \textcolor{keywordtype}{int} max\_slaves; \textcolor{comment}{/* Max number of ok slaves for a single master. */}
03201     \textcolor{keywordtype}{int} this\_slaves; \textcolor{comment}{/* Number of ok slaves for our master (if we are slave). */}
03202     mstime\_t min\_pong = 0, now = mstime();
03203     clusterNode *min\_pong\_node = NULL;
03204     \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} iteration = 0;
03205     mstime\_t handshake\_timeout;
03206 
03207     iteration++; \textcolor{comment}{/* Number of times this function was called so far. */}
03208 
03209     \textcolor{comment}{/* We want to take myself->ip in sync with the cluster-announce-ip option.}
03210 \textcolor{comment}{     * The option can be set at runtime via CONFIG SET, so we periodically check}
03211 \textcolor{comment}{     * if the option changed to reflect this into myself->ip. */}
03212     \{
03213         \textcolor{keyword}{static} \textcolor{keywordtype}{char} *prev\_ip = NULL;
03214         \textcolor{keywordtype}{char} *curr\_ip = server.cluster\_announce\_ip;
03215         \textcolor{keywordtype}{int} changed = 0;
03216 
03217         \textcolor{keywordflow}{if} (prev\_ip == NULL && curr\_ip != NULL) changed = 1;
03218         \textcolor{keywordflow}{if} (prev\_ip != NULL && curr\_ip == NULL) changed = 1;
03219         \textcolor{keywordflow}{if} (prev\_ip && curr\_ip && strcmp(prev\_ip,curr\_ip)) changed = 1;
03220 
03221         \textcolor{keywordflow}{if} (changed) \{
03222             prev\_ip = curr\_ip;
03223             \textcolor{keywordflow}{if} (prev\_ip) prev\_ip = zstrdup(prev\_ip);
03224 
03225             \textcolor{keywordflow}{if} (curr\_ip) \{
03226                 strncpy(myself->ip,server.cluster\_announce\_ip,
      \hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN});
03227                 myself->ip[\hyperlink{server_8h_ad97c5405ed22a94e9fcc10fba577d6c0}{NET\_IP\_STR\_LEN}-1] = \textcolor{stringliteral}{'\(\backslash\)0'};
03228             \} \textcolor{keywordflow}{else} \{
03229                 myself->ip[0] = \textcolor{stringliteral}{'\(\backslash\)0'}; \textcolor{comment}{/* Force autodetection. */}
03230             \}
03231         \}
03232     \}
03233 
03234     \textcolor{comment}{/* The handshake timeout is the time after which a handshake node that was}
03235 \textcolor{comment}{     * not turned into a normal node is removed from the nodes. Usually it is}
03236 \textcolor{comment}{     * just the NODE\_TIMEOUT value, but when NODE\_TIMEOUT is too small we use}
03237 \textcolor{comment}{     * the value of 1 second. */}
03238     handshake\_timeout = server.cluster\_node\_timeout;
03239     \textcolor{keywordflow}{if} (handshake\_timeout < 1000) handshake\_timeout = 1000;
03240 
03241     \textcolor{comment}{/* Check if we have disconnected nodes and re-establish the connection.}
03242 \textcolor{comment}{     * Also update a few stats while we are here, that can be used to make}
03243 \textcolor{comment}{     * better decisions in other part of the code. */}
03244     di = dictGetSafeIterator(server.cluster->nodes);
03245     server.cluster->stats\_pfail\_nodes = 0;
03246     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
03247         clusterNode *node = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
03248 
03249         \textcolor{comment}{/* Not interested in reconnecting the link with myself or nodes}
03250 \textcolor{comment}{         * for which we have no address. */}
03251         \textcolor{keywordflow}{if} (node->flags & (\hyperlink{cluster_8h_afee946c4e74c08465e9b4ead5e3659e6}{CLUSTER\_NODE\_MYSELF}|
      \hyperlink{cluster_8h_a2bbed8bf0615871a01ca8b7f691b56d8}{CLUSTER\_NODE\_NOADDR})) \textcolor{keywordflow}{continue};
03252 
03253         \textcolor{keywordflow}{if} (node->flags & \hyperlink{cluster_8h_a5306c1ae8988b8be0a1a02bd9162dfa1}{CLUSTER\_NODE\_PFAIL})
03254             server.cluster->stats\_pfail\_nodes++;
03255 
03256         \textcolor{comment}{/* A Node in HANDSHAKE state has a limited lifespan equal to the}
03257 \textcolor{comment}{         * configured node timeout. */}
03258         \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a70f1a5bb82f54ce5d17b13de42176790}{nodeInHandshake}(node) && now - node->ctime > handshake\_timeout) \{
03259             clusterDelNode(node);
03260             \textcolor{keywordflow}{continue};
03261         \}
03262 
03263         \textcolor{keywordflow}{if} (node->link == NULL) \{
03264             \textcolor{keywordtype}{int} fd;
03265             mstime\_t old\_ping\_sent;
03266             clusterLink *link;
03267 
03268             fd = anetTcpNonBlockBindConnect(server.neterr, node->ip,
03269                 node->cport, \hyperlink{server_8h_a53b900c09238a4ff78e0af9574335dfd}{NET\_FIRST\_BIND\_ADDR});
03270             \textcolor{keywordflow}{if} (fd == -1) \{
03271                 \textcolor{comment}{/* We got a synchronous error from connect before}
03272 \textcolor{comment}{                 * clusterSendPing() had a chance to be called.}
03273 \textcolor{comment}{                 * If node->ping\_sent is zero, failure detection can't work,}
03274 \textcolor{comment}{                 * so we claim we actually sent a ping now (that will}
03275 \textcolor{comment}{                 * be really sent as soon as the link is obtained). */}
03276                 \textcolor{keywordflow}{if} (node->ping\_sent == 0) node->ping\_sent = mstime();
03277                 serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG}, \textcolor{stringliteral}{"Unable to connect to "}
03278                     \textcolor{stringliteral}{"Cluster Node [%s]:%d -> %s"}, node->ip,
03279                     node->cport, server.neterr);
03280                 \textcolor{keywordflow}{continue};
03281             \}
03282             link = createClusterLink(node);
03283             link->fd = fd;
03284             node->link = link;
03285             aeCreateFileEvent(server.el,link->fd,\hyperlink{ae_8h_a7a9a2162d007d09739955b4e55c65bf3}{AE\_READABLE},
03286                     clusterReadHandler,link);
03287             \textcolor{comment}{/* Queue a PING in the new connection ASAP: this is crucial}
03288 \textcolor{comment}{             * to avoid false positives in failure detection.}
03289 \textcolor{comment}{             *}
03290 \textcolor{comment}{             * If the node is flagged as MEET, we send a MEET message instead}
03291 \textcolor{comment}{             * of a PING one, to force the receiver to add us in its node}
03292 \textcolor{comment}{             * table. */}
03293             old\_ping\_sent = node->ping\_sent;
03294             clusterSendPing(link, node->flags & \hyperlink{cluster_8h_ad992a5c70af8bc805aae5405106ff9f7}{CLUSTER\_NODE\_MEET} ?
03295                     \hyperlink{cluster_8h_aaf264f57ae1869c57093fd9fbc6fc5bc}{CLUSTERMSG\_TYPE\_MEET} : 
      \hyperlink{cluster_8h_aeb8a936505e22f64e5039523a3c96d4c}{CLUSTERMSG\_TYPE\_PING});
03296             \textcolor{keywordflow}{if} (old\_ping\_sent) \{
03297                 \textcolor{comment}{/* If there was an active ping before the link was}
03298 \textcolor{comment}{                 * disconnected, we want to restore the ping time, otherwise}
03299 \textcolor{comment}{                 * replaced by the clusterSendPing() call. */}
03300                 node->ping\_sent = old\_ping\_sent;
03301             \}
03302             \textcolor{comment}{/* We can clear the flag after the first packet is sent.}
03303 \textcolor{comment}{             * If we'll never receive a PONG, we'll never send new packets}
03304 \textcolor{comment}{             * to this node. Instead after the PONG is received and we}
03305 \textcolor{comment}{             * are no longer in meet/handshake status, we want to send}
03306 \textcolor{comment}{             * normal PING packets. */}
03307             node->flags &= ~\hyperlink{cluster_8h_ad992a5c70af8bc805aae5405106ff9f7}{CLUSTER\_NODE\_MEET};
03308 
03309             serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG},\textcolor{stringliteral}{"Connecting with Node %.40s at %s:%d"},
03310                     node->name, node->ip, node->cport);
03311         \}
03312     \}
03313     dictReleaseIterator(di);
03314 
03315     \textcolor{comment}{/* Ping some random node 1 time every 10 iterations, so that we usually ping}
03316 \textcolor{comment}{     * one random node every second. */}
03317     \textcolor{keywordflow}{if} (!(iteration % 10)) \{
03318         \textcolor{keywordtype}{int} j;
03319 
03320         \textcolor{comment}{/* Check a few random nodes and ping the one with the oldest}
03321 \textcolor{comment}{         * pong\_received time. */}
03322         \textcolor{keywordflow}{for} (j = 0; j < 5; j++) \{
03323             de = dictGetRandomKey(server.cluster->nodes);
03324             clusterNode *\textcolor{keyword}{this} = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
03325 
03326             \textcolor{comment}{/* Don't ping nodes disconnected or with a ping currently active. */}
03327             \textcolor{keywordflow}{if} (\textcolor{keyword}{this}->link == NULL || \textcolor{keyword}{this}->ping\_sent != 0) \textcolor{keywordflow}{continue};
03328             \textcolor{keywordflow}{if} (\textcolor{keyword}{this}->flags & (\hyperlink{cluster_8h_afee946c4e74c08465e9b4ead5e3659e6}{CLUSTER\_NODE\_MYSELF}|
      \hyperlink{cluster_8h_a60571342a067f1e5772a04b36feff6a6}{CLUSTER\_NODE\_HANDSHAKE}))
03329                 \textcolor{keywordflow}{continue};
03330             \textcolor{keywordflow}{if} (min\_pong\_node == NULL || min\_pong > \textcolor{keyword}{this}->pong\_received) \{
03331                 min\_pong\_node = \textcolor{keyword}{this};
03332                 min\_pong = \textcolor{keyword}{this}->pong\_received;
03333             \}
03334         \}
03335         \textcolor{keywordflow}{if} (min\_pong\_node) \{
03336             serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG},\textcolor{stringliteral}{"Pinging node %.40s"}, min\_pong\_node->name);
03337             clusterSendPing(min\_pong\_node->link, \hyperlink{cluster_8h_aeb8a936505e22f64e5039523a3c96d4c}{CLUSTERMSG\_TYPE\_PING});
03338         \}
03339     \}
03340 
03341     \textcolor{comment}{/* Iterate nodes to check if we need to flag something as failing.}
03342 \textcolor{comment}{     * This loop is also responsible to:}
03343 \textcolor{comment}{     * 1) Check if there are orphaned masters (masters without non failing}
03344 \textcolor{comment}{     *    slaves).}
03345 \textcolor{comment}{     * 2) Count the max number of non failing slaves for a single master.}
03346 \textcolor{comment}{     * 3) Count the number of slaves for our master, if we are a slave. */}
03347     orphaned\_masters = 0;
03348     max\_slaves = 0;
03349     this\_slaves = 0;
03350     di = dictGetSafeIterator(server.cluster->nodes);
03351     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
03352         clusterNode *node = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
03353         now = mstime(); \textcolor{comment}{/* Use an updated time at every iteration. */}
03354         mstime\_t delay;
03355 
03356         \textcolor{keywordflow}{if} (node->flags &
03357             (\hyperlink{cluster_8h_afee946c4e74c08465e9b4ead5e3659e6}{CLUSTER\_NODE\_MYSELF}|\hyperlink{cluster_8h_a2bbed8bf0615871a01ca8b7f691b56d8}{CLUSTER\_NODE\_NOADDR}|
      \hyperlink{cluster_8h_a60571342a067f1e5772a04b36feff6a6}{CLUSTER\_NODE\_HANDSHAKE}))
03358                 \textcolor{keywordflow}{continue};
03359 
03360         \textcolor{comment}{/* Orphaned master check, useful only if the current instance}
03361 \textcolor{comment}{         * is a slave that may migrate to another master. */}
03362         \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(myself) && \hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(node) && !
      \hyperlink{cluster_8h_a6a31c614ff4f5ac8ebaa630b0a921c3d}{nodeFailed}(node)) \{
03363             \textcolor{keywordtype}{int} okslaves = clusterCountNonFailingSlaves(node);
03364 
03365             \textcolor{comment}{/* A master is orphaned if it is serving a non-zero number of}
03366 \textcolor{comment}{             * slots, have no working slaves, but used to have at least one}
03367 \textcolor{comment}{             * slave, or failed over a master that used to have slaves. */}
03368             \textcolor{keywordflow}{if} (okslaves == 0 && node->numslots > 0 &&
03369                 node->flags & \hyperlink{cluster_8h_a1d5a62356ed9f5986613c2315a358119}{CLUSTER\_NODE\_MIGRATE\_TO})
03370             \{
03371                 orphaned\_masters++;
03372             \}
03373             \textcolor{keywordflow}{if} (okslaves > max\_slaves) max\_slaves = okslaves;
03374             \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(myself) && myself->slaveof == node)
03375                 this\_slaves = okslaves;
03376         \}
03377 
03378         \textcolor{comment}{/* If we are waiting for the PONG more than half the cluster}
03379 \textcolor{comment}{         * timeout, reconnect the link: maybe there is a connection}
03380 \textcolor{comment}{         * issue even if the node is alive. */}
03381         \textcolor{keywordflow}{if} (node->link && \textcolor{comment}{/* is connected */}
03382             now - node->link->ctime >
03383             server.cluster\_node\_timeout && \textcolor{comment}{/* was not already reconnected */}
03384             node->ping\_sent && \textcolor{comment}{/* we already sent a ping */}
03385             node->pong\_received < node->ping\_sent && \textcolor{comment}{/* still waiting pong */}
03386             \textcolor{comment}{/* and we are waiting for the pong more than timeout/2 */}
03387             now - node->ping\_sent > server.cluster\_node\_timeout/2)
03388         \{
03389             \textcolor{comment}{/* Disconnect the link, it will be reconnected automatically. */}
03390             freeClusterLink(node->link);
03391         \}
03392 
03393         \textcolor{comment}{/* If we have currently no active ping in this instance, and the}
03394 \textcolor{comment}{         * received PONG is older than half the cluster timeout, send}
03395 \textcolor{comment}{         * a new ping now, to ensure all the nodes are pinged without}
03396 \textcolor{comment}{         * a too big delay. */}
03397         \textcolor{keywordflow}{if} (node->link &&
03398             node->ping\_sent == 0 &&
03399             (now - node->pong\_received) > server.cluster\_node\_timeout/2)
03400         \{
03401             clusterSendPing(node->link, \hyperlink{cluster_8h_aeb8a936505e22f64e5039523a3c96d4c}{CLUSTERMSG\_TYPE\_PING});
03402             \textcolor{keywordflow}{continue};
03403         \}
03404 
03405         \textcolor{comment}{/* If we are a master and one of the slaves requested a manual}
03406 \textcolor{comment}{         * failover, ping it continuously. */}
03407         \textcolor{keywordflow}{if} (server.cluster->mf\_end &&
03408             \hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(myself) &&
03409             server.cluster->mf\_slave == node &&
03410             node->link)
03411         \{
03412             clusterSendPing(node->link, \hyperlink{cluster_8h_aeb8a936505e22f64e5039523a3c96d4c}{CLUSTERMSG\_TYPE\_PING});
03413             \textcolor{keywordflow}{continue};
03414         \}
03415 
03416         \textcolor{comment}{/* Check only if we have an active ping for this instance. */}
03417         \textcolor{keywordflow}{if} (node->ping\_sent == 0) \textcolor{keywordflow}{continue};
03418 
03419         \textcolor{comment}{/* Compute the delay of the PONG. Note that if we already received}
03420 \textcolor{comment}{         * the PONG, then node->ping\_sent is zero, so can't reach this}
03421 \textcolor{comment}{         * code at all. */}
03422         delay = now - node->ping\_sent;
03423 
03424         \textcolor{keywordflow}{if} (delay > server.cluster\_node\_timeout) \{
03425             \textcolor{comment}{/* Timeout reached. Set the node as possibly failing if it is}
03426 \textcolor{comment}{             * not already in this state. */}
03427             \textcolor{keywordflow}{if} (!(node->flags & (\hyperlink{cluster_8h_a5306c1ae8988b8be0a1a02bd9162dfa1}{CLUSTER\_NODE\_PFAIL}|
      \hyperlink{cluster_8h_ad211e85c7baf8a5a59acd747e4e9005a}{CLUSTER\_NODE\_FAIL}))) \{
03428                 serverLog(\hyperlink{server_8h_abcaffe365dee628fcf9fc90c69d534a1}{LL\_DEBUG},\textcolor{stringliteral}{"*** NODE %.40s possibly failing"},
03429                     node->name);
03430                 node->flags |= \hyperlink{cluster_8h_a5306c1ae8988b8be0a1a02bd9162dfa1}{CLUSTER\_NODE\_PFAIL};
03431                 update\_state = 1;
03432             \}
03433         \}
03434     \}
03435     dictReleaseIterator(di);
03436 
03437     \textcolor{comment}{/* If we are a slave node but the replication is still turned off,}
03438 \textcolor{comment}{     * enable it if we know the address of our master and it appears to}
03439 \textcolor{comment}{     * be up. */}
03440     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(myself) &&
03441         server.masterhost == NULL &&
03442         myself->slaveof &&
03443         \hyperlink{cluster_8h_ad1197dcefeb1bdf0cf163aacd971fbff}{nodeHasAddr}(myself->slaveof))
03444     \{
03445         replicationSetMaster(myself->slaveof->ip, myself->slaveof->port);
03446     \}
03447 
03448     \textcolor{comment}{/* Abourt a manual failover if the timeout is reached. */}
03449     manualFailoverCheckTimeout();
03450 
03451     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(myself)) \{
03452         clusterHandleManualFailover();
03453         clusterHandleSlaveFailover();
03454         \textcolor{comment}{/* If there are orphaned slaves, and we are a slave among the masters}
03455 \textcolor{comment}{         * with the max number of non-failing slaves, consider migrating to}
03456 \textcolor{comment}{         * the orphaned masters. Note that it does not make sense to try}
03457 \textcolor{comment}{         * a migration if there is no master with at least *two* working}
03458 \textcolor{comment}{         * slaves. */}
03459         \textcolor{keywordflow}{if} (orphaned\_masters && max\_slaves >= 2 && this\_slaves == max\_slaves)
03460             clusterHandleSlaveMigration(max\_slaves);
03461     \}
03462 
03463     \textcolor{keywordflow}{if} (update\_state || server.cluster->state == \hyperlink{cluster_8h_a4a46e6d5b85c594d08283dc6da2a32bf}{CLUSTER\_FAIL})
03464         clusterUpdateState();
03465 \}
03466 
03467 \textcolor{comment}{/* This function is called before the event handler returns to sleep for}
03468 \textcolor{comment}{ * events. It is useful to perform operations that must be done ASAP in}
03469 \textcolor{comment}{ * reaction to events fired but that are not safe to perform inside event}
03470 \textcolor{comment}{ * handlers, or to perform potentially expansive tasks that we need to do}
03471 \textcolor{comment}{ * a single time before replying to clients. */}
03472 \textcolor{keywordtype}{void} clusterBeforeSleep(\textcolor{keywordtype}{void}) \{
03473     \textcolor{comment}{/* Handle failover, this is needed when it is likely that there is already}
03474 \textcolor{comment}{     * the quorum from masters in order to react fast. */}
03475     \textcolor{keywordflow}{if} (server.cluster->todo\_before\_sleep & \hyperlink{cluster_8h_afb969dfe84cf59e2340ed10cbf334a47}{CLUSTER\_TODO\_HANDLE\_FAILOVER})
03476         clusterHandleSlaveFailover();
03477 
03478     \textcolor{comment}{/* Update the cluster state. */}
03479     \textcolor{keywordflow}{if} (server.cluster->todo\_before\_sleep & \hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE})
03480         clusterUpdateState();
03481 
03482     \textcolor{comment}{/* Save the config, possibly using fsync. */}
03483     \textcolor{keywordflow}{if} (server.cluster->todo\_before\_sleep & \hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG}) \{
03484         \textcolor{keywordtype}{int} fsync = server.cluster->todo\_before\_sleep &
03485                     \hyperlink{cluster_8h_accc9a00230cd04789db2398bb3ab715a}{CLUSTER\_TODO\_FSYNC\_CONFIG};
03486         clusterSaveConfigOrDie(fsync);
03487     \}
03488 
03489     \textcolor{comment}{/* Reset our flags (not strictly needed since every single function}
03490 \textcolor{comment}{     * called for flags set should be able to clear its flag). */}
03491     server.cluster->todo\_before\_sleep = 0;
03492 \}
03493 
03494 \textcolor{keywordtype}{void} clusterDoBeforeSleep(\textcolor{keywordtype}{int} flags) \{
03495     server.cluster->todo\_before\_sleep |= flags;
03496 \}
03497 
03498 \textcolor{comment}{/* -----------------------------------------------------------------------------}
03499 \textcolor{comment}{ * Slots management}
03500 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
03501 
03502 \textcolor{comment}{/* Test bit 'pos' in a generic bitmap. Return 1 if the bit is set,}
03503 \textcolor{comment}{ * otherwise 0. */}
03504 \textcolor{keywordtype}{int} bitmapTestBit(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *bitmap, \textcolor{keywordtype}{int} pos) \{
03505     off\_t byte = pos/8;
03506     \textcolor{keywordtype}{int} bit = pos&7;
03507     \textcolor{keywordflow}{return} (bitmap[byte] & (1<<bit)) != 0;
03508 \}
03509 
03510 \textcolor{comment}{/* Set the bit at position 'pos' in a bitmap. */}
03511 \textcolor{keywordtype}{void} bitmapSetBit(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *bitmap, \textcolor{keywordtype}{int} pos) \{
03512     off\_t byte = pos/8;
03513     \textcolor{keywordtype}{int} bit = pos&7;
03514     bitmap[byte] |= 1<<bit;
03515 \}
03516 
03517 \textcolor{comment}{/* Clear the bit at position 'pos' in a bitmap. */}
03518 \textcolor{keywordtype}{void} bitmapClearBit(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *bitmap, \textcolor{keywordtype}{int} pos) \{
03519     off\_t byte = pos/8;
03520     \textcolor{keywordtype}{int} bit = pos&7;
03521     bitmap[byte] &= ~(1<<bit);
03522 \}
03523 
03524 \textcolor{comment}{/* Return non-zero if there is at least one master with slaves in the cluster.}
03525 \textcolor{comment}{ * Otherwise zero is returned. Used by clusterNodeSetSlotBit() to set the}
03526 \textcolor{comment}{ * MIGRATE\_TO flag the when a master gets the first slot. */}
03527 \textcolor{keywordtype}{int} clusterMastersHaveSlaves(\textcolor{keywordtype}{void}) \{
03528     dictIterator *di = dictGetSafeIterator(server.cluster->nodes);
03529     dictEntry *de;
03530     \textcolor{keywordtype}{int} slaves = 0;
03531     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
03532         clusterNode *node = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
03533 
03534         \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(node)) \textcolor{keywordflow}{continue};
03535         slaves += node->numslaves;
03536     \}
03537     dictReleaseIterator(di);
03538     \textcolor{keywordflow}{return} slaves != 0;
03539 \}
03540 
03541 \textcolor{comment}{/* Set the slot bit and return the old value. */}
03542 \textcolor{keywordtype}{int} clusterNodeSetSlotBit(clusterNode *n, \textcolor{keywordtype}{int} slot) \{
03543     \textcolor{keywordtype}{int} old = bitmapTestBit(n->slots,slot);
03544     bitmapSetBit(n->slots,slot);
03545     \textcolor{keywordflow}{if} (!old) \{
03546         n->numslots++;
03547         \textcolor{comment}{/* When a master gets its first slot, even if it has no slaves,}
03548 \textcolor{comment}{         * it gets flagged with MIGRATE\_TO, that is, the master is a valid}
03549 \textcolor{comment}{         * target for replicas migration, if and only if at least one of}
03550 \textcolor{comment}{         * the other masters has slaves right now.}
03551 \textcolor{comment}{         *}
03552 \textcolor{comment}{         * Normally masters are valid targerts of replica migration if:}
03553 \textcolor{comment}{         * 1. The used to have slaves (but no longer have).}
03554 \textcolor{comment}{         * 2. They are slaves failing over a master that used to have slaves.}
03555 \textcolor{comment}{         *}
03556 \textcolor{comment}{         * However new masters with slots assigned are considered valid}
03557 \textcolor{comment}{         * migration tagets if the rest of the cluster is not a slave-less.}
03558 \textcolor{comment}{         *}
03559 \textcolor{comment}{         * See https://github.com/antirez/redis/issues/3043 for more info. */}
03560         \textcolor{keywordflow}{if} (n->numslots == 1 && clusterMastersHaveSlaves())
03561             n->flags |= \hyperlink{cluster_8h_a1d5a62356ed9f5986613c2315a358119}{CLUSTER\_NODE\_MIGRATE\_TO};
03562     \}
03563     \textcolor{keywordflow}{return} old;
03564 \}
03565 
03566 \textcolor{comment}{/* Clear the slot bit and return the old value. */}
03567 \textcolor{keywordtype}{int} clusterNodeClearSlotBit(clusterNode *n, \textcolor{keywordtype}{int} slot) \{
03568     \textcolor{keywordtype}{int} old = bitmapTestBit(n->slots,slot);
03569     bitmapClearBit(n->slots,slot);
03570     \textcolor{keywordflow}{if} (old) n->numslots--;
03571     \textcolor{keywordflow}{return} old;
03572 \}
03573 
03574 \textcolor{comment}{/* Return the slot bit from the cluster node structure. */}
03575 \textcolor{keywordtype}{int} clusterNodeGetSlotBit(clusterNode *n, \textcolor{keywordtype}{int} slot) \{
03576     \textcolor{keywordflow}{return} bitmapTestBit(n->slots,slot);
03577 \}
03578 
03579 \textcolor{comment}{/* Add the specified slot to the list of slots that node 'n' will}
03580 \textcolor{comment}{ * serve. Return C\_OK if the operation ended with success.}
03581 \textcolor{comment}{ * If the slot is already assigned to another instance this is considered}
03582 \textcolor{comment}{ * an error and C\_ERR is returned. */}
03583 \textcolor{keywordtype}{int} clusterAddSlot(clusterNode *n, \textcolor{keywordtype}{int} slot) \{
03584     \textcolor{keywordflow}{if} (server.cluster->slots[slot]) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
03585     clusterNodeSetSlotBit(n,slot);
03586     server.cluster->slots[slot] = n;
03587     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
03588 \}
03589 
03590 \textcolor{comment}{/* Delete the specified slot marking it as unassigned.}
03591 \textcolor{comment}{ * Returns C\_OK if the slot was assigned, otherwise if the slot was}
03592 \textcolor{comment}{ * already unassigned C\_ERR is returned. */}
03593 \textcolor{keywordtype}{int} clusterDelSlot(\textcolor{keywordtype}{int} slot) \{
03594     clusterNode *n = server.cluster->slots[slot];
03595 
03596     \textcolor{keywordflow}{if} (!n) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
03597     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(clusterNodeClearSlotBit(n,slot) == 1);
03598     server.cluster->slots[slot] = NULL;
03599     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
03600 \}
03601 
03602 \textcolor{comment}{/* Delete all the slots associated with the specified node.}
03603 \textcolor{comment}{ * The number of deleted slots is returned. */}
03604 \textcolor{keywordtype}{int} clusterDelNodeSlots(clusterNode *node) \{
03605     \textcolor{keywordtype}{int} deleted = 0, j;
03606 
03607     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}; j++) \{
03608         \textcolor{keywordflow}{if} (clusterNodeGetSlotBit(node,j)) \{
03609             clusterDelSlot(j);
03610             deleted++;
03611         \}
03612     \}
03613     \textcolor{keywordflow}{return} deleted;
03614 \}
03615 
03616 \textcolor{comment}{/* Clear the migrating / importing state for all the slots.}
03617 \textcolor{comment}{ * This is useful at initialization and when turning a master into slave. */}
03618 \textcolor{keywordtype}{void} clusterCloseAllSlots(\textcolor{keywordtype}{void}) \{
03619     memset(server.cluster->migrating\_slots\_to,0,
03620         \textcolor{keyword}{sizeof}(server.cluster->migrating\_slots\_to));
03621     memset(server.cluster->importing\_slots\_from,0,
03622         \textcolor{keyword}{sizeof}(server.cluster->importing\_slots\_from));
03623 \}
03624 
03625 \textcolor{comment}{/* -----------------------------------------------------------------------------}
03626 \textcolor{comment}{ * Cluster state evaluation function}
03627 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
03628 
03629 \textcolor{comment}{/* The following are defines that are only used in the evaluation function}
03630 \textcolor{comment}{ * and are based on heuristics. Actaully the main point about the rejoin and}
03631 \textcolor{comment}{ * writable delay is that they should be a few orders of magnitude larger}
03632 \textcolor{comment}{ * than the network latency. */}
03633 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLUSTER\_MAX\_REJOIN\_DELAY} 5000
03634 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLUSTER\_MIN\_REJOIN\_DELAY} 500
03635 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{CLUSTER\_WRITABLE\_DELAY} 2000
03636 
03637 \textcolor{keywordtype}{void} clusterUpdateState(\textcolor{keywordtype}{void}) \{
03638     \textcolor{keywordtype}{int} j, new\_state;
03639     \textcolor{keywordtype}{int} reachable\_masters = 0;
03640     \textcolor{keyword}{static} mstime\_t among\_minority\_time;
03641     \textcolor{keyword}{static} mstime\_t first\_call\_time = 0;
03642 
03643     server.cluster->todo\_before\_sleep &= ~\hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE};
03644 
03645     \textcolor{comment}{/* If this is a master node, wait some time before turning the state}
03646 \textcolor{comment}{     * into OK, since it is not a good idea to rejoin the cluster as a writable}
03647 \textcolor{comment}{     * master, after a reboot, without giving the cluster a chance to}
03648 \textcolor{comment}{     * reconfigure this node. Note that the delay is calculated starting from}
03649 \textcolor{comment}{     * the first call to this function and not since the server start, in order}
03650 \textcolor{comment}{     * to don't count the DB loading time. */}
03651     \textcolor{keywordflow}{if} (first\_call\_time == 0) first\_call\_time = mstime();
03652     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(myself) &&
03653         server.cluster->state == \hyperlink{cluster_8h_a4a46e6d5b85c594d08283dc6da2a32bf}{CLUSTER\_FAIL} &&
03654         mstime() - first\_call\_time < \hyperlink{cluster_8c_af5e38d5b0c4ba321bd893835975980b1}{CLUSTER\_WRITABLE\_DELAY}) \textcolor{keywordflow}{return};
03655 
03656     \textcolor{comment}{/* Start assuming the state is OK. We'll turn it into FAIL if there}
03657 \textcolor{comment}{     * are the right conditions. */}
03658     new\_state = \hyperlink{cluster_8h_adbda03922c45cac3cfc98a5c34a9d2d2}{CLUSTER\_OK};
03659 
03660     \textcolor{comment}{/* Check if all the slots are covered. */}
03661     \textcolor{keywordflow}{if} (server.cluster\_require\_full\_coverage) \{
03662         \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}; j++) \{
03663             \textcolor{keywordflow}{if} (server.cluster->slots[j] == NULL ||
03664                 server.cluster->slots[j]->flags & (\hyperlink{cluster_8h_ad211e85c7baf8a5a59acd747e4e9005a}{CLUSTER\_NODE\_FAIL}))
03665             \{
03666                 new\_state = \hyperlink{cluster_8h_a4a46e6d5b85c594d08283dc6da2a32bf}{CLUSTER\_FAIL};
03667                 \textcolor{keywordflow}{break};
03668             \}
03669         \}
03670     \}
03671 
03672     \textcolor{comment}{/* Compute the cluster size, that is the number of master nodes}
03673 \textcolor{comment}{     * serving at least a single slot.}
03674 \textcolor{comment}{     *}
03675 \textcolor{comment}{     * At the same time count the number of reachable masters having}
03676 \textcolor{comment}{     * at least one slot. */}
03677     \{
03678         dictIterator *di;
03679         dictEntry *de;
03680 
03681         server.cluster->size = 0;
03682         di = dictGetSafeIterator(server.cluster->nodes);
03683         \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
03684             clusterNode *node = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
03685 
03686             \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(node) && node->numslots) \{
03687                 server.cluster->size++;
03688                 \textcolor{keywordflow}{if} ((node->flags & (\hyperlink{cluster_8h_ad211e85c7baf8a5a59acd747e4e9005a}{CLUSTER\_NODE\_FAIL}|
      \hyperlink{cluster_8h_a5306c1ae8988b8be0a1a02bd9162dfa1}{CLUSTER\_NODE\_PFAIL})) == 0)
03689                     reachable\_masters++;
03690             \}
03691         \}
03692         dictReleaseIterator(di);
03693     \}
03694 
03695     \textcolor{comment}{/* If we are in a minority partition, change the cluster state}
03696 \textcolor{comment}{     * to FAIL. */}
03697     \{
03698         \textcolor{keywordtype}{int} needed\_quorum = (server.cluster->size / 2) + 1;
03699 
03700         \textcolor{keywordflow}{if} (reachable\_masters < needed\_quorum) \{
03701             new\_state = \hyperlink{cluster_8h_a4a46e6d5b85c594d08283dc6da2a32bf}{CLUSTER\_FAIL};
03702             among\_minority\_time = mstime();
03703         \}
03704     \}
03705 
03706     \textcolor{comment}{/* Log a state change */}
03707     \textcolor{keywordflow}{if} (new\_state != server.cluster->state) \{
03708         mstime\_t rejoin\_delay = server.cluster\_node\_timeout;
03709 
03710         \textcolor{comment}{/* If the instance is a master and was partitioned away with the}
03711 \textcolor{comment}{         * minority, don't let it accept queries for some time after the}
03712 \textcolor{comment}{         * partition heals, to make sure there is enough time to receive}
03713 \textcolor{comment}{         * a configuration update. */}
03714         \textcolor{keywordflow}{if} (rejoin\_delay > \hyperlink{cluster_8c_adb83a5ca7312d0554348246a2d240bae}{CLUSTER\_MAX\_REJOIN\_DELAY})
03715             rejoin\_delay = \hyperlink{cluster_8c_adb83a5ca7312d0554348246a2d240bae}{CLUSTER\_MAX\_REJOIN\_DELAY};
03716         \textcolor{keywordflow}{if} (rejoin\_delay < \hyperlink{cluster_8c_a215c4f74aaedd23cc5c82ea52548eb44}{CLUSTER\_MIN\_REJOIN\_DELAY})
03717             rejoin\_delay = \hyperlink{cluster_8c_a215c4f74aaedd23cc5c82ea52548eb44}{CLUSTER\_MIN\_REJOIN\_DELAY};
03718 
03719         \textcolor{keywordflow}{if} (new\_state == \hyperlink{cluster_8h_adbda03922c45cac3cfc98a5c34a9d2d2}{CLUSTER\_OK} &&
03720             \hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(myself) &&
03721             mstime() - among\_minority\_time < rejoin\_delay)
03722         \{
03723             \textcolor{keywordflow}{return};
03724         \}
03725 
03726         \textcolor{comment}{/* Change the state and log the event. */}
03727         serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Cluster state changed: %s"},
03728             new\_state == \hyperlink{cluster_8h_adbda03922c45cac3cfc98a5c34a9d2d2}{CLUSTER\_OK} ? \textcolor{stringliteral}{"ok"} : \textcolor{stringliteral}{"fail"});
03729         server.cluster->state = new\_state;
03730     \}
03731 \}
03732 
03733 \textcolor{comment}{/* This function is called after the node startup in order to verify that data}
03734 \textcolor{comment}{ * loaded from disk is in agreement with the cluster configuration:}
03735 \textcolor{comment}{ *}
03736 \textcolor{comment}{ * 1) If we find keys about hash slots we have no responsibility for, the}
03737 \textcolor{comment}{ *    following happens:}
03738 \textcolor{comment}{ *    A) If no other node is in charge according to the current cluster}
03739 \textcolor{comment}{ *       configuration, we add these slots to our node.}
03740 \textcolor{comment}{ *    B) If according to our config other nodes are already in charge for}
03741 \textcolor{comment}{ *       this lots, we set the slots as IMPORTING from our point of view}
03742 \textcolor{comment}{ *       in order to justify we have those slots, and in order to make}
03743 \textcolor{comment}{ *       redis-trib aware of the issue, so that it can try to fix it.}
03744 \textcolor{comment}{ * 2) If we find data in a DB different than DB0 we return C\_ERR to}
03745 \textcolor{comment}{ *    signal the caller it should quit the server with an error message}
03746 \textcolor{comment}{ *    or take other actions.}
03747 \textcolor{comment}{ *}
03748 \textcolor{comment}{ * The function always returns C\_OK even if it will try to correct}
03749 \textcolor{comment}{ * the error described in "1". However if data is found in DB different}
03750 \textcolor{comment}{ * from DB0, C\_ERR is returned.}
03751 \textcolor{comment}{ *}
03752 \textcolor{comment}{ * The function also uses the logging facility in order to warn the user}
03753 \textcolor{comment}{ * about desynchronizations between the data we have in memory and the}
03754 \textcolor{comment}{ * cluster configuration. */}
03755 \textcolor{keywordtype}{int} verifyClusterConfigWithData(\textcolor{keywordtype}{void}) \{
03756     \textcolor{keywordtype}{int} j;
03757     \textcolor{keywordtype}{int} update\_config = 0;
03758 
03759     \textcolor{comment}{/* If this node is a slave, don't perform the check at all as we}
03760 \textcolor{comment}{     * completely depend on the replication stream. */}
03761     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(myself)) \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
03762 
03763     \textcolor{comment}{/* Make sure we only have keys in DB0. */}
03764     \textcolor{keywordflow}{for} (j = 1; j < server.dbnum; j++) \{
03765         \textcolor{keywordflow}{if} (\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.db[j].dict)) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
03766     \}
03767 
03768     \textcolor{comment}{/* Check that all the slots we see populated memory have a corresponding}
03769 \textcolor{comment}{     * entry in the cluster table. Otherwise fix the table. */}
03770     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}; j++) \{
03771         \textcolor{keywordflow}{if} (!countKeysInSlot(j)) \textcolor{keywordflow}{continue}; \textcolor{comment}{/* No keys in this slot. */}
03772         \textcolor{comment}{/* Check if we are assigned to this slot or if we are importing it.}
03773 \textcolor{comment}{         * In both cases check the next slot as the configuration makes}
03774 \textcolor{comment}{         * sense. */}
03775         \textcolor{keywordflow}{if} (server.cluster->slots[j] == myself ||
03776             server.cluster->importing\_slots\_from[j] != NULL) \textcolor{keywordflow}{continue};
03777 
03778         \textcolor{comment}{/* If we are here data and cluster config don't agree, and we have}
03779 \textcolor{comment}{         * slot 'j' populated even if we are not importing it, nor we are}
03780 \textcolor{comment}{         * assigned to this slot. Fix this condition. */}
03781 
03782         update\_config++;
03783         \textcolor{comment}{/* Case A: slot is unassigned. Take responsibility for it. */}
03784         \textcolor{keywordflow}{if} (server.cluster->slots[j] == NULL) \{
03785             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"I have keys for unassigned slot %d. "}
03786                                     \textcolor{stringliteral}{"Taking responsibility for it."},j);
03787             clusterAddSlot(myself,j);
03788         \} \textcolor{keywordflow}{else} \{
03789             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING}, \textcolor{stringliteral}{"I have keys for slot %d, but the slot is "}
03790                                     \textcolor{stringliteral}{"assigned to another node. "}
03791                                     \textcolor{stringliteral}{"Setting it to importing state."},j);
03792             server.cluster->importing\_slots\_from[j] = server.cluster->slots[j];
03793         \}
03794     \}
03795     \textcolor{keywordflow}{if} (update\_config) clusterSaveConfigOrDie(1);
03796     \textcolor{keywordflow}{return} \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK};
03797 \}
03798 
03799 \textcolor{comment}{/* -----------------------------------------------------------------------------}
03800 \textcolor{comment}{ * SLAVE nodes handling}
03801 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
03802 
03803 \textcolor{comment}{/* Set the specified node 'n' as master for this node.}
03804 \textcolor{comment}{ * If this node is currently a master, it is turned into a slave. */}
03805 \textcolor{keywordtype}{void} clusterSetMaster(clusterNode *n) \{
03806     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(n != myself);
03807     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(myself->numslots == 0);
03808 
03809     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(myself)) \{
03810         myself->flags &= ~(\hyperlink{cluster_8h_a5dcea846e31b55b73244aa2e496a31bf}{CLUSTER\_NODE\_MASTER}|
      \hyperlink{cluster_8h_a1d5a62356ed9f5986613c2315a358119}{CLUSTER\_NODE\_MIGRATE\_TO});
03811         myself->flags |= \hyperlink{cluster_8h_a34b7bfd1f810397be68c3b5d13d4d134}{CLUSTER\_NODE\_SLAVE};
03812         clusterCloseAllSlots();
03813     \} \textcolor{keywordflow}{else} \{
03814         \textcolor{keywordflow}{if} (myself->slaveof)
03815             clusterNodeRemoveSlave(myself->slaveof,myself);
03816     \}
03817     myself->slaveof = n;
03818     clusterNodeAddSlave(n,myself);
03819     replicationSetMaster(n->ip, n->port);
03820     resetManualFailover();
03821 \}
03822 
03823 \textcolor{comment}{/* -----------------------------------------------------------------------------}
03824 \textcolor{comment}{ * Nodes to string representation functions.}
03825 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
03826 
\Hypertarget{cluster_8c_source_l03827}\hyperlink{structredisNodeFlags}{03827} \textcolor{keyword}{struct} \hyperlink{structredisNodeFlags}{redisNodeFlags} \{
03828     uint16\_t flag;
03829     \textcolor{keywordtype}{char} *name;
03830 \};
03831 
03832 \textcolor{keyword}{static} \textcolor{keyword}{struct} \hyperlink{structredisNodeFlags}{redisNodeFlags} redisNodeFlagsTable[] = \{
03833     \{\hyperlink{cluster_8h_afee946c4e74c08465e9b4ead5e3659e6}{CLUSTER\_NODE\_MYSELF},       \textcolor{stringliteral}{"myself,"}\},
03834     \{\hyperlink{cluster_8h_a5dcea846e31b55b73244aa2e496a31bf}{CLUSTER\_NODE\_MASTER},       \textcolor{stringliteral}{"master,"}\},
03835     \{\hyperlink{cluster_8h_a34b7bfd1f810397be68c3b5d13d4d134}{CLUSTER\_NODE\_SLAVE},        \textcolor{stringliteral}{"slave,"}\},
03836     \{\hyperlink{cluster_8h_a5306c1ae8988b8be0a1a02bd9162dfa1}{CLUSTER\_NODE\_PFAIL},        \textcolor{stringliteral}{"fail?,"}\},
03837     \{\hyperlink{cluster_8h_ad211e85c7baf8a5a59acd747e4e9005a}{CLUSTER\_NODE\_FAIL},         \textcolor{stringliteral}{"fail,"}\},
03838     \{\hyperlink{cluster_8h_a60571342a067f1e5772a04b36feff6a6}{CLUSTER\_NODE\_HANDSHAKE},    \textcolor{stringliteral}{"handshake,"}\},
03839     \{\hyperlink{cluster_8h_a2bbed8bf0615871a01ca8b7f691b56d8}{CLUSTER\_NODE\_NOADDR},       \textcolor{stringliteral}{"noaddr,"}\}
03840 \};
03841 
03842 \textcolor{comment}{/* Concatenate the comma separated list of node flags to the given SDS}
03843 \textcolor{comment}{ * string 'ci'. */}
03844 sds representClusterNodeFlags(sds ci, uint16\_t flags) \{
03845     size\_t orig\_len = sdslen(ci);
03846     \textcolor{keywordtype}{int} i, size = \textcolor{keyword}{sizeof}(redisNodeFlagsTable)/\textcolor{keyword}{sizeof}(\textcolor{keyword}{struct} \hyperlink{structredisNodeFlags}{redisNodeFlags});
03847     \textcolor{keywordflow}{for} (i = 0; i < size; i++) \{
03848         \textcolor{keyword}{struct} \hyperlink{structredisNodeFlags}{redisNodeFlags} *nodeflag = redisNodeFlagsTable + i;
03849         \textcolor{keywordflow}{if} (flags & nodeflag->flag) ci = sdscat(ci, nodeflag->name);
03850     \}
03851     \textcolor{comment}{/* If no flag was added, add the "noflags" special flag. */}
03852     \textcolor{keywordflow}{if} (sdslen(ci) == orig\_len) ci = sdscat(ci,\textcolor{stringliteral}{"noflags,"});
03853     sdsIncrLen(ci,-1); \textcolor{comment}{/* Remove trailing comma. */}
03854     \textcolor{keywordflow}{return} ci;
03855 \}
03856 
03857 \textcolor{comment}{/* Generate a csv-alike representation of the specified cluster node.}
03858 \textcolor{comment}{ * See clusterGenNodesDescription() top comment for more information.}
03859 \textcolor{comment}{ *}
03860 \textcolor{comment}{ * The function returns the string representation as an SDS string. */}
03861 sds clusterGenNodeDescription(clusterNode *node) \{
03862     \textcolor{keywordtype}{int} j, start;
03863     sds ci;
03864 
03865     \textcolor{comment}{/* Node coordinates */}
03866     ci = sdscatprintf(sdsempty(),\textcolor{stringliteral}{"%.40s %s:%d@%d "},
03867         node->name,
03868         node->ip,
03869         node->port,
03870         node->cport);
03871 
03872     \textcolor{comment}{/* Flags */}
03873     ci = representClusterNodeFlags(ci, node->flags);
03874 
03875     \textcolor{comment}{/* Slave of... or just "-" */}
03876     \textcolor{keywordflow}{if} (node->slaveof)
03877         ci = sdscatprintf(ci,\textcolor{stringliteral}{" %.40s "},node->slaveof->name);
03878     \textcolor{keywordflow}{else}
03879         ci = sdscatlen(ci,\textcolor{stringliteral}{" - "},3);
03880 
03881     \textcolor{comment}{/* Latency from the POV of this node, config epoch, link status */}
03882     ci = sdscatprintf(ci,\textcolor{stringliteral}{"%lld %lld %llu %s"},
03883         (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) node->ping\_sent,
03884         (\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) node->pong\_received,
03885         (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) node->configEpoch,
03886         (node->link || node->flags & \hyperlink{cluster_8h_afee946c4e74c08465e9b4ead5e3659e6}{CLUSTER\_NODE\_MYSELF}) ?
03887                     \textcolor{stringliteral}{"connected"} : \textcolor{stringliteral}{"disconnected"});
03888 
03889     \textcolor{comment}{/* Slots served by this instance */}
03890     start = -1;
03891     \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}; j++) \{
03892         \textcolor{keywordtype}{int} bit;
03893 
03894         \textcolor{keywordflow}{if} ((bit = clusterNodeGetSlotBit(node,j)) != 0) \{
03895             \textcolor{keywordflow}{if} (start == -1) start = j;
03896         \}
03897         \textcolor{keywordflow}{if} (start != -1 && (!bit || j == \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}-1)) \{
03898             \textcolor{keywordflow}{if} (bit && j == \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}-1) j++;
03899 
03900             \textcolor{keywordflow}{if} (start == j-1) \{
03901                 ci = sdscatprintf(ci,\textcolor{stringliteral}{" %d"},start);
03902             \} \textcolor{keywordflow}{else} \{
03903                 ci = sdscatprintf(ci,\textcolor{stringliteral}{" %d-%d"},start,j-1);
03904             \}
03905             start = -1;
03906         \}
03907     \}
03908 
03909     \textcolor{comment}{/* Just for MYSELF node we also dump info about slots that}
03910 \textcolor{comment}{     * we are migrating to other instances or importing from other}
03911 \textcolor{comment}{     * instances. */}
03912     \textcolor{keywordflow}{if} (node->flags & \hyperlink{cluster_8h_afee946c4e74c08465e9b4ead5e3659e6}{CLUSTER\_NODE\_MYSELF}) \{
03913         \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}; j++) \{
03914             \textcolor{keywordflow}{if} (server.cluster->migrating\_slots\_to[j]) \{
03915                 ci = sdscatprintf(ci,\textcolor{stringliteral}{" [%d->-%.40s]"},j,
03916                     server.cluster->migrating\_slots\_to[j]->name);
03917             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.cluster->importing\_slots\_from[j]) \{
03918                 ci = sdscatprintf(ci,\textcolor{stringliteral}{" [%d-<-%.40s]"},j,
03919                     server.cluster->importing\_slots\_from[j]->name);
03920             \}
03921         \}
03922     \}
03923     \textcolor{keywordflow}{return} ci;
03924 \}
03925 
03926 \textcolor{comment}{/* Generate a csv-alike representation of the nodes we are aware of,}
03927 \textcolor{comment}{ * including the "myself" node, and return an SDS string containing the}
03928 \textcolor{comment}{ * representation (it is up to the caller to free it).}
03929 \textcolor{comment}{ *}
03930 \textcolor{comment}{ * All the nodes matching at least one of the node flags specified in}
03931 \textcolor{comment}{ * "filter" are excluded from the output, so using zero as a filter will}
03932 \textcolor{comment}{ * include all the known nodes in the representation, including nodes in}
03933 \textcolor{comment}{ * the HANDSHAKE state.}
03934 \textcolor{comment}{ *}
03935 \textcolor{comment}{ * The representation obtained using this function is used for the output}
03936 \textcolor{comment}{ * of the CLUSTER NODES function, and as format for the cluster}
03937 \textcolor{comment}{ * configuration file (nodes.conf) for a given node. */}
03938 sds clusterGenNodesDescription(\textcolor{keywordtype}{int} filter) \{
03939     sds ci = sdsempty(), ni;
03940     dictIterator *di;
03941     dictEntry *de;
03942 
03943     di = dictGetSafeIterator(server.cluster->nodes);
03944     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
03945         clusterNode *node = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
03946 
03947         \textcolor{keywordflow}{if} (node->flags & filter) \textcolor{keywordflow}{continue};
03948         ni = clusterGenNodeDescription(node);
03949         ci = sdscatsds(ci,ni);
03950         sdsfree(ni);
03951         ci = sdscatlen(ci,\textcolor{stringliteral}{"\(\backslash\)n"},1);
03952     \}
03953     dictReleaseIterator(di);
03954     \textcolor{keywordflow}{return} ci;
03955 \}
03956 
03957 \textcolor{comment}{/* -----------------------------------------------------------------------------}
03958 \textcolor{comment}{ * CLUSTER command}
03959 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
03960 
03961 \textcolor{keyword}{const} \textcolor{keywordtype}{char} *clusterGetMessageTypeString(\textcolor{keywordtype}{int} type) \{
03962     \textcolor{keywordflow}{switch}(type) \{
03963     \textcolor{keywordflow}{case} \hyperlink{cluster_8h_aeb8a936505e22f64e5039523a3c96d4c}{CLUSTERMSG\_TYPE\_PING}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"ping"};
03964     \textcolor{keywordflow}{case} \hyperlink{cluster_8h_a33e9439f462f28177a31dfc74de0c16b}{CLUSTERMSG\_TYPE\_PONG}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"pong"};
03965     \textcolor{keywordflow}{case} \hyperlink{cluster_8h_aaf264f57ae1869c57093fd9fbc6fc5bc}{CLUSTERMSG\_TYPE\_MEET}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"meet"};
03966     \textcolor{keywordflow}{case} \hyperlink{cluster_8h_af5d51e3ad9965074b2124aabe1895d59}{CLUSTERMSG\_TYPE\_FAIL}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"fail"};
03967     \textcolor{keywordflow}{case} \hyperlink{cluster_8h_a874fecfd3ff886c2c697f5649ebee5ee}{CLUSTERMSG\_TYPE\_PUBLISH}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"publish"};
03968     \textcolor{keywordflow}{case} \hyperlink{cluster_8h_a739009308ed4cb5b19630a5f872408d2}{CLUSTERMSG\_TYPE\_FAILOVER\_AUTH\_REQUEST}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"auth-req"}
      ;
03969     \textcolor{keywordflow}{case} \hyperlink{cluster_8h_ae0db3a998d7da521c5359bdd8708f5f6}{CLUSTERMSG\_TYPE\_FAILOVER\_AUTH\_ACK}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"auth-ack"};
03970     \textcolor{keywordflow}{case} \hyperlink{cluster_8h_a51dc58bb78128fcae1751d654130ec0f}{CLUSTERMSG\_TYPE\_UPDATE}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"update"};
03971     \textcolor{keywordflow}{case} \hyperlink{cluster_8h_aa875273b4b11ae73d3cd3a8aea4ddcba}{CLUSTERMSG\_TYPE\_MFSTART}: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"mfstart"};
03972     \}
03973     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"unknown"};
03974 \}
03975 
03976 \textcolor{keywordtype}{int} getSlotOrReply(\hyperlink{structclient}{client} *c, robj *o) \{
03977     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} slot;
03978 
03979     \textcolor{keywordflow}{if} (getLongLongFromObject(o,&slot) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK} ||
03980         slot < 0 || slot >= \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS})
03981     \{
03982         addReplyError(c,\textcolor{stringliteral}{"Invalid or out of range slot"});
03983         \textcolor{keywordflow}{return} -1;
03984     \}
03985     \textcolor{keywordflow}{return} (\textcolor{keywordtype}{int}) slot;
03986 \}
03987 
03988 \textcolor{keywordtype}{void} clusterReplyMultiBulkSlots(\hyperlink{structclient}{client} *c) \{
03989     \textcolor{comment}{/* Format: 1) 1) start slot}
03990 \textcolor{comment}{     *            2) end slot}
03991 \textcolor{comment}{     *            3) 1) master IP}
03992 \textcolor{comment}{     *               2) master port}
03993 \textcolor{comment}{     *               3) node ID}
03994 \textcolor{comment}{     *            4) 1) replica IP}
03995 \textcolor{comment}{     *               2) replica port}
03996 \textcolor{comment}{     *               3) node ID}
03997 \textcolor{comment}{     *           ... continued until done}
03998 \textcolor{comment}{     */}
03999 
04000     \textcolor{keywordtype}{int} num\_masters = 0;
04001     \textcolor{keywordtype}{void} *slot\_replylen = addDeferredMultiBulkLength(c);
04002 
04003     dictEntry *de;
04004     dictIterator *di = dictGetSafeIterator(server.cluster->nodes);
04005     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
04006         clusterNode *node = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
04007         \textcolor{keywordtype}{int} j = 0, start = -1;
04008 
04009         \textcolor{comment}{/* Skip slaves (that are iterated when producing the output of their}
04010 \textcolor{comment}{         * master) and  masters not serving any slot. */}
04011         \textcolor{keywordflow}{if} (!\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(node) || node->numslots == 0) \textcolor{keywordflow}{continue};
04012 
04013         \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}; j++) \{
04014             \textcolor{keywordtype}{int} bit, i;
04015 
04016             \textcolor{keywordflow}{if} ((bit = clusterNodeGetSlotBit(node,j)) != 0) \{
04017                 \textcolor{keywordflow}{if} (start == -1) start = j;
04018             \}
04019             \textcolor{keywordflow}{if} (start != -1 && (!bit || j == \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}-1)) \{
04020                 \textcolor{keywordtype}{int} nested\_elements = 3; \textcolor{comment}{/* slots (2) + master addr (1). */}
04021                 \textcolor{keywordtype}{void} *nested\_replylen = addDeferredMultiBulkLength(c);
04022 
04023                 \textcolor{keywordflow}{if} (bit && j == \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}-1) j++;
04024 
04025                 \textcolor{comment}{/* If slot exists in output map, add to it's list.}
04026 \textcolor{comment}{                 * else, create a new output map for this slot */}
04027                 \textcolor{keywordflow}{if} (start == j-1) \{
04028                     addReplyLongLong(c, start); \textcolor{comment}{/* only one slot; low==high */}
04029                     addReplyLongLong(c, start);
04030                 \} \textcolor{keywordflow}{else} \{
04031                     addReplyLongLong(c, start); \textcolor{comment}{/* low */}
04032                     addReplyLongLong(c, j-1);   \textcolor{comment}{/* high */}
04033                 \}
04034                 start = -1;
04035 
04036                 \textcolor{comment}{/* First node reply position is always the master */}
04037                 addReplyMultiBulkLen(c, 3);
04038                 addReplyBulkCString(c, node->ip);
04039                 addReplyLongLong(c, node->port);
04040                 addReplyBulkCBuffer(c, node->name, \hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN});
04041 
04042                 \textcolor{comment}{/* Remaining nodes in reply are replicas for slot range */}
04043                 \textcolor{keywordflow}{for} (i = 0; i < node->numslaves; i++) \{
04044                     \textcolor{comment}{/* This loop is copy/pasted from clusterGenNodeDescription()}
04045 \textcolor{comment}{                     * with modifications for per-slot node aggregation */}
04046                     \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a6a31c614ff4f5ac8ebaa630b0a921c3d}{nodeFailed}(node->slaves[i])) \textcolor{keywordflow}{continue};
04047                     addReplyMultiBulkLen(c, 3);
04048                     addReplyBulkCString(c, node->slaves[i]->ip);
04049                     addReplyLongLong(c, node->slaves[i]->port);
04050                     addReplyBulkCBuffer(c, node->slaves[i]->name, 
      \hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN});
04051                     nested\_elements++;
04052                 \}
04053                 setDeferredMultiBulkLength(c, nested\_replylen, nested\_elements);
04054                 num\_masters++;
04055             \}
04056         \}
04057     \}
04058     dictReleaseIterator(di);
04059     setDeferredMultiBulkLength(c, slot\_replylen, num\_masters);
04060 \}
04061 
04062 \textcolor{keywordtype}{void} clusterCommand(\hyperlink{structclient}{client} *c) \{
04063     \textcolor{keywordflow}{if} (server.cluster\_enabled == 0) \{
04064         addReplyError(c,\textcolor{stringliteral}{"This instance has cluster support disabled"});
04065         \textcolor{keywordflow}{return};
04066     \}
04067 
04068     \textcolor{keywordflow}{if} (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"help"})) \{
04069         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *help[] = \{
04070 \textcolor{stringliteral}{"addslots <slot> [slot ...] -- Assign slots to current node."},
04071 \textcolor{stringliteral}{"bumpepoch -- Advance the cluster config epoch."},
04072 \textcolor{stringliteral}{"count-failure-reports <node-id> -- Return number of failure reports for <node-id>."},
04073 \textcolor{stringliteral}{"countkeysinslot <slot> - Return the number of keys in <slot>."},
04074 \textcolor{stringliteral}{"delslots <slot> [slot ...] -- Delete slots information from current node."},
04075 \textcolor{stringliteral}{"failover [force|takeover] -- Promote current slave node to being a master."},
04076 \textcolor{stringliteral}{"forget <node-id> -- Remove a node from the cluster."},
04077 \textcolor{stringliteral}{"getkeysinslot <slot> <count> -- Return key names stored by current node in a slot."},
04078 \textcolor{stringliteral}{"flushslots -- Delete current node own slots information."},
04079 \textcolor{stringliteral}{"info - Return onformation about the cluster."},
04080 \textcolor{stringliteral}{"keyslot <key> -- Return the hash slot for <key>."},
04081 \textcolor{stringliteral}{"meet <ip> <port> [bus-port] -- Connect nodes into a working cluster."},
04082 \textcolor{stringliteral}{"myid -- Return the node id."},
04083 \textcolor{stringliteral}{"nodes -- Return cluster configuration seen by node. Output format:"},
04084 \textcolor{stringliteral}{"    <id> <ip:port> <flags> <master> <pings> <pongs> <epoch> <link> <slot> ... <slot>"},
04085 \textcolor{stringliteral}{"replicate <node-id> -- Configure current node as slave to <node-id>."},
04086 \textcolor{stringliteral}{"reset [hard|soft] -- Reset current node (default: soft)."},
04087 \textcolor{stringliteral}{"set-config-epoch <epoch> - Set config epoch of current node."},
04088 \textcolor{stringliteral}{"setslot <slot> (importing|migrating|stable|node <node-id>) -- Set slot state."},
04089 \textcolor{stringliteral}{"slaves <node-id> -- Return <node-id> slaves."},
04090 \textcolor{stringliteral}{"slots -- Return information about slots range mappings. Each range is made of:"},
04091 \textcolor{stringliteral}{"    start, end, master and replicas IP addresses, ports and ids"},
04092 NULL
04093         \};
04094         addReplyHelp(c, help);
04095     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"meet"}) && (c->argc == 4 || c->argc == 5)) \{
04096         \textcolor{comment}{/* CLUSTER MEET <ip> <port> [cport] */}
04097         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} port, cport;
04098 
04099         \textcolor{keywordflow}{if} (getLongLongFromObject(c->argv[3], &port) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
04100             addReplyErrorFormat(c,\textcolor{stringliteral}{"Invalid TCP base port specified: %s"},
04101                                 (\textcolor{keywordtype}{char}*)c->argv[3]->ptr);
04102             \textcolor{keywordflow}{return};
04103         \}
04104 
04105         \textcolor{keywordflow}{if} (c->argc == 5) \{
04106             \textcolor{keywordflow}{if} (getLongLongFromObject(c->argv[4], &cport) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
04107                 addReplyErrorFormat(c,\textcolor{stringliteral}{"Invalid TCP bus port specified: %s"},
04108                                     (\textcolor{keywordtype}{char}*)c->argv[4]->ptr);
04109                 \textcolor{keywordflow}{return};
04110             \}
04111         \} \textcolor{keywordflow}{else} \{
04112             cport = port + \hyperlink{cluster_8h_ac619a9ae48ab1431daa590fb5e75cea8}{CLUSTER\_PORT\_INCR};
04113         \}
04114 
04115         \textcolor{keywordflow}{if} (clusterStartHandshake(c->argv[2]->ptr,port,cport) == 0 &&
04116             errno == EINVAL)
04117         \{
04118             addReplyErrorFormat(c,\textcolor{stringliteral}{"Invalid node address specified: %s:%s"},
04119                             (\textcolor{keywordtype}{char}*)c->argv[2]->ptr, (\textcolor{keywordtype}{char}*)c->argv[3]->ptr);
04120         \} \textcolor{keywordflow}{else} \{
04121             addReply(c,shared.ok);
04122         \}
04123     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"nodes"}) && c->argc == 2) \{
04124         \textcolor{comment}{/* CLUSTER NODES */}
04125         robj *o;
04126         sds ci = clusterGenNodesDescription(0);
04127 
04128         o = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},ci);
04129         addReplyBulk(c,o);
04130         decrRefCount(o);
04131     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"myid"}) && c->argc == 2) \{
04132         \textcolor{comment}{/* CLUSTER MYID */}
04133         addReplyBulkCBuffer(c,myself->name, \hyperlink{cluster_8h_ace7a882972eff7149675252938643b6e}{CLUSTER\_NAMELEN});
04134     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"slots"}) && c->argc == 2) \{
04135         \textcolor{comment}{/* CLUSTER SLOTS */}
04136         clusterReplyMultiBulkSlots(c);
04137     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"flushslots"}) && c->argc == 2) \{
04138         \textcolor{comment}{/* CLUSTER FLUSHSLOTS */}
04139         \textcolor{keywordflow}{if} (\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.db[0].dict) != 0) \{
04140             addReplyError(c,\textcolor{stringliteral}{"DB must be empty to perform CLUSTER FLUSHSLOTS."});
04141             \textcolor{keywordflow}{return};
04142         \}
04143         clusterDelNodeSlots(myself);
04144         clusterDoBeforeSleep(\hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE}|
      \hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG});
04145         addReply(c,shared.ok);
04146     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"addslots"}) ||
04147                !strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"delslots"})) && c->argc >= 3)
04148     \{
04149         \textcolor{comment}{/* CLUSTER ADDSLOTS <slot> [slot] ... */}
04150         \textcolor{comment}{/* CLUSTER DELSLOTS <slot> [slot] ... */}
04151         \textcolor{keywordtype}{int} j, slot;
04152         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *slots = zmalloc(\hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS});
04153         \textcolor{keywordtype}{int} del = !strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"delslots"});
04154 
04155         memset(slots,0,\hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS});
04156         \textcolor{comment}{/* Check that all the arguments are parseable and that all the}
04157 \textcolor{comment}{         * slots are not already busy. */}
04158         \textcolor{keywordflow}{for} (j = 2; j < c->argc; j++) \{
04159             \textcolor{keywordflow}{if} ((slot = getSlotOrReply(c,c->argv[j])) == -1) \{
04160                 zfree(slots);
04161                 \textcolor{keywordflow}{return};
04162             \}
04163             \textcolor{keywordflow}{if} (del && server.cluster->slots[slot] == NULL) \{
04164                 addReplyErrorFormat(c,\textcolor{stringliteral}{"Slot %d is already unassigned"}, slot);
04165                 zfree(slots);
04166                 \textcolor{keywordflow}{return};
04167             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!del && server.cluster->slots[slot]) \{
04168                 addReplyErrorFormat(c,\textcolor{stringliteral}{"Slot %d is already busy"}, slot);
04169                 zfree(slots);
04170                 \textcolor{keywordflow}{return};
04171             \}
04172             \textcolor{keywordflow}{if} (slots[slot]++ == 1) \{
04173                 addReplyErrorFormat(c,\textcolor{stringliteral}{"Slot %d specified multiple times"},
04174                     (\textcolor{keywordtype}{int})slot);
04175                 zfree(slots);
04176                 \textcolor{keywordflow}{return};
04177             \}
04178         \}
04179         \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}; j++) \{
04180             \textcolor{keywordflow}{if} (slots[j]) \{
04181                 \textcolor{keywordtype}{int} retval;
04182 
04183                 \textcolor{comment}{/* If this slot was set as importing we can clear this}
04184 \textcolor{comment}{                 * state as now we are the real owner of the slot. */}
04185                 \textcolor{keywordflow}{if} (server.cluster->importing\_slots\_from[j])
04186                     server.cluster->importing\_slots\_from[j] = NULL;
04187 
04188                 retval = del ? clusterDelSlot(j) :
04189                                clusterAddSlot(myself,j);
04190                 \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,retval == 
      \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK});
04191             \}
04192         \}
04193         zfree(slots);
04194         clusterDoBeforeSleep(\hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE}|
      \hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG});
04195         addReply(c,shared.ok);
04196     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"setslot"}) && c->argc >= 4) \{
04197         \textcolor{comment}{/* SETSLOT 10 MIGRATING <node ID> */}
04198         \textcolor{comment}{/* SETSLOT 10 IMPORTING <node ID> */}
04199         \textcolor{comment}{/* SETSLOT 10 STABLE */}
04200         \textcolor{comment}{/* SETSLOT 10 NODE <node ID> */}
04201         \textcolor{keywordtype}{int} slot;
04202         clusterNode *n;
04203 
04204         \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(myself)) \{
04205             addReplyError(c,\textcolor{stringliteral}{"Please use SETSLOT only with masters."});
04206             \textcolor{keywordflow}{return};
04207         \}
04208 
04209         \textcolor{keywordflow}{if} ((slot = getSlotOrReply(c,c->argv[2])) == -1) \textcolor{keywordflow}{return};
04210 
04211         \textcolor{keywordflow}{if} (!strcasecmp(c->argv[3]->ptr,\textcolor{stringliteral}{"migrating"}) && c->argc == 5) \{
04212             \textcolor{keywordflow}{if} (server.cluster->slots[slot] != myself) \{
04213                 addReplyErrorFormat(c,\textcolor{stringliteral}{"I'm not the owner of hash slot %u"},slot);
04214                 \textcolor{keywordflow}{return};
04215             \}
04216             \textcolor{keywordflow}{if} ((n = clusterLookupNode(c->argv[4]->ptr)) == NULL) \{
04217                 addReplyErrorFormat(c,\textcolor{stringliteral}{"I don't know about node %s"},
04218                     (\textcolor{keywordtype}{char}*)c->argv[4]->ptr);
04219                 \textcolor{keywordflow}{return};
04220             \}
04221             server.cluster->migrating\_slots\_to[slot] = n;
04222         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[3]->ptr,\textcolor{stringliteral}{"importing"}) && c->argc == 5) \{
04223             \textcolor{keywordflow}{if} (server.cluster->slots[slot] == myself) \{
04224                 addReplyErrorFormat(c,
04225                     \textcolor{stringliteral}{"I'm already the owner of hash slot %u"},slot);
04226                 \textcolor{keywordflow}{return};
04227             \}
04228             \textcolor{keywordflow}{if} ((n = clusterLookupNode(c->argv[4]->ptr)) == NULL) \{
04229                 addReplyErrorFormat(c,\textcolor{stringliteral}{"I don't know about node %s"},
04230                     (\textcolor{keywordtype}{char}*)c->argv[4]->ptr);
04231                 \textcolor{keywordflow}{return};
04232             \}
04233             server.cluster->importing\_slots\_from[slot] = n;
04234         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[3]->ptr,\textcolor{stringliteral}{"stable"}) && c->argc == 4) \{
04235             \textcolor{comment}{/* CLUSTER SETSLOT <SLOT> STABLE */}
04236             server.cluster->importing\_slots\_from[slot] = NULL;
04237             server.cluster->migrating\_slots\_to[slot] = NULL;
04238         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[3]->ptr,\textcolor{stringliteral}{"node"}) && c->argc == 5) \{
04239             \textcolor{comment}{/* CLUSTER SETSLOT <SLOT> NODE <NODE ID> */}
04240             clusterNode *n = clusterLookupNode(c->argv[4]->ptr);
04241 
04242             \textcolor{keywordflow}{if} (!n) \{
04243                 addReplyErrorFormat(c,\textcolor{stringliteral}{"Unknown node %s"},
04244                     (\textcolor{keywordtype}{char}*)c->argv[4]->ptr);
04245                 \textcolor{keywordflow}{return};
04246             \}
04247             \textcolor{comment}{/* If this hash slot was served by 'myself' before to switch}
04248 \textcolor{comment}{             * make sure there are no longer local keys for this hash slot. */}
04249             \textcolor{keywordflow}{if} (server.cluster->slots[slot] == myself && n != myself) \{
04250                 \textcolor{keywordflow}{if} (countKeysInSlot(slot) != 0) \{
04251                     addReplyErrorFormat(c,
04252                         \textcolor{stringliteral}{"Can't assign hashslot %d to a different node "}
04253                         \textcolor{stringliteral}{"while I still hold keys for this hash slot."}, slot);
04254                     \textcolor{keywordflow}{return};
04255                 \}
04256             \}
04257             \textcolor{comment}{/* If this slot is in migrating status but we have no keys}
04258 \textcolor{comment}{             * for it assigning the slot to another node will clear}
04259 \textcolor{comment}{             * the migratig status. */}
04260             \textcolor{keywordflow}{if} (countKeysInSlot(slot) == 0 &&
04261                 server.cluster->migrating\_slots\_to[slot])
04262                 server.cluster->migrating\_slots\_to[slot] = NULL;
04263 
04264             \textcolor{comment}{/* If this node was importing this slot, assigning the slot to}
04265 \textcolor{comment}{             * itself also clears the importing status. */}
04266             \textcolor{keywordflow}{if} (n == myself &&
04267                 server.cluster->importing\_slots\_from[slot])
04268             \{
04269                 \textcolor{comment}{/* This slot was manually migrated, set this node configEpoch}
04270 \textcolor{comment}{                 * to a new epoch so that the new version can be propagated}
04271 \textcolor{comment}{                 * by the cluster.}
04272 \textcolor{comment}{                 *}
04273 \textcolor{comment}{                 * Note that if this ever results in a collision with another}
04274 \textcolor{comment}{                 * node getting the same configEpoch, for example because a}
04275 \textcolor{comment}{                 * failover happens at the same time we close the slot, the}
04276 \textcolor{comment}{                 * configEpoch collision resolution will fix it assigning}
04277 \textcolor{comment}{                 * a different epoch to each node. */}
04278                 \textcolor{keywordflow}{if} (clusterBumpConfigEpochWithoutConsensus() == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
04279                     serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
04280                         \textcolor{stringliteral}{"configEpoch updated after importing slot %d"}, slot);
04281                 \}
04282                 server.cluster->importing\_slots\_from[slot] = NULL;
04283             \}
04284             clusterDelSlot(slot);
04285             clusterAddSlot(n,slot);
04286         \} \textcolor{keywordflow}{else} \{
04287             addReplyError(c,
04288                 \textcolor{stringliteral}{"Invalid CLUSTER SETSLOT action or number of arguments. Try CLUSTER HELP"});
04289             \textcolor{keywordflow}{return};
04290         \}
04291         clusterDoBeforeSleep(\hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG}|
      \hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE});
04292         addReply(c,shared.ok);
04293     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"bumpepoch"}) && c->argc == 2) \{
04294         \textcolor{comment}{/* CLUSTER BUMPEPOCH */}
04295         \textcolor{keywordtype}{int} retval = clusterBumpConfigEpochWithoutConsensus();
04296         sds reply = sdscatprintf(sdsempty(),\textcolor{stringliteral}{"+%s %llu\(\backslash\)r\(\backslash\)n"},
04297                 (retval == \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) ? \textcolor{stringliteral}{"BUMPED"} : \textcolor{stringliteral}{"STILL"},
04298                 (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) myself->configEpoch);
04299         addReplySds(c,reply);
04300     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"info"}) && c->argc == 2) \{
04301         \textcolor{comment}{/* CLUSTER INFO */}
04302         \textcolor{keywordtype}{char} *statestr[] = \{\textcolor{stringliteral}{"ok"},\textcolor{stringliteral}{"fail"},\textcolor{stringliteral}{"needhelp"}\};
04303         \textcolor{keywordtype}{int} slots\_assigned = 0, slots\_ok = 0, slots\_pfail = 0, slots\_fail = 0;
04304         uint64\_t myepoch;
04305         \textcolor{keywordtype}{int} j;
04306 
04307         \textcolor{keywordflow}{for} (j = 0; j < \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}; j++) \{
04308             clusterNode *n = server.cluster->slots[j];
04309 
04310             \textcolor{keywordflow}{if} (n == NULL) \textcolor{keywordflow}{continue};
04311             slots\_assigned++;
04312             \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a6a31c614ff4f5ac8ebaa630b0a921c3d}{nodeFailed}(n)) \{
04313                 slots\_fail++;
04314             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_ac0ab1cbdbc2a49b30c98d73640476e32}{nodeTimedOut}(n)) \{
04315                 slots\_pfail++;
04316             \} \textcolor{keywordflow}{else} \{
04317                 slots\_ok++;
04318             \}
04319         \}
04320 
04321         myepoch = (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(myself) && myself->slaveof) ?
04322                   myself->slaveof->configEpoch : myself->configEpoch;
04323 
04324         sds info = sdscatprintf(sdsempty(),
04325             \textcolor{stringliteral}{"cluster\_state:%s\(\backslash\)r\(\backslash\)n"}
04326             \textcolor{stringliteral}{"cluster\_slots\_assigned:%d\(\backslash\)r\(\backslash\)n"}
04327             \textcolor{stringliteral}{"cluster\_slots\_ok:%d\(\backslash\)r\(\backslash\)n"}
04328             \textcolor{stringliteral}{"cluster\_slots\_pfail:%d\(\backslash\)r\(\backslash\)n"}
04329             \textcolor{stringliteral}{"cluster\_slots\_fail:%d\(\backslash\)r\(\backslash\)n"}
04330             \textcolor{stringliteral}{"cluster\_known\_nodes:%lu\(\backslash\)r\(\backslash\)n"}
04331             \textcolor{stringliteral}{"cluster\_size:%d\(\backslash\)r\(\backslash\)n"}
04332             \textcolor{stringliteral}{"cluster\_current\_epoch:%llu\(\backslash\)r\(\backslash\)n"}
04333             \textcolor{stringliteral}{"cluster\_my\_epoch:%llu\(\backslash\)r\(\backslash\)n"}
04334             , statestr[server.cluster->state],
04335             slots\_assigned,
04336             slots\_ok,
04337             slots\_pfail,
04338             slots\_fail,
04339             \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.cluster->nodes),
04340             server.cluster->size,
04341             (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) server.cluster->currentEpoch,
04342             (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) myepoch
04343         );
04344 
04345         \textcolor{comment}{/* Show stats about messages sent and received. */}
04346         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} tot\_msg\_sent = 0;
04347         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} tot\_msg\_received = 0;
04348 
04349         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < \hyperlink{cluster_8h_a6222c464c1f2125f42271d2abd63853e}{CLUSTERMSG\_TYPE\_COUNT}; i++) \{
04350             \textcolor{keywordflow}{if} (server.cluster->stats\_bus\_messages\_sent[i] == 0) \textcolor{keywordflow}{continue};
04351             tot\_msg\_sent += server.cluster->stats\_bus\_messages\_sent[i];
04352             info = sdscatprintf(info,
04353                 \textcolor{stringliteral}{"cluster\_stats\_messages\_%s\_sent:%lld\(\backslash\)r\(\backslash\)n"},
04354                 clusterGetMessageTypeString(i),
04355                 server.cluster->stats\_bus\_messages\_sent[i]);
04356         \}
04357         info = sdscatprintf(info,
04358             \textcolor{stringliteral}{"cluster\_stats\_messages\_sent:%lld\(\backslash\)r\(\backslash\)n"}, tot\_msg\_sent);
04359 
04360         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < \hyperlink{cluster_8h_a6222c464c1f2125f42271d2abd63853e}{CLUSTERMSG\_TYPE\_COUNT}; i++) \{
04361             \textcolor{keywordflow}{if} (server.cluster->stats\_bus\_messages\_received[i] == 0) \textcolor{keywordflow}{continue};
04362             tot\_msg\_received += server.cluster->stats\_bus\_messages\_received[i];
04363             info = sdscatprintf(info,
04364                 \textcolor{stringliteral}{"cluster\_stats\_messages\_%s\_received:%lld\(\backslash\)r\(\backslash\)n"},
04365                 clusterGetMessageTypeString(i),
04366                 server.cluster->stats\_bus\_messages\_received[i]);
04367         \}
04368         info = sdscatprintf(info,
04369             \textcolor{stringliteral}{"cluster\_stats\_messages\_received:%lld\(\backslash\)r\(\backslash\)n"}, tot\_msg\_received);
04370 
04371         \textcolor{comment}{/* Produce the reply protocol. */}
04372         addReplySds(c,sdscatprintf(sdsempty(),\textcolor{stringliteral}{"$%lu\(\backslash\)r\(\backslash\)n"},
04373             (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long})sdslen(info)));
04374         addReplySds(c,info);
04375         addReply(c,shared.crlf);
04376     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"saveconfig"}) && c->argc == 2) \{
04377         \textcolor{keywordtype}{int} retval = clusterSaveConfig(1);
04378 
04379         \textcolor{keywordflow}{if} (retval == 0)
04380             addReply(c,shared.ok);
04381         \textcolor{keywordflow}{else}
04382             addReplyErrorFormat(c,\textcolor{stringliteral}{"error saving the cluster node config: %s"},
04383                 strerror(errno));
04384     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"keyslot"}) && c->argc == 3) \{
04385         \textcolor{comment}{/* CLUSTER KEYSLOT <key> */}
04386         sds key = c->argv[2]->ptr;
04387 
04388         addReplyLongLong(c,keyHashSlot(key,sdslen(key)));
04389     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"countkeysinslot"}) && c->argc == 3) \{
04390         \textcolor{comment}{/* CLUSTER COUNTKEYSINSLOT <slot> */}
04391         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} slot;
04392 
04393         \textcolor{keywordflow}{if} (getLongLongFromObjectOrReply(c,c->argv[2],&slot,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
04394             \textcolor{keywordflow}{return};
04395         \textcolor{keywordflow}{if} (slot < 0 || slot >= \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS}) \{
04396             addReplyError(c,\textcolor{stringliteral}{"Invalid slot"});
04397             \textcolor{keywordflow}{return};
04398         \}
04399         addReplyLongLong(c,countKeysInSlot(slot));
04400     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"getkeysinslot"}) && c->argc == 4) \{
04401         \textcolor{comment}{/* CLUSTER GETKEYSINSLOT <slot> <count> */}
04402         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} maxkeys, slot;
04403         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} numkeys, j;
04404         robj **keys;
04405 
04406         \textcolor{keywordflow}{if} (getLongLongFromObjectOrReply(c,c->argv[2],&slot,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
04407             \textcolor{keywordflow}{return};
04408         \textcolor{keywordflow}{if} (getLongLongFromObjectOrReply(c,c->argv[3],&maxkeys,NULL)
04409             != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
04410             \textcolor{keywordflow}{return};
04411         \textcolor{keywordflow}{if} (slot < 0 || slot >= \hyperlink{cluster_8h_aa3e2cb951eebb16725ecc3f5beefd9fd}{CLUSTER\_SLOTS} || maxkeys < 0) \{
04412             addReplyError(c,\textcolor{stringliteral}{"Invalid slot or number of keys"});
04413             \textcolor{keywordflow}{return};
04414         \}
04415 
04416         \textcolor{comment}{/* Avoid allocating more than needed in case of large COUNT argument}
04417 \textcolor{comment}{         * and smaller actual number of keys. */}
04418         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} keys\_in\_slot = countKeysInSlot(slot);
04419         \textcolor{keywordflow}{if} (maxkeys > keys\_in\_slot) maxkeys = keys\_in\_slot;
04420 
04421         keys = zmalloc(\textcolor{keyword}{sizeof}(robj*)*maxkeys);
04422         numkeys = getKeysInSlot(slot, keys, maxkeys);
04423         addReplyMultiBulkLen(c,numkeys);
04424         \textcolor{keywordflow}{for} (j = 0; j < numkeys; j++) \{
04425             addReplyBulk(c,keys[j]);
04426             decrRefCount(keys[j]);
04427         \}
04428         zfree(keys);
04429     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"forget"}) && c->argc == 3) \{
04430         \textcolor{comment}{/* CLUSTER FORGET <NODE ID> */}
04431         clusterNode *n = clusterLookupNode(c->argv[2]->ptr);
04432 
04433         \textcolor{keywordflow}{if} (!n) \{
04434             addReplyErrorFormat(c,\textcolor{stringliteral}{"Unknown node %s"}, (\textcolor{keywordtype}{char}*)c->argv[2]->ptr);
04435             \textcolor{keywordflow}{return};
04436         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n == myself) \{
04437             addReplyError(c,\textcolor{stringliteral}{"I tried hard but I can't forget myself..."});
04438             \textcolor{keywordflow}{return};
04439         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(myself) && myself->slaveof == n) \{
04440             addReplyError(c,\textcolor{stringliteral}{"Can't forget my master!"});
04441             \textcolor{keywordflow}{return};
04442         \}
04443         clusterBlacklistAddNode(n);
04444         clusterDelNode(n);
04445         clusterDoBeforeSleep(\hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE}|
04446                              \hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG});
04447         addReply(c,shared.ok);
04448     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"replicate"}) && c->argc == 3) \{
04449         \textcolor{comment}{/* CLUSTER REPLICATE <NODE ID> */}
04450         clusterNode *n = clusterLookupNode(c->argv[2]->ptr);
04451 
04452         \textcolor{comment}{/* Lookup the specified node in our table. */}
04453         \textcolor{keywordflow}{if} (!n) \{
04454             addReplyErrorFormat(c,\textcolor{stringliteral}{"Unknown node %s"}, (\textcolor{keywordtype}{char}*)c->argv[2]->ptr);
04455             \textcolor{keywordflow}{return};
04456         \}
04457 
04458         \textcolor{comment}{/* I can't replicate myself. */}
04459         \textcolor{keywordflow}{if} (n == myself) \{
04460             addReplyError(c,\textcolor{stringliteral}{"Can't replicate myself"});
04461             \textcolor{keywordflow}{return};
04462         \}
04463 
04464         \textcolor{comment}{/* Can't replicate a slave. */}
04465         \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(n)) \{
04466             addReplyError(c,\textcolor{stringliteral}{"I can only replicate a master, not a slave."});
04467             \textcolor{keywordflow}{return};
04468         \}
04469 
04470         \textcolor{comment}{/* If the instance is currently a master, it should have no assigned}
04471 \textcolor{comment}{         * slots nor keys to accept to replicate some other node.}
04472 \textcolor{comment}{         * Slaves can switch to another master without issues. */}
04473         \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(myself) &&
04474             (myself->numslots != 0 || \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.db[0].dict) != 0)) \{
04475             addReplyError(c,
04476                 \textcolor{stringliteral}{"To set a master the node must be empty and "}
04477                 \textcolor{stringliteral}{"without assigned slots."});
04478             \textcolor{keywordflow}{return};
04479         \}
04480 
04481         \textcolor{comment}{/* Set the master. */}
04482         clusterSetMaster(n);
04483         clusterDoBeforeSleep(\hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE}|
      \hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG});
04484         addReply(c,shared.ok);
04485     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"slaves"}) && c->argc == 3) \{
04486         \textcolor{comment}{/* CLUSTER SLAVES <NODE ID> */}
04487         clusterNode *n = clusterLookupNode(c->argv[2]->ptr);
04488         \textcolor{keywordtype}{int} j;
04489 
04490         \textcolor{comment}{/* Lookup the specified node in our table. */}
04491         \textcolor{keywordflow}{if} (!n) \{
04492             addReplyErrorFormat(c,\textcolor{stringliteral}{"Unknown node %s"}, (\textcolor{keywordtype}{char}*)c->argv[2]->ptr);
04493             \textcolor{keywordflow}{return};
04494         \}
04495 
04496         \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(n)) \{
04497             addReplyError(c,\textcolor{stringliteral}{"The specified node is not a master"});
04498             \textcolor{keywordflow}{return};
04499         \}
04500 
04501         addReplyMultiBulkLen(c,n->numslaves);
04502         \textcolor{keywordflow}{for} (j = 0; j < n->numslaves; j++) \{
04503             sds ni = clusterGenNodeDescription(n->slaves[j]);
04504             addReplyBulkCString(c,ni);
04505             sdsfree(ni);
04506         \}
04507     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"count-failure-reports"}) &&
04508                c->argc == 3)
04509     \{
04510         \textcolor{comment}{/* CLUSTER COUNT-FAILURE-REPORTS <NODE ID> */}
04511         clusterNode *n = clusterLookupNode(c->argv[2]->ptr);
04512 
04513         \textcolor{keywordflow}{if} (!n) \{
04514             addReplyErrorFormat(c,\textcolor{stringliteral}{"Unknown node %s"}, (\textcolor{keywordtype}{char}*)c->argv[2]->ptr);
04515             \textcolor{keywordflow}{return};
04516         \} \textcolor{keywordflow}{else} \{
04517             addReplyLongLong(c,clusterNodeFailureReportsCount(n));
04518         \}
04519     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"failover"}) &&
04520                (c->argc == 2 || c->argc == 3))
04521     \{
04522         \textcolor{comment}{/* CLUSTER FAILOVER [FORCE|TAKEOVER] */}
04523         \textcolor{keywordtype}{int} force = 0, takeover = 0;
04524 
04525         \textcolor{keywordflow}{if} (c->argc == 3) \{
04526             \textcolor{keywordflow}{if} (!strcasecmp(c->argv[2]->ptr,\textcolor{stringliteral}{"force"})) \{
04527                 force = 1;
04528             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[2]->ptr,\textcolor{stringliteral}{"takeover"})) \{
04529                 takeover = 1;
04530                 force = 1; \textcolor{comment}{/* Takeover also implies force. */}
04531             \} \textcolor{keywordflow}{else} \{
04532                 addReply(c,shared.syntaxerr);
04533                 \textcolor{keywordflow}{return};
04534             \}
04535         \}
04536 
04537         \textcolor{comment}{/* Check preconditions. */}
04538         \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(myself)) \{
04539             addReplyError(c,\textcolor{stringliteral}{"You should send CLUSTER FAILOVER to a slave"});
04540             \textcolor{keywordflow}{return};
04541         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (myself->slaveof == NULL) \{
04542             addReplyError(c,\textcolor{stringliteral}{"I'm a slave but my master is unknown to me"});
04543             \textcolor{keywordflow}{return};
04544         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!force &&
04545                    (\hyperlink{cluster_8h_a6a31c614ff4f5ac8ebaa630b0a921c3d}{nodeFailed}(myself->slaveof) ||
04546                     myself->slaveof->link == NULL))
04547         \{
04548             addReplyError(c,\textcolor{stringliteral}{"Master is down or failed, "}
04549                             \textcolor{stringliteral}{"please use CLUSTER FAILOVER FORCE"});
04550             \textcolor{keywordflow}{return};
04551         \}
04552         resetManualFailover();
04553         server.cluster->mf\_end = mstime() + \hyperlink{cluster_8h_a869ee97118edc95fc7ba2abe472ef79e}{CLUSTER\_MF\_TIMEOUT};
04554 
04555         \textcolor{keywordflow}{if} (takeover) \{
04556             \textcolor{comment}{/* A takeover does not perform any initial check. It just}
04557 \textcolor{comment}{             * generates a new configuration epoch for this node without}
04558 \textcolor{comment}{             * consensus, claims the master's slots, and broadcast the new}
04559 \textcolor{comment}{             * configuration. */}
04560             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Taking over the master (user request)."});
04561             clusterBumpConfigEpochWithoutConsensus();
04562             clusterFailoverReplaceYourMaster();
04563         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (force) \{
04564             \textcolor{comment}{/* If this is a forced failover, we don't need to talk with our}
04565 \textcolor{comment}{             * master to agree about the offset. We just failover taking over}
04566 \textcolor{comment}{             * it without coordination. */}
04567             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Forced failover user request accepted."});
04568             server.cluster->mf\_can\_start = 1;
04569         \} \textcolor{keywordflow}{else} \{
04570             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},\textcolor{stringliteral}{"Manual failover user request accepted."});
04571             clusterSendMFStart(myself->slaveof);
04572         \}
04573         addReply(c,shared.ok);
04574     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"set-config-epoch"}) && c->argc == 3)
04575     \{
04576         \textcolor{comment}{/* CLUSTER SET-CONFIG-EPOCH <epoch>}
04577 \textcolor{comment}{         *}
04578 \textcolor{comment}{         * The user is allowed to set the config epoch only when a node is}
04579 \textcolor{comment}{         * totally fresh: no config epoch, no other known node, and so forth.}
04580 \textcolor{comment}{         * This happens at cluster creation time to start with a cluster where}
04581 \textcolor{comment}{         * every node has a different node ID, without to rely on the conflicts}
04582 \textcolor{comment}{         * resolution system which is too slow when a big cluster is created. */}
04583         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} epoch;
04584 
04585         \textcolor{keywordflow}{if} (getLongLongFromObjectOrReply(c,c->argv[2],&epoch,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
04586             \textcolor{keywordflow}{return};
04587 
04588         \textcolor{keywordflow}{if} (epoch < 0) \{
04589             addReplyErrorFormat(c,\textcolor{stringliteral}{"Invalid config epoch specified: %lld"},epoch);
04590         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.cluster->nodes) > 1) \{
04591             addReplyError(c,\textcolor{stringliteral}{"The user can assign a config epoch only when the "}
04592                             \textcolor{stringliteral}{"node does not know any other node."});
04593         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (myself->configEpoch != 0) \{
04594             addReplyError(c,\textcolor{stringliteral}{"Node config epoch is already non-zero"});
04595         \} \textcolor{keywordflow}{else} \{
04596             myself->configEpoch = epoch;
04597             serverLog(\hyperlink{server_8h_a31229b9334bba7d6be2a72970967a14b}{LL\_WARNING},
04598                 \textcolor{stringliteral}{"configEpoch set to %llu via CLUSTER SET-CONFIG-EPOCH"},
04599                 (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}) myself->configEpoch);
04600 
04601             \textcolor{keywordflow}{if} (server.cluster->currentEpoch < (uint64\_t)epoch)
04602                 server.cluster->currentEpoch = epoch;
04603             \textcolor{comment}{/* No need to fsync the config here since in the unlucky event}
04604 \textcolor{comment}{             * of a failure to persist the config, the conflict resolution code}
04605 \textcolor{comment}{             * will assign an unique config to this node. */}
04606             clusterDoBeforeSleep(\hyperlink{cluster_8h_abea0d393cba342261e4a7e6fb745f388}{CLUSTER\_TODO\_UPDATE\_STATE}|
04607                                  \hyperlink{cluster_8h_a0ae5ff08fbae3c655012b4de8bfc327d}{CLUSTER\_TODO\_SAVE\_CONFIG});
04608             addReply(c,shared.ok);
04609         \}
04610     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[1]->ptr,\textcolor{stringliteral}{"reset"}) &&
04611                (c->argc == 2 || c->argc == 3))
04612     \{
04613         \textcolor{comment}{/* CLUSTER RESET [SOFT|HARD] */}
04614         \textcolor{keywordtype}{int} hard = 0;
04615 
04616         \textcolor{comment}{/* Parse soft/hard argument. Default is soft. */}
04617         \textcolor{keywordflow}{if} (c->argc == 3) \{
04618             \textcolor{keywordflow}{if} (!strcasecmp(c->argv[2]->ptr,\textcolor{stringliteral}{"hard"})) \{
04619                 hard = 1;
04620             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[2]->ptr,\textcolor{stringliteral}{"soft"})) \{
04621                 hard = 0;
04622             \} \textcolor{keywordflow}{else} \{
04623                 addReply(c,shared.syntaxerr);
04624                 \textcolor{keywordflow}{return};
04625             \}
04626         \}
04627 
04628         \textcolor{comment}{/* Slaves can be reset while containing data, but not master nodes}
04629 \textcolor{comment}{         * that must be empty. */}
04630         \textcolor{keywordflow}{if} (\hyperlink{cluster_8h_a2d8e84269474d8750565fb3fb67aa436}{nodeIsMaster}(myself) && \hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(c->db->dict) != 0) \{
04631             addReplyError(c,\textcolor{stringliteral}{"CLUSTER RESET can't be called with "}
04632                             \textcolor{stringliteral}{"master nodes containing keys"});
04633             \textcolor{keywordflow}{return};
04634         \}
04635         clusterReset(hard);
04636         addReply(c,shared.ok);
04637     \} \textcolor{keywordflow}{else} \{
04638          addReplyErrorFormat(c, \textcolor{stringliteral}{"Unknown subcommand or wrong number of arguments for '%s'. Try CLUSTER
       HELP"},
04639             (\textcolor{keywordtype}{char}*)c->argv[1]->ptr);
04640         \textcolor{keywordflow}{return};
04641     \}
04642 \}
04643 
04644 \textcolor{comment}{/* -----------------------------------------------------------------------------}
04645 \textcolor{comment}{ * DUMP, RESTORE and MIGRATE commands}
04646 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
04647 
04648 \textcolor{comment}{/* Generates a DUMP-format representation of the object 'o', adding it to the}
04649 \textcolor{comment}{ * io stream pointed by 'rio'. This function can't fail. */}
04650 \textcolor{keywordtype}{void} createDumpPayload(rio *payload, robj *o) \{
04651     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} buf[2];
04652     uint64\_t crc;
04653 
04654     \textcolor{comment}{/* Serialize the object in a RDB-like format. It consist of an object type}
04655 \textcolor{comment}{     * byte followed by the serialized object. This is understood by RESTORE. */}
04656     rioInitWithBuffer(payload,sdsempty());
04657     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(rdbSaveObjectType(payload,o));
04658     \hyperlink{server_8h_a88114b5169b4c382df6b56506285e56a}{serverAssert}(rdbSaveObject(payload,o));
04659 
04660     \textcolor{comment}{/* Write the footer, this is how it looks like:}
04661 \textcolor{comment}{     * ----------------+---------------------+---------------+}
04662 \textcolor{comment}{     * ... RDB payload | 2 bytes RDB version | 8 bytes CRC64 |}
04663 \textcolor{comment}{     * ----------------+---------------------+---------------+}
04664 \textcolor{comment}{     * RDB version and CRC are both in little endian.}
04665 \textcolor{comment}{     */}
04666 
04667     \textcolor{comment}{/* RDB version */}
04668     buf[0] = \hyperlink{rdb_8h_ae34418fdbb9794fb7558a4f58bdc1cad}{RDB\_VERSION} & 0xff;
04669     buf[1] = (\hyperlink{rdb_8h_ae34418fdbb9794fb7558a4f58bdc1cad}{RDB\_VERSION} >> 8) & 0xff;
04670     payload->io.buffer.ptr = sdscatlen(payload->io.buffer.ptr,buf,2);
04671 
04672     \textcolor{comment}{/* CRC64 */}
04673     crc = crc64(0,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)payload->io.buffer.ptr,
04674                 sdslen(payload->io.buffer.ptr));
04675     \hyperlink{endianconv_8h_aa311b9f944c3b988f3601698a95890c1}{memrev64ifbe}(&crc);
04676     payload->io.buffer.ptr = sdscatlen(payload->io.buffer.ptr,&crc,8);
04677 \}
04678 
04679 \textcolor{comment}{/* Verify that the RDB version of the dump payload matches the one of this Redis}
04680 \textcolor{comment}{ * instance and that the checksum is ok.}
04681 \textcolor{comment}{ * If the DUMP payload looks valid C\_OK is returned, otherwise C\_ERR}
04682 \textcolor{comment}{ * is returned. */}
04683 \textcolor{keywordtype}{int} verifyDumpPayload(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p, size\_t len) \{
04684     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *footer;
04685     uint16\_t rdbver;
04686     uint64\_t crc;
04687 
04688     \textcolor{comment}{/* At least 2 bytes of RDB version and 8 of CRC64 should be present. */}
04689     \textcolor{keywordflow}{if} (len < 10) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
04690     footer = p+(len-10);
04691 
04692     \textcolor{comment}{/* Verify RDB version */}
04693     rdbver = (footer[1] << 8) | footer[0];
04694     \textcolor{keywordflow}{if} (rdbver > \hyperlink{rdb_8h_ae34418fdbb9794fb7558a4f58bdc1cad}{RDB\_VERSION}) \textcolor{keywordflow}{return} \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
04695 
04696     \textcolor{comment}{/* Verify CRC64 */}
04697     crc = crc64(0,p,len-8);
04698     \hyperlink{endianconv_8h_aa311b9f944c3b988f3601698a95890c1}{memrev64ifbe}(&crc);
04699     \textcolor{keywordflow}{return} (memcmp(&crc,footer+2,8) == 0) ? \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK} : \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR};
04700 \}
04701 
04702 \textcolor{comment}{/* DUMP keyname}
04703 \textcolor{comment}{ * DUMP is actually not used by Redis Cluster but it is the obvious}
04704 \textcolor{comment}{ * complement of RESTORE and can be useful for different applications. */}
04705 \textcolor{keywordtype}{void} dumpCommand(\hyperlink{structclient}{client} *c) \{
04706     robj *o, *dumpobj;
04707     rio payload;
04708 
04709     \textcolor{comment}{/* Check if the key is here. */}
04710     \textcolor{keywordflow}{if} ((o = lookupKeyRead(c->db,c->argv[1])) == NULL) \{
04711         addReply(c,shared.nullbulk);
04712         \textcolor{keywordflow}{return};
04713     \}
04714 
04715     \textcolor{comment}{/* Create the DUMP encoded representation. */}
04716     createDumpPayload(&payload,o);
04717 
04718     \textcolor{comment}{/* Transfer to the client */}
04719     dumpobj = createObject(\hyperlink{server_8h_a65236ea160f69cdef33ec942092af88f}{OBJ\_STRING},payload.io.buffer.ptr);
04720     addReplyBulk(c,dumpobj);
04721     decrRefCount(dumpobj);
04722     \textcolor{keywordflow}{return};
04723 \}
04724 
04725 \textcolor{comment}{/* RESTORE key ttl serialized-value [REPLACE] */}
04726 \textcolor{keywordtype}{void} restoreCommand(\hyperlink{structclient}{client} *c) \{
04727     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ttl;
04728     rio payload;
04729     \textcolor{keywordtype}{int} j, type, replace = 0;
04730     robj *obj;
04731 
04732     \textcolor{comment}{/* Parse additional options */}
04733     \textcolor{keywordflow}{for} (j = 4; j < c->argc; j++) \{
04734         \textcolor{keywordflow}{if} (!strcasecmp(c->argv[j]->ptr,\textcolor{stringliteral}{"replace"})) \{
04735             replace = 1;
04736         \} \textcolor{keywordflow}{else} \{
04737             addReply(c,shared.syntaxerr);
04738             \textcolor{keywordflow}{return};
04739         \}
04740     \}
04741 
04742     \textcolor{comment}{/* Make sure this key does not already exist here... */}
04743     \textcolor{keywordflow}{if} (!replace && lookupKeyWrite(c->db,c->argv[1]) != NULL) \{
04744         addReply(c,shared.busykeyerr);
04745         \textcolor{keywordflow}{return};
04746     \}
04747 
04748     \textcolor{comment}{/* Check if the TTL value makes sense */}
04749     \textcolor{keywordflow}{if} (getLongLongFromObjectOrReply(c,c->argv[2],&ttl,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK}) \{
04750         \textcolor{keywordflow}{return};
04751     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ttl < 0) \{
04752         addReplyError(c,\textcolor{stringliteral}{"Invalid TTL value, must be >= 0"});
04753         \textcolor{keywordflow}{return};
04754     \}
04755 
04756     \textcolor{comment}{/* Verify RDB version and data checksum. */}
04757     \textcolor{keywordflow}{if} (verifyDumpPayload(c->argv[3]->ptr,sdslen(c->argv[3]->ptr)) == \hyperlink{server_8h_af98ac28d5f4d23d7ed5985188e6fb7d1}{C\_ERR})
04758     \{
04759         addReplyError(c,\textcolor{stringliteral}{"DUMP payload version or checksum are wrong"});
04760         \textcolor{keywordflow}{return};
04761     \}
04762 
04763     rioInitWithBuffer(&payload,c->argv[3]->ptr);
04764     \textcolor{keywordflow}{if} (((type = rdbLoadObjectType(&payload)) == -1) ||
04765         ((obj = rdbLoadObject(type,&payload)) == NULL))
04766     \{
04767         addReplyError(c,\textcolor{stringliteral}{"Bad data format"});
04768         \textcolor{keywordflow}{return};
04769     \}
04770 
04771     \textcolor{comment}{/* Remove the old key if needed. */}
04772     \textcolor{keywordflow}{if} (replace) dbDelete(c->db,c->argv[1]);
04773 
04774     \textcolor{comment}{/* Create the key and set the TTL if any */}
04775     dbAdd(c->db,c->argv[1],obj);
04776     \textcolor{keywordflow}{if} (ttl) setExpire(c,c->db,c->argv[1],mstime()+ttl);
04777     signalModifiedKey(c->db,c->argv[1]);
04778     addReply(c,shared.ok);
04779     server.dirty++;
04780 \}
04781 
04782 \textcolor{comment}{/* MIGRATE socket cache implementation.}
04783 \textcolor{comment}{ *}
04784 \textcolor{comment}{ * We take a map between host:ip and a TCP socket that we used to connect}
04785 \textcolor{comment}{ * to this instance in recent time.}
04786 \textcolor{comment}{ * This sockets are closed when the max number we cache is reached, and also}
04787 \textcolor{comment}{ * in serverCron() when they are around for more than a few seconds. */}
04788 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{MIGRATE\_SOCKET\_CACHE\_ITEMS} 64 \textcolor{comment}{/* max num of items in the cache. */}
04789 \textcolor{preprocessor}{#}\textcolor{preprocessor}{define} \textcolor{preprocessor}{MIGRATE\_SOCKET\_CACHE\_TTL} 10 \textcolor{comment}{/* close cached sockets after 10 sec. */}
04790 
\Hypertarget{cluster_8c_source_l04791}\hyperlink{structmigrateCachedSocket}{04791} \textcolor{keyword}{typedef} \textcolor{keyword}{struct} \hyperlink{structmigrateCachedSocket}{migrateCachedSocket} \{
04792     \textcolor{keywordtype}{int} fd;
04793     \textcolor{keywordtype}{long} last\_dbid;
04794     time\_t last\_use\_time;
04795 \} migrateCachedSocket;
04796 
04797 \textcolor{comment}{/* Return a migrateCachedSocket containing a TCP socket connected with the}
04798 \textcolor{comment}{ * target instance, possibly returning a cached one.}
04799 \textcolor{comment}{ *}
04800 \textcolor{comment}{ * This function is responsible of sending errors to the client if a}
04801 \textcolor{comment}{ * connection can't be established. In this case -1 is returned.}
04802 \textcolor{comment}{ * Otherwise on success the socket is returned, and the caller should not}
04803 \textcolor{comment}{ * attempt to free it after usage.}
04804 \textcolor{comment}{ *}
04805 \textcolor{comment}{ * If the caller detects an error while using the socket, migrateCloseSocket()}
04806 \textcolor{comment}{ * should be called so that the connection will be created from scratch}
04807 \textcolor{comment}{ * the next time. */}
04808 migrateCachedSocket* migrateGetSocket(\hyperlink{structclient}{client} *c, robj *host, robj *port, \textcolor{keywordtype}{long} timeout) \{
04809     \textcolor{keywordtype}{int} fd;
04810     sds name = sdsempty();
04811     migrateCachedSocket *cs;
04812 
04813     \textcolor{comment}{/* Check if we have an already cached socket for this ip:port pair. */}
04814     name = sdscatlen(name,host->ptr,sdslen(host->ptr));
04815     name = sdscatlen(name,\textcolor{stringliteral}{":"},1);
04816     name = sdscatlen(name,port->ptr,sdslen(port->ptr));
04817     cs = dictFetchValue(server.migrate\_cached\_sockets,name);
04818     \textcolor{keywordflow}{if} (cs) \{
04819         sdsfree(name);
04820         cs->last\_use\_time = server.unixtime;
04821         \textcolor{keywordflow}{return} cs;
04822     \}
04823 
04824     \textcolor{comment}{/* No cached socket, create one. */}
04825     \textcolor{keywordflow}{if} (\hyperlink{dict_8h_af193430dd3d5579a52b194512f72c1f0}{dictSize}(server.migrate\_cached\_sockets) == 
      \hyperlink{cluster_8c_ac30325257580f172bb7885ac10c482f7}{MIGRATE\_SOCKET\_CACHE\_ITEMS}) \{
04826         \textcolor{comment}{/* Too many items, drop one at random. */}
04827         dictEntry *de = dictGetRandomKey(server.migrate\_cached\_sockets);
04828         cs = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
04829         close(cs->fd);
04830         zfree(cs);
04831         dictDelete(server.migrate\_cached\_sockets,\hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de));
04832     \}
04833 
04834     \textcolor{comment}{/* Create the socket */}
04835     fd = anetTcpNonBlockConnect(server.neterr,c->argv[1]->ptr,
04836                                 atoi(c->argv[2]->ptr));
04837     \textcolor{keywordflow}{if} (fd == -1) \{
04838         sdsfree(name);
04839         addReplyErrorFormat(c,\textcolor{stringliteral}{"Can't connect to target node: %s"},
04840             server.neterr);
04841         \textcolor{keywordflow}{return} NULL;
04842     \}
04843     anetEnableTcpNoDelay(server.neterr,fd);
04844 
04845     \textcolor{comment}{/* Check if it connects within the specified timeout. */}
04846     \textcolor{keywordflow}{if} ((aeWait(fd,\hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE},timeout) & \hyperlink{ae_8h_ab6bfb0366ccb6277112d132c2a2bf500}{AE\_WRITABLE}) == 0) \{
04847         sdsfree(name);
04848         addReplySds(c,
04849             sdsnew(\textcolor{stringliteral}{"-IOERR error or timeout connecting to the client\(\backslash\)r\(\backslash\)n"}));
04850         close(fd);
04851         \textcolor{keywordflow}{return} NULL;
04852     \}
04853 
04854     \textcolor{comment}{/* Add to the cache and return it to the caller. */}
04855     cs = zmalloc(\textcolor{keyword}{sizeof}(*cs));
04856     cs->fd = fd;
04857     cs->last\_dbid = -1;
04858     cs->last\_use\_time = server.unixtime;
04859     dictAdd(server.migrate\_cached\_sockets,name,cs);
04860     \textcolor{keywordflow}{return} cs;
04861 \}
04862 
04863 \textcolor{comment}{/* Free a migrate cached connection. */}
04864 \textcolor{keywordtype}{void} migrateCloseSocket(robj *host, robj *port) \{
04865     sds name = sdsempty();
04866     migrateCachedSocket *cs;
04867 
04868     name = sdscatlen(name,host->ptr,sdslen(host->ptr));
04869     name = sdscatlen(name,\textcolor{stringliteral}{":"},1);
04870     name = sdscatlen(name,port->ptr,sdslen(port->ptr));
04871     cs = dictFetchValue(server.migrate\_cached\_sockets,name);
04872     \textcolor{keywordflow}{if} (!cs) \{
04873         sdsfree(name);
04874         \textcolor{keywordflow}{return};
04875     \}
04876 
04877     close(cs->fd);
04878     zfree(cs);
04879     dictDelete(server.migrate\_cached\_sockets,name);
04880     sdsfree(name);
04881 \}
04882 
04883 \textcolor{keywordtype}{void} migrateCloseTimedoutSockets(\textcolor{keywordtype}{void}) \{
04884     dictIterator *di = dictGetSafeIterator(server.migrate\_cached\_sockets);
04885     dictEntry *de;
04886 
04887     \textcolor{keywordflow}{while}((de = dictNext(di)) != NULL) \{
04888         migrateCachedSocket *cs = \hyperlink{dict_8h_ae8d2cc391873b2bea2b87c4f80f43120}{dictGetVal}(de);
04889 
04890         \textcolor{keywordflow}{if} ((server.unixtime - cs->last\_use\_time) > 
      \hyperlink{cluster_8c_ad338d1ae62fe93944193ff175f6d6526}{MIGRATE\_SOCKET\_CACHE\_TTL}) \{
04891             close(cs->fd);
04892             zfree(cs);
04893             dictDelete(server.migrate\_cached\_sockets,\hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de));
04894         \}
04895     \}
04896     dictReleaseIterator(di);
04897 \}
04898 
04899 \textcolor{comment}{/* MIGRATE host port key dbid timeout [COPY | REPLACE]}
04900 \textcolor{comment}{ *}
04901 \textcolor{comment}{ * On in the multiple keys form:}
04902 \textcolor{comment}{ *}
04903 \textcolor{comment}{ * MIGRATE host port "" dbid timeout [COPY | REPLACE] KEYS key1 key2 ... keyN */}
04904 \textcolor{keywordtype}{void} migrateCommand(\hyperlink{structclient}{client} *c) \{
04905     migrateCachedSocket *cs;
04906     \textcolor{keywordtype}{int} copy, replace, j;
04907     \textcolor{keywordtype}{long} timeout;
04908     \textcolor{keywordtype}{long} dbid;
04909     robj **ov = NULL; \textcolor{comment}{/* Objects to migrate. */}
04910     robj **kv = NULL; \textcolor{comment}{/* Key names. */}
04911     robj **newargv = NULL; \textcolor{comment}{/* Used to rewrite the command as DEL ... keys ... */}
04912     rio cmd, payload;
04913     \textcolor{keywordtype}{int} may\_retry = 1;
04914     \textcolor{keywordtype}{int} write\_error = 0;
04915     \textcolor{keywordtype}{int} argv\_rewritten = 0;
04916 
04917     \textcolor{comment}{/* To support the KEYS option we need the following additional state. */}
04918     \textcolor{keywordtype}{int} first\_key = 3; \textcolor{comment}{/* Argument index of the first key. */}
04919     \textcolor{keywordtype}{int} num\_keys = 1;  \textcolor{comment}{/* By default only migrate the 'key' argument. */}
04920 
04921     \textcolor{comment}{/* Initialization */}
04922     copy = 0;
04923     replace = 0;
04924 
04925     \textcolor{comment}{/* Parse additional options */}
04926     \textcolor{keywordflow}{for} (j = 6; j < c->argc; j++) \{
04927         \textcolor{keywordflow}{if} (!strcasecmp(c->argv[j]->ptr,\textcolor{stringliteral}{"copy"})) \{
04928             copy = 1;
04929         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[j]->ptr,\textcolor{stringliteral}{"replace"})) \{
04930             replace = 1;
04931         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!strcasecmp(c->argv[j]->ptr,\textcolor{stringliteral}{"keys"})) \{
04932             \textcolor{keywordflow}{if} (sdslen(c->argv[3]->ptr) != 0) \{
04933                 addReplyError(c,
04934                     \textcolor{stringliteral}{"When using MIGRATE KEYS option, the key argument"}
04935                     \textcolor{stringliteral}{" must be set to the empty string"});
04936                 \textcolor{keywordflow}{return};
04937             \}
04938             first\_key = j+1;
04939             num\_keys = c->argc - j - 1;
04940             \textcolor{keywordflow}{break}; \textcolor{comment}{/* All the remaining args are keys. */}
04941         \} \textcolor{keywordflow}{else} \{
04942             addReply(c,shared.syntaxerr);
04943             \textcolor{keywordflow}{return};
04944         \}
04945     \}
04946 
04947     \textcolor{comment}{/* Sanity check */}
04948     \textcolor{keywordflow}{if} (getLongFromObjectOrReply(c,c->argv[5],&timeout,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK} ||
04949         getLongFromObjectOrReply(c,c->argv[4],&dbid,NULL) != \hyperlink{server_8h_a303769ef1065076e68731584e758d3e1}{C\_OK})
04950     \{
04951         \textcolor{keywordflow}{return};
04952     \}
04953     \textcolor{keywordflow}{if} (timeout <= 0) timeout = 1000;
04954 
04955     \textcolor{comment}{/* Check if the keys are here. If at least one key is to migrate, do it}
04956 \textcolor{comment}{     * otherwise if all the keys are missing reply with "NOKEY" to signal}
04957 \textcolor{comment}{     * the caller there was nothing to migrate. We don't return an error in}
04958 \textcolor{comment}{     * this case, since often this is due to a normal condition like the key}
04959 \textcolor{comment}{     * expiring in the meantime. */}
04960     ov = zrealloc(ov,\textcolor{keyword}{sizeof}(robj*)*num\_keys);
04961     kv = zrealloc(kv,\textcolor{keyword}{sizeof}(robj*)*num\_keys);
04962     \textcolor{keywordtype}{int} oi = 0;
04963 
04964     \textcolor{keywordflow}{for} (j = 0; j < num\_keys; j++) \{
04965         \textcolor{keywordflow}{if} ((ov[oi] = lookupKeyRead(c->db,c->argv[first\_key+j])) != NULL) \{
04966             kv[oi] = c->argv[first\_key+j];
04967             oi++;
04968         \}
04969     \}
04970     num\_keys = oi;
04971     \textcolor{keywordflow}{if} (num\_keys == 0) \{
04972         zfree(ov); zfree(kv);
04973         addReplySds(c,sdsnew(\textcolor{stringliteral}{"+NOKEY\(\backslash\)r\(\backslash\)n"}));
04974         \textcolor{keywordflow}{return};
04975     \}
04976 
04977 try\_again:
04978     write\_error = 0;
04979 
04980     \textcolor{comment}{/* Connect */}
04981     cs = migrateGetSocket(c,c->argv[1],c->argv[2],timeout);
04982     \textcolor{keywordflow}{if} (cs == NULL) \{
04983         zfree(ov); zfree(kv);
04984         \textcolor{keywordflow}{return}; \textcolor{comment}{/* error sent to the client by migrateGetSocket() */}
04985     \}
04986 
04987     rioInitWithBuffer(&cmd,sdsempty());
04988 
04989     \textcolor{comment}{/* Send the SELECT command if the current DB is not already selected. */}
04990     \textcolor{keywordtype}{int} select = cs->last\_dbid != dbid; \textcolor{comment}{/* Should we emit SELECT? */}
04991     \textcolor{keywordflow}{if} (select) \{
04992         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,rioWriteBulkCount(&cmd,\textcolor{stringliteral}{'*'},2));
04993         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,rioWriteBulkString(&cmd,\textcolor{stringliteral}{"SELECT"},6));
04994         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,rioWriteBulkLongLong(&cmd,dbid));
04995     \}
04996 
04997     \textcolor{comment}{/* Create RESTORE payload and generate the protocol to call the command. */}
04998     \textcolor{keywordflow}{for} (j = 0; j < num\_keys; j++) \{
04999         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ttl = 0;
05000         \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} expireat = getExpire(c->db,kv[j]);
05001 
05002         \textcolor{keywordflow}{if} (expireat != -1) \{
05003             ttl = expireat-mstime();
05004             \textcolor{keywordflow}{if} (ttl < 1) ttl = 1;
05005         \}
05006         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,rioWriteBulkCount(&cmd,\textcolor{stringliteral}{'*'},replace ? 5 : 4));
05007         \textcolor{keywordflow}{if} (server.cluster\_enabled)
05008             \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,
05009                 rioWriteBulkString(&cmd,\textcolor{stringliteral}{"RESTORE-ASKING"},14));
05010         \textcolor{keywordflow}{else}
05011             \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,rioWriteBulkString(&cmd,\textcolor{stringliteral}{"RESTORE"},7));
05012         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,\hyperlink{server_8h_afcfb5bd97af52d1dbce331745cae030c}{sdsEncodedObject}(kv[j]));
05013         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,rioWriteBulkString(&cmd,kv[j]->ptr,
05014                 sdslen(kv[j]->ptr)));
05015         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,rioWriteBulkLongLong(&cmd,ttl));
05016 
05017         \textcolor{comment}{/* Emit the payload argument, that is the serialized object using}
05018 \textcolor{comment}{         * the DUMP format. */}
05019         createDumpPayload(&payload,ov[j]);
05020         \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,
05021             rioWriteBulkString(&cmd,payload.io.buffer.ptr,
05022                                sdslen(payload.io.buffer.ptr)));
05023         sdsfree(payload.io.buffer.ptr);
05024 
05025         \textcolor{comment}{/* Add the REPLACE option to the RESTORE command if it was specified}
05026 \textcolor{comment}{         * as a MIGRATE option. */}
05027         \textcolor{keywordflow}{if} (replace)
05028             \hyperlink{server_8h_a7308f76cbff9a8d3797fe78190b91282}{serverAssertWithInfo}(c,NULL,rioWriteBulkString(&cmd,\textcolor{stringliteral}{"REPLACE"},7));
05029     \}
05030 
05031     \textcolor{comment}{/* Transfer the query to the other node in 64K chunks. */}
05032     errno = 0;
05033     \{
05034         sds buf = cmd.io.buffer.ptr;
05035         size\_t pos = 0, towrite;
05036         \textcolor{keywordtype}{int} nwritten = 0;
05037 
05038         \textcolor{keywordflow}{while} ((towrite = sdslen(buf)-pos) > 0) \{
05039             towrite = (towrite > (64*1024) ? (64*1024) : towrite);
05040             nwritten = syncWrite(cs->fd,buf+pos,towrite,timeout);
05041             \textcolor{keywordflow}{if} (nwritten != (\textcolor{keywordtype}{signed})towrite) \{
05042                 write\_error = 1;
05043                 \textcolor{keywordflow}{goto} socket\_err;
05044             \}
05045             pos += nwritten;
05046         \}
05047     \}
05048 
05049     \textcolor{keywordtype}{char} buf1[1024]; \textcolor{comment}{/* Select reply. */}
05050     \textcolor{keywordtype}{char} buf2[1024]; \textcolor{comment}{/* Restore reply. */}
05051 
05052     \textcolor{comment}{/* Read the SELECT reply if needed. */}
05053     \textcolor{keywordflow}{if} (select && syncReadLine(cs->fd, buf1, \textcolor{keyword}{sizeof}(buf1), timeout) <= 0)
05054         \textcolor{keywordflow}{goto} socket\_err;
05055 
05056     \textcolor{comment}{/* Read the RESTORE replies. */}
05057     \textcolor{keywordtype}{int} error\_from\_target = 0;
05058     \textcolor{keywordtype}{int} socket\_error = 0;
05059     \textcolor{keywordtype}{int} del\_idx = 1; \textcolor{comment}{/* Index of the key argument for the replicated DEL op. */}
05060 
05061     \textcolor{keywordflow}{if} (!copy) newargv = zmalloc(\textcolor{keyword}{sizeof}(robj*)*(num\_keys+1));
05062 
05063     \textcolor{keywordflow}{for} (j = 0; j < num\_keys; j++) \{
05064         \textcolor{keywordflow}{if} (syncReadLine(cs->fd, buf2, \textcolor{keyword}{sizeof}(buf2), timeout) <= 0) \{
05065             socket\_error = 1;
05066             \textcolor{keywordflow}{break};
05067         \}
05068         \textcolor{keywordflow}{if} ((select && buf1[0] == \textcolor{stringliteral}{'-'}) || buf2[0] == \textcolor{stringliteral}{'-'}) \{
05069             \textcolor{comment}{/* On error assume that last\_dbid is no longer valid. */}
05070             \textcolor{keywordflow}{if} (!error\_from\_target) \{
05071                 cs->last\_dbid = -1;
05072                 addReplyErrorFormat(c,\textcolor{stringliteral}{"Target instance replied with error: %s"},
05073                     (select && buf1[0] == \textcolor{stringliteral}{'-'}) ? buf1+1 : buf2+1);
05074                 error\_from\_target = 1;
05075             \}
05076         \} \textcolor{keywordflow}{else} \{
05077             \textcolor{keywordflow}{if} (!copy) \{
05078                 \textcolor{comment}{/* No COPY option: remove the local key, signal the change. */}
05079                 dbDelete(c->db,kv[j]);
05080                 signalModifiedKey(c->db,kv[j]);
05081                 server.dirty++;
05082 
05083                 \textcolor{comment}{/* Populate the argument vector to replace the old one. */}
05084                 newargv[del\_idx++] = kv[j];
05085                 incrRefCount(kv[j]);
05086             \}
05087         \}
05088     \}
05089 
05090     \textcolor{comment}{/* On socket error, if we want to retry, do it now before rewriting the}
05091 \textcolor{comment}{     * command vector. We only retry if we are sure nothing was processed}
05092 \textcolor{comment}{     * and we failed to read the first reply (j == 0 test). */}
05093     \textcolor{keywordflow}{if} (!error\_from\_target && socket\_error && j == 0 && may\_retry &&
05094         errno != ETIMEDOUT)
05095     \{
05096         \textcolor{keywordflow}{goto} socket\_err; \textcolor{comment}{/* A retry is guaranteed because of tested conditions.*/}
05097     \}
05098 
05099     \textcolor{comment}{/* On socket errors, close the migration socket now that we still have}
05100 \textcolor{comment}{     * the original host/port in the ARGV. Later the original command may be}
05101 \textcolor{comment}{     * rewritten to DEL and will be too later. */}
05102     \textcolor{keywordflow}{if} (socket\_error) migrateCloseSocket(c->argv[1],c->argv[2]);
05103 
05104     \textcolor{keywordflow}{if} (!copy) \{
05105         \textcolor{comment}{/* Translate MIGRATE as DEL for replication/AOF. Note that we do}
05106 \textcolor{comment}{         * this only for the keys for which we received an acknowledgement}
05107 \textcolor{comment}{         * from the receiving Redis server, by using the del\_idx index. */}
05108         \textcolor{keywordflow}{if} (del\_idx > 1) \{
05109             newargv[0] = createStringObject(\textcolor{stringliteral}{"DEL"},3);
05110             \textcolor{comment}{/* Note that the following call takes ownership of newargv. */}
05111             replaceClientCommandVector(c,del\_idx,newargv);
05112             argv\_rewritten = 1;
05113         \} \textcolor{keywordflow}{else} \{
05114             \textcolor{comment}{/* No key transfer acknowledged, no need to rewrite as DEL. */}
05115             zfree(newargv);
05116         \}
05117         newargv = NULL; \textcolor{comment}{/* Make it safe to call zfree() on it in the future. */}
05118     \}
05119 
05120     \textcolor{comment}{/* If we are here and a socket error happened, we don't want to retry.}
05121 \textcolor{comment}{     * Just signal the problem to the client, but only do it if we did not}
05122 \textcolor{comment}{     * already queue a different error reported by the destination server. */}
05123     \textcolor{keywordflow}{if} (!error\_from\_target && socket\_error) \{
05124         may\_retry = 0;
05125         \textcolor{keywordflow}{goto} socket\_err;
05126     \}
05127 
05128     \textcolor{keywordflow}{if} (!error\_from\_target) \{
05129         \textcolor{comment}{/* Success! Update the last\_dbid in migrateCachedSocket, so that we can}
05130 \textcolor{comment}{         * avoid SELECT the next time if the target DB is the same. Reply +OK.}
05131 \textcolor{comment}{         *}
05132 \textcolor{comment}{         * Note: If we reached this point, even if socket\_error is true}
05133 \textcolor{comment}{         * still the SELECT command succeeded (otherwise the code jumps to}
05134 \textcolor{comment}{         * socket\_err label. */}
05135         cs->last\_dbid = dbid;
05136         addReply(c,shared.ok);
05137     \} \textcolor{keywordflow}{else} \{
05138         \textcolor{comment}{/* On error we already sent it in the for loop above, and set}
05139 \textcolor{comment}{         * the curretly selected socket to -1 to force SELECT the next time. */}
05140     \}
05141 
05142     sdsfree(cmd.io.buffer.ptr);
05143     zfree(ov); zfree(kv); zfree(newargv);
05144     \textcolor{keywordflow}{return};
05145 
05146 \textcolor{comment}{/* On socket errors we try to close the cached socket and try again.}
05147 \textcolor{comment}{ * It is very common for the cached socket to get closed, if just reopening}
05148 \textcolor{comment}{ * it works it's a shame to notify the error to the caller. */}
05149 socket\_err:
05150     \textcolor{comment}{/* Cleanup we want to perform in both the retry and no retry case.}
05151 \textcolor{comment}{     * Note: Closing the migrate socket will also force SELECT next time. */}
05152     sdsfree(cmd.io.buffer.ptr);
05153 
05154     \textcolor{comment}{/* If the command was rewritten as DEL and there was a socket error,}
05155 \textcolor{comment}{     * we already closed the socket earlier. While migrateCloseSocket()}
05156 \textcolor{comment}{     * is idempotent, the host/port arguments are now gone, so don't do it}
05157 \textcolor{comment}{     * again. */}
05158     \textcolor{keywordflow}{if} (!argv\_rewritten) migrateCloseSocket(c->argv[1],c->argv[2]);
05159     zfree(newargv);
05160     newargv = NULL; \textcolor{comment}{/* This will get reallocated on retry. */}
05161 
05162     \textcolor{comment}{/* Retry only if it's not a timeout and we never attempted a retry}
05163 \textcolor{comment}{     * (or the code jumping here did not set may\_retry to zero). */}
05164     \textcolor{keywordflow}{if} (errno != ETIMEDOUT && may\_retry) \{
05165         may\_retry = 0;
05166         \textcolor{keywordflow}{goto} try\_again;
05167     \}
05168 
05169     \textcolor{comment}{/* Cleanup we want to do if no retry is attempted. */}
05170     zfree(ov); zfree(kv);
05171     addReplySds(c,
05172         sdscatprintf(sdsempty(),
05173             \textcolor{stringliteral}{"-IOERR error or timeout %s to target instance\(\backslash\)r\(\backslash\)n"},
05174             write\_error ? \textcolor{stringliteral}{"writing"} : \textcolor{stringliteral}{"reading"}));
05175     \textcolor{keywordflow}{return};
05176 \}
05177 
05178 \textcolor{comment}{/* -----------------------------------------------------------------------------}
05179 \textcolor{comment}{ * Cluster functions related to serving / redirecting clients}
05180 \textcolor{comment}{ * -------------------------------------------------------------------------- */}
05181 
05182 \textcolor{comment}{/* The ASKING command is required after a -ASK redirection.}
05183 \textcolor{comment}{ * The client should issue ASKING before to actually send the command to}
05184 \textcolor{comment}{ * the target instance. See the Redis Cluster specification for more}
05185 \textcolor{comment}{ * information. */}
05186 \textcolor{keywordtype}{void} askingCommand(\hyperlink{structclient}{client} *c) \{
05187     \textcolor{keywordflow}{if} (server.cluster\_enabled == 0) \{
05188         addReplyError(c,\textcolor{stringliteral}{"This instance has cluster support disabled"});
05189         \textcolor{keywordflow}{return};
05190     \}
05191     c->flags |= \hyperlink{server_8h_a108ac316dfd847430daf3c97f28557d3}{CLIENT\_ASKING};
05192     addReply(c,shared.ok);
05193 \}
05194 
05195 \textcolor{comment}{/* The READONLY command is used by clients to enter the read-only mode.}
05196 \textcolor{comment}{ * In this mode slaves will not redirect clients as long as clients access}
05197 \textcolor{comment}{ * with read-only commands to keys that are served by the slave's master. */}
05198 \textcolor{keywordtype}{void} readonlyCommand(\hyperlink{structclient}{client} *c) \{
05199     \textcolor{keywordflow}{if} (server.cluster\_enabled == 0) \{
05200         addReplyError(c,\textcolor{stringliteral}{"This instance has cluster support disabled"});
05201         \textcolor{keywordflow}{return};
05202     \}
05203     c->flags |= \hyperlink{server_8h_a84ba0494755e2f4f0faf6017175b5e0a}{CLIENT\_READONLY};
05204     addReply(c,shared.ok);
05205 \}
05206 
05207 \textcolor{comment}{/* The READWRITE command just clears the READONLY command state. */}
05208 \textcolor{keywordtype}{void} readwriteCommand(\hyperlink{structclient}{client} *c) \{
05209     c->flags &= ~\hyperlink{server_8h_a84ba0494755e2f4f0faf6017175b5e0a}{CLIENT\_READONLY};
05210     addReply(c,shared.ok);
05211 \}
05212 
05213 \textcolor{comment}{/* Return the pointer to the cluster node that is able to serve the command.}
05214 \textcolor{comment}{ * For the function to succeed the command should only target either:}
05215 \textcolor{comment}{ *}
05216 \textcolor{comment}{ * 1) A single key (even multiple times like LPOPRPUSH mylist mylist).}
05217 \textcolor{comment}{ * 2) Multiple keys in the same hash slot, while the slot is stable (no}
05218 \textcolor{comment}{ *    resharding in progress).}
05219 \textcolor{comment}{ *}
05220 \textcolor{comment}{ * On success the function returns the node that is able to serve the request.}
05221 \textcolor{comment}{ * If the node is not 'myself' a redirection must be perfomed. The kind of}
05222 \textcolor{comment}{ * redirection is specified setting the integer passed by reference}
05223 \textcolor{comment}{ * 'error\_code', which will be set to CLUSTER\_REDIR\_ASK or}
05224 \textcolor{comment}{ * CLUSTER\_REDIR\_MOVED.}
05225 \textcolor{comment}{ *}
05226 \textcolor{comment}{ * When the node is 'myself' 'error\_code' is set to CLUSTER\_REDIR\_NONE.}
05227 \textcolor{comment}{ *}
05228 \textcolor{comment}{ * If the command fails NULL is returned, and the reason of the failure is}
05229 \textcolor{comment}{ * provided via 'error\_code', which will be set to:}
05230 \textcolor{comment}{ *}
05231 \textcolor{comment}{ * CLUSTER\_REDIR\_CROSS\_SLOT if the request contains multiple keys that}
05232 \textcolor{comment}{ * don't belong to the same hash slot.}
05233 \textcolor{comment}{ *}
05234 \textcolor{comment}{ * CLUSTER\_REDIR\_UNSTABLE if the request contains multiple keys}
05235 \textcolor{comment}{ * belonging to the same slot, but the slot is not stable (in migration or}
05236 \textcolor{comment}{ * importing state, likely because a resharding is in progress).}
05237 \textcolor{comment}{ *}
05238 \textcolor{comment}{ * CLUSTER\_REDIR\_DOWN\_UNBOUND if the request addresses a slot which is}
05239 \textcolor{comment}{ * not bound to any node. In this case the cluster global state should be}
05240 \textcolor{comment}{ * already "down" but it is fragile to rely on the update of the global state,}
05241 \textcolor{comment}{ * so we also handle it here.}
05242 \textcolor{comment}{ *}
05243 \textcolor{comment}{ * CLUSTER\_REDIR\_DOWN\_STATE if the cluster is down but the user attempts to}
05244 \textcolor{comment}{ * execute a command that addresses one or more keys. */}
05245 clusterNode *getNodeByQuery(\hyperlink{structclient}{client} *c, \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *cmd, robj **argv, \textcolor{keywordtype}{int} 
      argc, \textcolor{keywordtype}{int} *hashslot, \textcolor{keywordtype}{int} *error\_code) \{
05246     clusterNode *n = NULL;
05247     robj *firstkey = NULL;
05248     \textcolor{keywordtype}{int} multiple\_keys = 0;
05249     multiState *ms, \_ms;
05250     multiCmd mc;
05251     \textcolor{keywordtype}{int} i, slot = 0, migrating\_slot = 0, importing\_slot = 0, missing\_keys = 0;
05252 
05253     \textcolor{comment}{/* Set error code optimistically for the base case. */}
05254     \textcolor{keywordflow}{if} (error\_code) *error\_code = \hyperlink{cluster_8h_a5cca5ce77d018a377acdcecf0b443373}{CLUSTER\_REDIR\_NONE};
05255 
05256     \textcolor{comment}{/* We handle all the cases as if they were EXEC commands, so we have}
05257 \textcolor{comment}{     * a common code path for everything */}
05258     \textcolor{keywordflow}{if} (cmd->proc == execCommand) \{
05259         \textcolor{comment}{/* If CLIENT\_MULTI flag is not set EXEC is just going to return an}
05260 \textcolor{comment}{         * error. */}
05261         \textcolor{keywordflow}{if} (!(c->flags & \hyperlink{server_8h_a7f61f783f429419f8c593291a509b03a}{CLIENT\_MULTI})) \textcolor{keywordflow}{return} myself;
05262         ms = &c->mstate;
05263     \} \textcolor{keywordflow}{else} \{
05264         \textcolor{comment}{/* In order to have a single codepath create a fake Multi State}
05265 \textcolor{comment}{         * structure if the client is not in MULTI/EXEC state, this way}
05266 \textcolor{comment}{         * we have a single codepath below. */}
05267         ms = &\_ms;
05268         \_ms.commands = &mc;
05269         \_ms.count = 1;
05270         mc.argv = argv;
05271         mc.argc = argc;
05272         mc.cmd = cmd;
05273     \}
05274 
05275     \textcolor{comment}{/* Check that all the keys are in the same hash slot, and obtain this}
05276 \textcolor{comment}{     * slot and the node associated. */}
05277     \textcolor{keywordflow}{for} (i = 0; i < ms->count; i++) \{
05278         \textcolor{keyword}{struct} \hyperlink{structredisCommand}{redisCommand} *mcmd;
05279         robj **margv;
05280         \textcolor{keywordtype}{int} margc, *keyindex, numkeys, j;
05281 
05282         mcmd = ms->commands[i].cmd;
05283         margc = ms->commands[i].argc;
05284         margv = ms->commands[i].argv;
05285 
05286         keyindex = getKeysFromCommand(mcmd,margv,margc,&numkeys);
05287         \textcolor{keywordflow}{for} (j = 0; j < numkeys; j++) \{
05288             robj *thiskey = margv[keyindex[j]];
05289             \textcolor{keywordtype}{int} thisslot = keyHashSlot((\textcolor{keywordtype}{char}*)thiskey->ptr,
05290                                        sdslen(thiskey->ptr));
05291 
05292             \textcolor{keywordflow}{if} (firstkey == NULL) \{
05293                 \textcolor{comment}{/* This is the first key we see. Check what is the slot}
05294 \textcolor{comment}{                 * and node. */}
05295                 firstkey = thiskey;
05296                 slot = thisslot;
05297                 n = server.cluster->slots[slot];
05298 
05299                 \textcolor{comment}{/* Error: If a slot is not served, we are in "cluster down"}
05300 \textcolor{comment}{                 * state. However the state is yet to be updated, so this was}
05301 \textcolor{comment}{                 * not trapped earlier in processCommand(). Report the same}
05302 \textcolor{comment}{                 * error to the client. */}
05303                 \textcolor{keywordflow}{if} (n == NULL) \{
05304                     getKeysFreeResult(keyindex);
05305                     \textcolor{keywordflow}{if} (error\_code)
05306                         *error\_code = \hyperlink{cluster_8h_ac77f67383a97866c21a56f66bada419b}{CLUSTER\_REDIR\_DOWN\_UNBOUND};
05307                     \textcolor{keywordflow}{return} NULL;
05308                 \}
05309 
05310                 \textcolor{comment}{/* If we are migrating or importing this slot, we need to check}
05311 \textcolor{comment}{                 * if we have all the keys in the request (the only way we}
05312 \textcolor{comment}{                 * can safely serve the request, otherwise we return a TRYAGAIN}
05313 \textcolor{comment}{                 * error). To do so we set the importing/migrating state and}
05314 \textcolor{comment}{                 * increment a counter for every missing key. */}
05315                 \textcolor{keywordflow}{if} (n == myself &&
05316                     server.cluster->migrating\_slots\_to[slot] != NULL)
05317                 \{
05318                     migrating\_slot = 1;
05319                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (server.cluster->importing\_slots\_from[slot] != NULL) \{
05320                     importing\_slot = 1;
05321                 \}
05322             \} \textcolor{keywordflow}{else} \{
05323                 \textcolor{comment}{/* If it is not the first key, make sure it is exactly}
05324 \textcolor{comment}{                 * the same key as the first we saw. */}
05325                 \textcolor{keywordflow}{if} (!equalStringObjects(firstkey,thiskey)) \{
05326                     \textcolor{keywordflow}{if} (slot != thisslot) \{
05327                         \textcolor{comment}{/* Error: multiple keys from different slots. */}
05328                         getKeysFreeResult(keyindex);
05329                         \textcolor{keywordflow}{if} (error\_code)
05330                             *error\_code = \hyperlink{cluster_8h_afbca3b8aad0bd8d1f013d81af78672af}{CLUSTER\_REDIR\_CROSS\_SLOT};
05331                         \textcolor{keywordflow}{return} NULL;
05332                     \} \textcolor{keywordflow}{else} \{
05333                         \textcolor{comment}{/* Flag this request as one with multiple different}
05334 \textcolor{comment}{                         * keys. */}
05335                         multiple\_keys = 1;
05336                     \}
05337                 \}
05338             \}
05339 
05340             \textcolor{comment}{/* Migarting / Improrting slot? Count keys we don't have. */}
05341             \textcolor{keywordflow}{if} ((migrating\_slot || importing\_slot) &&
05342                 lookupKeyRead(&server.db[0],thiskey) == NULL)
05343             \{
05344                 missing\_keys++;
05345             \}
05346         \}
05347         getKeysFreeResult(keyindex);
05348     \}
05349 
05350     \textcolor{comment}{/* No key at all in command? then we can serve the request}
05351 \textcolor{comment}{     * without redirections or errors in all the cases. */}
05352     \textcolor{keywordflow}{if} (n == NULL) \textcolor{keywordflow}{return} myself;
05353 
05354     \textcolor{comment}{/* Cluster is globally down but we got keys? We can't serve the request. */}
05355     \textcolor{keywordflow}{if} (server.cluster->state != \hyperlink{cluster_8h_adbda03922c45cac3cfc98a5c34a9d2d2}{CLUSTER\_OK}) \{
05356         \textcolor{keywordflow}{if} (error\_code) *error\_code = \hyperlink{cluster_8h_a62aea13c6a6bad14d00664033b3cae1a}{CLUSTER\_REDIR\_DOWN\_STATE};
05357         \textcolor{keywordflow}{return} NULL;
05358     \}
05359 
05360     \textcolor{comment}{/* Return the hashslot by reference. */}
05361     \textcolor{keywordflow}{if} (hashslot) *hashslot = slot;
05362 
05363     \textcolor{comment}{/* MIGRATE always works in the context of the local node if the slot}
05364 \textcolor{comment}{     * is open (migrating or importing state). We need to be able to freely}
05365 \textcolor{comment}{     * move keys among instances in this case. */}
05366     \textcolor{keywordflow}{if} ((migrating\_slot || importing\_slot) && cmd->proc == migrateCommand)
05367         \textcolor{keywordflow}{return} myself;
05368 
05369     \textcolor{comment}{/* If we don't have all the keys and we are migrating the slot, send}
05370 \textcolor{comment}{     * an ASK redirection. */}
05371     \textcolor{keywordflow}{if} (migrating\_slot && missing\_keys) \{
05372         \textcolor{keywordflow}{if} (error\_code) *error\_code = \hyperlink{cluster_8h_ae93f7d31db8c46cdf4c6a7e2f15fd00b}{CLUSTER\_REDIR\_ASK};
05373         \textcolor{keywordflow}{return} server.cluster->migrating\_slots\_to[slot];
05374     \}
05375 
05376     \textcolor{comment}{/* If we are receiving the slot, and the client correctly flagged the}
05377 \textcolor{comment}{     * request as "ASKING", we can serve the request. However if the request}
05378 \textcolor{comment}{     * involves multiple keys and we don't have them all, the only option is}
05379 \textcolor{comment}{     * to send a TRYAGAIN error. */}
05380     \textcolor{keywordflow}{if} (importing\_slot &&
05381         (c->flags & \hyperlink{server_8h_a108ac316dfd847430daf3c97f28557d3}{CLIENT\_ASKING} || cmd->flags & \hyperlink{server_8h_af0b13ef0f1dabe404fd7d904cb66b548}{CMD\_ASKING}))
05382     \{
05383         \textcolor{keywordflow}{if} (multiple\_keys && missing\_keys) \{
05384             \textcolor{keywordflow}{if} (error\_code) *error\_code = \hyperlink{cluster_8h_a55ae67727361b72bce02b01dd58511f2}{CLUSTER\_REDIR\_UNSTABLE};
05385             \textcolor{keywordflow}{return} NULL;
05386         \} \textcolor{keywordflow}{else} \{
05387             \textcolor{keywordflow}{return} myself;
05388         \}
05389     \}
05390 
05391     \textcolor{comment}{/* Handle the read-only client case reading from a slave: if this}
05392 \textcolor{comment}{     * node is a slave and the request is about an hash slot our master}
05393 \textcolor{comment}{     * is serving, we can reply without redirection. */}
05394     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a84ba0494755e2f4f0faf6017175b5e0a}{CLIENT\_READONLY} &&
05395         (cmd->flags & \hyperlink{server_8h_a7e9c728f228e1c82ae1e22173375abcf}{CMD\_READONLY} || cmd->proc == evalCommand ||
05396          cmd->proc == evalShaCommand) &&
05397         \hyperlink{cluster_8h_a3c99881f6892130c902b42b1f84a0e11}{nodeIsSlave}(myself) &&
05398         myself->slaveof == n)
05399     \{
05400         \textcolor{keywordflow}{return} myself;
05401     \}
05402 
05403     \textcolor{comment}{/* Base case: just return the right node. However if this node is not}
05404 \textcolor{comment}{     * myself, set error\_code to MOVED since we need to issue a rediretion. */}
05405     \textcolor{keywordflow}{if} (n != myself && error\_code) *error\_code = \hyperlink{cluster_8h_a26a42bb5d79b437e3a8329d66d7fce81}{CLUSTER\_REDIR\_MOVED};
05406     \textcolor{keywordflow}{return} n;
05407 \}
05408 
05409 \textcolor{comment}{/* Send the client the right redirection code, according to error\_code}
05410 \textcolor{comment}{ * that should be set to one of CLUSTER\_REDIR\_* macros.}
05411 \textcolor{comment}{ *}
05412 \textcolor{comment}{ * If CLUSTER\_REDIR\_ASK or CLUSTER\_REDIR\_MOVED error codes}
05413 \textcolor{comment}{ * are used, then the node 'n' should not be NULL, but should be the}
05414 \textcolor{comment}{ * node we want to mention in the redirection. Moreover hashslot should}
05415 \textcolor{comment}{ * be set to the hash slot that caused the redirection. */}
05416 \textcolor{keywordtype}{void} clusterRedirectClient(\hyperlink{structclient}{client} *c, clusterNode *n, \textcolor{keywordtype}{int} hashslot, \textcolor{keywordtype}{int} error\_code) \{
05417     \textcolor{keywordflow}{if} (error\_code == \hyperlink{cluster_8h_afbca3b8aad0bd8d1f013d81af78672af}{CLUSTER\_REDIR\_CROSS\_SLOT}) \{
05418         addReplySds(c,sdsnew(\textcolor{stringliteral}{"-CROSSSLOT Keys in request don't hash to the same slot\(\backslash\)r\(\backslash\)n"}));
05419     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (error\_code == \hyperlink{cluster_8h_a55ae67727361b72bce02b01dd58511f2}{CLUSTER\_REDIR\_UNSTABLE}) \{
05420         \textcolor{comment}{/* The request spawns mutliple keys in the same slot,}
05421 \textcolor{comment}{         * but the slot is not "stable" currently as there is}
05422 \textcolor{comment}{         * a migration or import in progress. */}
05423         addReplySds(c,sdsnew(\textcolor{stringliteral}{"-TRYAGAIN Multiple keys request during rehashing of slot\(\backslash\)r\(\backslash\)n"}));
05424     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (error\_code == \hyperlink{cluster_8h_a62aea13c6a6bad14d00664033b3cae1a}{CLUSTER\_REDIR\_DOWN\_STATE}) \{
05425         addReplySds(c,sdsnew(\textcolor{stringliteral}{"-CLUSTERDOWN The cluster is down\(\backslash\)r\(\backslash\)n"}));
05426     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (error\_code == \hyperlink{cluster_8h_ac77f67383a97866c21a56f66bada419b}{CLUSTER\_REDIR\_DOWN\_UNBOUND}) \{
05427         addReplySds(c,sdsnew(\textcolor{stringliteral}{"-CLUSTERDOWN Hash slot not served\(\backslash\)r\(\backslash\)n"}));
05428     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (error\_code == \hyperlink{cluster_8h_a26a42bb5d79b437e3a8329d66d7fce81}{CLUSTER\_REDIR\_MOVED} ||
05429                error\_code == \hyperlink{cluster_8h_ae93f7d31db8c46cdf4c6a7e2f15fd00b}{CLUSTER\_REDIR\_ASK})
05430     \{
05431         addReplySds(c,sdscatprintf(sdsempty(),
05432             \textcolor{stringliteral}{"-%s %d %s:%d\(\backslash\)r\(\backslash\)n"},
05433             (error\_code == \hyperlink{cluster_8h_ae93f7d31db8c46cdf4c6a7e2f15fd00b}{CLUSTER\_REDIR\_ASK}) ? \textcolor{stringliteral}{"ASK"} : \textcolor{stringliteral}{"MOVED"},
05434             hashslot,n->ip,n->port));
05435     \} \textcolor{keywordflow}{else} \{
05436         \hyperlink{server_8h_a11cc378e7778a830b41240578de3b204}{serverPanic}(\textcolor{stringliteral}{"getNodeByQuery() unknown error."});
05437     \}
05438 \}
05439 
05440 \textcolor{comment}{/* This function is called by the function processing clients incrementally}
05441 \textcolor{comment}{ * to detect timeouts, in order to handle the following case:}
05442 \textcolor{comment}{ *}
05443 \textcolor{comment}{ * 1) A client blocks with BLPOP or similar blocking operation.}
05444 \textcolor{comment}{ * 2) The master migrates the hash slot elsewhere or turns into a slave.}
05445 \textcolor{comment}{ * 3) The client may remain blocked forever (or up to the max timeout time)}
05446 \textcolor{comment}{ *    waiting for a key change that will never happen.}
05447 \textcolor{comment}{ *}
05448 \textcolor{comment}{ * If the client is found to be blocked into an hash slot this node no}
05449 \textcolor{comment}{ * longer handles, the client is sent a redirection error, and the function}
05450 \textcolor{comment}{ * returns 1. Otherwise 0 is returned and no operation is performed. */}
05451 \textcolor{keywordtype}{int} clusterRedirectBlockedClientIfNeeded(\hyperlink{structclient}{client} *c) \{
05452     \textcolor{keywordflow}{if} (c->flags & \hyperlink{server_8h_a503ad979164a52f0f5e2a63e4c7da3a0}{CLIENT\_BLOCKED} && c->btype == \hyperlink{server_8h_a279f6a31729ba24d6dab0944b82e0b55}{BLOCKED\_LIST}) \{
05453         dictEntry *de;
05454         dictIterator *di;
05455 
05456         \textcolor{comment}{/* If the cluster is down, unblock the client with the right error. */}
05457         \textcolor{keywordflow}{if} (server.cluster->state == \hyperlink{cluster_8h_a4a46e6d5b85c594d08283dc6da2a32bf}{CLUSTER\_FAIL}) \{
05458             clusterRedirectClient(c,NULL,0,\hyperlink{cluster_8h_a62aea13c6a6bad14d00664033b3cae1a}{CLUSTER\_REDIR\_DOWN\_STATE});
05459             \textcolor{keywordflow}{return} 1;
05460         \}
05461 
05462         \textcolor{comment}{/* All keys must belong to the same slot, so check first key only. */}
05463         di = dictGetIterator(c->bpop.keys);
05464         \textcolor{keywordflow}{if} ((de = dictNext(di)) != NULL) \{
05465             robj *key = \hyperlink{dict_8h_a3271c334309904a3086deca94f96e46e}{dictGetKey}(de);
05466             \textcolor{keywordtype}{int} slot = keyHashSlot((\textcolor{keywordtype}{char}*)key->ptr, sdslen(key->ptr));
05467             clusterNode *node = server.cluster->slots[slot];
05468 
05469             \textcolor{comment}{/* We send an error and unblock the client if:}
05470 \textcolor{comment}{             * 1) The slot is unassigned, emitting a cluster down error.}
05471 \textcolor{comment}{             * 2) The slot is not handled by this node, nor being imported. */}
05472             \textcolor{keywordflow}{if} (node != myself &&
05473                 server.cluster->importing\_slots\_from[slot] == NULL)
05474             \{
05475                 \textcolor{keywordflow}{if} (node == NULL) \{
05476                     clusterRedirectClient(c,NULL,0,
05477                         \hyperlink{cluster_8h_ac77f67383a97866c21a56f66bada419b}{CLUSTER\_REDIR\_DOWN\_UNBOUND});
05478                 \} \textcolor{keywordflow}{else} \{
05479                     clusterRedirectClient(c,node,slot,
05480                         \hyperlink{cluster_8h_a26a42bb5d79b437e3a8329d66d7fce81}{CLUSTER\_REDIR\_MOVED});
05481                 \}
05482                 dictReleaseIterator(di);
05483                 \textcolor{keywordflow}{return} 1;
05484             \}
05485         \}
05486         dictReleaseIterator(di);
05487     \}
05488     \textcolor{keywordflow}{return} 0;
05489 \}
\end{DoxyCode}
